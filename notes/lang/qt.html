<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="author" content="district10" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title></title>
    <link rel="stylesheet" href="../github-markdown.css" type="text/css" />
    <link rel="stylesheet" href="../highlight.css" type="text/css" />
    <link rel="stylesheet" href="../notes.css" type="text/css" />
</head>
<body class="markdown-body">
<div id="navigator">
    <a id="gotoindex" href="index.html" title="&#12304;&#22238;&#21040;&#31508;&#35760;&#32034;&#24341; | Back to Index&#12305;">&#9763;</a></div>
<div id="main-body">
<h1 id="qt">Qt</h1>
<h2 id="c-gui-qt4-&#32534;&#31243;">C++ GUI Qt4 &#32534;&#31243;</h2>
<div class="figure">
<img src="http://img3.douban.com/mpic/s5934624.jpg" />

</div>
<p>&#26412;&#20070; example &#28304;&#30721;&#26159;&#21487;&#20197;&#20813;&#36153;&#19979;&#21040;&#30340;&#65306;<a href="http://www.informit.com/store/c-plus-plus-gui-programming-with-qt4-9780132354165">C++ GUI Programming with Qt4, 2nd Edition | InformIT</a></p>
<p>&#36825;&#26412;&#20070;&#30340;&#20195;&#30721;&#30495;&#26159;&#30334;&#30475;&#19981;&#21388;&#12290;&#22312;&#36825;&#20320;&#24635;&#33021;&#25214;&#21040;&#33258;&#24049;&#38656;&#35201;&#30340;&#37027;&#19968;&#37096;&#20998;&#12290;</p>
<ul>
<li><dl>
<dt>Part I: Basic Qt <code class="foldable">@</code></dt>
<dd><dl>
<dt>Getting Started <code class="fold">@</code></dt>
<dd><dl>
<dt>hello.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;QApplication&gt;</span>
<span class="ot">#include &lt;QLabel&gt;</span>

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
    <span class="ot">QApplication</span> app(argc, argv);
    <span class="ot">QLabel</span> *label = <span class="kw">new</span> <span class="ot">QLabel</span>(<span class="st">&quot;Hello Qt!&quot;</span>);
    label-&gt;show();
    <span class="kw">return</span> app.exec();
}</code></pre></div>
</dd>
<dt>hello.pro <code class="fold">@</code></dt>
<dd><pre class="plain"><code>TEMPLATE      = app
SOURCES       = hello.cpp</code></pre>
</dd>
<dt>bash <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># gen Makefile</span>
$ <span class="kw">qmake</span> hello.pro
$ <span class="kw">make</span>

<span class="co"># template: VC Project</span>
$ <span class="kw">qmake</span> -tp vc hello.pro</code></pre></div>
</dd>
<dt>qmake &#30340;&#24110;&#21161; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">qmake</span> -help
<span class="kw">Usage</span>: c:\Qt\qt-4.8.6-x64-msvc2010\qt-4.8.6-x64-msvc2010\bin\qmake.exe [mode] [options] [files]

<span class="kw">QMake</span> has two modes, one mode for generating project files based on
<span class="kw">some</span> heuristics, and the other for generating makefiles. Normally you
<span class="kw">shouldn</span><span class="st">&#39;t need to specify a mode, as makefile generation is the default</span>
<span class="st">mode for qmake, but you may use this to test qmake on an existing project</span>

<span class="st">Mode:</span>
<span class="st">  -project       Put qmake into project file generation mode</span>
<span class="st">                 In this mode qmake interprets files as files to</span>
<span class="st">                 be built,</span>
<span class="st">                 defaults to *.c; *.ui; *.y; *.l; *.ts; *.xlf; *.qrc; *.h; *.hpp; *.hh; *.hxx; *.cpp; *.cc; *.cxx</span>
<span class="st">                 Note: The created .pro file probably will</span>
<span class="st">                 need to be edited. For example add the QT variable to</span>
<span class="st">                 specify what modules are required.</span>
<span class="st">  -makefile      Put qmake into makefile generation mode (default)</span>
<span class="st">                 In this mode qmake interprets files as project files to</span>
<span class="st">                 be processed, if skipped qmake will try to find a project</span>
<span class="st">                 file in your current working directory</span>

<span class="st">Warnings Options:</span>
<span class="st">  -Wnone         Turn off all warnings; specific ones may be re-enabled by</span>
<span class="st">                 later -W options</span>
<span class="st">  -Wall          Turn on all warnings</span>
<span class="st">  -Wparser       Turn on parser warnings</span>
<span class="st">  -Wlogic        Turn on logic warnings (on by default)</span>
<span class="st">  -Wdeprecated   Turn on deprecation warnings (on by default)</span>

<span class="st">Options:</span>
<span class="st">   * You can place any variable assignment in options and it will be     *</span>
<span class="st">   * processed as if it was in [files]. These assignments will be parsed *</span>
<span class="st">   * before [files].                                                     *</span>
<span class="st">  -o file        Write output to file</span>
<span class="st">  -d             Increase debug level</span>
<span class="st">  -t templ       Overrides TEMPLATE as templ</span>
<span class="st">  -tp prefix     Overrides TEMPLATE so that prefix is prefixed into the value</span>
<span class="st">  -help          This help</span>
<span class="st">  -v             Version information</span>
<span class="st">  -after         All variable assignments after this will be</span>
<span class="st">                 parsed after [files]</span>
<span class="st">  -norecursive   Don&#39;</span>t do a recursive search
  <span class="kw">-recursive</span>     Do a recursive search
  <span class="kw">-set</span> <span class="kw">&lt;</span>prop<span class="kw">&gt;</span> <span class="kw">&lt;</span>value<span class="kw">&gt;</span> Set persistent property
  <span class="kw">-unset</span> <span class="kw">&lt;</span>prop<span class="kw">&gt;</span>  Unset persistent property
  <span class="kw">-query</span> <span class="kw">&lt;</span>prop<span class="kw">&gt;</span>  Query persistent property. Show all if <span class="kw">&lt;</span>prop<span class="kw">&gt;</span> is empty.
  <span class="kw">-cache</span> file    Use file as cache           [makefile mode only]
  <span class="kw">-spec</span> spec     Use spec as QMAKESPEC       [makefile mode only]
  <span class="kw">-nocache</span>       Don<span class="st">&#39;t use a cache file      [makefile mode only]</span>
<span class="st">  -nodepend      Don&#39;</span>t generate dependencies [makefile mode only]
  <span class="kw">-nomoc</span>         Don<span class="st">&#39;t generate moc targets  [makefile mode only]</span>
<span class="st">  -nopwd         Don&#39;</span>t look for files in pwd [project mode only]</code></pre></div>
</dd>
<dt>&#29615;&#22659;&#21464;&#37327; <code class="fold">@</code></dt>
<dd><p>&#35774;&#32622;</p>
<table>
<thead>
<tr class="header">
<th>&#29615;&#22659;&#21464;&#37327;</th>
<th>&#20540;</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>%QTDIR%</code></td>
<td><code>C:\Qt\qt-4.8.6-x64-msvc2010\qt-4.8.6-x64-msvc2010</code></td>
</tr>
<tr class="even">
<td><code>%QTMAKESPEC%</code></td>
<td><code>win32-msvc2010</code></td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">mkdir</span> build <span class="kw">&amp;&amp;</span> <span class="kw">cd</span> build
$ <span class="kw">qmake</span> -spec win32-msvc2010 -r -tp vc</code></pre></div>
<p>&#21487;&#20197;&#22312; <code>qt-everywhere-opensource-src-4.8.6\mkspecs</code> &#25991;&#20214;&#22841;&#19979;&#30475;&#21040;&#25152;&#26377; spects&#12290;</p>
<p>&#65288;&#36825;&#26679;&#32534;&#35793;&#30340;&#39033;&#30446;&#34429;&#28982;&#24037;&#31243;&#22312;&#22806;&#38754;&#65288;out of source&#65289;&#65292;&#20294; build &#20986;&#26469;&#30340;&#19996;&#35199;&#65292;&#23621;&#28982;&#22312;&#28304;&#30721;&#30340;&#25991;&#20214;&#22841;&#21834;&#12290;&#24046;&#35780;&#65281;&#65289;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QLabel</span> *label = <span class="kw">new</span> <span class="ot">QLabel</span>(<span class="st">&quot;&lt;h2&gt;&lt;i&gt;Hello&lt;/i&gt; &quot;</span>
                           <span class="st">&quot;&lt;font color=red&gt;Qt!&lt;/font&gt;&lt;/h2&gt;&quot;</span>);</code></pre></div>
<p>&#22914;&#26524;&#20320;&#26377;&#19968;&#20010; cpp &#25991;&#20214;&#65292;&#27604;&#22914; <code>quit.cpp</code>&#65292;&#22312;&#25991;&#20214;&#22841;&#19979; <code class="sourceCode bash"><span class="kw">qmake</span> -project</code> &#21487;&#20197;&#20135;&#29983;&#19968;&#20010; <code>.pro</code> Qt &#24037;&#31243;&#25991;&#20214;&#65292;&#20877; <code class="sourceCode bash"><span class="kw">qmake</span> quit.pro</code> &#23601;&#21487;&#20197;&#20135;&#29983; Makefile&#12290;</p>
</dd>
</dl>
</dd>
<dt>Making Connections <code class="fold">@</code></dt>
<dd><p>Signal &#8594; Slot: <code class="sourceCode cpp">setValue(value)</code> &#8594; <code class="sourceCode cpp">valueChanged(value)</code></p>
<p>Layouts</p>
<ol>
<li><code class="sourceCode cpp"><span class="ot">QHBoxLayout</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QVBoxLayout</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QGridLayout</span></code></li>
</ol>
<dl>
<dt><code>layout-&gt;addWidget, widget-&gt;setLayout</code> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QWidget</span> *window = <span class="kw">new</span> <span class="ot">QWidget</span>;
window-&gt;setWindowTitle(<span class="st">&quot;Enter Your Age&quot;</span>);

<span class="ot">QSpinBox</span> *spinBox = <span class="kw">new</span> <span class="ot">QSpinBox</span>;
<span class="ot">QSlider</span> *slider = <span class="kw">new</span> <span class="ot">QSlider</span>(<span class="ot">Qt::</span>Horizontal);
spinBox-&gt;setRange(<span class="dv">0</span>, <span class="dv">130</span>);
slider-&gt;setRange(<span class="dv">0</span>, <span class="dv">130</span>);

<span class="ot">QObject::</span>connect(spinBox, <span class="kw">SIGNAL</span>(valueChanged(<span class="dt">int</span>)),
                 slider, <span class="kw">SLOT</span>(setValue(<span class="dt">int</span>)));
<span class="ot">QObject::</span>connect(slider, <span class="kw">SIGNAL</span>(valueChanged(<span class="dt">int</span>)),
                 spinBox, <span class="kw">SLOT</span>(setValue(<span class="dt">int</span>)));
spinBox-&gt;setValue(<span class="dv">35</span>);

<span class="ot">QHBoxLayout</span> *layout = <span class="kw">new</span> <span class="ot">QHBoxLayout</span>;
layout-&gt;addWidget(spinBox);
layout-&gt;addWidget(slider);
window-&gt;setLayout(layout);

window-&gt;show();

<span class="ot">QPushButton</span> *button = <span class="kw">new</span> <span class="ot">QPushButton</span>(<span class="st">&quot;Quit&quot;</span>);
<span class="ot">QObject::</span>connect(button, <span class="kw">SIGNAL</span>(clicked()),
                 &amp;app, <span class="kw">SLOT</span>(quit()));</code></pre></div>
</dd>
<dt>UI style</dt>
<dd><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">./hello.exe</span> -style motif</code></pre></div>
</dd>
</dl>
</dd>
<dt>Using the Reference Documentation <code class="foldable">@</code></dt>
<dd><p>&#65288;&#25991;&#26723;&#30830;&#23454;&#20016;&#23500;&#12290;&#65289;</p>
</dd>
<dt>Creating Dialogs <code class="fold">@</code></dt>
<dd><dl>
<dt><code>layout-&gt;addLayout</code> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#25512;&#33616;&#22312; Qt &#30340; Signal &amp; Slots &#20013;&#19981;&#20351;&#29992; const&#65292;&#20063;&#19981;&#20351;&#29992; &amp;</span>
<span class="fu">connect</span>(lineEdit, <span class="kw">SIGNAL</span>(textChanged(<span class="dt">const</span> <span class="ot">QString</span> &amp;)),
        <span class="kw">this</span>, <span class="kw">SLOT</span>(enableFindButton(<span class="dt">const</span> <span class="ot">QString</span> &amp;)));

<span class="ot">QVBoxLayout</span> *leftLayout = <span class="kw">new</span> <span class="ot">QVBoxLayout</span>;
leftLayout-&gt;addLayout(topLeftLayout);
leftLayout-&gt;addWidget(caseCheckBox);
leftLayout-&gt;addWidget(backwardCheckBox);

<span class="ot">QHBoxLayout</span> *mainLayout = <span class="kw">new</span> <span class="ot">QHBoxLayout</span>;
mainLayout-&gt;addLayout(leftLayout);
mainLayout-&gt;addLayout(rightLayout);
setLayout(mainLayout);

setWindowTitle(<span class="fu">tr</span>(<span class="st">&quot;Find&quot;</span>));
setFixedHeight(sizeHint().height()); <span class="co">// ideal height</span>

<span class="ot">Qt::</span>CaseSensitivity cs =
        caseCheckBox-&gt;isChecked() ? <span class="ot">Qt::</span>CaseSensitive
                                  : <span class="ot">Qt::</span>CaseInsensitive;</code></pre></div>
<p><code class="sourceCode cpp"><span class="ot">QSize</span> <span class="ot">QWidget::</span>sizeHint()</code> &#8594; &#8220;ideal&#8221; size.</p>
<p>The <code>emit</code> keyword is specific to Qt; like other Qt extensions it is converted into standard C++ by the <strong>C++ preprocessor</strong>.</p>
<p>Since the <code>FindDialog</code> class definition contains the <code>Q_OBJECT</code> macro, the makefile generated by <code class="sourceCode bash"><span class="kw">qmake</span></code> will include special rules to run <code class="sourceCode bash"><span class="kw">moc</span></code>, Qt&#8217;s <strong>meta-object compiler</strong>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QCheckBox</span> *caseCheckBox = <span class="kw">new</span> <span class="ot">QCheckBox</span>(<span class="fu">tr</span>(<span class="st">&quot;Match &amp;case&quot;</span>));
<span class="ot">QPushButton</span> *closeButton = <span class="kw">new</span> <span class="ot">QPushButton</span>(<span class="fu">tr</span>(<span class="st">&quot;Close&quot;</span>));
<span class="ot">QWidget::</span>setTabOrder()</code></pre></div>
</dd>
</dl>
</dd>
<dt>Signals and Slots in Depth <code class="fold">@</code></dt>
<dd><dl>
<dt>One signal can be connected to many slots: <code class="fold">@</code></dt>
<dd><p>When the signal is emitted, the slots are called one after the other, in an unspecified order.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="fu">connect</span>(slider, <span class="kw">SIGNAL</span>(valueChanged(<span class="dt">int</span>)),
        spinBox, <span class="kw">SLOT</span>(setValue(<span class="dt">int</span>)));
<span class="fu">connect</span>(slider, <span class="kw">SIGNAL</span>(valueChanged(<span class="dt">int</span>)),
        <span class="kw">this</span>, <span class="kw">SLOT</span>(updateStatusBarIndicator(<span class="dt">int</span>)));</code></pre></div>
</dd>
<dt>Many signals can be connected to the same slot: <code class="fold">@</code></dt>
<dd><p>When either signal is emitted, the slot is called.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="fu">connect</span>(lcd, <span class="kw">SIGNAL</span>(overflow()),
        <span class="kw">this</span>, <span class="kw">SLOT</span>(handleMathError()));
<span class="fu">connect</span>(calculator, <span class="kw">SIGNAL</span>(divisionByZero()),
        <span class="kw">this</span>, <span class="kw">SLOT</span>(handleMathError()));</code></pre></div>
</dd>
<dt>A signal can be connected to another signal: <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="fu">connect</span>(lineEdit, <span class="kw">SIGNAL</span>(textChanged(<span class="dt">const</span> <span class="ot">QString</span> &amp;)),
        <span class="kw">this</span>, <span class="kw">SIGNAL</span>(updateRecord(<span class="dt">const</span> <span class="ot">QString</span> &amp;)));</code></pre></div>
</dd>
<dt>Connections can be removed: <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="fu">disconnect</span>(lcd, <span class="kw">SIGNAL</span>(overflow()),
           <span class="kw">this</span>, <span class="kw">SLOT</span>(handleMathError()));</code></pre></div>
</dd>
</dl>
</dd>
<dt>Parameter types <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// same</span>
<span class="fu">connect</span>(ftp, <span class="kw">SIGNAL</span>(rawCommandReply(<span class="dt">int</span>, <span class="dt">const</span> <span class="ot">QString</span> &amp;)),
        <span class="kw">this</span>, <span class="kw">SLOT</span>(processReply(<span class="dt">int</span>, <span class="dt">const</span> <span class="ot">QString</span> &amp;)));
<span class="co">// less</span>
<span class="fu">connect</span>(ftp, <span class="kw">SIGNAL</span>(rawCommandReply(<span class="dt">int</span>, <span class="dt">const</span> <span class="ot">QString</span> &amp;)),
        <span class="kw">this</span>, <span class="kw">SLOT</span>(checkErrorCode(<span class="dt">int</span>)));

<span class="co">// default</span>
<span class="fu">connect</span>(findDialog, <span class="kw">SIGNAL</span>(findNext(<span class="dt">const</span> <span class="ot">QString</span> &amp;,
                                            <span class="ot">Qt::</span>CaseSensitivity)),
                spreadsheet, <span class="kw">SLOT</span>(findNext(<span class="dt">const</span> <span class="ot">QString</span> &amp;,
                                           <span class="ot">Qt::</span>CaseSensitivity)));</code></pre></div>
<p>&#38656;&#35201;&#27880;&#24847;&#30340;&#26159;&#36825;&#37324;&#29992;&#24341;&#29992;&#24182;&#27809;&#26377;&#29992;&#12290;&#20449;&#21495;&#21644;&#27133;&#20043;&#38388;&#25353;&#20540;&#20256;&#36882;&#12290;</p>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/setlayout.png" alt="set-layout-png" />
<p class="caption">set-layout-png</p>
</div>
</dd>
<dt>Qt&#8217;s Meta-Object System <code class="fold">@</code></dt>
<dd><p>The mechanism is called the <strong>meta-object</strong> system, and it provides two key services: <code>signal-slots</code> and <code>introspection</code>&#65288;&#20869;&#30465;&#65289;. The introspection functionality is necessary for implementing signals and slots, and allows application programmers to obtain &#8220;meta-information&#8221; about <code class="sourceCode cpp"><span class="ot">QObject</span></code> subclasses at run-time, including the list of signals and slots supported by the object and its class name. The mechanism also supports properties (used extensively by Qt Designer) and text translation (for internationalization), and it lays the foundation for the <code class="sourceCode cpp">QtScript</code> module.</p>
<p>Standard C++ doesn&#8217;t provide support for the dynamic meta-information needed by Qt&#8217;s meta-object system. Qt solves this problem by providing a separate tool, <code class="sourceCode bash"><span class="kw">moc</span></code>, that parses <code>Q_OBJECT</code> class definitions and makes the information available through C++ functions. Since <code>moc</code> implements all its functionality using pure C++, Qt&#8217;s meta-object system <strong>works with any C++ compiler</strong>.</p>
<p>The mechanism works as follows:</p>
<ol>
<li>The <code>Q_OBJECT</code> macro declares some <strong>introspection functions</strong> that must be implemented in every <code class="sourceCode cpp"><span class="ot">QObject</span></code> subclass: <code class="sourceCode cpp">metaObject()</code>, <code class="sourceCode cpp"><span class="fu">tr</span>()</code>, <code class="sourceCode cpp">qt_metacall()</code>, and a few more.</li>
<li>Qt&#8217;s <code class="sourceCode bash"><span class="kw">moc</span></code> tool generates implementations for the functions declared by <code>Q_OBJECT</code> and for all the signals.</li>
<li><code class="sourceCode cpp"><span class="ot">QObject</span></code> member functions such as <code class="sourceCode cpp"><span class="fu">connect</span>()</code> and <code class="sourceCode cpp"><span class="fu">disconnect</span>()</code> use the introspection functions to do their work.</li>
</ol>
<p>All of this is handled automatically by <code class="sourceCode bash"><span class="kw">qmake</span></code>, <code class="sourceCode bash"><span class="kw">moc</span></code>, and <code class="sourceCode cpp"><span class="ot">QObject</span></code>, so you rarely need to think about it. But if you are curious, you can read the <code class="sourceCode cpp"><span class="ot">QMetaObject</span></code> class documentation and have a look at the C++ source files generated by moc to see how the implementation works.</p>
</dd>
</dl>
</dd>
</dl>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QRegExp</span> regExp(<span class="st">&quot;[A-Za-z][1-9][0-9]{0,2}&quot;</span>);
lineEdit-&gt;setValidator(<span class="kw">new</span> <span class="ot">QRegExpValidator</span>(regExp, <span class="kw">this</span>));</code></pre></div>
<p>The <code class="sourceCode bash"><span class="kw">qmake</span></code> tool is smart enough to detect the user interface file <code>gotocelldialog.ui</code> and to generate the appropriate makefile rules to invoke <code class="sourceCode bash"><span class="kw">uic</span></code>, Qt&#8217;s user interface compiler. The <code class="sourceCode bash"><span class="kw">uic</span></code> tool converts <code>gotocelldialog.ui</code> into C++ and puts the result in <code class="sourceCode cpp">ui_gotocelldialog.h</code>.</p>
<p><strong>In the constructor, we call <code class="sourceCode cpp">setupUi()</code> to initialize the form.</strong></p>
<p>Also in the constructor, we set up a validator to restrict the range of the input. Qt provides three built-in validator classes: <code class="sourceCode cpp"><span class="ot">QIntValidator</span></code>, <code class="sourceCode cpp"><span class="ot">QDoubleValidator</span></code>, and <code class="sourceCode cpp"><span class="ot">QRegExpValidator</span></code>. Here we use a <code class="sourceCode cpp"><span class="ot">QRegExpValidator</span></code> with the regular expression <code>[A-Za-z][1-9][0-9]{0,2}</code>, which means: Allow one uppercase or lowercase letter, followed by one digit in the range 1 to 9, followed by zero, one, or two digits each in the range 0 to 9. (For an introduction to regular expressions, see the <code class="sourceCode cpp"><span class="ot">QRegExp</span></code> class documentation.)</p>
<p>By passing this to the <code class="sourceCode cpp"><span class="ot">QRegExpValidator</span></code> constructor, we make it a child of the <code class="sourceCode cpp">GoToCellDialog</code> object. By doing so, we don&#8217;t have to worry about deleting the <code class="sourceCode cpp"><span class="ot">QRegExpValidator</span></code> later; it will be deleted automatically when its parent is deleted.</p>
<p><strong>Qt&#8217;s parent-child mechanism</strong> is implemented in <code class="sourceCode cpp"><span class="ot">QObject</span></code>. When we create an object (a widget, validator, or any other kind) with a parent, the parent adds the object to the list of its children. When the parent is deleted, it walks through its list of children and deletes each child. The children themselves then delete all of their children, and so on <strong>recursively until none remain</strong>. The parent&#8211;child mechanism <strong>greatly simplifies memory management</strong>, <strong>reducing the risk of memory leaks</strong>. <strong>The only objects we must call delete on are the objects we create with new and that have no parent.</strong> And if we delete a child object before its parent, Qt will automatically remove that object from the parent&#8217;s list of children. For widgets, the parent has an additional meaning: <em>Child widgets are shown within the parent&#8217;s area</em>. When we delete the parent widget, not only does the child vanish from memory, it also vanishes from the screen. At the end of the constructor, we connect the <kbd>OK</kbd> button to <code class="sourceCode cpp"><span class="ot">QDialog</span></code>&#8217;s <code class="sourceCode cpp">accept()</code> slot and the Cancel button to the <code class="sourceCode cpp">reject()</code> slot. Both slots close the dialog, but <code>accept()</code> sets the dialog&#8217;s result value to <code class="sourceCode cpp"><span class="ot">QDialog::</span>Accepted</code> (which equals 1), and <code>reject()</code> sets the result to <code class="sourceCode cpp"><span class="ot">QDialog::</span>Rejected</code> (which equals 0). When we use this dialog, we can use the result to see if the user clicked <kbd>OK</kbd> and act accordingly.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#22312; gotocell.h &#37324;&#32487;&#25215; UI &#25991;&#20214;&#30340;&#31867;</span>
<span class="kw">class</span> GoToCellDialog : <span class="kw">public</span> <span class="ot">QDialog</span>, <span class="kw">public</span> Ui::GoToCellDialog

<span class="co">// &#22312; gotocell.cpp &#37324;&#30452;&#25509;&#29992;&#65288;&#19981;&#29992; ui-&gt;buttonBox&#65289;</span>
<span class="fu">connect</span>(buttonBox, <span class="kw">SIGNAL</span>(accepted()), <span class="kw">this</span>, <span class="kw">SLOT</span>(accept()));
<span class="fu">connect</span>(buttonBox, <span class="kw">SIGNAL</span>(rejected()), <span class="kw">this</span>, <span class="kw">SLOT</span>(reject()));

<span class="co">// signal/slot &#40664;&#35748;&#21517;&#31216;&#30340;&#65292;&#20063;&#30452;&#25509;&#23454;&#29616;&#21363;&#21487;</span>
<span class="dt">void</span> GoToCellDialog::on_lineEdit_textChanged()
{
    <span class="co">// QPushButton * QDialogButtonBox::button(StandardButton which) const</span>
    buttonBox-&gt;button(<span class="ot">QDialogButtonBox::</span>Ok)-&gt;setEnabled(
        lineEdit-&gt;hasAcceptableInput());
}</code></pre></div>
<h4 id="rapid-dialog-design">Rapid Dialog Design</h4>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/dlg.png" alt="shape changing dialog" />
<p class="caption">shape changing dialog</p>
</div>
<p>We will create the widget with its extended appearance in Qt Designer, and hide the secondary and tertiary keys at run-time as needed. The widget looks complicated, but it&#8217;s fairly easy to do in Qt Designer. The trick is to do the primary key part first, then duplicate it twice to obtain the secondary and tertiary keys.</p>
<h4 id="shape-changing-dialogs">Shape-Changing Dialogs</h4>
<p><img src="http://gnat.qiniudn.com/qt/layout-three-parts.png" /> <img src="http://gnat.qiniudn.com/qt/connecting.png" /> <img src="http://gnat.qiniudn.com/qt/connecting2.png" /></p>
<dl>
<dt>setSizeConstraint</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">secondaryGroupBox-&gt;hide();
tertiaryGroupBox-&gt;hide();
layout()-&gt;setSizeConstraint(<span class="ot">QLayout::</span>SetFixedSize); <span class="co">// &#22266;&#23450;&#23610;&#23544;</span>

<span class="ot">QChar</span> ch = first;
<span class="kw">while</span> (ch &lt;= last) {
    primaryColumnCombo-&gt;addItem(<span class="ot">QString</span>(ch));
    ch = ch.unicode() + <span class="dv">1</span>;
}</code></pre></div>
</dd>
</dl>
<p>The other common type of shape-changing dialogs, multi-page dialogs, are even easier to create in Qt, either in code or using Qt Designer. Such dialogs can be built in many different ways.</p>
<ol>
<li>A <code class="sourceCode cpp"><span class="ot">QTabWidget</span></code> can be used in its own right. It provides a tab bar that controls a built-in <code class="sourceCode cpp"><span class="ot">QStackedWidget</span></code>.</li>
<li>A <code class="sourceCode cpp"><span class="ot">QListWidget</span></code> and a <code class="sourceCode cpp"><span class="ot">QStackedWidget</span></code> can be used together, with the <code class="sourceCode cpp"><span class="ot">QListWidget</span></code>&#8217;s current item determining which page the <code class="sourceCode cpp"><span class="ot">QStackedWidget</span></code> shows, by connecting the <code class="sourceCode cpp"><span class="ot">QListWidget::</span>currentRowChanged()</code> signal to the <code class="sourceCode cpp"><span class="ot">QStackedWidget::</span>setCurrentIndex()</code> slot.</li>
<li>A <code class="sourceCode cpp"><span class="ot">QTreeWidget</span></code> can be used with a <code class="sourceCode cpp"><span class="ot">QStackedWidget</span></code> in a similar way to a <code class="sourceCode cpp"><span class="ot">QListWidget</span></code>.</li>
</ol>
<h4 id="dynamic-dialogs">Dynamic Dialogs</h4>
<p>Dynamic dialogs are dialogs that are created from Qt Designer <code>.ui</code> files at run-time. Instead of converting the <code>.ui</code> file to C++ code using <code class="sourceCode bash"><span class="kw">uic</span></code>, we can load the file at run-time using the <code class="sourceCode cpp"><span class="ot">QUiLoader</span></code> class:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QUiLoader</span> uiLoader;
<span class="ot">QFile</span> file(<span class="st">&quot;sortdialog.ui&quot;</span>);
<span class="ot">QWidget</span> *sortDialog = uiLoader.load(&amp;file);
<span class="kw">if</span> (sortDialog) {
    ...
}</code></pre></div>
<p>We can access the form&#8217;s child widgets using <code class="sourceCode cpp"><span class="ot">QObject::</span>findChild&lt;T&gt;()</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QComboBox</span> *primaryColumnCombo =
    sortDialog-&gt;findChild&lt;<span class="ot">QComboBox</span> *&gt;(<span class="st">&quot;primaryColumnCombo&quot;</span>);
<span class="kw">if</span> (primaryColumnCombo) {
    ...
}</code></pre></div>
<dl>
<dt><code class="sourceCode cpp">T <span class="ot">QObject::</span>findChild(<span class="dt">const</span> <span class="ot">QString</span> &amp; name = <span class="ot">QString</span>()) <span class="dt">const</span></code></dt>
<dd><p>Returns the child of this object that can be cast into type <code class="sourceCode cpp">T</code> and that is called name, or 0 if there is no such object. Omitting the name argument causes all object names to be matched. The search is <strong>performed recursively</strong>.</p>
<p>If there is more than one child matching the search, the most direct ancestor is returned. If there are several direct ancestors, it is undefined which one will be returned. In that case, <code class="sourceCode cpp">findChildren()</code> should be used.</p>
</dd>
</dl>
<h4 id="built-in-widget-and-dialog-classes">Built-in Widget and Dialog Classes</h4>
<ol>
<li>Single-page container widgets
<ol style="list-style-type: lower-roman">
<li><code class="sourceCode cpp"><span class="ot">QPushButton</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QToolButton</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QCheckBox</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QRadioButton</span></code></li>
</ol></li>
<li>Multi-page container widgets
<ol style="list-style-type: lower-roman">
<li><code class="sourceCode cpp"><span class="ot">QGroupBox</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QFrame</span></code></li>
</ol></li>
<li>Item viw widgets
<ol style="list-style-type: lower-roman">
<li><code class="sourceCode cpp"><span class="ot">QTabWidget</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QToolBox</span></code></li>
</ol></li>
<li>Display widgets
<ol style="list-style-type: lower-roman">
<li><code class="sourceCode cpp"><span class="ot">QListView</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QTreeView</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QListView</span></code> (as icons)</li>
<li><code class="sourceCode cpp"><span class="ot">QTableView</span></code></li>
</ol></li>
<li>Input widgets
<ol style="list-style-type: lower-roman">
<li><code class="sourceCode cpp"><span class="ot">QLabel</span></code> (text)</li>
<li><code class="sourceCode cpp"><span class="ot">QLabel</span></code> (image)</li>
<li><code class="sourceCode cpp"><span class="ot">QLCDNumber</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QProgressBar</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QTextBrowser</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QSpinBox</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QDoubleSpinBox</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QComboBox</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QDateEdit</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QTimeEdit</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QDateTimeEdit</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QScrollBar</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QSlider</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QLineEdit</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QDial</span></code></li>
</ol></li>
<li>Feedback dialogs
<ol style="list-style-type: lower-roman">
<li><code class="sourceCode cpp"><span class="ot">QTextEdit</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QInputDialog</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QProgressDialog</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QMessageBox</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QErrorMessage</span></code></li>
</ol></li>
<li>Color and font dialogs
<ol style="list-style-type: lower-roman">
<li><code class="sourceCode cpp"><span class="ot">QColorDialog</span></code>;</li>
</ol></li>
</ol>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> MainWindow : <span class="kw">public</span> <span class="ot">QMainWindow</span>
{
    <span class="kw">Q_OBJECT</span>

<span class="kw">public</span>:
    MainWindow();

<span class="kw">protected</span>:
    <span class="dt">void</span> closeEvent(<span class="ot">QCloseEvent</span> *event);

<span class="kw">private</span> <span class="kw">slots</span>:
    <span class="dt">void</span> open();
    ...

<span class="kw">private</span>:
    <span class="dt">void</span> createActions();
    <span class="dt">void</span> createMenus();
    <span class="dt">void</span> createContextMenu();
    <span class="dt">void</span> createToolBars();
    <span class="dt">void</span> createStatusBar();
    <span class="dt">void</span> readSettings();
    <span class="dt">void</span> writeSettings();
    ...

    Spreadsheet *spreadsheet;
    FindDialog *findDialog;
    <span class="ot">QLabel</span> *locationLabel;
    <span class="ot">QLabel</span> *formulaLabel;
    <span class="ot">QStringList</span> recentFiles;
    <span class="ot">QString</span> curFile;

    <span class="kw">enum</span> { MaxRecentFiles = <span class="dv">5</span> };
    <span class="ot">QAction</span> *recentFileActions[MaxRecentFiles];
    <span class="ot">QAction</span> *separatorAction;

    <span class="ot">QMenu</span> *fileMenu;
    <span class="ot">QMenu</span> *editMenu;
    <span class="ot">QMenu</span> *selectSubMenu;
    <span class="ot">QMenu</span> *toolsMenu;
    ...</code></pre></div>
<dl>
<dt><code>.pro</code></dt>
<dd><pre class="plain"><code>RESOURCES = spreadsheet.qrc</code></pre>
</dd>
<dt><code>.qrc</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;RCC&gt;</span>
<span class="kw">&lt;qresource&gt;</span>
    <span class="kw">&lt;file&gt;</span>images/icon.png<span class="kw">&lt;/file&gt;</span>
    ...
    <span class="kw">&lt;file&gt;</span>images/gotocell.png<span class="kw">&lt;/file&gt;</span>
<span class="kw">&lt;/qresource&gt;</span>
<span class="kw">&lt;/RCC&gt;</span></code></pre></div>
</dd>
</dl>
<h4 id="creating-menus-and-toolbars">Creating Menus and Toolbars</h4>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/menu.png" alt="menus" />
<p class="caption">menus</p>
</div>
<dl>
<dt>actions</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::createActions()
{
    newAction = <span class="kw">new</span> <span class="ot">QAction</span>(<span class="fu">tr</span>(<span class="st">&quot;&amp;New&quot;</span>), <span class="kw">this</span>);
    newAction-&gt;setIcon(<span class="ot">QIcon</span>(<span class="st">&quot;:/images/new.png&quot;</span>));
    newAction-&gt;setShortcut(<span class="ot">QKeySequence::</span>New);
    newAction-&gt;setStatusTip(<span class="fu">tr</span>(<span class="st">&quot;Create a new spreadsheet file&quot;</span>));
    <span class="fu">connect</span>(newAction, <span class="kw">SIGNAL</span>(triggered()), <span class="kw">this</span>, <span class="kw">SLOT</span>(newFile()));

    openAction...
    saveAction...
    saveAsAction...

    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; MaxRecentFiles; ++i) {
        recentFileActions[i] = <span class="kw">new</span> <span class="ot">QAction</span>(<span class="kw">this</span>);
        recentFileActions[i]-&gt;setVisible(<span class="kw">false</span>);
        <span class="fu">connect</span>(recentFileActions[i], <span class="kw">SIGNAL</span>(triggered()),
                <span class="kw">this</span>, <span class="kw">SLOT</span>(openRecentFile()));
    }

    exitAction...
    cutAction...
    copyAction...
    pasteAction...
    deleteAction...
    selectRowAction...
    selectColumnAction...
    selectAllAction...
    findAction...
    goToCellAction...
    recalculateAction...
    sortAction...

    showGridAction = <span class="kw">new</span> <span class="ot">QAction</span>(<span class="fu">tr</span>(<span class="st">&quot;&amp;Show Grid&quot;</span>), <span class="kw">this</span>);
    showGridAction-&gt;setCheckable(<span class="kw">true</span>);
    showGridAction-&gt;setChecked(spreadsheet-&gt;showGrid());
    showGridAction-&gt;setStatusTip(<span class="fu">tr</span>(<span class="st">&quot;Show or hide the spreadsheet&#39;s &quot;</span>
                                    <span class="st">&quot;grid&quot;</span>));
    <span class="fu">connect</span>(showGridAction, <span class="kw">SIGNAL</span>(toggled(<span class="dt">bool</span>)),
            spreadsheet, <span class="kw">SLOT</span>(setShowGrid(<span class="dt">bool</span>)));
<span class="ot">#if QT_VERSION &lt; 0x040102</span>
    <span class="co">// workaround for a QTableWidget bug in Qt 4.1.1</span>
    <span class="fu">connect</span>(showGridAction, <span class="kw">SIGNAL</span>(toggled(<span class="dt">bool</span>)),
            spreadsheet-&gt;viewport(), <span class="kw">SLOT</span>(update()));
<span class="ot">#endif</span>

    autoRecalcAction = <span class="kw">new</span> <span class="ot">QAction</span>(<span class="fu">tr</span>(<span class="st">&quot;&amp;Auto-Recalculate&quot;</span>), <span class="kw">this</span>);
    autoRecalcAction-&gt;setCheckable(<span class="kw">true</span>);
    autoRecalcAction-&gt;setChecked(spreadsheet-&gt;autoRecalculate());
    autoRecalcAction-&gt;setStatusTip(<span class="fu">tr</span>(<span class="st">&quot;Switch auto-recalculation on or &quot;</span>
                                      <span class="st">&quot;off&quot;</span>));
    <span class="fu">connect</span>(autoRecalcAction, <span class="kw">SIGNAL</span>(toggled(<span class="dt">bool</span>)),
            spreadsheet, <span class="kw">SLOT</span>(setAutoRecalculate(<span class="dt">bool</span>)));

    aboutAction = <span class="kw">new</span> <span class="ot">QAction</span>(<span class="fu">tr</span>(<span class="st">&quot;&amp;About&quot;</span>), <span class="kw">this</span>);
    aboutAction-&gt;setStatusTip(<span class="fu">tr</span>(<span class="st">&quot;Show the application&#39;s About box&quot;</span>));
    <span class="fu">connect</span>(aboutAction, <span class="kw">SIGNAL</span>(triggered()), <span class="kw">this</span>, <span class="kw">SLOT</span>(about()));

    aboutQtAction = <span class="kw">new</span> <span class="ot">QAction</span>(<span class="fu">tr</span>(<span class="st">&quot;About &amp;Qt&quot;</span>), <span class="kw">this</span>);
    aboutQtAction-&gt;setStatusTip(<span class="fu">tr</span>(<span class="st">&quot;Show the Qt library&#39;s About box&quot;</span>));
    <span class="fu">connect</span>(aboutQtAction, <span class="kw">SIGNAL</span>(triggered()), <span class="kw">qApp</span>, <span class="kw">SLOT</span>(aboutQt()));
}</code></pre></div>
</dd>
</dl>
<p>Show Grid is a <strong>checkable action</strong>. Checkable actions are rendered with a check-mark in the menu and <strong>implemented as toggle buttons in the toolbar</strong>. When the action is turned on, the Spreadsheet component displays a grid. We initialize the action with the default for the Spreadsheet component so that they are synchronized at startup.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::createMenus()
{
    <span class="co">// QMainWindow::menuBar() function returns a pointer to a QMenuBar.</span>
    <span class="co">// The menu bar is created the first time menuBar() is called.</span>
    fileMenu = menuBar()-&gt;addMenu(<span class="fu">tr</span>(<span class="st">&quot;&amp;File&quot;</span>));
    fileMenu-&gt;addAction(newAction);
    fileMenu-&gt;addAction(openAction);
    fileMenu-&gt;addAction(saveAction);
    fileMenu-&gt;addAction(saveAsAction);
    <span class="co">// may be invisible: separatorAction-&gt;setVisible(!recentFiles.isEmpty());</span>
    separatorAction = fileMenu-&gt;addSeparator();
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; MaxRecentFiles; ++i)
        fileMenu-&gt;addAction(recentFileActions[i]);
    fileMenu-&gt;addSeparator();
    fileMenu-&gt;addAction(exitAction);

    editMenu, toolsMenu, optionsMenu...

    menuBar()-&gt;addSeparator();

    helpMenu...</code></pre></div>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/context-menu.png" alt="context menu" />
<p class="caption">context menu</p>
</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::createContextMenu()
{
    <span class="co">// QWidget::addAction</span>
    spreadsheet-&gt;addAction(cutAction);
    spreadsheet-&gt;addAction(copyAction);
    spreadsheet-&gt;addAction(pasteAction);
    spreadsheet-&gt;setContextMenuPolicy(<span class="ot">Qt::</span>ActionsContextMenu);
}</code></pre></div>
<p>A more sophisticated way of providing context menus is to reimplement the <code class="sourceCode cpp"><span class="ot">QWidget::</span>contextMenuEvent()</code> function, create a <code class="sourceCode cpp"><span class="ot">QMenu</span></code> widget, populate it with the desired actions, and call <code class="sourceCode cpp">exec()</code> on it.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QWidgetAction</span> *TextureEditor::createEditModeToolButton()
{
    <span class="ot">QWidgetAction</span> *action = <span class="kw">new</span> <span class="ot">QWidgetAction</span>( <span class="kw">this</span> );

    <span class="ot">QComboBox</span> *ems = <span class="kw">new</span> <span class="ot">QComboBox</span>;
    ems-&gt;addItem( <span class="st">&quot;good &quot;</span>);
    ems-&gt;addItem( <span class="st">&quot;bad &quot;</span>);
    <span class="co">// ems-&gt;addAction( actionZoomIn );</span>
    <span class="co">// ems-&gt;addAction( actionZoomOut );</span>
    action-&gt;setDefaultWidget( ems );
    <span class="kw">return</span> action;
}

actionEditMode =
        createEditModeToolButton();

menuEdit-&gt;addAction( actionEditMode );</code></pre></div>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/toolbar.png" alt="ToolBar" />
<p class="caption">ToolBar</p>
</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::createToolBars()
{
    <span class="co">// QToolBar *QMainWindow::addToolBar(title)</span>
    fileToolBar = addToolBar(<span class="fu">tr</span>(<span class="st">&quot;&amp;File&quot;</span>));
    fileToolBar-&gt;addAction(newAction);
    ...

    editToolBar = addToolBar(<span class="fu">tr</span>(<span class="st">&quot;&amp;Edit&quot;</span>));
    ...
    editToolBar-&gt;addSeparator();
    ...
}

<span class="ot">QToolBar</span> *toolBarEdit = ui-&gt;mainToolBar;
removeToolBar( toolBarEdit );
addToolBar( <span class="ot">Qt::</span>RightToolBarArea, toolBarEdit );
toolBarEdit-&gt;show();</code></pre></div>
<h4 id="setting-up-the-status-bar">Setting Up the Status Bar</h4>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/status-bar.png" alt="Status Bar" />
<p class="caption">Status Bar</p>
</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::createStatusBar()
{
    locationLabel = <span class="kw">new</span> <span class="ot">QLabel</span>(<span class="st">&quot; W999 &quot;</span>);
    locationLabel-&gt;setAlignment(<span class="ot">Qt::</span>AlignHCenter);
    locationLabel-&gt;setMinimumSize(locationLabel-&gt;sizeHint());

    formulaLabel = <span class="kw">new</span> <span class="ot">QLabel</span>;
    formulaLabel-&gt;setIndent(<span class="dv">3</span>);

    <span class="co">// The QMainWindow::statusBar() function returns a pointer to the status</span>
    <span class="co">// bar. (The status bar is created the first time statusBar() is called.)</span>
    statusBar()-&gt;addWidget(locationLabel);
    statusBar()-&gt;addWidget(formulaLabel, <span class="dv">1</span>);

    <span class="fu">connect</span>(spreadsheet, <span class="kw">SIGNAL</span>(currentCellChanged(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>)),
            <span class="kw">this</span>, <span class="kw">SLOT</span>(updateStatusBar()));
    <span class="fu">connect</span>(spreadsheet, <span class="kw">SIGNAL</span>(modified()),
            <span class="kw">this</span>, <span class="kw">SLOT</span>(spreadsheetModified()));

    updateStatusBar();
}

<span class="dt">void</span> MainWindow::updateStatusBar()
{
    locationLabel-&gt;setText(spreadsheet-&gt;currentLocation());
    formulaLabel-&gt;setText(spreadsheet-&gt;currentFormula());
}</code></pre></div>
<h4 id="implementing-the-file-menu">Implementing the File Menu</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::newFile()
{
    <span class="kw">if</span> (okToContinue()) {
        spreadsheet-&gt;clear();
        setCurrentFile(<span class="st">&quot;&quot;</span>);
    }
}

<span class="dt">bool</span> MainWindow::okToContinue()
{
    <span class="kw">if</span> (isWindowModified()) {
        <span class="dt">int</span> r = <span class="ot">QMessageBox::</span>warning(<span class="kw">this</span>, <span class="fu">tr</span>(<span class="st">&quot;Spreadsheet&quot;</span>),
                        <span class="fu">tr</span>(<span class="st">&quot;The document has been modified.</span><span class="ch">\n</span><span class="st">&quot;</span>
                           <span class="st">&quot;Do you want to save your changes?&quot;</span>),
                        <span class="ot">QMessageBox::</span>Yes | <span class="ot">QMessageBox::</span>No
                        | <span class="ot">QMessageBox::</span>Cancel);
        <span class="kw">if</span> (r == <span class="ot">QMessageBox::</span>Yes) {
            <span class="kw">return</span> save();
        } <span class="kw">else</span> <span class="kw">if</span> (r == <span class="ot">QMessageBox::</span>Cancel) {
            <span class="kw">return</span> <span class="kw">false</span>;
        }
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre></div>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/qmessagebox-style.png" alt="QMessageBox Styles" />
<p class="caption">QMessageBox Styles</p>
</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QString</span> fileName =
    <span class="ot">QFileDialog::</span>getOpenFileName(<span class="kw">this</span>,
                                 <span class="fu">tr</span>(<span class="st">&quot;Open Spreadsheet&quot;</span>), <span class="st">&quot;.&quot;</span>,
                                 <span class="fu">tr</span>(<span class="st">&quot;Spreadsheet files (*.sp)&quot;</span>));
<span class="kw">if</span> (!fileName.isEmpty())
    loadFile(fileName);</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> MainWindow::save()
{
    <span class="kw">if</span> (curFile.isEmpty()) {
        <span class="kw">return</span> saveAs();
    } <span class="kw">else</span> {
        <span class="kw">return</span> saveFile(curFile);
    }
}</code></pre></div>
<p>Syntax:</p>
<ol>
<li><p><code class="sourceCode cpp"><span class="ot">QMessageBox::</span>warning(parent, title, message, buttons)</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span>           about(<span class="ot">QWidget</span> * parent,
                     <span class="dt">const</span> <span class="ot">QString</span> &amp; title,
                     <span class="dt">const</span> <span class="ot">QString</span> &amp; text)

<span class="dt">void</span>           aboutQt(<span class="ot">QWidget</span> * parent,
                       <span class="dt">const</span> <span class="ot">QString</span> &amp; title = <span class="ot">QString</span>())

StandardButton critical(<span class="ot">QWidget</span> * parent,
                        <span class="dt">const</span> <span class="ot">QString</span> &amp; title,
                        <span class="dt">const</span> <span class="ot">QString</span> &amp; text,
                        StandardButtons buttons = Ok,
                        StandardButton defaultButton = NoButton)

StandardButton information(<span class="ot">QWidget</span> * parent,
                           <span class="dt">const</span> <span class="ot">QString</span> &amp; title,
                           <span class="dt">const</span> <span class="ot">QString</span> &amp; text,
                           StandardButtons buttons = Ok,
                           StandardButton defaultButton = NoButton)

StandardButton question(<span class="ot">QWidget</span> * parent,
                        <span class="dt">const</span> <span class="ot">QString</span> &amp; title,
                        <span class="dt">const</span> <span class="ot">QString</span> &amp; text,
                        StandardButtons buttons = Ok,
                        StandardButton defaultButton = NoButton)

StandardButton warning(<span class="ot">QWidget</span> * parent,
                       <span class="dt">const</span> <span class="ot">QString</span> &amp; title,
                       <span class="dt">const</span> <span class="ot">QString</span> &amp; text,
                       StandardButtons buttons = Ok,
                       StandardButton defaultButton = NoButton)</code></pre></div></li>
<li><p><code class="sourceCode cpp"><span class="ot">QFileDialog::</span>getOpenFileName(parent, title, filter)</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QStringList</span> filters;
filters &lt;&lt; <span class="st">&quot;Image files (*.png *.xpm *.jpg)&quot;</span>
        &lt;&lt; <span class="st">&quot;Text files (*.txt)&quot;</span>
        &lt;&lt; <span class="st">&quot;Any files (*)&quot;</span>;

<span class="ot">QFileDialog</span> dialog(<span class="kw">this</span>);
dialog.setNameFilters(filters);
dialog.exec();

<span class="ot">QStringList</span> <span class="ot">QFileDialog::</span>getOpenFileNames ( <span class="ot">QWidget</span> * parent = <span class="dv">0</span>,
                                            <span class="dt">const</span> <span class="ot">QString</span> &amp; caption = <span class="ot">QString</span>(),
                                            <span class="dt">const</span> <span class="ot">QString</span> &amp; dir = <span class="ot">QString</span>(),
                                            <span class="dt">const</span> <span class="ot">QString</span> &amp; filter = <span class="ot">QString</span>(),
                                            <span class="ot">QString</span> * selectedFilter = <span class="dv">0</span>,
                                            Options options = <span class="dv">0</span> ); [<span class="dt">static</span>]
<span class="co">// filter: images (*.bmp *.png *.jpg *.jpeg *.png *.gif *.tif *.tiff)&quot;</span></code></pre></div></li>
<li><p><code class="sourceCode cpp"><span class="ot">QFileDialog::</span>getSaveFileName(parent, title, filter)</code></p></li>
</ol>
<div class="figure">
<img src="http://doc.qt.io/qt-4.8/images/filedialogurls.png" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QList</span>&lt;<span class="ot">QUrl</span>&gt; urls;
urls &lt;&lt; <span class="ot">QUrl::</span>fromLocalFile(<span class="st">&quot;/home/gvatteka/dev/qt-45&quot;</span>)
     &lt;&lt; <span class="ot">QUrl::</span>fromLocalFile(<span class="ot">QDesktopServices::</span>storageLocation(<span class="ot">QDesktopServices::</span>MusicLocation));

<span class="ot">QFileDialog</span> dialog;
dialog.setSidebarUrls(urls);
dialog.setFileMode(<span class="ot">QFileDialog::</span>AnyFile);
<span class="kw">if</span>(dialog.exec()) {
    <span class="co">// ...</span>
}</code></pre></div>
<p><code class="sourceCode cpp"><span class="ot">QWidget::</span>closeEvent()</code>, we can intercept attempts to close the main window and decide whether we want the window to actually close or not.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::closeEvent(<span class="ot">QCloseEvent</span> *event)
{
    <span class="kw">if</span> (okToContinue()) {
        writeSettings();
        event-&gt;accept();
    } <span class="kw">else</span> {
        event-&gt;ignore();
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::setCurrentFile(<span class="dt">const</span> <span class="ot">QString</span> &amp;fileName)
{
    curFile = fileName;
    setWindowModified(<span class="kw">false</span>);

    <span class="ot">QString</span> shownName = <span class="fu">tr</span>(<span class="st">&quot;Untitled&quot;</span>);
    <span class="kw">if</span> (!curFile.isEmpty()) {
        shownName = strippedName(curFile);
        recentFiles.removeAll(curFile);
        recentFiles.prepend(curFile);
        updateRecentFileActions();
    }

    setWindowTitle(<span class="fu">tr</span>(<span class="st">&quot;%1[*] - %2&quot;</span>).arg(shownName)
                                   .arg(<span class="fu">tr</span>(<span class="st">&quot;Spreadsheet&quot;</span>)));

    <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; MaxRecentFiles; ++j) {
        <span class="kw">if</span> (j &lt; recentFiles.count()) {
            <span class="ot">QString</span> text = <span class="fu">tr</span>(<span class="st">&quot;&amp;%1 %2&quot;</span>)
                           .arg(j + <span class="dv">1</span>)
                           .arg(strippedName(recentFiles[j]));
            recentFileActions[j]-&gt;setText(text);
            recentFileActions[j]-&gt;setData(recentFiles[j]); <span class="co">// QVariant</span>
            recentFileActions[j]-&gt;setVisible(<span class="kw">true</span>);
        } <span class="kw">else</span> {
            recentFileActions[j]-&gt;setVisible(<span class="kw">false</span>);
        }
    }
    separatorAction-&gt;setVisible(!recentFiles.isEmpty()); <span class="co">// &#20116;&#20307;&#25237;&#22320;&#65281;</span>
}

<span class="ot">QString</span> MainWindow::strippedName(<span class="dt">const</span> <span class="ot">QString</span> &amp;fullFileName)
{
    <span class="kw">return</span> <span class="ot">QFileInfo</span>(fullFileName).fileName();
}

<span class="ot">QMutableStringListIterator</span> i(recentFiles);
<span class="kw">while</span> (i.hasNext()) {
    <span class="kw">if</span> (!<span class="ot">QFile::</span>exists(i.next()))
        i.remove();
}</code></pre></div>
<dl>
<dt><code class="sourceCode cpp"><span class="ot">QFileInfo</span></code></dt>
<dd><p>The <code class="sourceCode cpp"><span class="ot">QFileInfo</span></code> class provides system-independent file information.</p>
<p>The file that the <code class="sourceCode cpp"><span class="ot">QFileInfo</span></code> works on is set in the constructor or later with <code class="sourceCode cpp">setFile()</code>. Use <code class="sourceCode cpp">exists()</code> to see if the file exists and <code class="sourceCode cpp">size()</code> to get its size.</p>
<p>If you want to switch off a <code class="sourceCode cpp"><span class="ot">QFileInfo</span></code>&#8217;s caching and force it to access the file system every time you request information from it call <code class="sourceCode cpp">setCaching(<span class="kw">false</span>)</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QDir</span>        absoluteDir() <span class="dt">const</span>
<span class="ot">QString</span>     absoluteFilePath() <span class="dt">const</span>
<span class="ot">QString</span>     absolutePath() <span class="dt">const</span>
<span class="ot">QString</span>     baseName() <span class="dt">const</span>
<span class="ot">QString</span>     fileName() <span class="dt">const</span>
<span class="ot">QString</span>     completeSuffix() <span class="dt">const</span>
<span class="ot">QDir</span>        dir() <span class="dt">const</span>

<span class="dt">bool</span>        exists() <span class="dt">const</span>
<span class="ot">QDateTime</span>   created() <span class="dt">const</span>

<span class="dt">bool</span>        isAbsolute() <span class="dt">const</span>
<span class="dt">bool</span>        isBundle() <span class="dt">const</span>
<span class="dt">bool</span>        isDir() <span class="dt">const</span>
<span class="dt">bool</span>        isExecutable() <span class="dt">const</span>
<span class="dt">bool</span>        isFile() <span class="dt">const</span>
<span class="dt">bool</span>        isHidden() <span class="dt">const</span>
<span class="dt">bool</span>        isReadable() <span class="dt">const</span>
<span class="dt">bool</span>        isRelative() <span class="dt">const</span>
<span class="dt">bool</span>        isRoot() <span class="dt">const</span>
<span class="dt">bool</span>        isSymLink() <span class="dt">const</span>
<span class="dt">bool</span>        isWritable() <span class="dt">const</span>
<span class="ot">QDateTime</span>   lastModified() <span class="dt">const</span>
<span class="ot">QDateTime</span>   lastRead() <span class="dt">const</span></code></pre></div>
<p>In contrast to <code class="sourceCode cpp">canonicalPath()</code> symbolic links or redundant &#8220;.&#8221; or &#8220;..&#8221; elements are not necessarily removed.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QFileInfo</span> fi(<span class="st">&quot;c:/temp/foo&quot;</span>);
<span class="co">// =&gt; fi.absoluteFilePath() =&gt; &quot;C:/temp/foo&quot;</span>

<span class="ot">QFileInfo</span> fi(<span class="st">&quot;/tmp/archive.tar.gz&quot;</span>);
<span class="ot">QString</span> base = fi.baseName();
<span class="co">// base = &quot;archive&quot;</span>

<span class="ot">QFileInfo</span> fi(<span class="st">&quot;/tmp/archive.tar.gz&quot;</span>);
<span class="ot">QString</span> ext = fi.completeSuffix();
<span class="co">// ext = &quot;tar.gz&quot;</span>

<span class="co">// For each of the following, dir() returns a QDir for &quot;~/examples/191697&quot;.</span>
<span class="ot">QFileInfo</span> fileInfo1(<span class="st">&quot;~/examples/191697/.&quot;</span>);
<span class="ot">QFileInfo</span> fileInfo2(<span class="st">&quot;~/examples/191697/..&quot;</span>);
<span class="ot">QFileInfo</span> fileInfo3(<span class="st">&quot;~/examples/191697/main.cpp&quot;</span>);

<span class="co">// For each of the following, dir() returns a QDir for &quot;.&quot;.</span>
<span class="ot">QFileInfo</span> fileInfo4(<span class="st">&quot;.&quot;</span>);
<span class="ot">QFileInfo</span> fileInfo5(<span class="st">&quot;..&quot;</span>); <span class="co">// be careful!</span>
<span class="ot">QFileInfo</span> fileInfo6(<span class="st">&quot;main.cpp&quot;</span>);</code></pre></div>
</dd>
</dl>
<p>Every action can have an associated &#8220;data&#8221; item of type <code class="sourceCode cpp"><span class="ot">QVariant</span></code>. The <code class="sourceCode cpp"><span class="ot">QVariant</span></code> type can hold values of many C++ and Qt types; we cover it in Chapter 11. Here, we store the full name of the file in the action&#8217;s &#8220;data&#8221; item so that we can easily retrieve it later. We also set the action to be visible.</p>
<p>The <code class="sourceCode cpp"><span class="fu">qobject_cast</span>&lt;T&gt;()</code> function performs a dynamic cast based on the meta-information generated by <code class="sourceCode bash"><span class="kw">moc</span></code>, Qt&#8217;s meta-object compiler. It returns a pointer of the requested <code class="sourceCode cpp"><span class="ot">QObject</span></code> subclass, or <code>0</code> if the object cannot be cast to that type. Unlike the Standard C++ <code class="sourceCode cpp"><span class="kw">dynamic_cast</span>&lt;T&gt;()</code>, Qt&#8217;s <code class="sourceCode cpp"><span class="fu">qobject_cast</span>&lt;T&gt;()</code> <strong>works correctly across dynamic library boundaries</strong>. In our example, we use <code class="sourceCode cpp"><span class="fu">qobject_cast</span>&lt;T&gt;()</code> to cast a <code class="sourceCode cpp"><span class="ot">QObject</span></code> pointer to a <code class="sourceCode cpp"><span class="ot">QAction</span></code> pointer. If the cast is successful (it should be), we call <code class="sourceCode cpp">loadFile()</code> with the full file name that we extract from the action&#8217;s data.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// connect(recentFileActions[i], SIGNAL(triggered()),</span>
<span class="co">//         this, SLOT(openRecentFile()))</span>
<span class="dt">void</span> MainWindow::openRecentFile()
{
    <span class="kw">if</span> (okToContinue()) {
        <span class="ot">QAction</span> *action = <span class="fu">qobject_cast</span>&lt;<span class="ot">QAction</span> *&gt;(sender());
        <span class="kw">if</span> (action)
            loadFile(action-&gt;data().toString());
    }
}</code></pre></div>
<h4 id="using-dialogs">Using Dialogs</h4>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/dialog.png" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::find()
{
    <span class="kw">if</span> (!findDialog) {
        findDialog = <span class="kw">new</span> FindDialog(<span class="kw">this</span>);
        <span class="co">// default params in slot</span>
        <span class="fu">connect</span>(findDialog, <span class="kw">SIGNAL</span>(findNext(<span class="dt">const</span> <span class="ot">QString</span> &amp;,
                                            <span class="ot">Qt::</span>CaseSensitivity)),
                spreadsheet, <span class="kw">SLOT</span>(findNext(<span class="dt">const</span> <span class="ot">QString</span> &amp;,
                                           <span class="ot">Qt::</span>CaseSensitivity)));
        <span class="fu">connect</span>(findDialog, <span class="kw">SIGNAL</span>(findPrevious(<span class="dt">const</span> <span class="ot">QString</span> &amp;,
                                                <span class="ot">Qt::</span>CaseSensitivity)),
                spreadsheet, <span class="kw">SLOT</span>(findPrevious(<span class="dt">const</span> <span class="ot">QString</span> &amp;,
                                               <span class="ot">Qt::</span>CaseSensitivity)));
    }

    findDialog-&gt;show();
    findDialog-&gt;raise();
    findDialog-&gt;activateWindow();
}</code></pre></div>
<p>Several scenarios are possible:</p>
<ol>
<li>This is the first time the user has invoked the Find dialog. (<code class="sourceCode cpp"><span class="kw">new</span></code>)</li>
<li>The Find dialog was invoked before, but the user closed it. (<code class="sourceCode cpp">show()</code>)</li>
<li>The Find dialog was invoked before and is still visible. (<code class="sourceCode cpp">raise(), activateWindow()</code>)</li>
</ol>
<p>A dialog is modeless if it&#8217;s invoked using <code>show()</code> (unless we call <code>setModal()</code> beforehand to make it modal); it is modal if it&#8217;s invoked using <code>exec()</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::goToCell()
{
    GoToCellDialog dialog(<span class="kw">this</span>); <span class="co">// &#19968;&#27425;&#24615; dialog</span>
    <span class="kw">if</span> (dialog.exec()) {
        <span class="ot">QString</span> str = dialog.lineEdit-&gt;text().toUpper();
        spreadsheet-&gt;setCurrentCell(str.mid(<span class="dv">1</span>).toInt() - <span class="dv">1</span>,
                                    str[<span class="dv">0</span>].unicode() - <span class="st">&#39;A&#39;</span>); <span class="co">// &#20116;&#20307;&#25237;&#22320;</span>
    }

    <span class="co">// or</span>
    <span class="co">//</span>
    <span class="co">// :   GoToCellDialog *dlg = new GoToCellDialog(this);</span>
    <span class="co">//     ...</span>
    <span class="co">//     delete dlg;</span>
}</code></pre></div>
<p>Creating modal dialogs (and context menus) on the stack is a common programming pattern since we usually don&#8217;t need the dialog (or menu) after we have used it, and it will <strong>automatically be destroyed at the end of the enclosing scope</strong>.</p>
<p>A more radical approach would be to pass a pointer to the Spreadsheet object when initializing the <code class="sourceCode cpp">SortDialog</code> object and to allow the dialog to operate directly on the <code class="sourceCode cpp">Spreadsheet</code>. This makes the <code class="sourceCode cpp">SortDialog</code> much less general, since it will work only on a certain type of widget, but it simplifies the code even further by eliminating the <code class="sourceCode cpp">SortDialog::setColumnRange()</code> function. The <code class="sourceCode cpp">MainWindow::sort()</code> function then becomes</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::sort()
{
    SortDialog dialog(<span class="kw">this</span>);
    dialog.setSpreadsheet(spreadsheet);
    dialog.exec();
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::about()
{
    <span class="ot">QMessageBox::</span>about(<span class="kw">this</span>, <span class="fu">tr</span>(<span class="st">&quot;About Spreadsheet&quot;</span>),
            <span class="fu">tr</span>(<span class="st">&quot;&lt;h2&gt;Spreadsheet 1.1&lt;/h2&gt;&quot;</span>
               <span class="st">&quot;&lt;p&gt;Copyright &amp;copy; 2008 Software Inc.&quot;</span>
               <span class="st">&quot;&lt;p&gt;Spreadsheet is a small application that &quot;</span>
               <span class="st">&quot;demonstrates QAction, QMainWindow, QMenuBar, &quot;</span>
               <span class="st">&quot;QStatusBar, QTableWidget, QToolBar, and many other &quot;</span>
               <span class="st">&quot;Qt classes.&quot;</span>));
}</code></pre></div>
<p>So far, we have used several convenience static functions from both <code class="sourceCode cpp"><span class="ot">QMessageBox</span></code> and <code class="sourceCode cpp"><span class="ot">QFileDialog</span></code>. These functions create a dialog, initialize it, and call <code>exec()</code> on it. It is also possible, although less convenient, to create a <code class="sourceCode cpp"><span class="ot">QMessageBox</span></code> or a <code class="sourceCode cpp"><span class="ot">QFileDialog</span></code> widget like any other widget and explicitly call <code>exec()</code>, or even <code>show()</code>, on it.</p>
<h4 id="storing-settings">Storing Settings</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QSettings::</span>QSettings(<span class="dt">const</span> <span class="ot">QString</span> &amp; organization,
                     <span class="dt">const</span> <span class="ot">QString</span> &amp; application = <span class="ot">QString</span>(),
                     <span class="ot">QObject</span> * parent = <span class="dv">0</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::writeSettings()
{
    <span class="ot">QSettings</span> settings(<span class="st">&quot;Software Inc.&quot;</span>, <span class="st">&quot;Spreadsheet&quot;</span>);

    <span class="co">// void QSettings::setValue(const QString &amp; key, const QVariant &amp; value)</span>
    settings.setValue(<span class="st">&quot;geometry&quot;</span>, saveGeometry());
    settings.setValue(<span class="st">&quot;recentFiles&quot;</span>, recentFiles);
    settings.setValue(<span class="st">&quot;showGrid&quot;</span>, showGridAction-&gt;isChecked());
    settings.setValue(<span class="st">&quot;autoRecalc&quot;</span>, autoRecalcAction-&gt;isChecked());
}

<span class="dt">void</span> MainWindow::readSettings()
{
    <span class="ot">QSettings</span> settings(<span class="st">&quot;Software Inc.&quot;</span>, <span class="st">&quot;Spreadsheet&quot;</span>);

    restoreGeometry(settings.value(<span class="st">&quot;geometry&quot;</span>).toByteArray());

    recentFiles = settings.value(<span class="st">&quot;recentFiles&quot;</span>).toStringList();
    updateRecentFileActions();

    <span class="co">// QVariant QSettings::value(const QString &amp; key,</span>
    <span class="co">//                           const QVariant &amp; defaultValue = QVariant())</span>
    <span class="dt">bool</span> showGrid = settings.value(<span class="st">&quot;showGrid&quot;</span>, <span class="kw">true</span>).toBool();
    showGridAction-&gt;setChecked(showGrid);

    <span class="dt">bool</span> autoRecalc = settings.value(<span class="st">&quot;autoRecalc&quot;</span>, <span class="kw">true</span>).toBool();
    autoRecalcAction-&gt;setChecked(autoRecalc);
}</code></pre></div>
<p>By default, <code class="sourceCode cpp"><span class="ot">QSettings</span></code> stores the application&#8217;s settings in platform-specific locations. On Windows, it uses the system registry; on Unix, it stores the data in text files; on Mac OS X, it uses the Core Foundation Preferences API.</p>
<p><code class="sourceCode cpp"><span class="ot">QSettings</span></code> stores settings as key&#8211;value pairs. The key is similar to a file system path. Subkeys can be specified <strong>using a path-like syntax</strong> (e.g., <code>findDialog/matchCase</code>) or <strong>using <code>beginGroup()</code> and <code>endGroup()</code></strong>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">settings.beginGroup(<span class="st">&quot;findDialog&quot;</span>);
{
    settings.setValue(<span class="st">&quot;matchCase&quot;</span>, caseCheckBox-&gt;isChecked());
    settings.setValue(<span class="st">&quot;searchBackward&quot;</span>,  backwardCheckBox-&gt;isChecked());
}
settings.endGroup()</code></pre></div>
<dl>
<dt><code class="sourceCode cpp"><span class="kw">qApp</span></code></dt>
<dd><p>A global pointer referring to the unique application object. It is equivalent to the pointer returned by the <code class="sourceCode cpp"><span class="ot">QCoreApplication::</span>instance()</code> function except that, in GUI applications, it is a pointer to a <code class="sourceCode cpp"><span class="ot">QApplication</span></code> instance.</p>
<p>Only one application object can be created.</p>
<p>The <code class="sourceCode cpp"><span class="ot">QApplication</span></code> object is accessible through the <code class="sourceCode cpp">instance()</code> function that returns a pointer equivalent to the global <code class="sourceCode cpp"><span class="kw">qApp</span></code> pointer.</p>
</dd>
</dl>
<h4 id="multiple-documents">Multiple Documents</h4>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/multidocument.png" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="fu">connect</span>(exitAction, <span class="kw">SIGNAL</span>(triggered()),
        <span class="kw">qApp</span>, <span class="kw">SLOT</span>(closeAllWindows()));</code></pre></div>
<p>The <code class="sourceCode cpp"><span class="ot">QApplication::</span>closeAllWindows()</code> slot closes all of the application&#8217;s windows, unless one of them rejects the close event. This is exactly the behavior we need here. We don&#8217;t have to worry about unsaved changes because that&#8217;s handled in <code class="sourceCode cpp">MainWindow::closeEvent()</code> whenever a window is closed.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">MainWindow::MainWindow()
{
    ...
    <span class="co">// This tells Qt to delete the window when it is closed. The</span>
    <span class="co">// Qt::WA_DeleteOnClose attribute is one of many flags</span>
    <span class="co">// that can be set on a QWidget to influence its behavior.</span>
    setAttribute(<span class="ot">Qt::</span>WA_DeleteOnClose);
    ...
}

<span class="kw">foreach</span> (<span class="ot">QWidget</span> *win, <span class="ot">QApplication::</span>topLevelWidgets()) {
    <span class="kw">if</span> (MainWindow *mainWin = <span class="fu">qobject_cast</span>&lt;MainWindow *&gt;(win)) {
        mainWin-&gt;updateRecentFileActions();
    }
}</code></pre></div>
<h4 id="splash-screens">Splash Screens</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
    <span class="ot">QApplication</span> app(argc, argv);

    <span class="ot">QSplashScreen</span> *splash = <span class="kw">new</span> <span class="ot">QSplashScreen</span>;
    splash-&gt;setPixmap(<span class="ot">QPixmap</span>(<span class="st">&quot;:/images/splash.png&quot;</span>));
    splash-&gt;show();

    <span class="ot">Qt::</span>Alignment topRight = <span class="ot">Qt::</span>AlignRight | <span class="ot">Qt::</span>AlignTop;
    splash-&gt;showMessage(<span class="ot">QObject::</span>tr(<span class="st">&quot;Setting up the main window...&quot;</span>),
                        topRight, <span class="ot">Qt::</span>white);

    MainWindow mainWin;

    splash-&gt;showMessage(<span class="ot">QObject::</span>tr(<span class="st">&quot;Loading modules...&quot;</span>),
                        topRight, <span class="ot">Qt::</span>white);
    loadModules();

    splash-&gt;showMessage(<span class="ot">QObject::</span>tr(<span class="st">&quot;Establishing connections...&quot;</span>),
                        topRight, <span class="ot">Qt::</span>white);
    establishConnections();

    <span class="co">// equivalent to setVisible(true)</span>
    mainWin.show();

    splash-&gt;finish(&amp;mainWin);
    <span class="kw">delete</span> splash;

    <span class="kw">return</span> app.exec();
}</code></pre></div>
<h3 id="implementing-application-functionality">4. Implementing Application Functionality</h3>
<h4 id="the-central-widget">The Central Widget</h4>
<p>The central area of a <code class="sourceCode cpp"><span class="ot">QMainWindow</span></code> can be occupied by any kind of widget. Here&#8217;s an overview of the possibilities:</p>
<ol>
<li>Use a standard Qt widget: <code class="sourceCode cpp"><span class="ot">QTableWidget</span></code>, <code class="sourceCode cpp"><span class="ot">QTextEdit</span></code></li>
<li>Use a custom widget</li>
<li>Use a plain <code class="sourceCode cpp"><span class="ot">QWidget</span></code> with a layout manager</li>
<li>Use a splitter</li>
<li>Use an MDI area</li>
</ol>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/tableWidget.png" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// spreadsheet.h</span>
<span class="kw">private</span>:
    <span class="ot">QString</span> text(<span class="dt">int</span> row, <span class="dt">int</span> column) <span class="dt">const</span>;

<span class="co">// spreadsheet.cpp</span>
<span class="ot">QString</span> Spreadsheet::text(<span class="dt">int</span> row, <span class="dt">int</span> column) <span class="dt">const</span>
{
    Cell *c = cell(row, column);
    <span class="kw">if</span> (c) {
        <span class="kw">return</span> c-&gt;text();
    } <span class="kw">else</span> {
        <span class="kw">return</span> <span class="st">&quot;&quot;</span>;
    }
}</code></pre></div>
<p>Qt&#8217;s item classes can be used out of the box as data holders. For example, a <code class="sourceCode cpp"><span class="ot">QTableWidgetItem</span></code> already stores a few attributes, including a string, font, color, and icon, and a pointer back to the <code class="sourceCode cpp"><span class="ot">QTableWidget</span></code>. The items can also hold data (<code class="sourceCode cpp">QVariants</code>), including registered custom types, and by subclassing the item class we can provide additional functionality.</p>
<p>Older toolkits provide a void pointer in their item classes to <strong>store custom data</strong>. In Qt, the more natural approach is to use <code>setData()</code> with a <code class="sourceCode cpp"><span class="ot">QVariant</span></code>, but if a void pointer is required, it can be trivially achieved by subclassing an item class and adding a void pointer member variable. For more challenging data handling requirements, such as large data sets, complex data items, database integration, and multiple data views, Qt provides <strong>a set of model/view classes</strong> that separate the data from their visual representation.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Spreadsheet::setFormula(<span class="dt">int</span> row, <span class="dt">int</span> column,
                             <span class="dt">const</span> <span class="ot">QString</span> &amp;formula)
{
    Cell *c = cell(row, column);
    <span class="kw">if</span> (!c) {
        c = <span class="kw">new</span> Cell;
        setItem(row, column, c);
    }
    c-&gt;setFormula(formula);
}</code></pre></div>
<dl>
<dt><code class="sourceCode cpp"><span class="kw">enum</span> <span class="ot">Qt::</span>CursorShape</code></dt>
<dd><p><a href="http://doc.qt.io/qt-4.8/qt.html#CursorShape-enum" class="uri">http://doc.qt.io/qt-4.8/qt.html#CursorShape-enum</a></p>
</dd>
</dl>
<h4 id="loading-and-saving">Loading and Saving</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> Spreadsheet::writeFile(<span class="dt">const</span> <span class="ot">QString</span> &amp;fileName)
{
    <span class="ot">QFile</span> file(fileName);
    <span class="kw">if</span> (!file.open(<span class="ot">QIODevice::</span>WriteOnly)) {
        <span class="ot">QMessageBox::</span>warning(<span class="kw">this</span>, <span class="fu">tr</span>(<span class="st">&quot;Spreadsheet&quot;</span>),
                             <span class="fu">tr</span>(<span class="st">&quot;Cannot write file </span><span class="ch">%1:\n%</span><span class="st">2.&quot;</span>)
                             .arg(file.fileName())
                             .arg(file.errorString()));
        <span class="kw">return</span> <span class="kw">false</span>;
    }

    <span class="ot">QDataStream</span> out(&amp;file);
    out.setVersion(<span class="ot">QDataStream::</span>Qt_4_3);

    out &lt;&lt; <span class="dt">quint32</span>(MagicNumber);

    <span class="co">// Application cursors are stored on an internal stack. setOverrideCursor()</span>
    <span class="co">// pushes the cursor onto the stack, and restoreOverrideCursor() pops the</span>
    <span class="co">// active cursor off the stack. changeOverrideCursor() changes the curently</span>
    <span class="co">// active application override cursor.</span>

    <span class="co">// Every setOverrideCursor() must eventually be followed by a corresponding</span>
    <span class="co">// restoreOverrideCursor(), otherwise the stack will never be emptied.</span>
    <span class="ot">QApplication::</span>setOverrideCursor(<span class="ot">Qt::</span>WaitCursor);
    <span class="kw">for</span> (<span class="dt">int</span> row = <span class="dv">0</span>; row &lt; RowCount; ++row) {
        <span class="kw">for</span> (<span class="dt">int</span> column = <span class="dv">0</span>; column &lt; ColumnCount; ++column) {
            <span class="ot">QString</span> str = formula(row, column);
            <span class="kw">if</span> (!str.isEmpty())
                out &lt;&lt; <span class="dt">quint16</span>(row) &lt;&lt; <span class="dt">quint16</span>(column) &lt;&lt; str;
        }
    }

    <span class="co">// Undoes the last setOverrideCursor().</span>
    <span class="ot">QApplication::</span>restoreOverrideCursor();
    <span class="co">// If setOverrideCursor() has been called twice, calling</span>
    <span class="co">// restoreOverrideCursor() will activate the first cursor set. Calling this</span>
    <span class="co">// function a second time restores the original widgets&#39; cursors.</span>

    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="dt">bool</span> Spreadsheet::readFile(<span class="dt">const</span> <span class="ot">QString</span> &amp;fileName)
{
    <span class="ot">QFile</span> file(fileName);
    <span class="kw">if</span> (!file.open(<span class="ot">QIODevice::</span>ReadOnly)) {
        <span class="ot">QMessageBox::</span>warning(<span class="kw">this</span>, <span class="fu">tr</span>(<span class="st">&quot;Spreadsheet&quot;</span>),
                             <span class="fu">tr</span>(<span class="st">&quot;Cannot read file </span><span class="ch">%1:\n%</span><span class="st">2.&quot;</span>)
                             .arg(file.fileName())
                             .arg(file.errorString()));
        <span class="kw">return</span> <span class="kw">false</span>;
    }

    <span class="ot">QDataStream</span> in(&amp;file);
    in.setVersion(<span class="ot">QDataStream::</span>Qt_4_3);

    <span class="dt">quint32</span> magic;
    in &gt;&gt; magic;
    <span class="kw">if</span> (magic != MagicNumber) {
        <span class="ot">QMessageBox::</span>warning(<span class="kw">this</span>, <span class="fu">tr</span>(<span class="st">&quot;Spreadsheet&quot;</span>),
                             <span class="fu">tr</span>(<span class="st">&quot;The file is not a Spreadsheet file.&quot;</span>));
        <span class="kw">return</span> <span class="kw">false</span>;
    }

    clear();

    <span class="dt">quint16</span> row;
    <span class="dt">quint16</span> column;
    <span class="ot">QString</span> str;

    <span class="ot">QApplication::</span>setOverrideCursor(<span class="ot">Qt::</span>WaitCursor);
    <span class="kw">while</span> (!in.atEnd()) {
        in &gt;&gt; row &gt;&gt; column &gt;&gt; str;
        setFormula(row, column, str);
    }
    <span class="ot">QApplication::</span>restoreOverrideCursor();
    <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre></div>
<p><code class="sourceCode cpp"><span class="ot">QDataStream</span></code> is very versatile. It can be used on a <code class="sourceCode cpp"><span class="ot">QFile</span></code>, and also on a <code class="sourceCode cpp"><span class="ot">QBuffer</span></code>, a <code class="sourceCode cpp"><span class="ot">QProcess</span></code>, a <code class="sourceCode cpp"><span class="ot">QTcpSocket</span></code>, a <code class="sourceCode cpp"><span class="ot">QUdpSocket</span></code>, or a <code class="sourceCode cpp"><span class="ot">QSslSocket</span></code>. Qt also offers a <code class="sourceCode cpp"><span class="ot">QTextStream</span></code> class that can be used instead of <code class="sourceCode cpp"><span class="ot">QDataStream</span></code> for reading and writing text files. Chapter 12 explains these classes in depth, and also describes various approaches to handling different <code class="sourceCode cpp"><span class="ot">QDataStream</span></code> versions.</p>
<p>The system clipboard is available in Qt through the <code class="sourceCode cpp"><span class="ot">QApplication::</span>clipboard()</code> static function. By calling <code class="sourceCode cpp"><span class="ot">QClipboard::</span>setText()</code>, we make the text available on the clipboard, both to this application and to other applications that support plain text.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Spreadsheet::cut()
{
    copy();
    del();
}

<span class="dt">void</span> Spreadsheet::copy()
{
    <span class="ot">QTableWidgetSelectionRange</span> range = selectedRange();
    <span class="ot">QString</span> str;

    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; range.rowCount(); ++i) {
        <span class="kw">if</span> (i &gt; <span class="dv">0</span>)
            str += <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; range.columnCount(); ++j) {
            <span class="kw">if</span> (j &gt; <span class="dv">0</span>)
                str += <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>;
            str += formula(range.topRow() + i, range.leftColumn() + j);
        }
    }
    <span class="ot">QApplication::</span>clipboard()-&gt;setText(str);
}

<span class="dt">void</span> Spreadsheet::paste()
{
    <span class="ot">QTableWidgetSelectionRange</span> range = selectedRange();
    <span class="ot">QString</span> str = <span class="ot">QApplication::</span>clipboard()-&gt;text();
    <span class="ot">QStringList</span> rows = str.split(<span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>);
    <span class="dt">int</span> numRows = rows.count();
    <span class="dt">int</span> numColumns = rows.first().count(<span class="st">&#39;</span><span class="ch">\t</span><span class="st">&#39;</span>) + <span class="dv">1</span>;

    <span class="kw">if</span> (range.rowCount() * range.columnCount() != <span class="dv">1</span>
            &amp;&amp; (range.rowCount() != numRows
                || range.columnCount() != numColumns)) {
        <span class="ot">QMessageBox::</span>information(<span class="kw">this</span>, <span class="fu">tr</span>(<span class="st">&quot;Spreadsheet&quot;</span>),
                <span class="fu">tr</span>(<span class="st">&quot;The information cannot be pasted because the copy &quot;</span>
                   <span class="st">&quot;and paste areas aren&#39;t the same size.&quot;</span>));
        <span class="kw">return</span>;
    }

    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; numRows; ++i) {
        <span class="ot">QStringList</span> columns = rows[i].split(<span class="st">&#39;</span><span class="ch">\t</span><span class="st">&#39;</span>);
        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; numColumns; ++j) {
            <span class="dt">int</span> row = range.topRow() + i;
            <span class="dt">int</span> column = range.leftColumn() + j;
            <span class="kw">if</span> (row &lt; RowCount &amp;&amp; column &lt; ColumnCount)
                setFormula(row, column, columns[j]);
        }
    }
    somethingChanged();
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QList</span>&lt;<span class="ot">QStringList</span>&gt; rows;
<span class="fu">qStableSort</span>(rows.begin(), rows.end(), compare);</code></pre></div>
<p>The <code class="sourceCode cpp"><span class="fu">qStableSort</span>()</code> function accepts a begin iterator, an end iterator, and a comparison function. The comparison function is a function that takes two arguments (two <code class="sourceCode cpp">QStringLists</code>) and that returns true if the first argument is &#8220;less than&#8221; the second argument, false otherwise. The compare object we pass as the comparison function isn&#8217;t really a function, but it can be used as one, as we will see shortly.</p>
<h4 id="subclassing-qtablewidget">Subclassing QTableWidget</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QVariant</span> Cell::evalFactor(<span class="dt">const</span> <span class="ot">QString</span> &amp;str, <span class="dt">int</span> &amp;pos) <span class="dt">const</span>
{
    <span class="ot">QVariant</span> result;
    <span class="dt">bool</span> negative = <span class="kw">false</span>;

    <span class="kw">if</span> (str[pos] == <span class="st">&#39;-&#39;</span>) {
        negative = <span class="kw">true</span>;
        ++pos;
    }

    <span class="kw">if</span> (str[pos] == <span class="st">&#39;(&#39;</span>) {
        ++pos;
        result = evalExpression(str, pos);
        <span class="kw">if</span> (str[pos] != <span class="st">&#39;)&#39;</span>)
            result = Invalid;
        ++pos;
    } <span class="kw">else</span> {
        <span class="ot">QRegExp</span> regExp(<span class="st">&quot;[A-Za-z][1-9][0-9]{0,2}&quot;</span>);
        <span class="ot">QString</span> token;

        <span class="kw">while</span> (str[pos].isLetterOrNumber() || str[pos] == <span class="st">&#39;.&#39;</span>) {
            token += str[pos];
            ++pos;
        }

        <span class="kw">if</span> (regExp.exactMatch(token)) {
            <span class="dt">int</span> column = token[<span class="dv">0</span>].toUpper().unicode() - <span class="st">&#39;A&#39;</span>;
            <span class="dt">int</span> row = token.mid(<span class="dv">1</span>).toInt() - <span class="dv">1</span>;

            Cell *c = <span class="kw">static_cast</span>&lt;Cell *&gt;(
                              tableWidget()-&gt;item(row, column));
            <span class="kw">if</span> (c) {
                result = c-&gt;value();
            } <span class="kw">else</span> {
                result = <span class="fl">0.0</span>;
            }
        } <span class="kw">else</span> {
            <span class="dt">bool</span> ok;
            result = token.toDouble(&amp;ok);
            <span class="kw">if</span> (!ok)
                result = Invalid;
        }
    }

    <span class="kw">if</span> (negative) {
        <span class="kw">if</span> (result.type() == <span class="ot">QVariant::</span>Double) {
            result = -result.toDouble();
        } <span class="kw">else</span> {
            result = Invalid;
        }
    }
    <span class="kw">return</span> result;
}</code></pre></div>
<h3 id="creating-custom-widgets">5. Creating Custom Widgets</h3>
<h4 id="customizing-qt-widgets">Customizing Qt Widgets</h4>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/hex-spin-widget.png" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QSpinBox::</span>setRange(<span class="dv">0</span>, <span class="dv">255</span>);
<span class="ot">QRegExpValidator</span> *validator =
        <span class="kw">new</span> <span class="ot">QRegExpValidator</span>(<span class="ot">QRegExp</span>(<span class="st">&quot;[0-9A-Fa-f]{1,8}&quot;</span>), <span class="kw">this</span>);

<span class="co">// called by QSpinBox when the user types a value into the editor part of the</span>
<span class="co">// spin box and presses Enter</span>
<span class="dt">int</span> HexSpinBox::valueFromText(<span class="dt">const</span> <span class="ot">QString</span> &amp;text) <span class="dt">const</span>
{
    <span class="kw">return</span> text.toInt( NULL, <span class="dv">16</span>);
}

<span class="co">// QSpinBox calls it to update the editor part of the spin box when the user</span>
<span class="co">// presses the spin box&#39;s up or down arrows.</span>
<span class="ot">QString</span> HexSpinBox::textFromValue(<span class="dt">int</span> value) <span class="dt">const</span>
{
    <span class="kw">return</span> <span class="ot">QString::</span>number(value, <span class="dv">16</span>).toUpper(); <span class="co">// lowercase</span>
}

<span class="co">// called by QSpinBox to see if the text entered so far is valid. There are</span>
<span class="co">// three possible results: Invalid (the text doesn&#39;t match the regular</span>
<span class="co">// expression), Intermediate (the text is a plausible part of a valid value),</span>
<span class="co">// and Acceptable (the text is valid). The eQRegExpValidator has a suitable</span>
<span class="co">// validate() function, so we simply return the result of calling it. In</span>
<span class="co">// theory, we should return Invalid or Intermediate for evalues that lie</span>
<span class="co">// outside the spin box&#39;s range, but QSpinBox is smart enough to detect that</span>
<span class="co">// condition without any help.</span>
<span class="ot">QValidator::</span>State HexSpinBox::validate(<span class="ot">QString</span> &amp;text, <span class="dt">int</span> &amp;pos) <span class="dt">const</span>
{
    <span class="kw">return</span> validator-&gt;validate(text, pos);
}</code></pre></div>
We have now finished the hexadecimal spin box. Customizing other Qt widgets follows the same pattern: 1) Pick a suitable Qt widget, 2) subclass it, and
<ol start="3" style="list-style-type: decimal">
<li>reimplement some virtual functions to change its behavior. If all we want to do is to customize an existing widget&#8217;s look and feel, we can apply a style sheet or implement a custom style instead of subclassing the widget, as explained in Chapter 19.</li>
</ol>
<h4 id="subclassing-qwidget">Subclassing QWidget</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> IconEditor : <span class="kw">public</span> <span class="ot">QWidget</span>
{
    <span class="kw">Q_OBJECT</span>
    <span class="kw">Q_PROPERTY</span>(<span class="ot">QColor</span> penColor READ penColor WRITE setPenColor)
    <span class="kw">Q_PROPERTY</span>(<span class="ot">QImage</span> iconImage READ iconImage WRITE setIconImage)
    <span class="kw">Q_PROPERTY</span>(<span class="dt">int</span> zoomFactor READ zoomFactor WRITE setZoomFactor)
    ...</code></pre></div>
<p>The IconEditor class uses the <code class="sourceCode cpp"><span class="kw">Q_PROPERTY</span>()</code> macro to declare three custom properties: penColor, iconImage, and zoomFactor. Each property has a data type, a &#8220;read&#8221; function, and an optional &#8220;write&#8221; function. For example, the penColor property is of type <code class="sourceCode cpp"><span class="ot">QColor</span></code> and can be read and written using the <code class="sourceCode cpp">penColor()</code> and <code class="sourceCode cpp">setPenColor()</code> functions.</p>
<dl>
<dt><code class="sourceCode cpp"><span class="kw">Q_PROPERTY</span></code></dt>
<dd><p>Qt provides a sophisticated property system similar to the ones supplied by some compiler vendors. However, as a compiler- and platform-independent library, Qt does not rely on non-standard compiler features like <code>__property</code> or <code>[property]</code>. The Qt solution works with any standard C++ compiler on every platform Qt supports. It is based on the Meta-Object System that also provides inter-object communication via signals and slots.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">Q_PROPERTY</span>(type name
           READ getFunction
           [WRITE setFunction]
           [RESET resetFunction]
           [NOTIFY notifySignal]
           [REVISION <span class="dt">int</span>]
           [DESIGNABLE <span class="dt">bool</span>]
           [SCRIPTABLE <span class="dt">bool</span>]
           [STORED <span class="dt">bool</span>]
           [USER <span class="dt">bool</span>]
           [CONSTANT]
           [FINAL])</code></pre></div>
<p>Here are some typical examples of property declarations taken from class <code class="sourceCode cpp"><span class="ot">QWidget</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">Q_PROPERTY</span>(<span class="dt">bool</span> focus READ hasFocus)
<span class="kw">Q_PROPERTY</span>(<span class="dt">bool</span> enabled READ isEnabled WRITE setEnabled)
<span class="kw">Q_PROPERTY</span>(<span class="ot">QCursor</span> cursor READ cursor WRITE setCursor RESET unsetCursor)</code></pre></div>
<p>A property behaves like a class data member, but it has additional features accessible through the Meta-Object System:</p>
<ol>
<li>A READ accessor function is required, e.g. <code class="sourceCode cpp"><span class="ot">QWidget::</span>focus</code> is a read-only property with READ function, <code class="sourceCode cpp"><span class="ot">QWidget::</span>hasFocus()</code>.</li>
<li>A WRITE accessor function is optional. It must return void and must take exactly one argument, either of the property&#8217;s type or a pointer or reference to that type.</li>
<li>A NOTIFY signal is optional. If defined, it should specify one existing signal in that class that is emitted whenever the value of the property changes.</li>
<li>Most properties are DESIGNABLE (default true)</li>
<li>Most properties are STORED (default true), but e.g., <code class="sourceCode cpp"><span class="ot">QWidget::</span>minimumWidth()</code> has STORED false, because its value is just taken from the width component of property <code class="sourceCode cpp"><span class="ot">QWidget::</span>minimumSize()</code>, which is a <code class="sourceCode cpp"><span class="ot">QSize</span></code>.</li>
<li>The USER attribute indicates whether the property is designated as the user-facing or user-editable property for the class. Normally, there is only one USER property per class (default false). e.g., QAbstractButton::checked is the user editable property for (checkable) buttons. Note that QItemDelegate gets and sets a widget&#8217;s USER property.</li>
<li>The presence of the FINAL attribute indicates that the property will not be overridden by a derived class.</li>
</ol>
<p>an example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> MyClass : <span class="kw">public</span> <span class="ot">QObject</span>
{
    <span class="kw">Q_OBJECT</span>
    <span class="kw">Q_PROPERTY</span>(Priority priority READ priority WRITE setPriority NOTIFY priorityChanged)
    <span class="kw">Q_ENUMS</span>(Priority)

<span class="kw">public</span>:
    MyClass(<span class="ot">QObject</span> *parent = <span class="dv">0</span>);
    ~MyClass();

    <span class="kw">enum</span> Priority { High, Low, VeryHigh, VeryLow };

    <span class="dt">void</span> setPriority(Priority priority)
    {
        m_priority = priority;
        <span class="kw">emit</span> priorityChanged(priority);
    }
    Priority priority() <span class="dt">const</span>
    { <span class="kw">return</span> m_priority; }

<span class="kw">signals</span>:
    <span class="dt">void</span> priorityChanged(Priority);

<span class="kw">private</span>:
    Priority m_priority;
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">MyClass *myinstance = <span class="kw">new</span> MyClass;
<span class="ot">QObject</span> *object = myinstance;

myinstance-&gt;setPriority(MyClass::VeryHigh);
object-&gt;setProperty(<span class="st">&quot;priority&quot;</span>, <span class="st">&quot;VeryHigh&quot;</span>);</code></pre></div>
<p><code class="sourceCode cpp"><span class="kw">Q_CLASSINFO</span>(<span class="st">&quot;Version&quot;</span>, <span class="st">&quot;3.0.0&quot;</span>)</code></p>
</dd>
</dl>
<p>&#22238;&#21040; IconEditor&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">protected</span>:
    <span class="dt">void</span> mousePressEvent(<span class="ot">QMouseEvent</span> *event);
    <span class="dt">void</span> mouseMoveEvent(<span class="ot">QMouseEvent</span> *event);
    <span class="dt">void</span> paintEvent(<span class="ot">QPaintEvent</span> *event);</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">IconEditor::IconEditor(<span class="ot">QWidget</span> *parent)
    : <span class="ot">QWidget</span>(parent)
{
    <span class="co">// the widget&#39;s content doesn&#39;t change when the widget is resized and that</span>
    <span class="co">// the content stays rooted to the widget&#39;s top-left corner</span>
    setAttribute(<span class="ot">Qt::</span>WA_StaticContents);


    <span class="co">// By calling setSizePolicy() in the constructor with QSizePolicy::Minimum</span>
    <span class="co">// as horizontal and vertical policies, we tell any layout manager that is</span>
    <span class="co">// responsible for this widget that the widget&#39;s size hint is really its</span>
    <span class="co">// minimum size. In other words, the widget can be stretched if required,</span>
    <span class="co">// but it should never shrink below the size hint.</span>
    setSizePolicy(<span class="ot">QSizePolicy::</span>Minimum, <span class="ot">QSizePolicy::</span>Minimum);

    curColor = <span class="ot">Qt::</span>black;
    zoom = <span class="dv">8</span>;

    image = <span class="ot">QImage</span>(<span class="dv">16</span>, <span class="dv">16</span>, <span class="ot">QImage::</span>Format_ARGB32);
    image.fill(<span class="fu">qRgba</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>));
}

<span class="co">//                r   g  b   a</span>
<span class="dt">QRgb</span> red = <span class="fu">qRgba</span>(<span class="dv">255</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">255</span>);
<span class="dt">QRgb</span> red = <span class="bn">0xFFFF0000</span>; <span class="co">// typedef of unsigned int</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// IconEditor.h</span>
<span class="kw">public</span>:
    <span class="ot">QSize</span> sizeHint() <span class="dt">const</span>;

<span class="co">// IconEditor.cpp</span>
<span class="ot">QSize</span> IconEditor::sizeHint() <span class="dt">const</span>
{
    <span class="ot">QSize</span> size = zoom * image.size();
    <span class="kw">if</span> (zoom &gt;= <span class="dv">3</span>)
        size += <span class="ot">QSize</span>(<span class="dv">1</span>, <span class="dv">1</span>);
    <span class="kw">return</span> size;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> IconEditor::setIconImage(<span class="dt">const</span> <span class="ot">QImage</span> &amp;newImage)
{
    <span class="kw">if</span> (newImage != image) {

        image = newImage.convertToFormat(<span class="ot">QImage::</span>Format_ARGB32);

        <span class="co">// call QWidget::update() to schedule a repainting of the widget</span>
        <span class="co">// using the new image</span>
        update();

        <span class="co">// call QWidget::updateGeometry() to tell any layout that contains the</span>
        <span class="co">// widget that the widget&#39;s size hint has changed. The layout will then</span>
        <span class="co">// automatically adapt to the new size hint.</span>
        updateGeometry();
    }
}</code></pre></div>
<p>force a paint event by calling <code class="sourceCode cpp"><span class="ot">QWidget::</span>update()</code> or <code class="sourceCode cpp"><span class="ot">QWidget::</span>repaint()</code>. The difference between these two functions is that <code class="sourceCode cpp">repaint()</code> forces an immediate repaint, whereas <code class="sourceCode cpp">update()</code> simply schedules a paint event for when Qt next processes events. <small>(Both functions do nothing if the widget isn&#8217;t visible on-screen.)</small></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> IconEditor::paintEvent(<span class="ot">QPaintEvent</span> *event)
{
    <span class="ot">QPainter</span> painter(<span class="kw">this</span>);

    <span class="co">// If the zoom factor is 3 or more, we draw the horizontal and vertical</span>
    <span class="co">// lines that form the grid using the QPainter::drawLine() function.</span>
    <span class="kw">if</span> (zoom &gt;= <span class="dv">3</span>) {

        <span class="co">// set new color</span>
        painter.setPen(palette().foreground().color());
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= image.width(); ++i)
            <span class="co">// x1, x2, y1, y2, topLeft &lt;= (0,0), x &lt;= width, y &lt;= height</span>
            painter.drawLine(zoom * i, <span class="dv">0</span>,
                             zoom * i, zoom * image.height());
        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= image.height(); ++j)
            painter.drawLine(<span class="dv">0</span>, zoom * j,
                             zoom * image.width(), zoom * j);
    }

    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; image.width(); ++i) {
        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; image.height(); ++j) {
            <span class="ot">QRect</span> rect = pixelRect(i, j);
            <span class="co">// QRegion: region of event, QRegion intersect(QRect/QRegion)</span>
            <span class="kw">if</span> (!event-&gt;region().intersect(rect).isEmpty()) {
                <span class="ot">QColor</span> color = <span class="ot">QColor::</span>fromRgba(image.pixel(i, j));
                <span class="kw">if</span> (color.alpha() &lt; <span class="dv">255</span>)
                    painter.fillRect(rect, <span class="ot">Qt::</span>white);
                painter.fillRect(rect, color);
            }
        }
    }
}</code></pre></div>
<p>A widget&#8217;s <strong>palette</strong> consists of three color groups: <code>active</code>, <code>inactive</code>, and <code>disabled</code>. Which color group should be used depends on the widget&#8217;s current state:</p>
<ol>
<li>The Active group is used for <strong>widgets in the currently active window</strong>.</li>
<li>The Inactive group is used for <strong>widgets in the other windows</strong>.</li>
<li>The Disabled group is used for <strong>disabled widgets in any window</strong>.</li>
</ol>
<p>Get an appropriate brush or color for drawing, the correct approach is to use the current <strong>palette</strong>, obtained from <code class="sourceCode cpp"><span class="ot">QWidget::</span>palette()</code>, and the required <strong>role</strong>, for example, <code class="sourceCode cpp"><span class="ot">QPalette::</span>foreground()</code>.</p>
<p>The <code class="sourceCode cpp">pixelRect()</code> function returns a <code class="sourceCode cpp"><span class="ot">QRect</span></code> suitable for <code class="sourceCode cpp"><span class="ot">QPainter::</span>fillRect()</code>. The <code>i</code> and <code>j</code> parameters are pixel coordinates in the QImage &#8212; not in the widget. If the zoom factor is 1, the two coordinate systems coincide exactly.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QRect</span> IconEditor::pixelRect(<span class="dt">int</span> i, <span class="dt">int</span> j) <span class="dt">const</span>
{
    <span class="kw">if</span> (zoom &gt;= <span class="dv">3</span>) {
        <span class="kw">return</span> <span class="ot">QRect</span>(zoom * i + <span class="dv">1</span>, zoom * j + <span class="dv">1</span>, zoom - <span class="dv">1</span>, zoom - <span class="dv">1</span>);
    } <span class="kw">else</span> {
        <span class="kw">return</span> <span class="ot">QRect</span>(zoom * i, zoom * j, zoom, zoom); <span class="co">// tl_x, tl_y, w, h</span>
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> IconEditor::mousePressEvent(<span class="ot">QMouseEvent</span> *event)
{
    <span class="kw">if</span> (event-&gt;button() == <span class="ot">Qt::</span>LeftButton) {
        <span class="co">// const QPoint &amp; QMouseEvent::pos() const</span>
        setImagePixel(event-&gt;pos(), <span class="kw">true</span>);
    } <span class="kw">else</span> <span class="kw">if</span> (event-&gt;button() == <span class="ot">Qt::</span>RightButton) {
        setImagePixel(event-&gt;pos(), <span class="kw">false</span>);
    }
}</code></pre></div>
<p><code class="sourceCode cpp">mouseMoveEvent()</code> handles &#8220;mouse move&#8221; events. By default, these events are generated only when the user is holding down a button. It is possible to change this behavior by calling <strong><code class="sourceCode cpp"><span class="ot">QWidget::</span>setMouseTracking()</code></strong>, but we don&#8217;t need to do so for this example. &#65288;&#36825;&#20010;&#21487;&#29992;&#20110;&#19977;&#32500;&#26174;&#31034;&#65288;&#21344;&#29992;&#40736;&#26631;&#65289;&#65289;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> IconEditor::setImagePixel(<span class="dt">const</span> <span class="ot">QPoint</span> &amp;pos, <span class="dt">bool</span> opaque)
{
    <span class="co">// widget coordinates ==&gt; image coordinates</span>
    <span class="dt">int</span> i = pos.x() / zoom;
    <span class="dt">int</span> j = pos.y() / zoom;

    <span class="co">// check whether the point is within the correct range</span>
    <span class="kw">if</span> (image.rect().contains(i, j)) {
        <span class="kw">if</span> (opaque) {
            image.setPixel(i, j, penColor().rgba());
        } <span class="kw">else</span> {
            image.setPixel(i, j, <span class="fu">qRgba</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>));
        }

        <span class="co">// update only this rectangle</span>
        update(pixelRect(i, j));
    }
}</code></pre></div>
<h4 id="integrating-custom-widgets-with-qt-designer">Integrating Custom Widgets with Qt Designer</h4>
<p>We must subclass <code class="sourceCode cpp"><span class="ot">QDesignerCustomWidgetInterface</span></code> and reimplement some virtual functions. We will assume that the plugin source code is located in a directory called iconeditorplugin and that the <code class="sourceCode cpp">IconEditor</code> source code is located in a parallel directory called iconeditor.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;QDesignerCustomWidgetInterface&gt;</span>

<span class="kw">class</span> IconEditorPlugin : <span class="kw">public</span> <span class="ot">QObject</span>,
                         <span class="kw">public</span> <span class="ot">QDesignerCustomWidgetInterface</span>
{
    <span class="kw">Q_OBJECT</span>
    <span class="kw">Q_INTERFACES</span>(<span class="ot">QDesignerCustomWidgetInterface</span>)

<span class="kw">public</span>:
    IconEditorPlugin(<span class="ot">QObject</span> *parent = <span class="dv">0</span>);

    <span class="co">// the name of the widget provided by the plugin</span>
    <span class="ot">QString</span> name() <span class="dt">const</span> { <span class="kw">return</span> <span class="st">&quot;IconEditor&quot;</span>; }

    <span class="co">// the name of the header file for the specified widget encapsulated by the</span>
    <span class="co">// plugin</span>
    <span class="ot">QString</span> includeFile() <span class="dt">const</span> { <span class="kw">return</span> <span class="st">&quot;iconeditor.h&quot;</span>; }

    <span class="co">// the name of the widget box group to which this custom widget should</span>
    <span class="co">// belong. If the name isn&#39;t already in use, Qt Designer will create a new</span>
    <span class="co">// group for the widget</span>
    <span class="ot">QString</span> group() <span class="dt">const</span>;

    <span class="co">// the icon to use to represent the custom widget in Qt Designer&#39;s widget</span>
    <span class="co">// box</span>
    <span class="ot">QIcon</span> icon() <span class="dt">const</span>;

    <span class="co">// QString QDesignerCustomWidgetInterface::whatsThis() const</span>
    <span class="co">// Returns a description of the widget that can be used by Qt Designer in</span>
    <span class="co">// &quot;What&#39;s This?&quot; help for the widget.</span>
    <span class="ot">QString</span> whatsThis() <span class="dt">const</span>;

    <span class="co">// Returns a short description of the widget that can be used by Qt</span>
    <span class="co">// Designer in a tool tip.</span>
    <span class="ot">QString</span> toolTip() <span class="dt">const</span>;

    <span class="co">// true if the widget can contain other widgets;</span>
    <span class="co">// otherwise, it returns false</span>
    <span class="dt">bool</span> isContainer() <span class="dt">const</span>;

    <span class="co">// Qt Designer calls the createWidget() function to create an instance of a</span>
    <span class="co">// widget class with the given parent</span>
    <span class="ot">QWidget</span> *createWidget(<span class="ot">QWidget</span> *parent);
};

<span class="co">// .cpp</span>
<span class="kw">Q_EXPORT_PLUGIN2</span>(iconeditorplugin, IconEditorPlugin)</code></pre></div>
<p><code>.pro</code></p>
<pre><code>TEMPLATE      = lib
CONFIG       += designer plugin release
HEADERS       = ../iconeditor/iconeditor.h \
                iconeditorplugin.h
SOURCES       = ../iconeditor/iconeditor.cpp \
                iconeditorplugin.cpp
RESOURCES     = iconeditorplugin.qrc
DESTDIR       = $$[QT_INSTALL_PLUGINS]/designer</code></pre>
<h4 id="double-buffering">Double Buffering</h4>
<p>Qt provides the <code class="sourceCode cpp"><span class="ot">QRubberBand</span></code> class for drawing rubber bands, but here we draw it ourselves to have finer control over the look, and to demonstrate double buffering.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;QMap&gt;</span>
<span class="ot">#include &lt;QPixmap&gt;</span>
<span class="ot">#include &lt;QVector&gt;</span>
<span class="ot">#include &lt;QWidget&gt;</span>

<span class="kw">class</span> <span class="ot">QToolButton</span>;
<span class="kw">class</span> PlotSettings;

<span class="kw">class</span> Plotter : <span class="kw">public</span> <span class="ot">QWidget</span>
{
    <span class="kw">Q_OBJECT</span>

<span class="kw">public</span>:
    Plotter(<span class="ot">QWidget</span> *parent = <span class="dv">0</span>);

    <span class="dt">void</span> setPlotSettings(<span class="dt">const</span> PlotSettings &amp;settings);
    <span class="dt">void</span> setCurveData(<span class="dt">int</span> id, <span class="dt">const</span> <span class="ot">QVector</span>&lt;<span class="ot">QPointF</span>&gt; &amp;data);
    <span class="dt">void</span> clearCurve(<span class="dt">int</span> id);
    <span class="ot">QSize</span> minimumSizeHint() <span class="dt">const</span>;
    <span class="ot">QSize</span> sizeHint() <span class="dt">const</span>;

<span class="kw">public</span> <span class="kw">slots</span>:
    <span class="dt">void</span> zoomIn();
    <span class="dt">void</span> zoomOut();

<span class="co">// In the protected section of the class, we declare</span>
<span class="co">// all the QWidget event handlers that we want to reimplement</span>
<span class="kw">protected</span>:
    <span class="dt">void</span> paintEvent(<span class="ot">QPaintEvent</span> *event);
    <span class="dt">void</span> resizeEvent(<span class="ot">QResizeEvent</span> *event);
    <span class="dt">void</span> mousePressEvent(<span class="ot">QMouseEvent</span> *event);
    <span class="dt">void</span> mouseMoveEvent(<span class="ot">QMouseEvent</span> *event);
    <span class="dt">void</span> mouseReleaseEvent(<span class="ot">QMouseEvent</span> *event);
    <span class="dt">void</span> keyPressEvent(<span class="ot">QKeyEvent</span> *event);
    <span class="dt">void</span> wheelEvent(<span class="ot">QWheelEvent</span> *event);

<span class="kw">private</span>:
    <span class="dt">void</span> updateRubberBandRegion();
    <span class="dt">void</span> refreshPixmap();
    <span class="dt">void</span> drawGrid(<span class="ot">QPainter</span> *painter);
    <span class="dt">void</span> drawCurves(<span class="ot">QPainter</span> *painter);

    <span class="kw">enum</span> { Margin = <span class="dv">50</span> };

    <span class="ot">QToolButton</span> *zoomInButton;
    <span class="ot">QToolButton</span> *zoomOutButton;
    <span class="co">// store a curve&#39;s points as a QVector&lt;QPointF&gt;</span>
    <span class="ot">QMap</span>&lt;<span class="dt">int</span>, <span class="ot">QVector</span>&lt;<span class="ot">QPointF</span>&gt; &gt; curveMap;
    <span class="ot">QVector</span>&lt;PlotSettings&gt; zoomStack;
    <span class="dt">int</span> curZoom;
    <span class="dt">bool</span> rubberBandIsShown;
    <span class="ot">QRect</span> rubberBandRect;

    <span class="co">// QPixmap. This variable holds a copy of the whole widget&#39;s rendering,</span>
    <span class="co">// identical to what is shown on-screen. The plot is always drawn onto this</span>
    <span class="co">// off-screen pixmap first; then the pixmap is copied onto the widget.</span>
    <span class="ot">QPixmap</span> pixmap;
};


<span class="co">// specifies the range of the x- and y-axes and the number of ticks for these</span>
<span class="co">// axes</span>
<span class="kw">class</span> PlotSettings
{
<span class="kw">public</span>:
    PlotSettings();

    <span class="dt">void</span> scroll(<span class="dt">int</span> dx, <span class="dt">int</span> dy);
    <span class="dt">void</span> adjust();
    <span class="dt">double</span> spanX() <span class="dt">const</span> { <span class="kw">return</span> maxX - minX; }
    <span class="dt">double</span> spanY() <span class="dt">const</span> { <span class="kw">return</span> maxY - minY; }

    <span class="dt">double</span> minX;
    <span class="dt">double</span> maxX;
    <span class="dt">double</span> minY;
    <span class="dt">double</span> maxY;
    <span class="dt">int</span> numXTicks;
    <span class="dt">int</span> numYTicks;

<span class="kw">private</span>:
    <span class="dt">static</span> <span class="dt">void</span> adjustAxis(<span class="dt">double</span> &amp;min, <span class="dt">double</span> &amp;max, <span class="dt">int</span> &amp;numTicks);
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Plotter::Plotter(<span class="ot">QWidget</span> *parent)
    : <span class="ot">QWidget</span>(parent)
{
    <span class="co">// tells QWidget to use the &quot;dark&quot; component of the palette as the color</span>
    <span class="co">// for erasing the widget, instead of the &quot;window&quot; component</span>
    <span class="co">// This gives Qt a default color that it can use to fill any newly revealed</span>
    <span class="co">// pixels when the widget is resized to a larger size, before paintEvent()</span>
    <span class="co">// even has the chance to paint the new pixels. We also need to call</span>
    <span class="co">// setAutoFillBackground(true) to enable this mechanism. (By default, child</span>
    <span class="co">// widgets inherit the background from their parent widget.)</span>
    setBackgroundRole(<span class="ot">QPalette::</span>Dark);
    setAutoFillBackground(<span class="kw">true</span>);

    <span class="co">// default: QSizePolicy::Preferred in both directions</span>
    setSizePolicy(<span class="ot">QSizePolicy::</span>Expanding, <span class="ot">QSizePolicy::</span>Expanding);

    <span class="co">// accept focus by clicking or by pressing Tab. When the Plotter has focus,</span>
    <span class="co">// it will receive events for key presses.</span>
    setFocusPolicy(<span class="ot">Qt::</span>StrongFocus);
    rubberBandIsShown = <span class="kw">false</span>;

    zoomInButton = <span class="kw">new</span> <span class="ot">QToolButton</span>(<span class="kw">this</span>);
    zoomInButton-&gt;setIcon(<span class="ot">QIcon</span>(<span class="st">&quot;:/images/zoomin.png&quot;</span>));
    zoomInButton-&gt;adjustSize();
    <span class="fu">connect</span>(zoomInButton, <span class="kw">SIGNAL</span>(clicked()), <span class="kw">this</span>, <span class="kw">SLOT</span>(zoomIn()));

    zoomOutButton = <span class="kw">new</span> <span class="ot">QToolButton</span>(<span class="kw">this</span>);
    zoomOutButton-&gt;setIcon(<span class="ot">QIcon</span>(<span class="st">&quot;:/images/zoomout.png&quot;</span>));
    zoomOutButton-&gt;adjustSize();
    <span class="fu">connect</span>(zoomOutButton, <span class="kw">SIGNAL</span>(clicked()), <span class="kw">this</span>, <span class="kw">SLOT</span>(zoomOut()));

    setPlotSettings(PlotSettings());
}

<span class="dt">void</span> Plotter::zoomOut()
{
    <span class="kw">if</span> (curZoom &gt; <span class="dv">0</span>) {
        --curZoom;
        zoomOutButton-&gt;setEnabled(curZoom &gt; <span class="dv">0</span>);
        zoomInButton-&gt;setEnabled(<span class="kw">true</span>);
        zoomInButton-&gt;show();
        refreshPixmap();
    }
}

<span class="dt">void</span> Plotter::setCurveData(<span class="dt">int</span> id, <span class="dt">const</span> <span class="ot">QVector</span>&lt;<span class="ot">QPointF</span>&gt; &amp;data)
{
    curveMap[id] = data;
    refreshPixmap();
}

<span class="dt">void</span> Plotter::clearCurve(<span class="dt">int</span> id);

<span class="dt">void</span> Plotter::paintEvent(<span class="ot">QPaintEvent</span> * <span class="co">/* event */</span>)
{
    <span class="ot">QStylePainter</span> painter(<span class="kw">this</span>);
    painter.drawPixmap(<span class="dv">0</span>, <span class="dv">0</span>, pixmap);

    <span class="kw">if</span> (rubberBandIsShown) {
        painter.setPen(palette().light().color());
        <span class="co">// QRect::normalized() ensures that the rubber band rectangle has</span>
        <span class="co">// positive width and height. And adjusted() reduces the size of the</span>
        <span class="co">// rectangle by one pixel to allow for its own 1-pixel-wide outline</span>
        painter.drawRect(rubberBandRect.normalized()
                                       .adjusted(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">-1</span>, <span class="dv">-1</span>));
    }

    <span class="kw">if</span> (hasFocus()) {
        <span class="ot">QStyleOptionFocusRect</span> option;
        option.initFrom(<span class="kw">this</span>);
        option.backgroundColor = palette().dark().color();
        painter.drawPrimitive(<span class="ot">QStyle::</span>PE_FrameFocusRect, option);
    }
}

<span class="dt">void</span> Plotter::resizeEvent(<span class="ot">QResizeEvent</span> * <span class="co">/* event */</span>)
{
    <span class="co">// reimplement resizeEvent() to place the Zoom In and Zoom Out buttons at</span>
    <span class="co">// the top right of the Plotter widget, side by side, separated by a</span>
    <span class="co">// 5-pixel gap and with a 5-pixel offset from the top and right edges of</span>
    <span class="co">// the parent widget</span>
    <span class="dt">int</span> x = width() - (zoomInButton-&gt;width()
                       + zoomOutButton-&gt;width() + <span class="dv">10</span>);
    zoomInButton-&gt;move(x, <span class="dv">5</span>);
    zoomOutButton-&gt;move(x + zoomInButton-&gt;width() + <span class="dv">5</span>, <span class="dv">5</span>);
    refreshPixmap();
}</code></pre></div>
<dl>
<dt><code class="sourceCode cpp"><span class="ot">QRubberBand</span></code></dt>
<dd><p>The QRubberBand class provides a rectangle or line that can indicate a selection or a boundary.</p>
<p>You can create a <code class="sourceCode cpp"><span class="ot">QRubberBand</span></code> whenever you need to render a rubber band around a given area (or to represent a single line), then call <code class="sourceCode cpp">setGeometry()</code>, <code class="sourceCode cpp">move()</code> or <code class="sourceCode cpp">resize()</code> to position and size it. A common pattern is to do this in conjunction with mouse events. For example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Widget::mousePressEvent(<span class="ot">QMouseEvent</span> *event)
{
    origin = event-&gt;pos();
    <span class="kw">if</span> (!rubberBand)
        rubberBand = <span class="kw">new</span> <span class="ot">QRubberBand</span>(<span class="ot">QRubberBand::</span>Rectangle, <span class="kw">this</span>);
    rubberBand-&gt;setGeometry(<span class="ot">QRect</span>(origin, <span class="ot">QSize</span>()));
    rubberBand-&gt;show();
}

<span class="dt">void</span> Widget::mouseMoveEvent(<span class="ot">QMouseEvent</span> *event)
{
    rubberBand-&gt;setGeometry(<span class="ot">QRect</span>(origin, event-&gt;pos()).normalized());
}

<span class="dt">void</span> Widget::mouseReleaseEvent(<span class="ot">QMouseEvent</span> *event)
{
    rubberBand-&gt;hide();
    <span class="co">// determine selection, for example using QRect::intersects()</span>
    <span class="co">// and QRect::contains().</span>
}</code></pre></div>
<p><code class="sourceCode cpp"><span class="kw">enum</span> <span class="ot">QRubberBand::</span>Shape { Line, Rectangle };</code> specifies what shape a <code class="sourceCode cpp"><span class="ot">QRubberBand</span></code> should have. This is a drawing hint that is passed down to the style system, and can be interpreted by each <code class="sourceCode cpp"><span class="ot">QStyle</span></code>.</p>
</dd>
</dl>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Plotter::mousePressEvent(<span class="ot">QMouseEvent</span> *event)
{
    <span class="ot">QRect</span> rect(Margin, Margin,
               width() - <span class="dv">2</span> * Margin, height() - <span class="dv">2</span> * Margin);

    <span class="kw">if</span> (event-&gt;button() == <span class="ot">Qt::</span>LeftButton) {
        <span class="kw">if</span> (rect.contains(event-&gt;pos())) {
            rubberBandIsShown = <span class="kw">true</span>;
            rubberBandRect.setTopLeft(event-&gt;pos());
            rubberBandRect.setBottomRight(event-&gt;pos());
            updateRubberBandRegion();

            <span class="co">// QWidget::setCursor() sets the cursor shape to use when the mouse</span>
            <span class="co">// hovers over a particular widget. If no cursor is set for a</span>
            <span class="co">// widget, the parent widget&#39;s cursor is used. The default for</span>
            <span class="co">// top-level widgets is an arrow cursor.</span>
            setCursor(<span class="ot">Qt::</span>CrossCursor);

            <span class="co">// QApplication::setOverrideCursor() with Qt::WaitCursor to change</span>
            <span class="co">// the application&#39;s cursor to the standard wait cursor.</span>
        }
    }
}

<span class="co">// consists of four calls to update() that schedule a paint event for the four</span>
<span class="co">// small rectangular areas that are covered by the rubber band (two vertical</span>
<span class="co">// and two horizontal lines).</span>
<span class="dt">void</span> Plotter::updateRubberBandRegion()
{
    <span class="ot">QRect</span> rect = rubberBandRect.normalized();
    update(rect.left(), rect.top(), rect.width(), <span class="dv">1</span>);
    update(rect.left(), rect.top(), <span class="dv">1</span>, rect.height());
    update(rect.left(), rect.bottom(), rect.width(), <span class="dv">1</span>);
    update(rect.right(), rect.top(), <span class="dv">1</span>, rect.height());
}

<span class="dt">void</span> Plotter::mouseMoveEvent(<span class="ot">QMouseEvent</span> *event)
{
    <span class="kw">if</span> (rubberBandIsShown) {
        <span class="co">// erases the rubber band</span>
        updateRubberBandRegion();
        rubberBandRect.setBottomRight(event-&gt;pos());
        <span class="co">// redraws it at the new coordinates</span>
        updateRubberBandRegion();
    }
}

<span class="dt">void</span> Plotter::mouseReleaseEvent(<span class="ot">QMouseEvent</span> *event)
{
    <span class="kw">if</span> ((event-&gt;button() == <span class="ot">Qt::</span>LeftButton) &amp;&amp; rubberBandIsShown) {
        rubberBandIsShown = <span class="kw">false</span>;
        <span class="co">// erase the rubber band</span>
        updateRubberBandRegion();
        <span class="co">// restore the standard arrow cursor</span>
        unsetCursor();

        <span class="co">// If the rubber band is at least 4 x 4, we perform the zoom.</span>
        <span class="co">// If the rubber band is smaller than that, it&#39;s likely that the user</span>
        <span class="co">// clicked the widget by mistake or to give it focus, so we do nothing</span>
        <span class="ot">QRect</span> rect = rubberBandRect.normalized();
        <span class="kw">if</span> (rect.width() &lt; <span class="dv">4</span> || rect.height() &lt; <span class="dv">4</span>)
            <span class="kw">return</span>;
        rect.translate(-Margin, -Margin);

        PlotSettings prevSettings = zoomStack[curZoom];
        PlotSettings settings;
        <span class="dt">double</span> dx = prevSettings.spanX() / (width() - <span class="dv">2</span> * Margin);
        <span class="dt">double</span> dy = prevSettings.spanY() / (height() - <span class="dv">2</span> * Margin);
        settings.minX = prevSettings.minX + dx * rect.left();
        settings.maxX = prevSettings.minX + dx * rect.right();
        settings.minY = prevSettings.maxY - dy * rect.bottom();
        settings.maxY = prevSettings.maxY - dy * rect.top();
        settings.adjust();

        zoomStack.resize(curZoom + <span class="dv">1</span>);
        zoomStack.append(settings);
        zoomIn();
    }
}

<span class="dt">void</span> Plotter::keyPressEvent(<span class="ot">QKeyEvent</span> *event)
{
    <span class="kw">switch</span> (event-&gt;key()) {
    <span class="kw">case</span> <span class="ot">Qt::</span>Key_Plus<span class="ot">:</span>
        zoomIn();
        <span class="kw">break</span>;
    <span class="kw">case</span> <span class="ot">Qt::</span>Key_Minus<span class="ot">:</span>
        zoomOut();
        <span class="kw">break</span>;
    <span class="kw">case</span> <span class="ot">Qt::</span>Key_Left<span class="ot">:</span>
        zoomStack[curZoom].scroll(<span class="dv">-1</span>, <span class="dv">0</span>);
        refreshPixmap();
        <span class="kw">break</span>;
    <span class="kw">case</span> <span class="ot">Qt::</span>Key_Right<span class="ot">:</span>
        zoomStack[curZoom].scroll(<span class="dv">+1</span>, <span class="dv">0</span>);
        refreshPixmap();
        <span class="kw">break</span>;
    <span class="kw">case</span> <span class="ot">Qt::</span>Key_Down<span class="ot">:</span>
        zoomStack[curZoom].scroll(<span class="dv">0</span>, <span class="dv">-1</span>);
        refreshPixmap();
        <span class="kw">break</span>;
    <span class="kw">case</span> <span class="ot">Qt::</span>Key_Up<span class="ot">:</span>
        zoomStack[curZoom].scroll(<span class="dv">0</span>, <span class="dv">+1</span>);
        refreshPixmap();
        <span class="kw">break</span>;
    <span class="kw">default</span>:
        <span class="ot">QWidget::</span>keyPressEvent(event);
    }
}

<span class="dt">void</span> Plotter::keyPressEvent(<span class="ot">QKeyEvent</span> *event)
{
    <span class="co">// For simplicity, we ignore the Shift, Ctrl, and Alt modifier keys, which</span>
    <span class="co">// are available through QKeyEvent::modifiers().</span>
    <span class="kw">switch</span> (event-&gt;key()) {
    <span class="kw">case</span> <span class="ot">Qt::</span>Key_Plus<span class="ot">:</span>
        zoomIn();
        <span class="kw">break</span>;
    <span class="kw">case</span> <span class="ot">Qt::</span>Key_Minus<span class="ot">:</span>
        zoomOut();
        <span class="kw">break</span>;
    <span class="kw">case</span> <span class="ot">Qt::</span>Key_Left<span class="ot">:</span>
        zoomStack[curZoom].scroll(<span class="dv">-1</span>, <span class="dv">0</span>);
        refreshPixmap();
        <span class="kw">break</span>;
    <span class="kw">case</span> <span class="ot">Qt::</span>Key_Right<span class="ot">:</span>
        zoomStack[curZoom].scroll(<span class="dv">+1</span>, <span class="dv">0</span>);
        refreshPixmap();
        <span class="kw">break</span>;
    <span class="kw">case</span> <span class="ot">Qt::</span>Key_Down<span class="ot">:</span>
        zoomStack[curZoom].scroll(<span class="dv">0</span>, <span class="dv">-1</span>);
        refreshPixmap();
        <span class="kw">break</span>;
    <span class="kw">case</span> <span class="ot">Qt::</span>Key_Up<span class="ot">:</span>
        zoomStack[curZoom].scroll(<span class="dv">0</span>, <span class="dv">+1</span>);
        refreshPixmap();
        <span class="kw">break</span>;
    <span class="kw">default</span>:
        <span class="ot">QWidget::</span>keyPressEvent(event);
    }
}

<span class="dt">void</span> Plotter::wheelEvent(<span class="ot">QWheelEvent</span> *event)
{
    <span class="dt">int</span> numDegrees = event-&gt;delta() / <span class="dv">8</span>;
    <span class="dt">int</span> numTicks = numDegrees / <span class="dv">15</span>;

    <span class="co">// Most mice provide only a vertical wheel, but some also have a horizontal</span>
    <span class="co">// wheel. Qt supports both kinds of wheel</span>
    <span class="kw">if</span> (event-&gt;orientation() == <span class="ot">Qt::</span>Horizontal) {
        zoomStack[curZoom].scroll(numTicks, <span class="dv">0</span>);
    } <span class="kw">else</span> {
        zoomStack[curZoom].scroll(<span class="dv">0</span>, numTicks);
    }

    <span class="co">// When we use QScrollArea (covered in Chapter 6) to provide scroll bars,</span>
    <span class="co">// QScrollArea handles the mouse wheel events automatically, so we don&#39;t</span>
    <span class="co">// need to reimplement wheelEvent() ourselves.</span>
    refreshPixmap();
}

<span class="dt">void</span> Plotter::refreshPixmap()
{
    pixmap = <span class="ot">QPixmap</span>(size());
    <span class="co">// Fills the pixmap with the widget&#39;s background color or pixmap. The given</span>
    <span class="co">// point, (x, y), defines an offset in widget coordinates to which the</span>
    <span class="co">// pixmap&#39;s top-left pixel will be mapped to.</span>
    pixmap.fill(<span class="kw">this</span>, <span class="dv">0</span>, <span class="dv">0</span>);

    <span class="ot">QPainter</span> painter(&amp;pixmap);
    <span class="co">// Initializes the painters pen, background and font to the same as the</span>
    <span class="co">// given widget. This function is called automatically when the painter is</span>
    <span class="co">// opened on a QWidget</span>
    painter.initFrom(<span class="kw">this</span>);
    drawGrid(&amp;painter);
    drawCurves(&amp;painter);
    update();
}

<span class="co">// The drawGrid() function draws the grid behind the curves and the axes. The</span>
<span class="co">// area on which we draw the grid is specified by rect. If the widget isn&#39;t</span>
<span class="co">// large enough to accommodate the graph, we return immediately.</span>
<span class="dt">void</span> Plotter::drawGrid(<span class="ot">QPainter</span> *painter)
{
    <span class="ot">QRect</span> rect(Margin, Margin,
               width() - <span class="dv">2</span> * Margin, height() - <span class="dv">2</span> * Margin);
    <span class="kw">if</span> (!rect.isValid())
        <span class="kw">return</span>;

    PlotSettings settings = zoomStack[curZoom];
    <span class="ot">QPen</span> quiteDark = palette().dark().color().light();
    <span class="ot">QPen</span> light = palette().light().color();

    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= settings.numXTicks; ++i) {
        <span class="dt">int</span> x = rect.left() + (i * (rect.width() - <span class="dv">1</span>)
                                 / settings.numXTicks);
        <span class="dt">double</span> label = settings.minX + (i * settings.spanX()
                                          / settings.numXTicks);
        painter-&gt;setPen(quiteDark);
        painter-&gt;drawLine(x, rect.top(), x, rect.bottom());
        painter-&gt;setPen(light);
        painter-&gt;drawLine(x, rect.bottom(), x, rect.bottom() + <span class="dv">5</span>);
        <span class="co">// painter-&gt;drawText(x, y, width, height, alignment, text);</span>
        <span class="co">// a more adaptable alternative would involve calculating the text&#39;s</span>
        <span class="co">// bounding rectangle using QFontMetrics</span>
        painter-&gt;drawText(x - <span class="dv">50</span>, rect.bottom() + <span class="dv">5</span>, <span class="dv">100</span>, <span class="dv">20</span>,
                          <span class="ot">Qt::</span>AlignHCenter | <span class="ot">Qt::</span>AlignTop,
                          <span class="ot">QString::</span>number(label));
    }
    <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= settings.numYTicks; ++j) {
        <span class="dt">int</span> y = rect.bottom() - (j * (rect.height() - <span class="dv">1</span>)
                                   / settings.numYTicks);
        <span class="dt">double</span> label = settings.minY + (j * settings.spanY()
                                          / settings.numYTicks);
        painter-&gt;setPen(quiteDark);
        painter-&gt;drawLine(rect.left(), y, rect.right(), y);
        painter-&gt;setPen(light);
        painter-&gt;drawLine(rect.left() - <span class="dv">5</span>, y, rect.left(), y);
        painter-&gt;drawText(rect.left() - Margin, y - <span class="dv">10</span>, Margin - <span class="dv">5</span>, <span class="dv">20</span>,
                          <span class="ot">Qt::</span>AlignRight | <span class="ot">Qt::</span>AlignVCenter,
                          <span class="ot">QString::</span>number(label));
    }
    painter-&gt;drawRect(rect.adjusted(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">-1</span>, <span class="dv">-1</span>));
}

<span class="dt">void</span> Plotter::drawCurves(<span class="ot">QPainter</span> *painter)
{
    <span class="dt">static</span> <span class="dt">const</span> <span class="ot">QColor</span> colorForIds[<span class="dv">6</span>] = {
        <span class="ot">Qt::</span>red, <span class="ot">Qt::</span>green, <span class="ot">Qt::</span>blue, <span class="ot">Qt::</span>cyan, <span class="ot">Qt::</span>magenta, <span class="ot">Qt::</span>yellow
    };
    PlotSettings settings = zoomStack[curZoom];
    <span class="ot">QRect</span> rect(Margin, Margin,
               width() - <span class="dv">2</span> * Margin, height() - <span class="dv">2</span> * Margin);
    <span class="kw">if</span> (!rect.isValid())
        <span class="kw">return</span>;

    <span class="co">// set the QPainter&#39;s clip region to the rectangle that contains the curves</span>
    <span class="co">// (excluding the margins and the frame around the graph)</span>
    painter-&gt;setClipRect(rect.adjusted(<span class="dv">+1</span>, <span class="dv">+1</span>, <span class="dv">-1</span>, <span class="dv">-1</span>));

    <span class="ot">QMapIterator</span>&lt;<span class="dt">int</span>, <span class="ot">QVector</span>&lt;<span class="ot">QPointF</span>&gt; &gt; i(curveMap);
    <span class="kw">while</span> (i.hasNext()) {
        i.next();

        <span class="dt">int</span> id = i.key();
        <span class="ot">QVector</span>&lt;<span class="ot">QPointF</span>&gt; data = i.value();
        <span class="ot">QPolygonF</span> polyline(data.count());

        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; data.count(); ++j) {
            <span class="dt">double</span> dx = data[j].x() - settings.minX;
            <span class="dt">double</span> dy = data[j].y() - settings.minY;
            <span class="dt">double</span> x = rect.left() + (dx * (rect.width() - <span class="dv">1</span>)
                                         / settings.spanX());
            <span class="dt">double</span> y = rect.bottom() - (dy * (rect.height() - <span class="dv">1</span>)
                                           / settings.spanY());
            polyline[j] = <span class="ot">QPointF</span>(x, y);
        }

        <span class="co">// set the pen color for the curve</span>
        painter-&gt;setPen(colorForIds[<span class="dt">uint</span>(id) % <span class="dv">6</span>]);
        <span class="co">// draw a line that goes through all the curve&#39;s points</span>
        painter-&gt;drawPolyline(polyline);

        <span class="co">// QPolygonF polygon;</span>
        <span class="co">// polygon &lt;&lt; QPointF(10.4, 20.5) &lt;&lt; QPointF(20.2, 30.2);</span>
    }
}</code></pre></div>
<h2 id="part-ii-intermediate-qt">Part II: Intermediate Qt</h2>
<h3 id="layout-management">6. Layout Management</h3>
<h4 id="laying-out-widgets-on-a-form">Laying Out Widgets on a Form</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">FindFileDialog::FindFileDialog(<span class="ot">QWidget</span> *parent)
    : <span class="ot">QDialog</span>(parent)
{
    ...
    setMinimumSize(<span class="dv">265</span>, <span class="dv">190</span>);
    resize(<span class="dv">365</span>, <span class="dv">240</span>);
}

<span class="dt">void</span> FindFileDialog::resizeEvent(<span class="ot">QResizeEvent</span> * <span class="co">/* event */</span>)
{
    <span class="dt">int</span> extraWidth = width() - minimumWidth();
    <span class="dt">int</span> extraHeight = height() - minimumHeight();
    ...
}

<span class="ot">QGridLayout</span> *leftLayout = <span class="kw">new</span> <span class="ot">QGridLayout</span>;
leftLayout-&gt;addWidget(namedLabel, <span class="dv">0</span>, <span class="dv">0</span>);
leftLayout-&gt;addWidget(namedLineEdit, <span class="dv">0</span>, <span class="dv">1</span>);
leftLayout-&gt;addWidget(lookInLabel, <span class="dv">1</span>, <span class="dv">0</span>);
leftLayout-&gt;addWidget(lookInLineEdit, <span class="dv">1</span>, <span class="dv">1</span>);
leftLayout-&gt;addWidget(subfoldersCheckBox, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>); <span class="co">// span two columns</span>
leftLayout-&gt;addWidget(tableWidget, <span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>);
leftLayout-&gt;addWidget(messageLabel, <span class="dv">4</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>);

<span class="ot">QVBoxLayout</span> *rightLayout = <span class="kw">new</span> <span class="ot">QVBoxLayout</span>;
rightLayout-&gt;addWidget(findButton);
rightLayout-&gt;addWidget(stopButton);
rightLayout-&gt;addWidget(closeButton);
<span class="co">// Stretch. Adds a stretchable space (a QSpacerItem) with zero minimum size and</span>
<span class="co">// stretch factor stretch to the end of this box layout. In Qt Designer, we can</span>
<span class="co">// achieve the same effect by inserting a spacer</span>
rightLayout-&gt;addStretch();
rightLayout-&gt;addWidget(helpButton);

<span class="ot">QHBoxLayout</span> *mainLayout = <span class="kw">new</span> <span class="ot">QHBoxLayout</span>;
mainLayout-&gt;addLayout(leftLayout);
mainLayout-&gt;addLayout(rightLayout);
setLayout(mainLayout);</code></pre></div>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/size-policy.png" />

</div>
<ol>
<li><code class="sourceCode cpp"><span class="ot">QLayout::</span>setContentsMargins()</code></li>
<li><code class="sourceCode cpp"><span class="ot">QLayout::</span>setSpacing()</code></li>
<li><code class="sourceCode cpp">gridlayout-&gt;addWidget(widget, row, column, rowSpan, columnSpan)</code></li>
<li><code class="sourceCode cpp"><span class="ot">QSizePolicy</span></code>, <code class="sourceCode cpp">sizeHint()</code>, <code class="sourceCode cpp">minimumSizeHint()</code>
<ol style="list-style-type: lower-roman">
<li>Fixed</li>
<li>Minimum</li>
<li>Maximum</li>
<li>Prefered</li>
<li>Expanding</li>
</ol></li>
</ol>
<p>In addition to the size policy&#8217;s horizontal and vertical components, the <code class="sourceCode cpp"><span class="ot">QSizePolicy</span></code> class stores <strong>a horizontal and a vertical stretch factor</strong>.</p>
<h4 id="stacked-layouts">Stacked Layouts</h4>
<p>For convenience, Qt also includes <code class="sourceCode cpp"><span class="ot">QStackedWidget</span></code>, which provides a <code class="sourceCode cpp"><span class="ot">QWidget</span></code> with a built-in <code class="sourceCode cpp"><span class="ot">QStackedLayout</span></code>.</p>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/stacked-widgets.png" />

</div>
<ol>
<li><code class="sourceCode cpp">setCurrentIndex()</code>, the page number for a child widget is available using <code class="sourceCode cpp">indexOf()</code></li>
<li>add a <code class="sourceCode cpp"><span class="ot">QListWidget</span></code> and a <code class="sourceCode cpp"><span class="ot">QStackedWidget</span></code> to the form.</li>
<li>Connect the list widget&#8217;s <code>currentRowChanged(int)</code> signal to the stacked widget&#8217;s <code class="sourceCode cpp">setCurrentIndex(<span class="dt">int</span>)</code> slot.</li>
<li>list widget&#8217;s <code>currentRow</code> property to 0.</li>
</ol>
<p>For cases where the number of pages is small and likely to remain small, a simpler alternative to using a <code class="sourceCode cpp"><span class="ot">QStackedWidget</span></code> and <code class="sourceCode cpp"><span class="ot">QListWidget</span></code> is to use a <code class="sourceCode cpp"><span class="ot">QTabWidget</span></code>.</p>
<h4 id="splitters">Splitters</h4>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/splitter.png" alt="splitter" />
<p class="caption">splitter</p>
</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;QtGui&gt;</span>

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
    <span class="ot">QApplication</span> app(argc, argv);

    <span class="ot">QTextEdit</span> *editor1 = <span class="kw">new</span> <span class="ot">QTextEdit</span>;
    <span class="ot">QTextEdit</span> *editor2 = <span class="kw">new</span> <span class="ot">QTextEdit</span>;
    <span class="ot">QTextEdit</span> *editor3 = <span class="kw">new</span> <span class="ot">QTextEdit</span>;

    <span class="ot">QSplitter</span> splitter(<span class="ot">Qt::</span>Horizontal);
    splitter.addWidget(editor1);
    splitter.addWidget(editor2);
    splitter.addWidget(editor3);

    editor1-&gt;setPlainText(<span class="st">&quot;...&quot;</span>);
    editor2-&gt;setPlainText(<span class="st">&quot;...&quot;</span>);
    editor3-&gt;setPlainText(<span class="st">&quot;...&quot;</span>);

    splitter.setWindowTitle(<span class="ot">QObject::</span>tr(<span class="st">&quot;Splitter&quot;</span>));
    splitter.show();

    <span class="kw">return</span> app.exec();
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">mainSplitter = <span class="kw">new</span> <span class="ot">QSplitter</span>(<span class="ot">Qt::</span>Horizontal);
mainSplitter-&gt;addWidget(foldersTreeWidget);
mainSplitter-&gt;addWidget(rightSplitter);
<span class="co">// (idx, stretch): idx: int QSplitter::indexOf(QWidget * widget)</span>
mainSplitter-&gt;setStretchFactor(<span class="dv">1</span>, <span class="dv">1</span>);
setCentralWidget(mainSplitter);

<span class="co">// write settings</span>
<span class="dt">void</span> MailClient::writeSettings()
{
    <span class="ot">QSettings</span> settings(<span class="st">&quot;Software Inc.&quot;</span>, <span class="st">&quot;Mail Client&quot;</span>);

    settings.beginGroup(<span class="st">&quot;mainWindow&quot;</span>);
    {
        settings.setValue(<span class="st">&quot;geometry&quot;</span>, saveGeometry());
        settings.setValue(<span class="st">&quot;mainSplitter&quot;</span>, mainSplitter-&gt;saveState());
        settings.setValue(<span class="st">&quot;rightSplitter&quot;</span>, rightSplitter-&gt;saveState());
    }
    settings.endGroup();
}

<span class="co">// readSettings</span>
<span class="dt">void</span> MailClient::readSettings()
{
    <span class="ot">QSettings</span> settings(<span class="st">&quot;Software Inc.&quot;</span>, <span class="st">&quot;Mail Client&quot;</span>);

    settings.beginGroup(<span class="st">&quot;mainWindow&quot;</span>);
    {
        restoreGeometry(settings.value(<span class="st">&quot;geometry&quot;</span>).toByteArray());
        mainSplitter-&gt;restoreState(
                settings.value(<span class="st">&quot;mainSplitter&quot;</span>).toByteArray());
        rightSplitter-&gt;restoreState(
                settings.value(<span class="st">&quot;rightSplitter&quot;</span>).toByteArray());
    }
    settings.endGroup();
}</code></pre></div>
<dl>
<dt><code class="sourceCode cpp"><span class="dt">void</span> <span class="ot">QSplitter::</span>setStretchFactor(<span class="dt">int</span> index, <span class="dt">int</span> stretch)</code></dt>
<dd><p>Updates the size policy of the widget at position index to have a stretch factor of stretch.</p>
<p>stretch is not the effective stretch factor; the effective stretch factor is calculated by taking the initial size of the widget and multiplying it with stretch.</p>
<p>This function is provided for convenience. It is equivalent to</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QWidget</span> *widget = splitter-&gt;widget(index);
<span class="ot">QSizePolicy</span> policy = widget-&gt;sizePolicy();
policy.setHorizontalStretch(stretch);
policy.setVerticalStretch(stretch);
widget-&gt;setSizePolicy(policy);</code></pre></div>
</dd>
</dl>
<h4 id="scrolling-areas">Scrolling Areas</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">IconEditor *iconEditor = <span class="kw">new</span> IconEditor;
iconEditor-&gt;setIconImage(<span class="ot">QImage</span>(<span class="st">&quot;:/images/mouse.png&quot;</span>));

<span class="ot">QScrollArea</span> scrollArea;
scrollArea.setWidget(iconEditor);
scrollArea.viewport()-&gt;setBackgroundRole(<span class="ot">QPalette::</span>Dark);
scrollArea.viewport()-&gt;setAutoFillBackground(<span class="kw">true</span>);
scrollArea.setWindowTitle(<span class="ot">QObject::</span>tr(<span class="st">&quot;Icon Editor&quot;</span>));
scrollArea.show();</code></pre></div>
<p>By calling <code>setWidgetResizable(true)</code>, we can tell <code class="sourceCode cpp"><span class="ot">QScrollArea</span></code> to automatically resize the widget to take advantage of any extra space beyond its size hint.</p>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/scroll-area.png" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// default of `enum Qt::ScrollBarPolicy`: Qt::ScrollBarAsNeeded</span>
scrollArea.setHorizontalScrollBarPolicy(<span class="ot">Qt::</span>ScrollBarAlwaysOn);
scrollArea.setVerticalScrollBarPolicy(<span class="ot">Qt::</span>ScrollBarAlwaysOff);</code></pre></div>
<h4 id="dock-windows-and-toolbars">Dock Windows and Toolbars</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QDockWidget::</span>setFeatures();</code></pre></div>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/dockarea.png" />

</div>
<p>The corners indicated with dotted lines <strong>can belong to either of their two adjoining dock areas</strong>. For example, we could make the top-left corner belong to the left dock area by calling <code class="sourceCode cpp"><span class="ot">QMainWindow::</span>setCorner(<span class="ot">Qt::</span>TopLeftCorner, <span class="ot">Qt::</span>LeftDockWidgetArea)</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QDockWidget</span> *shapesDockWidget = <span class="kw">new</span> <span class="ot">QDockWidget</span>(<span class="fu">tr</span>(<span class="st">&quot;Shapes&quot;</span>));
shapesDockWidget-&gt;setObjectName(<span class="st">&quot;shapesDockWidget&quot;</span>);
shapesDockWidget-&gt;setWidget(treeWidget);
<span class="co">// setAllowedAreas() call specifies constraints on which dock areas can accept</span>
<span class="co">// the dock window</span>
shapesDockWidget-&gt;setAllowedAreas(<span class="ot">Qt::</span>LeftDockWidgetArea
                                     | <span class="ot">Qt::</span>RightDockWidgetArea);
addDockWidget(<span class="ot">Qt::</span>RightDockWidgetArea, shapesDockWidget);</code></pre></div>
<p>Normally we do not bother to give widgets object names, but when we create dock windows and toolbars, doing so is necessary if we want to use <code class="sourceCode cpp"><span class="ot">QMainWindow::</span>saveState()</code> and <code class="sourceCode cpp"><span class="ot">QMainWindow::</span>restoreState()</code> to save and restore the dock window and toolbar geometries and states.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QToolBar</span> *fontToolBar = <span class="kw">new</span> <span class="ot">QToolBar</span>(<span class="fu">tr</span>(<span class="st">&quot;Font&quot;</span>));

fontToolBar-&gt;setObjectName(<span class="st">&quot;fontToolBar&quot;</span>);
fontToolBar-&gt;addWidget(familyComboBox);
fontToolBar-&gt;addWidget(sizeSpinBox);
fontToolBar-&gt;addAction(boldAction);
fontToolBar-&gt;addAction(italicAction);
fontToolBar-&gt;addAction(underlineAction);

fontToolBar-&gt;setAllowedAreas(<span class="ot">Qt::</span>TopToolBarArea
                                | <span class="ot">Qt::</span>BottomToolBarArea);
addToolBar(fontToolBar);</code></pre></div>
<dl>
<dt><code class="sourceCode cpp"><span class="ot">QMainWindow::</span>addToolBar</code></dt>
<dd><p>Adds a/the toolbar (into the specified area) in this main window.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span>        addToolBar(<span class="ot">Qt::</span>ToolBarArea area, <span class="ot">QToolBar</span> * toolbar)
<span class="dt">void</span>        addToolBar(<span class="ot">QToolBar</span> * toolbar)
<span class="ot">QToolBar</span>  * addToolBar(<span class="dt">const</span> <span class="ot">QString</span> &amp; title)</code></pre></div>
</dd>
<dt><code class="sourceCode cpp"><span class="ot">QMainWindow</span></code>&#8217;s <code>saveState()</code> and <code>restoreState()</code>:</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">settings.setValue(<span class="st">&quot;geometry&quot;</span>, saveGeometry());
settings.setValue(<span class="st">&quot;state&quot;</span>, saveState());

restoreGeometry(settings.value(<span class="st">&quot;geometry&quot;</span>).toByteArray());
restoreState(settings.value(<span class="st">&quot;state&quot;</span>).toByteArray());</code></pre></div>
</dd>
</dl>
<p>Finally, <code class="sourceCode cpp"><span class="ot">QMainWindow</span></code> provides a context menu that lists all the dock windows and toolbars. The user can close and restore dock windows and hide and restore toolbars using this menu: <code class="sourceCode cpp"><span class="ot">QMenu</span> * <span class="ot">QMainWindow::</span>createPopupMenu()</code></p>
<h4 id="multiple-document-interface">Multiple Document Interface</h4>
<p>QMdiArea</p>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/mdi2.png" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">MainWindow::MainWindow()
{
    mdiArea = <span class="kw">new</span> <span class="ot">QMdiArea</span>;
    setCentralWidget(mdiArea);
    <span class="fu">connect</span>(mdiArea, <span class="kw">SIGNAL</span>(subWindowActivated(<span class="ot">QMdiSubWindow</span>*)),
            <span class="kw">this</span>, <span class="kw">SLOT</span>(updateActions()));

    createActions();
    createMenus();
    createToolBars();
    createStatusBar();

    setWindowIcon(<span class="ot">QPixmap</span>(<span class="st">&quot;:/images/icon.png&quot;</span>));
    setWindowTitle(<span class="fu">tr</span>(<span class="st">&quot;MDI Editor&quot;</span>));
    <span class="co">// Such timers time out as soon as the event loop is idle. In practice,</span>
    <span class="co">// this means that the constructor will finish, and then after the main</span>
    <span class="co">// window has been shown, loadFiles() will be called</span>
    <span class="ot">QTimer::</span>singleShot(<span class="dv">0</span>, <span class="kw">this</span>, <span class="kw">SLOT</span>(loadFiles()));
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::loadFiles()
{
    <span class="ot">QStringList</span> args = <span class="ot">QApplication::</span>arguments();
    args.removeFirst();
    <span class="kw">if</span> (!args.isEmpty()) {
        <span class="kw">foreach</span> (<span class="ot">QString</span> arg, args)
            openFile(arg);
        mdiArea-&gt;cascadeSubWindows();
    } <span class="kw">else</span> {
        newFile();
    }
    mdiArea-&gt;activateNextSubWindow();
}</code></pre></div>
<p><strong>Qt-specific command-line options</strong>, such as <code>-style</code> and <code>-font</code>, are automatically removed from the argument list by the <code class="sourceCode cpp"><span class="ot">QApplication</span></code> constructor. So, if we write <code class="sourceCode bash"><span class="kw">mdieditor</span> -style motif readme.txt</code> on the command line, <code class="sourceCode cpp"><span class="ot">QApplication::</span>arguments()</code> returns a <code class="sourceCode cpp"><span class="ot">QStringList</span></code> containing two items (&#8220;mdieditor&#8221; and &#8220;readme.txt&#8221;), and the MDI Editor application starts up with the document readme.txt.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::newFile()
{
    Editor *editor = <span class="kw">new</span> Editor;
    editor-&gt;newFile();
    addEditor(editor);
}

<span class="dt">void</span> createActions();
<span class="dt">void</span> createMenus();
<span class="dt">void</span> createToolBars();
<span class="dt">void</span> createStatusBar();

<span class="dt">void</span> MainWindow::cut()
{
    <span class="kw">if</span> (activeEditor())
        activeEditor()-&gt;cut();
}

<span class="ot">QSize</span> Editor::sizeHint() <span class="dt">const</span>
{
    <span class="kw">return</span> <span class="ot">QSize</span>(<span class="dv">72</span> * fontMetrics().width(<span class="st">&#39;x&#39;</span>),
                 <span class="dv">25</span> * fontMetrics().lineSpacing());
}

<span class="dt">void</span> Editor::newFile()
{
    <span class="dt">static</span> <span class="dt">int</span> documentNumber = <span class="dv">1</span>;

    curFile = <span class="fu">tr</span>(<span class="st">&quot;document</span><span class="ch">%1.tx</span><span class="st">t&quot;</span>).arg(documentNumber);
    setWindowTitle(curFile + <span class="st">&quot;[*]&quot;</span>);
    action-&gt;setText(curFile);
    isUntitled = <span class="kw">true</span>;
    ++documentNumber;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QGridLayout</span> *mainLayout = <span class="kw">new</span> <span class="ot">QGridLayout</span>;
mainLayout-&gt;setColumnStretch(<span class="dv">0</span>, <span class="dv">1</span>);
mainLayout-&gt;setColumnStretch(<span class="dv">1</span>, <span class="dv">3</span>);
mainLayout-&gt;addWidget(listWidget, <span class="dv">0</span>, <span class="dv">0</span>);
mainLayout-&gt;addLayout(stackedLayout, <span class="dv">0</span>, <span class="dv">1</span>);
mainLayout-&gt;addWidget(buttonBox, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>);
setLayout(mainLayout);</code></pre></div>
<h3 id="event-processing">7. Event Processing</h3>
<h4 id="reimplementing-event-handlers">Reimplementing Event Handlers</h4>
<p><code class="sourceCode cpp"><span class="ot">QEvent::</span>type()</code> returns <code class="sourceCode cpp"><span class="ot">QEvent::</span>MouseButtonPress</code></p>
<p>Events are notified to objects through their <code>event()</code> function, inherited from <code class="sourceCode cpp"><span class="ot">QObject</span></code>. The <code>event()</code> implementation in <code class="sourceCode cpp"><span class="ot">QWidget</span></code> forwards the most common types of events to specific event handlers, such as <code class="sourceCode cpp">mousePressEvent()</code>, <code class="sourceCode cpp">keyPressEvent()</code>, and <code class="sourceCode cpp">paintEvent()</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> CodeEditor::keyPressEvent(<span class="ot">QKeyEvent</span> *event)
{
    <span class="kw">switch</span> (event-&gt;key()) {
    <span class="kw">case</span> <span class="ot">Qt::</span>Key_Home<span class="ot">:</span>
        <span class="co">// has ControlModifier turned on</span>
        <span class="kw">if</span> (event-&gt;modifiers() &amp; <span class="ot">Qt::</span>ControlModifier) {
            goToBeginningOfDocument();
        } <span class="kw">else</span> {
            goToBeginningOfLine();
        }
        <span class="kw">break</span>;
    <span class="kw">case</span> <span class="ot">Qt::</span>Key_End<span class="ot">:</span>
        ...
    <span class="kw">default</span>:
        <span class="ot">QWidget::</span>keyPressEvent(event);
    }
}</code></pre></div>
<p>The <kbd>Tab</kbd> and <kbd>Backtab</kbd> (<kbd>Shift</kbd>+<kbd>Tab</kbd>) keys are special cases. <code class="sourceCode cpp"><span class="ot">QWidget::</span>event()</code> handles them before it calls <code class="sourceCode cpp">keyPressEvent()</code>, with the semantic of passing the focus to the next or previous widget in the focus chain. This behavior is usually what we want, but in a <code class="sourceCode cpp">CodeEditor</code> widget, we might prefer to make Tab indent a line. The <code>event()</code> reimplementation would then look like this:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> CodeEditor::event(<span class="ot">QEvent</span> *event)
{
    <span class="kw">if</span> (event-&gt;type() == <span class="ot">QEvent::</span>KeyPress) {
        <span class="ot">QKeyEvent</span> *keyEvent = <span class="kw">static_cast</span>&lt;<span class="ot">QKeyEvent</span> *&gt;(event);
        <span class="kw">if</span> (keyEvent-&gt;key() == <span class="ot">Qt::</span>Key_Tab) {
            insertAtCurrentPosition(<span class="st">&#39;</span><span class="ch">\t</span><span class="st">&#39;</span>);
            <span class="kw">return</span> <span class="kw">true</span>;
        }
    }
    <span class="kw">return</span> <span class="ot">QWidget::</span>event(event);
}</code></pre></div>
<p><code class="sourceCode cpp"><span class="ot">QAction::</span>setShortcutContext()</code> or <code class="sourceCode cpp"><span class="ot">QShortcut::</span>setContext()</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// ticker.h</span>
<span class="ot">#include &lt;QWidget&gt;</span>

<span class="kw">class</span> Ticker : <span class="kw">public</span> <span class="ot">QWidget</span>
{
    <span class="kw">Q_OBJECT</span>
    <span class="kw">Q_PROPERTY</span>(<span class="ot">QString</span> text READ text WRITE setText)

<span class="kw">public</span>:
    Ticker(<span class="ot">QWidget</span> *parent = <span class="dv">0</span>);

    <span class="dt">void</span> setText(<span class="dt">const</span> <span class="ot">QString</span> &amp;newText);
    <span class="ot">QString</span> text() <span class="dt">const</span> { <span class="kw">return</span> myText; }
    <span class="ot">QSize</span> sizeHint() <span class="dt">const</span>;

<span class="kw">protected</span>:
    <span class="dt">void</span> paintEvent(<span class="ot">QPaintEvent</span> *event);

    <span class="dt">void</span> timerEvent(<span class="ot">QTimerEvent</span> *event);
    <span class="dt">void</span> showEvent(<span class="ot">QShowEvent</span> *event);
    <span class="dt">void</span> hideEvent(<span class="ot">QHideEvent</span> *event);

<span class="kw">private</span>:
    <span class="ot">QString</span> myText;
    <span class="dt">int</span> offset;
    <span class="dt">int</span> myTimerId;
};

<span class="co">// ticker.cpp</span>
<span class="dt">void</span> Ticker::setText(<span class="dt">const</span> <span class="ot">QString</span> &amp;newText)
{
    myText = newText;
    update();               <span class="co">// repaint</span>
    updateGeometry();       <span class="co">// sizeHint()</span>
}

<span class="ot">QSize</span> Ticker::sizeHint() <span class="dt">const</span>
{
    <span class="co">// QWidget::fontMetrics() returns a QFontMetrics object that can be queried</span>
    <span class="co">// to obtain information relating to the widget&#39;s font.</span>
    <span class="kw">return</span> fontMetrics().size(<span class="dv">0</span>, text());
    <span class="co">// QFontMetricsF metrics = qApp-&gt;font();</span>
}

<span class="dt">void</span> Ticker::paintEvent(<span class="ot">QPaintEvent</span> * <span class="co">/* event */</span>)
{
    <span class="ot">QPainter</span> painter(<span class="kw">this</span>);

    <span class="co">// QWidget::fontMetrics() returns a QFontMetrics object that can be queried</span>
    <span class="co">// to obtain information relating to the widget&#39;s font.</span>
    <span class="dt">int</span> textWidth = fontMetrics().width(text());
    <span class="kw">if</span> (textWidth &lt; <span class="dv">1</span>)
        <span class="kw">return</span>;
    <span class="dt">int</span> x = -offset;
    <span class="kw">while</span> (x &lt; width()) {
        painter.drawText(x, <span class="dv">0</span>, textWidth, height(), <span class="co">// &#36825;&#26159; QWidget::height()</span>
                         <span class="ot">Qt::</span>AlignLeft | <span class="ot">Qt::</span>AlignVCenter, text());
        x += textWidth;
    }
}

<span class="dt">void</span> Ticker::showEvent(<span class="ot">QShowEvent</span> * <span class="co">/* event */</span>)
{
    <span class="co">// The call to QObject::startTimer() returns an ID number, which we can use</span>
    <span class="co">// later to identify the timer. QObject supports multiple independent</span>
    <span class="co">// timers, each with its own time interval.</span>
    myTimerId = startTimer(<span class="dv">30</span>);
}

<span class="dt">void</span> Ticker::timerEvent(<span class="ot">QTimerEvent</span> *event)
{
    <span class="kw">if</span> (event-&gt;timerId() == myTimerId) {
        ++offset;
        <span class="kw">if</span> (offset &gt;= fontMetrics().width(text()))
            offset = <span class="dv">0</span>;
        <span class="co">// scrolls the contents of the widget one pixel to the left using</span>
        <span class="co">// QWidget::scroll()</span>
        scroll(<span class="dv">-1</span>, <span class="dv">0</span>);
    } <span class="kw">else</span> {
        <span class="co">// If the timer event isn&#39;t for the timer we are interested in, we pass</span>
        <span class="co">// it on to the base class</span>
        <span class="ot">QWidget::</span>timerEvent(event);
    }
}

<span class="dt">void</span> Ticker::hideEvent(<span class="ot">QHideEvent</span> * <span class="co">/* event */</span>)
{
    killTimer(myTimerId);
    myTimerId = <span class="dv">0</span>;
}</code></pre></div>
<h4 id="installing-event-filters">Installing Event Filters</h4>
<dl>
<dt><code class="sourceCode cpp"><span class="dt">void</span> <span class="ot">QObject::</span>installEventFilter(<span class="ot">QObject</span> * filterObj)</code></dt>
<dd><p>Installs an event filter filterObj on this object. For example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">monitoredObj-&gt;installEventFilter(filterObj);
firstNameEdit-&gt;installEventFilter(<span class="kw">this</span>);</code></pre></div>
</dd>
</dl>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> CustomerInfoDialog::eventFilter(<span class="ot">QObject</span> *target, <span class="ot">QEvent</span> *event)
{
    <span class="kw">if</span> (target == firstNameEdit || target == lastNameEdit
            || target == cityEdit || target == phoneNumberEdit) {
        <span class="kw">if</span> (event-&gt;type() == <span class="ot">QEvent::</span>KeyPress) {
            <span class="ot">QKeyEvent</span> *keyEvent = <span class="kw">static_cast</span>&lt;<span class="ot">QKeyEvent</span> *&gt;(event);
            <span class="kw">if</span> (keyEvent-&gt;key() == <span class="ot">Qt::</span>Key_Space) {
                focusNextChild();
                <span class="co">// return true to tell Qt that we have handled the event. If we</span>
                <span class="co">// returned false, Qt would send the event to its intended</span>
                <span class="co">// target, resulting in a spurious space being inserted into</span>
                <span class="co">// the QLineEdit</span>
                <span class="kw">return</span> <span class="kw">true</span>; <span class="co">// event handled</span>
            }
        }
    }
    <span class="co">// fall through</span>
    <span class="kw">return</span> <span class="ot">QDialog::</span>eventFilter(target, event);
}</code></pre></div>
<dl>
<dt>Qt offers five levels at which events can be processed and filtered:</dt>
<dd><ol>
<li>We can <strong>reimplement a specific event handler</strong>, <code>mousePressEvent()</code>, <code>keyPressEvent()</code>, <code>paintEvent()</code></li>
<li>We can <strong>reimplement</strong> <code class="sourceCode cpp"><span class="ot">QObject::</span>event()</code></li>
<li>We can <strong>install an event filter on a single <code class="sourceCode cpp"><span class="ot">QObject</span></code></strong>.</li>
<li>We can <strong>install an event filter on the <code class="sourceCode cpp"><span class="ot">QApplication</span></code> object</strong>.
<ol style="list-style-type: lower-roman">
<li>Once an event filter has been registered for <code>qApp</code> (<strong>the unique <code class="sourceCode cpp"><span class="ot">QApplication</span></code> object</strong>)</li>
<li>mostly useful for debugging</li>
</ol></li>
<li>We can <strong>subclass <code class="sourceCode cpp"><span class="ot">QApplication</span></code> and reimplement <code>notify()</code></strong>.
<ol style="list-style-type: lower-roman">
<li>Qt calls <code class="sourceCode cpp"><span class="ot">QApplication::</span>notify()</code> to <strong>send out an event</strong>.</li>
<li>Event filters are generally more useful, because there can be any number of concurrent event filters, but only one <code>notify()</code> function.</li>
</ol></li>
</ol>
</dd>
</dl>
<p>Many event types, including mouse and key events, can be <strong>propagated</strong> (<code>['pr&#593;p&#601;'get]</code>). If the event has not been handled on the way to its target object or by the target object itself, the whole event processing process is repeated, but this time with the target object&#8217;s parent as the new target. This continues, going from parent to parent, <strong>until either the event is handled or the top-level object is reached</strong>.</p>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/event.png" alt="This figure shows how a key press event is propagated from child to parent in a dialog. When the user presses a key, the event is first sent to the widget that has focus, in this case the bottom-right QCheckBox. If the QCheckBox doesn&#8217;t handle the event, Qt sends it to the QGroupBox, and finally to the QDialog object." />
<p class="caption">This figure shows how a key press event is propagated from child to parent in a dialog. When the user presses a key, the event is first sent to the widget that has focus, in this case the bottom-right <code class="sourceCode cpp"><span class="ot">QCheckBox</span></code>. If the <code class="sourceCode cpp"><span class="ot">QCheckBox</span></code> doesn&#8217;t handle the event, Qt sends it to the <code class="sourceCode cpp"><span class="ot">QGroupBox</span></code>, and finally to the <code class="sourceCode cpp"><span class="ot">QDialog</span></code> object.</p>
</div>
<h4 id="staying-responsive-during-intensive-processing">Staying Responsive during Intensive Processing</h4>
<p>When we call <code class="sourceCode cpp"><span class="ot">QApplication::</span>exec()</code>, we start Qt&#8217;s <strong>event loop</strong>. Qt issues a few events on startup to show and paint the widgets. After that, the event loop is running, constantly checking to see whether any events have occurred and dispatching these events to <code class="sourceCode cpp">QObjects</code> in the application.</p>
<dl>
<dt><strong>Long-running operations</strong></dt>
<dd><p>If we spend too much time processing a particular event, the user interface will become unresponsive.</p>
<ol>
<li>One solution is to use multiple threads.</li>
<li>A simpler solution is to <strong>make frequent calls to <code class="sourceCode cpp"><span class="ot">QApplication::</span>processEvents()</code></strong> in the file saving code. This function <strong>tells Qt to process any pending events, and then returns control to the caller</strong>. In fact, <code class="sourceCode cpp"><span class="ot">QApplication::</span>exec()</code> is little more than a while loop around a <code>processEvents()</code> function call. &#65288;&#36825;&#20040;&#40657; <code class="sourceCode cpp"><span class="ot">QApplication::</span>exec()</code> &#22909;&#21527;&#8230;&#8230;&#65289;</li>
</ol>
</dd>
</dl>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> Spreadsheet::writeFile(<span class="dt">const</span> <span class="ot">QString</span> &amp;fileName)
{
    <span class="ot">QFile</span> file(fileName);
    ...
    <span class="ot">QApplication::</span>setOverrideCursor(<span class="ot">Qt::</span>WaitCursor);
    <span class="kw">for</span> (<span class="dt">int</span> row = <span class="dv">0</span>; row &lt; RowCount; ++row) {
        <span class="kw">for</span> (<span class="dt">int</span> column = <span class="dv">0</span>; column &lt; ColumnCount; ++column) {
            <span class="ot">QString</span> str = formula(row, column);
            <span class="kw">if</span> (!str.isEmpty())
                out &lt;&lt; <span class="dt">quint16</span>(row) &lt;&lt; <span class="dt">quint16</span>(column) &lt;&lt; str;
        }
        <span class="co">// keep the user interface responsive using processEvents()</span>
        <span class="kw">qApp</span>-&gt;processEvents();
    }
    <span class="ot">QApplication::</span>restoreOverrideCursor();
    <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre></div>
<p>One danger with this approach is that the user might close the main window while the application is still saving, or even click <kbd>File|Save</kbd> a second time, resulting in undefined behavior. The easiest solution to this problem is to replace <code class="sourceCode cpp"><span class="kw">qApp</span>-&gt;processEvents();</code> with <code class="sourceCode cpp"><span class="kw">qApp</span>-&gt;processEvents(<span class="ot">QEventLoop::</span>ExcludeUserInputEvents);</code> telling Qt to ignore mouse and key events.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> Spreadsheet::writeFile(<span class="dt">const</span> <span class="ot">QString</span> &amp;fileName)
{
    <span class="ot">QFile</span> file(fileName);
    ...
    <span class="ot">QProgressDialog</span> progress(<span class="kw">this</span>);
    progress.setLabelText(<span class="fu">tr</span>(<span class="st">&quot;Saving %1&quot;</span>).arg(fileName));
    progress.setRange(<span class="dv">0</span>, RowCount);
    progress.setModal(<span class="kw">true</span>);
    <span class="co">// We don&#39;t call show() on the QProgressDialog because progress dialogs do</span>
    <span class="co">// that for themselves. If the operation turns out to be short, presumably</span>
    <span class="co">// because the file to save is small or because the machine is fast,</span>
    <span class="co">// QProgressDialog will detect this and will not show itself at all.</span>

    <span class="kw">for</span> (<span class="dt">int</span> row = <span class="dv">0</span>; row &lt; RowCount; ++row) {
        progress.setValue(row);
        <span class="kw">qApp</span>-&gt;processEvents();
        <span class="kw">if</span> (progress.wasCanceled()) {
            file.remove();
            <span class="kw">return</span> <span class="kw">false</span>;
        }
        <span class="kw">for</span> (<span class="dt">int</span> column = <span class="dv">0</span>; column &lt; ColumnCount; ++column) {
            <span class="ot">QString</span> str = formula(row, column);
            <span class="kw">if</span> (!str.isEmpty())
                out &lt;&lt; <span class="dt">quint16</span>(row) &lt;&lt; <span class="dt">quint16</span>(column) &lt;&lt; str;
        }
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre></div>
<p>In addition to multithreading and using <code class="sourceCode cpp"><span class="ot">QProgressDialog</span></code>, there is a completely different way of dealing with long-running operations: Instead of performing the processing when the user requests, we can <strong>defer (&#25512;&#36831;) the processing until the application is idle</strong>. This can work if the processing can be safely interrupted and resumed, since we cannot predict how long the application will be idle.</p>
<p>In Qt, this approach can be implemented by using a <strong>0-millisecond timer</strong>. These timers time out whenever there are no pending events.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Spreadsheet::timerEvent(<span class="ot">QTimerEvent</span> *event)
{
    <span class="kw">if</span> (event-&gt;timerId() == myTimerId) {
        <span class="kw">while</span> (step &lt; MaxStep &amp;&amp; !<span class="kw">qApp</span>-&gt;hasPendingEvents()) {
            performStep(step);
            ++step;
        }
    } <span class="kw">else</span> {
        <span class="ot">QTableWidget::</span>timerEvent(event);
    }
}</code></pre></div>
<h3 id="d-graphics">8. 2D Graphics</h3>
<p>Qt&#8217;s 2D graphics engine is based on the <code class="sourceCode cpp"><span class="ot">QPainter</span></code> class. <code class="sourceCode cpp"><span class="ot">QPainter</span></code> can <strong>draw geometric shapes</strong> (points, lines, rectangles, ellipses, arcs, chords, pie segments, polygons, and B&#233;zier curves), as well as pixmaps, images, and text. Furthermore, <code class="sourceCode cpp"><span class="ot">QPainter</span></code> supports <strong>advanced features</strong> such as antialiasing (for text and shape edges), alpha blending, gradient filling, and vector paths. <code class="sourceCode cpp"><span class="ot">QPainter</span></code> also supports <strong>linear transformations</strong>, such as translation, rotation, shearing, and scaling.</p>
<p><code class="sourceCode cpp"><span class="ot">QPainter</span></code> can be used to draw on a &#8220;paint device&#8221;, such as a <code class="sourceCode cpp"><span class="ot">QWidget</span></code>, a <code class="sourceCode cpp"><span class="ot">QPixmap</span></code>, a <code class="sourceCode cpp"><span class="ot">QImage</span></code>, or a <code class="sourceCode cpp"><span class="ot">QSvgGenerator</span></code>. <code class="sourceCode cpp"><span class="ot">QPainter</span></code> can also be used in conjunction with <code class="sourceCode cpp"><span class="ot">QPrinter</span></code> for printing and for generating PDF documents. This means that we can often use the same code to display data on-screen and to produce printed reports.</p>
<p>By reimplementing <code class="sourceCode cpp"><span class="ot">QWidget::</span>paintEvent()</code>, we can create custom widgets and exercise complete control over their appearance, as we saw in Chapter 5. For customizing the look and feel of predefined Qt widgets, we can also specify a style sheet or create a <code class="sourceCode cpp"><span class="ot">QStyle</span></code> subclass; we cover both of these approaches in Chapter 19.</p>
<p>A common requirement is the need to display large numbers of lightweight arbitrarily shaped items that the user can interact with on a 2D canvas. Qt 4.2 introduced a completely new &#8220;graphics view&#8221; architecture centered on the <code class="sourceCode cpp"><span class="ot">QGraphicsView</span></code>, <code class="sourceCode cpp"><span class="ot">QGraphicsScene</span></code>, and <code class="sourceCode cpp"><span class="ot">QGraphicsItem</span></code> classes. This architecture offers a high-level interface for doing item-based graphics, and supports standard user actions on items, including moving, selecting, and grouping. The items themselves are drawn using <code class="sourceCode cpp"><span class="ot">QPainter</span></code> as usual and can be transformed individually. We cover this architecture later in the chapter.</p>
<p>An alternative to <code class="sourceCode cpp"><span class="ot">QPainter</span></code> is to use OpenGL commands. OpenGL is a standard library for drawing 3D graphics. In Chapter 20, we will see how to use the <code class="sourceCode cpp">QtOpenGL</code> module, which makes it easy to integrate OpenGL code into Qt applications.</p>
<h4 id="painting-with-qpainter">Painting with QPainter</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// create a QPainter and pass a pointer to the device</span>
<span class="dt">void</span> MyWidget::paintEvent(<span class="ot">QPaintEvent</span> *event)
{
    <span class="ot">QPainter</span> painter(<span class="kw">this</span>);
    ...
}</code></pre></div>
<p>The way the drawing is performed is influenced by <code class="sourceCode cpp"><span class="ot">QPainter</span></code>&#8217;s settings. Some of these are adopted from the device, whereas others are initialized to default values. The three main painter settings are the pen, the brush, and the font.</p>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/QPainter.png" alt="QPainter" />
<p class="caption">QPainter</p>
</div>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/capjoin.png" alt="Caption Style &amp; Join Style" />
<p class="caption">Caption Style &amp; Join Style</p>
</div>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/line.png" alt="Line Style" />
<p class="caption">Line Style</p>
</div>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/brush.png" alt="Brush Style" />
<p class="caption">Brush Style</p>
</div>
<p>These settings can be modified at any time by calling <code class="sourceCode cpp">setPen()</code>, <code class="sourceCode cpp">setBrush()</code>, and <code class="sourceCode cpp">setFont()</code> with a <code class="sourceCode cpp"><span class="ot">QPen</span></code>, <code class="sourceCode cpp"><span class="ot">QBrush</span></code>, or <code class="sourceCode cpp"><span class="ot">QFont</span></code> object.</p>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/draw3.png" alt="An ellipse &amp; a pie segment &amp; a B&#233;zier curve" />
<p class="caption">An ellipse &amp; a pie segment &amp; a B&#233;zier curve</p>
</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// drawEllipse</span>
<span class="ot">QPainter</span> painter(<span class="kw">this</span>);
painter.setRenderHint(<span class="ot">QPainter::</span>Antialiasing, <span class="kw">true</span>);
painter.setPen(<span class="ot">QPen</span>(<span class="ot">Qt::</span>black, <span class="dv">12</span>, <span class="ot">Qt::</span>DashDotLine, <span class="ot">Qt::</span>RoundCap));
painter.setBrush(<span class="ot">QBrush</span>(<span class="ot">Qt::</span>green, <span class="ot">Qt::</span>SolidPattern));
painter.drawEllipse(<span class="dv">80</span>, <span class="dv">80</span>, <span class="dv">400</span>, <span class="dv">240</span>);</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// drawPie</span>
<span class="ot">QPainter</span> painter(<span class="kw">this</span>);
painter.setRenderHint(<span class="ot">QPainter::</span>Antialiasing, <span class="kw">true</span>);
painter.setPen(<span class="ot">QPen</span>(<span class="ot">Qt::</span>black, <span class="dv">15</span>, <span class="ot">Qt::</span>SolidLine, <span class="ot">Qt::</span>RoundCap, <span class="ot">Qt::</span>MiterJoin));
painter.setBrush(<span class="ot">QBrush</span>(<span class="ot">Qt::</span>blue,  <span class="ot">Qt::</span>DiagCrossPattern));
painter.drawPie(<span class="dv">80</span>, <span class="dv">80</span>, <span class="dv">400</span>, <span class="dv">240</span>, <span class="dv">60</span> * <span class="dv">16</span>, <span class="dv">270</span> * <span class="dv">16</span>);</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// cubic B&#233;zier curve</span>
<span class="ot">QPainter</span> painter(<span class="kw">this</span>);
painter.setRenderHint(<span class="ot">QPainter::</span>Antialiasing, <span class="kw">true</span>);
<span class="ot">QPainterPath</span> path;
path.moveTo(<span class="dv">80</span>, <span class="dv">320</span>);
<span class="co">// two control points: c1X, c1Y, c2X, c2Y</span>
<span class="co">// endPoint: endPointX, endPointY</span>
<span class="co">// void QPainterPath::cubicTo(const QPointF &amp; c1, /* qreal c1X, qreal c1Y, */</span>
<span class="co">//                            const QPointF &amp; c2, /* qreal c2X, qreal c2Y, */</span>
<span class="co">//                            const QPointF &amp; endPoint)</span>
path.cubicTo(<span class="dv">200</span>, <span class="dv">80</span>, <span class="dv">320</span>, <span class="dv">80</span>, <span class="dv">480</span>, <span class="dv">320</span>);
painter.setPen(<span class="ot">QPen</span>(<span class="ot">Qt::</span>black, <span class="dv">8</span>));
painter.drawPath(path);</code></pre></div>
<p>The <code class="sourceCode cpp"><span class="ot">QPainterPath</span></code> class can specify arbitrary vector shapes by connecting basic graphical elements together: straight lines, ellipses, polygons, arcs, B&#233;zier curves, and other painter paths. Painter paths are the ultimate drawing primitive in the sense that any shape or combination of shapes can be expressed as a painter path. A path specifies an outline, and the area described by the outline can be filled using a brush. In the example in Figure 8.5 (c), we didn&#8217;t set a brush, so only the outline is drawn.</p>
<p>These three examples use built-in brush patterns (<code class="sourceCode cpp"><span class="ot">Qt::</span>SolidPattern</code>, <code class="sourceCode cpp"><span class="ot">Qt::</span>DiagCrossPattern</code>, and <code class="sourceCode cpp"><span class="ot">Qt::</span>NoBrush</code>). <strong>In modern applications, gradient fills are a popular alternative to monochrome fill patterns.</strong> Gradients rely on <strong>color interpolation</strong> to obtain smooth transitions between two or more colors. They are frequently used to produce 3D effects; for example, the <code>Plastique</code> and <code>Cleanlooks</code> styles use gradients to render <code class="sourceCode cpp">QPushButtons</code>. Qt supports three types of gradients: linear, conical <code>['k&#593;n&#618;kl]</code> (&#22278;&#38181;&#24418;&#30340;), and radial. The Oven Timer example in the next section combines all three types of gradients in a single widget to make it look like the real thing.</p>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/gradient.png" alt="QPainter&#8217;s gradient brushes" />
<p class="caption">QPainter&#8217;s gradient brushes</p>
</div>
<ol>
<li><p><strong>Linear gradients</strong> are defined by two control points and by a series of &#8220;<strong>color stops</strong>&#8221; on the line that connects these two points. For example, the linear gradient in Figure 8.6 is created using the following</p>
<p>code:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QLinearGradient</span> gradient(<span class="dv">50</span>, <span class="dv">100</span>, <span class="dv">300</span>, <span class="dv">350</span>);
gradient.setColorAt(<span class="fl">0.0</span>, <span class="ot">Qt::</span>white);
gradient.setColorAt(<span class="fl">0.2</span>, <span class="ot">Qt::</span>green);
gradient.setColorAt(<span class="fl">1.0</span>, <span class="ot">Qt::</span>black);</code></pre></div></li>
<li><p><strong>Radial gradients</strong> are defined by a center point(x<sub>c</sub>, y<sub>c</sub>), a radius r, and a focal point(x<sub>f</sub>, y<sub>f</sub>), in addition to the color stops. The center point and the radius specify a circle. The colors spread outward from the focal point, which can be the center point or any other point inside the circle.</p></li>
<li><p><strong>Conical gradients</strong> are defined by a center point (x<sub>c</sub>, y<sub>c</sub>) and an angle a. The colors spread around the center point like the sweep of a watch&#8217;s seconds hand.</p></li>
</ol>
<p>We specify three colors at three different positions between the two control points. Positions are specified as floating-point values between 0 and 1, where 0 corresponds to the first control point and 1 to the second control point. Colors between the specified stops are linearly interpolated.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QPen::</span>QPen(<span class="dt">const</span> <span class="ot">QBrush</span> &amp; brush,
           <span class="dt">qreal</span> width,
           <span class="ot">Qt::</span>PenStyle style = <span class="ot">Qt::</span>SolidLine,
           <span class="ot">Qt::</span>PenCapStyle cap = <span class="ot">Qt::</span>SquareCap,
           <span class="ot">Qt::</span>PenJoinStyle join = <span class="ot">Qt::</span>BevelJoin)</code></pre></div>
<p>So far, we have mentioned <code class="sourceCode cpp"><span class="ot">QPainter</span></code>&#8217;s pen, brush, and font settings. In addition to these, <code class="sourceCode cpp"><span class="ot">QPainter</span></code> has other settings that influence the way shapes and text are drawn:</p>
<ol>
<li>The <strong>background brush</strong> is used to fill the background of geometric shapes (underneath the brush pattern), text, or bitmaps when the background mode is <code class="sourceCode cpp"><span class="ot">Qt::</span>OpaqueMode</code> (the default is <code class="sourceCode cpp"><span class="ot">Qt::</span>TransparentMode</code>).</li>
<li>The <strong>brush origin</strong> is the starting point for brush patterns, normally the top-left corner of the widget.</li>
<li>The <strong>clip region</strong> is the area of the device that can be painted. Painting outside the clip region has no effect.</li>
<li>The <strong>viewport</strong>, <strong>window</strong>, and <strong>world transform</strong> determine how logical <code class="sourceCode cpp"><span class="ot">QPainter</span></code> coordinates map to physical paint device coordinates. By default, these are set up so that the logical and physical coordinate systems coincide. We cover coordinate systems in the next section.</li>
</ol>
<p>The composition mode specifies how the newly drawn pixels should interact with the pixels already present on the paint device. The default is &#8220;source over&#8221;, where drawn pixels are alpha-blended on top of existing pixels. This is supported only on certain devices and is covered later in this chapter.</p>
<p>At any time, we can save the current state of a painter on an internal stack by calling <code class="sourceCode cpp">save()</code> and restore it later on by calling <code class="sourceCode cpp">restore()</code>.</p>
<h4 id="coordinate-system-transformations">Coordinate System Transformations</h4>
<p>With <code class="sourceCode cpp"><span class="ot">QPainter</span></code>&#8217;s default coordinate system, the point (0, 0) is located at the top-left corner of the paint device, x-coordinates increase rightward, and y-coordinates increase downward. Each pixel occupies an area of size 1 &#215; 1 in the default coordinate system.</p>
<p>Conceptually, the center of a pixel lies on <strong>&#8220;half-pixel&#8221; coordinates</strong>. For example, the top-left pixel of a widget covers the area between points (0, 0) and (1, 1), and its center is located at (0.5, 0.5). If we tell <code class="sourceCode cpp"><span class="ot">QPainter</span></code> to draw a pixel at, say, (100, 100), it will approximate the result by shifting the coordinate by +0.5 in both directions, resulting in the pixel centered at (100.5, 100.5) being drawn.</p>
<p>This distinction may seem rather academic at first, but it has important consequences in practice. First, the shifting by +0.5 occurs only if antialiasing is disabled (the default); if antialiasing is enabled and we try to draw a pixel at (100, 100) in black, <code class="sourceCode cpp"><span class="ot">QPainter</span></code> will actually color the four pixels (99.5, 99.5), (99.5, 100.5), (100.5, 99.5), and (100.5, 100.5) light gray, to give the impression of a pixel lying exactly at the meeting point of the four pixels. If this effect is undesirable, we can avoid it by specifying half-pixel coordinates or by translating the <code class="sourceCode cpp"><span class="ot">QPainter</span></code> by (+0.5, +0.5).</p>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/drawrect-1.png" alt="QPainter::drawRect(2, 2, 6, 5) with no antialiasing" />
<p class="caption"><code class="sourceCode cpp"><span class="ot">QPainter::</span>drawRect(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">5</span>)</code> with no antialiasing</p>
</div>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/drawrect-2.png" alt="QPainter::drawRect(2, 2, 6, 5) with antialiasing" />
<p class="caption"><code class="sourceCode cpp"><span class="ot">QPainter::</span>drawRect(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">5</span>)</code> with antialiasing</p>
</div>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/drawrect-3.png" alt="QPainter::drawRect(2.5, 2.5, 6, 5) with antialiasing" />
<p class="caption"><code class="sourceCode cpp"><span class="ot">QPainter::</span>drawRect(<span class="fl">2.5</span>, <span class="fl">2.5</span>, <span class="dv">6</span>, <span class="dv">5</span>)</code> with antialiasing</p>
</div>
<p>Now that we understand the default coordinate system, we can take a closer look at how it can be changed using <code class="sourceCode cpp"><span class="ot">QPainter</span></code>&#8217;s viewport, window, and world transform. <small>(In this context, the term &#8220;window&#8221; does not refer to a window in the sense of a top-level widget, and the &#8220;viewport&#8221; has nothing to do with <code class="sourceCode cpp"><span class="ot">QScrollArea</span></code>&#8217;s viewport.)</small></p>
<p>The window&#8211;viewport mechanism is useful to make the drawing code independent of the size or resolution of the paint device. For example, if we want the logical coordinates to extend from (-50, -50) to (+50, +50), with (0, 0) in the middle, we can set the window as follows: <code class="sourceCode cpp">painter.setWindow(<span class="dv">-50</span>, <span class="dv">-50</span>, <span class="dv">100</span>, <span class="dv">100</span>);</code>.</p>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/winport.png" />

</div>
<p>Now comes the world transform. The world transform is a transformation matrix that is applied in addition to the window&#8211;viewport conversion. It allows us to translate, scale, rotate, or shear the items we are drawing. For example, if we wanted to draw text at a 45&#176; angle, we would use this code:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QTransform</span> transform;
transform.rotate(<span class="fl">+45.0</span>);
painter.setWorldTransform(transform);
painter.drawText(pos, <span class="fu">tr</span>(<span class="st">&quot;Sales&quot;</span>));</code></pre></div>
The logical coordinates we pass to <code class="sourceCode cpp">drawText()</code> are converted by the world transform, then mapped to physical coordinates using the window&#8211;viewport settings. If we specify multiple transformations, they are applied in the order in which they are given. For example, if we want to use the point (50,
<ol start="50" style="list-style-type: decimal">
<li>as the rotation&#8217;s pivot point, we can do so by translating the window by (+50, +50), performing the rotation, and then translating the window back to its original position:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QTransform</span> transform;
transform.translate(<span class="fl">+50.0</span>, <span class="fl">+50.0</span>);
transform.rotate(<span class="fl">+45.0</span>);
transform.translate(<span class="fl">-50.0</span>, <span class="fl">-50.0</span>);
painter.setWorldTransform(transform);
painter.drawText(pos, <span class="fu">tr</span>(<span class="st">&quot;Sales&quot;</span>));</code></pre></div>
<p>A simpler way to specify transformations is to use <code class="sourceCode cpp"><span class="ot">QPainter</span></code>&#8217;s <code class="sourceCode cpp">translate()</code>, <code class="sourceCode cpp">scale()</code>, <code class="sourceCode cpp">rotate()</code>, and <code class="sourceCode cpp">shear()</code>.</p>
<p>If we want to use the same transformations repeatedly, it is more efficient to store them in a <code class="sourceCode cpp"><span class="ot">QTransform</span></code> object and set the world transform on the painter whenever the transformations are needed.</p>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/oventimer.png" alt="Oventimer" />
<p class="caption">Oventimer</p>
</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// oventimer.h</span>
<span class="ot">#include &lt;QDateTime&gt;</span>
<span class="ot">#include &lt;QWidget&gt;</span>

<span class="kw">class</span> <span class="ot">QTimer</span>;

<span class="kw">class</span> OvenTimer : <span class="kw">public</span> <span class="ot">QWidget</span>
{
    <span class="kw">Q_OBJECT</span>

<span class="kw">public</span>:
    OvenTimer(<span class="ot">QWidget</span> *parent = <span class="dv">0</span>);

    <span class="dt">void</span> setDuration(<span class="dt">int</span> secs);
    <span class="dt">int</span> duration() <span class="dt">const</span>;
    <span class="dt">void</span> draw(<span class="ot">QPainter</span> *painter);

<span class="kw">signals</span>:
    <span class="dt">void</span> timeout();

<span class="kw">protected</span>:
    <span class="dt">void</span> paintEvent(<span class="ot">QPaintEvent</span> *event);
    <span class="dt">void</span> mousePressEvent(<span class="ot">QMouseEvent</span> *event);

<span class="kw">private</span>:
    <span class="ot">QDateTime</span> finishTime;
    <span class="ot">QTimer</span> *updateTimer;
    <span class="ot">QTimer</span> *finishTimer;
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// oventimer.cpp</span>
<span class="ot">#include &lt;QtGui&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>

<span class="ot">#ifndef M_PI</span>
<span class="ot">#define M_PI 3.14159265359</span>
<span class="ot">#endif</span>

<span class="ot">#include &quot;oventimer.h&quot;</span>

<span class="dt">const</span> <span class="dt">double</span> DegreesPerMinute = <span class="fl">7.0</span>;
<span class="dt">const</span> <span class="dt">double</span> DegreesPerSecond = DegreesPerMinute / <span class="dv">60</span>;
<span class="dt">const</span> <span class="dt">int</span> MaxMinutes = <span class="dv">45</span>;
<span class="dt">const</span> <span class="dt">int</span> MaxSeconds = MaxMinutes * <span class="dv">60</span>;
<span class="dt">const</span> <span class="dt">int</span> UpdateInterval = <span class="dv">5</span>;

OvenTimer::OvenTimer(<span class="ot">QWidget</span> *parent)
    : <span class="ot">QWidget</span>(parent)
{
    finishTime = <span class="ot">QDateTime::</span>currentDateTime();

    <span class="co">//  refresh the appearance of the widget every five seconds</span>
    updateTimer = <span class="kw">new</span> <span class="ot">QTimer</span>(<span class="kw">this</span>);
    <span class="fu">connect</span>(updateTimer, <span class="kw">SIGNAL</span>(timeout()), <span class="kw">this</span>, <span class="kw">SLOT</span>(update()));

    <span class="co">// finishTimer emits the widget&#39;s timeout() signal when the oven timer</span>
    <span class="co">// reaches 0. The finishTimer needs to time out only once, so we call</span>
    <span class="co">// setSingleShot(true)</span>
    finishTimer = <span class="kw">new</span> <span class="ot">QTimer</span>(<span class="kw">this</span>);
    finishTimer-&gt;setSingleShot(<span class="kw">true</span>);
    <span class="fu">connect</span>(finishTimer, <span class="kw">SIGNAL</span>(timeout()), <span class="kw">this</span>, <span class="kw">SIGNAL</span>(timeout()));
    <span class="co">// an optimization to stop updating the widget when the timer is inactive</span>
    <span class="fu">connect</span>(finishTimer, <span class="kw">SIGNAL</span>(timeout()), updateTimer, <span class="kw">SLOT</span>(stop()));

    <span class="ot">QFont</span> font;
    font.setPointSize(<span class="dv">8</span>);
    setFont(font);
}

<span class="dt">void</span> OvenTimer::setDuration(<span class="dt">int</span> secs)
{
    secs = <span class="fu">qBound</span>(<span class="dv">0</span>, secs, MaxSeconds);

    finishTime = <span class="ot">QDateTime::</span>currentDateTime().addSecs(secs);

    <span class="kw">if</span> (secs &gt; <span class="dv">0</span>) {
        updateTimer-&gt;start(UpdateInterval * <span class="dv">1000</span>);
        finishTimer-&gt;start(secs * <span class="dv">1000</span>);
    } <span class="kw">else</span> {
        updateTimer-&gt;stop();
        finishTimer-&gt;stop();
    }
    update();
}

<span class="dt">int</span> OvenTimer::duration() <span class="dt">const</span>
{
    <span class="dt">int</span> secs = <span class="ot">QDateTime::</span>currentDateTime().secsTo(finishTime);
    <span class="kw">if</span> (secs &lt; <span class="dv">0</span>)
        secs = <span class="dv">0</span>;
    <span class="kw">return</span> secs;
}

<span class="dt">void</span> OvenTimer::mousePressEvent(<span class="ot">QMouseEvent</span> *event)
{
    <span class="ot">QPointF</span> point = event-&gt;pos() - rect().center();
    <span class="dt">double</span> theta = std::atan2(-point.x(), -point.y()) * <span class="fl">180.0</span> / M_PI;
    setDuration(duration() + <span class="dt">int</span>(theta / DegreesPerSecond));
    update();
}

<span class="dt">void</span> OvenTimer::paintEvent(<span class="ot">QPaintEvent</span> * <span class="co">/* event */</span>)
{
    <span class="ot">QPainter</span> painter(<span class="kw">this</span>);
    painter.setRenderHint(<span class="ot">QPainter::</span>Antialiasing, <span class="kw">true</span>);

    <span class="dt">int</span> side = <span class="fu">qMin</span>(width(), height());

    <span class="co">// &#26368;&#22823;&#20869;&#25509;&#27491;&#26041;&#24418;</span>
    <span class="co">// Sets the painter&#39;s viewport rectangle to be the rectangle beginning at</span>
    <span class="co">// (x, y) with the given width and height.</span>
    painter.setViewport((width() - side) / <span class="dv">2</span>, (height() - side) / <span class="dv">2</span>,
                        side, side);

    <span class="co">// [0:100, 0:100] --&gt; [-50:50, -50:50]</span>
    <span class="co">// The window rectangle is part of the view transformation. The window</span>
    <span class="co">// specifies the logical coordinate system. Its sister, the viewport(),</span>
    <span class="co">// specifies the device coordinate system.</span>
    painter.setWindow(<span class="dv">-50</span>, <span class="dv">-50</span>, <span class="dv">100</span>, <span class="dv">100</span>);

    draw(&amp;painter);
}

<span class="dt">void</span> OvenTimer::draw(<span class="ot">QPainter</span> *painter)
{
    <span class="co">// The triangle is specified by three hard-coded coordinates</span>
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> triangle[<span class="dv">3</span>][<span class="dv">2</span>] = {
        { <span class="dv">-2</span>, <span class="dv">-49</span> }, { <span class="dv">+2</span>, <span class="dv">-49</span> }, { <span class="dv">0</span>, <span class="dv">-47</span> }
    };
    <span class="ot">QPen</span> thickPen(palette().foreground(), <span class="fl">1.5</span>);
    <span class="ot">QPen</span> thinPen(palette().foreground(), <span class="fl">0.5</span>);
    <span class="ot">QColor</span> niceBlue(<span class="dv">150</span>, <span class="dv">150</span>, <span class="dv">200</span>);

    <span class="co">// triangle zero marker</span>
    painter-&gt;setPen(thinPen);
    painter-&gt;setBrush(palette().foreground());
    painter-&gt;drawPolygon(<span class="ot">QPolygon</span>(<span class="dv">3</span>, &amp;triangle[<span class="dv">0</span>][<span class="dv">0</span>]));

    <span class="ot">QConicalGradient</span> coneGradient(<span class="dv">0</span>, <span class="dv">0</span>, <span class="fl">-90.0</span>);
    coneGradient.setColorAt(<span class="fl">0.0</span>, <span class="ot">Qt::</span>darkGray);
    coneGradient.setColorAt(<span class="fl">0.2</span>, niceBlue);
    coneGradient.setColorAt(<span class="fl">0.5</span>, <span class="ot">Qt::</span>white);
    coneGradient.setColorAt(<span class="fl">1.0</span>, <span class="ot">Qt::</span>darkGray);

    painter-&gt;setBrush(coneGradient);
    painter-&gt;drawEllipse(<span class="dv">-46</span>, <span class="dv">-46</span>, <span class="dv">92</span>, <span class="dv">92</span>);

    <span class="co">// halo effect</span>
    <span class="ot">QRadialGradient</span> haloGradient(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">20</span>, <span class="dv">0</span>, <span class="dv">0</span>);
    haloGradient.setColorAt(<span class="fl">0.0</span>, <span class="ot">Qt::</span>lightGray);
    haloGradient.setColorAt(<span class="fl">0.8</span>, <span class="ot">Qt::</span>darkGray);
    haloGradient.setColorAt(<span class="fl">0.9</span>, <span class="ot">Qt::</span>white);
    haloGradient.setColorAt(<span class="fl">1.0</span>, <span class="ot">Qt::</span>black);

    <span class="co">// NoPen is a pen!</span>
    painter-&gt;setPen(<span class="ot">Qt::</span>NoPen);
    painter-&gt;setBrush(haloGradient);
    painter-&gt;drawEllipse(<span class="dv">-20</span>, <span class="dv">-20</span>, <span class="dv">40</span>, <span class="dv">40</span>);

    <span class="ot">QLinearGradient</span> knobGradient(<span class="dv">-7</span>, <span class="dv">-25</span>, <span class="dv">7</span>, <span class="dv">-25</span>);
    knobGradient.setColorAt(<span class="fl">0.0</span>, <span class="ot">Qt::</span>black);
    knobGradient.setColorAt(<span class="fl">0.2</span>, niceBlue);
    knobGradient.setColorAt(<span class="fl">0.3</span>, <span class="ot">Qt::</span>lightGray);
    knobGradient.setColorAt(<span class="fl">0.8</span>, <span class="ot">Qt::</span>white);
    knobGradient.setColorAt(<span class="fl">1.0</span>, <span class="ot">Qt::</span>black);

    <span class="co">// rotate the painter&#39;s coordinate system</span>
    painter-&gt;rotate(duration() * DegreesPerSecond);
    painter-&gt;setBrush(knobGradient);
    painter-&gt;setPen(thinPen);
    painter-&gt;drawRoundRect(<span class="dv">-7</span>, <span class="dv">-25</span>, <span class="dv">14</span>, <span class="dv">50</span>, <span class="dv">99</span>, <span class="dv">49</span>);

    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= MaxMinutes; ++i) {
        <span class="kw">if</span> (i % <span class="dv">5</span> == <span class="dv">0</span>) {
            painter-&gt;setPen(thickPen);
            painter-&gt;drawLine(<span class="dv">0</span>, <span class="dv">-41</span>, <span class="dv">0</span>, <span class="dv">-44</span>);
            painter-&gt;drawText(<span class="dv">-15</span>, <span class="dv">-41</span>, <span class="dv">30</span>, <span class="dv">30</span>,
                              <span class="ot">Qt::</span>AlignHCenter | <span class="ot">Qt::</span>AlignTop,
                              <span class="ot">QString::</span>number(i));
        } <span class="kw">else</span> {
            painter-&gt;setPen(thinPen);
            painter-&gt;drawLine(<span class="dv">0</span>, <span class="dv">-42</span>, <span class="dv">0</span>, <span class="dv">-44</span>);
        }
        painter-&gt;rotate(-DegreesPerMinute);
    }
}</code></pre></div>
<p>The code in the for loop suffers from a minor flaw, which would quickly become apparent if we performed more iterations. Each time we call <code class="sourceCode cpp">rotate()</code>, we effectively multiply the current world transform with a rotation transform, producing a new world transform. The rounding errors associated with floating-point arithmetic gradually accumulate, resulting in an increasingly inaccurate world transform.</p>
<p>Here&#8217;s one way to rewrite the code to avoid this issue, using <code class="sourceCode cpp">save()</code> and <code class="sourceCode cpp">restore()</code> to save and reload the original transform for each iteration:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= MaxMinutes; ++i) {
    painter-&gt;save();
    painter-&gt;rotate(-i * DegreesPerMinute);
    <span class="kw">if</span> (i % <span class="dv">5</span> == <span class="dv">0</span>) {
        painter-&gt;setPen(thickPen);
        painter-&gt;drawLine(<span class="dv">0</span>, <span class="dv">-41</span>, <span class="dv">0</span>, <span class="dv">-44</span>);
        painter-&gt;drawText(<span class="dv">-15</span>, <span class="dv">-41</span>, <span class="dv">30</span>, <span class="dv">30</span>,
        Qtk:AlignHCenter | <span class="ot">Qt::</span>AlignTop,
        <span class="ot">QString::</span>number(i));
    } <span class="kw">else</span> {
        painter-&gt;setPen(thinPen);
        painter-&gt;drawLine(<span class="dv">0</span>, <span class="dv">-42</span>, <span class="dv">0</span>, <span class="dv">-44</span>);
    }
    painter-&gt;restore();
}</code></pre></div>
<h4 id="high-quality-rendering-with-qimage">High-Quality Rendering with QImage</h4>
<p>When accuracy is more important than efficiency, we can draw to a <code class="sourceCode cpp"><span class="ot">QImage</span></code> and copy the result onto the screen. This always uses <strong>Qt&#8217;s own internal paint engine</strong>, giving identical results on all platforms. <strong>The only restriction</strong> is that the <code class="sourceCode cpp"><span class="ot">QImage</span></code> on which we paint must be created with an argument of either <code class="sourceCode cpp"><span class="ot">QImage::</span>Format_RGB32</code> or <code class="sourceCode cpp"><span class="ot">QImage::</span>Format_ARGB32_Premultiplied</code>.</p>
<p>The premultiplied <code>ARGB32</code> format is almost identical to the conventional <code>ARGB32</code> format (<code>0xAARRGGBB</code>), the difference being that the red, green, and blue channels are <strong>&#8220;premultiplied&#8221;</strong> with the alpha channel. This means that the RGB values, which normally range from <code>0x00</code> to <code>0xFF</code>, are scaled <strong>from <code>0x00</code> to <code>the alpha value</code></strong>. For example, a 50%-transparent blue color is represented as <code>0x7F0000FF</code> in <code>ARGB32</code> format, but <code>0x7F00007F</code> in premultiplied <code>ARGB32</code> format, and similarly a 75%-transparent dark green of <code>0x3F008000</code> in <code>ARGB32</code> format would be <code>0x3F002000</code> in premultiplied <code>ARGB32</code> format.</p>
<p>Let&#8217;s suppose we want to use antialiasing for drawing a widget, and we want to obtain good results even on X11 systems with no X Render extension. The original <code class="sourceCode cpp">paintEvent()</code> handler, which relies on X Render for the antialiasing, might look like this:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MyWidget::paintEvent(<span class="ot">QPaintEvent</span> *event)
{
    <span class="ot">QImage</span> image(size(), <span class="ot">QImage::</span>Format_ARGB32_Premultiplied);
    <span class="co">// draw on the image</span>
    <span class="ot">QPainter</span> imagePainter(&amp;image);
    <span class="co">// initializes the painter&#39;s pen, background, and font based on the widget</span>
    imagePainter.initFrom(<span class="kw">this</span>);
    imagePainter.setRenderHint(<span class="ot">QPainter::</span>Antialiasing, <span class="kw">true</span>);
    imagePainter.eraseRect(rect());
    draw(&amp;imagePainter);
    <span class="co">// Ends painting. Any resources used while painting are released. You don&#39;t</span>
    <span class="co">// normally need to call this since it is called by the destructor.</span>
    imagePainter.end();
    <span class="ot">QPainter</span> widgetPainter(<span class="kw">this</span>);
    widgetPainter.drawImage(<span class="dv">0</span>, <span class="dv">0</span>, image);
}</code></pre></div>
<p>One particularly powerful feature of Qt&#8217;s graphics engine is its support for <strong>composition modes</strong>. These specify how a source and a destination pixel are merged together when drawing. This applies to all painting operations, including pen, brush, gradient, and image drawing. The default composition mode is <code class="sourceCode cpp"><span class="ot">QImage::</span>CompositionMode_SourceOver</code>, meaning that the source pixel (the pixel we are drawing) is blended on top of the destination pixel (the existing pixel) in such a way that the alpha component of the source defines its translucency&#65288;<code>[tr&#230;ns'lj&#650;s&#601;nsi]</code> &#21322;&#36879;&#26126;&#65289;. Figure 8.13 shows the result of drawing a semi-transparent butterfly (the &#8220;source&#8221; image) on top of a checker pattern (the &#8220;destination&#8221; image) with the different modes.</p>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/composite.png" />

</div>
<dl>
<dt><code class="sourceCode cpp"><span class="ot">QPainter::</span>setCompositionMode()</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QImage</span> resultImage = checkerPatternImage;
<span class="ot">QPainter</span> painter(&amp;resultImage);
painter.setCompositionMode(<span class="ot">QPainter::</span>CompositionMode_Xor);
painter.drawImage(<span class="dv">0</span>, <span class="dv">0</span>, butterflyImage);</code></pre></div>
</dd>
</dl>
<p>One issue to be aware of is that the <code class="sourceCode cpp"><span class="ot">QImage::</span>CompositionMode_Xor</code> operation also applies to the alpha channel. This means that if we XOR the color white (<code>0xFFFFFFFF</code>) with itself, we obtain a transparent color (<code>0x00000000</code>), not black (<code>0xFF000000</code>).</p>
<h4 id="item-based-rendering-with-graphics-view">Item-Based Rendering with Graphics View</h4>
<p>Drawing using <code class="sourceCode cpp"><span class="ot">QPainter</span></code> is ideal for custom widgets and for drawing one or just a few items. For graphics in which we need to <strong>handle anything from a handful up to tens of thousands of items</strong>, and we want the user to <strong>be able to click, drag, and select items</strong>, Qt&#8217;s graphics view classes provide the solution we need.</p>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/multiview.png" />

</div>
<p>The graphics view architecture consists of <strong>a scene</strong>, represented by the <code class="sourceCode cpp"><span class="ot">QGraphicsScene</span></code> class, and <strong>items in the scene</strong>, represented by <code class="sourceCode cpp"><span class="ot">QGraphicsItem</span></code> subclasses. <strong>The scene (along with its item) is made visible to users by showing them in a view</strong>, represented by the <code class="sourceCode cpp"><span class="ot">QGraphicsView</span></code> class. The same scene can be shown in more than one view&#8212;for example, to show different parts of a large scene, or to show the scene under different transformations. This is illustrated schematically in Figure 8.14.</p>
<p>Several predefined <code class="sourceCode cpp"><span class="ot">QGraphicsItem</span></code> subclasses are provided, including <code class="sourceCode cpp"><span class="ot">QGraphicsLineItem</span></code>, <code class="sourceCode cpp"><span class="ot">QGraphicsPixmapItem</span></code>, <code class="sourceCode cpp"><span class="ot">QGraphicsSimpleTextItem</span></code> (for styled plain text), and <code class="sourceCode cpp"><span class="ot">QGraphicsTextItem</span></code> (for rich text); see Figure 8.15. We can also create our own custom <code class="sourceCode cpp"><span class="ot">QGraphicsItem</span></code> subclasses, as we will see later in this section.</p>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/graphicsitem.png" />

</div>
<p>A <code class="sourceCode cpp"><span class="ot">QGraphicsScene</span></code> holds a collection of graphics items. A scene has three layers: <strong>a background layer</strong>, <strong>an item layer</strong>, and <strong>a foreground layer</strong>. The background and foreground are normally specified by <code class="sourceCode cpp">QBrushes</code>, but it is possible to reimplement <code class="sourceCode cpp">drawBackground()</code> or <code class="sourceCode cpp">drawForeground()</code> for complete control. If we want to use a pixmap as a background, we could simply create a texture <code class="sourceCode cpp"><span class="ot">QBrush</span></code> based on that pixmap. The foreground brush could be set to a semi-transparent white to give a faded effect, or to be a cross pattern to provide a grid overlay.</p>
<p><strong>The scene can tell us which items have collided, which are selected, and which are at a particular point or in a particular region.</strong> A scene&#8217;s graphics items are either top-level (the scene is their parent) or children (their parent is another item). Any transformations applied to an item are automatically applied to its children. The graphics view architecture provides two ways of grouping items. One is to simply make an item a child of another item. Another way is to use a <code class="sourceCode cpp"><span class="ot">QGraphicsItemGroup</span></code>. Adding an item to a group does not cause it to be transformed in any way; these groups are convenient for handling multiple items as though they were a single item. A <code class="sourceCode cpp"><span class="ot">QGraphicsView</span></code> is a widget that presents a scene, providing scroll bars if necessary and capable of applying transformations that affect how the scene is rendered. This is useful to support zooming and rotating as aids for viewing the scene. By default, <code class="sourceCode cpp"><span class="ot">QGraphicsView</span></code> renders using Qt&#8217;s built-in 2D paint engine, but it can be changed to use an OpenGL widget with a single <code class="sourceCode cpp">setViewport()</code> call after it has been constructed. It is also easy to print a scene, or parts of a scene, as we will discuss in the next section where we see several techniques for printing using Qt.</p>
<p>The architecture uses three different coordinate systems: 1) <strong>viewport coordinates</strong>; 2) <strong>scene coordinates</strong>, and 3) <strong>item coordinates</strong> &#8212; with functions for mapping from one coordinate system to another. Viewport coordinates are coordinates inside the <code class="sourceCode cpp"><span class="ot">QGraphicsView</span></code>&#8217;s viewport. Scene coordinates are logical coordinates that are used for positioning top-level items on the scene. Item coordinates are specific to each item and are centered about an item-local (0, 0) point; these remain unchanged when we move the item on the scene. In practice, we usually only care about the scene coordinates (for positioning top-level items) and item coordinates (for positioning child items and for drawing items). Drawing each item in terms of its own local coordinate system means that we do not have to worry about where an item is in the scene or what transformations have been applied to it. The graphics view classes are straightforward to use and offer a great deal of functionality. To introduce some of what can be done with them, we will review two examples. The first example is a simple diagram editor, which will show how to create items and how to handle user interaction. The second example is an annotated map program that shows how to handle large numbers of graphics objects and how to render them efficiently at different zoom levels. The Diagram application shown in Figure 8.16 allows users to create nodes and links. Nodes are graphics items that show plain text inside a rounded rectangle, whereas links are lines that connect pairs of nodes. Nodes that are selected are shown with a dashed outline drawn with a thicker pen than usual. We will begin by looking at links, since they are the simplest, then nodes, and then we will see how they are used in context.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;QGraphicsLineItem&gt;</span>

<span class="kw">class</span> Node;

<span class="co">// The Link class is derived from QGraphicsLineItem, which represents a line in</span>
<span class="co">// a QGraphicsScene.</span>
<span class="kw">class</span> Link : <span class="kw">public</span> <span class="ot">QGraphicsLineItem</span>
{
<span class="kw">public</span>:
    Link(Node *fromNode, Node *toNode);
    ~Link();

    Node *fromNode() <span class="dt">const</span>;
    Node *toNode() <span class="dt">const</span>;

    <span class="dt">void</span> setColor(<span class="dt">const</span> <span class="ot">QColor</span> &amp;color);
    <span class="ot">QColor</span> color() <span class="dt">const</span>;

    <span class="dt">void</span> trackNodes();

<span class="kw">private</span>:
    Node *myFromNode;
    Node *myToNode;
};</code></pre></div>
<p><code class="sourceCode cpp"><span class="ot">QGraphicsItem</span></code> is not a <code class="sourceCode cpp"><span class="ot">QObject</span></code> subclass, but if we wanted to add signals and slots to Link, there is nothing to stop us from using multiple inheritance with <code class="sourceCode cpp"><span class="ot">QObject</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Link::Link(Node *fromNode, Node *toNode)
{
    myFromNode = fromNode;
    myToNode = toNode;

    myFromNode-&gt;addLink(<span class="kw">this</span>);
    myToNode-&gt;addLink(<span class="kw">this</span>);

    setFlags(<span class="ot">QGraphicsItem::</span>ItemIsSelectable);

    <span class="co">// Every graphics item has an (x, y) position, and a z value that specifies</span>
    <span class="co">// how far forward or back it is in the scene. Since we are going to draw</span>
    <span class="co">// our lines from the center of one node to the center of another node, we</span>
    <span class="co">// give the line a negative z value so that it will always be drawn</span>
    <span class="co">// underneath the nodes it connects. As a result, links will appear as</span>
    <span class="co">// lines between the nearest edges of the nodes they connect.</span>
    setZValue(<span class="dv">-1</span>);

    setColor(<span class="ot">Qt::</span>darkRed);
    trackNodes();
}

<span class="dt">void</span> Link::setColor(<span class="dt">const</span> <span class="ot">QColor</span> &amp;color)
{
    <span class="co">// The setPen() function is inherited from QGraphicsLineItem.</span>
    setPen(<span class="ot">QPen</span>(color, <span class="fl">1.0</span>));
}

<span class="ot">QColor</span> Link::color() <span class="dt">const</span>
{
    <span class="kw">return</span> pen().color();
}

<span class="dt">void</span> Link::trackNodes()
{
    <span class="co">// QGraphicsItem::pos() function returns the position of its graphics item</span>
    <span class="co">// relative to the scene (for top- level items) or to the parent item (for</span>
    <span class="co">// child items)</span>
    setLine(<span class="ot">QLineF</span>(myFromNode-&gt;pos(), myToNode-&gt;pos()));
}</code></pre></div>
<p>For the <code>Node</code> class, we will handle all the graphics ourselves. Another difference between nodes and links is that nodes are more interactive. We will begin by reviewing the Node declaration, breaking it into a few pieces since it is quite long.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;QApplication&gt;</span>
<span class="ot">#include &lt;QColor&gt;</span>
<span class="ot">#include &lt;QGraphicsItem&gt;</span>
<span class="ot">#include &lt;QSet&gt;</span>

<span class="kw">class</span> Link;

<span class="kw">class</span> Node : <span class="kw">public</span> <span class="ot">QGraphicsItem</span>
{
    <span class="co">// Q_DECLARE_TR_FUNCTIONS() macro is used to add a tr() function to this</span>
    <span class="co">// class, even though it is not a QObject subclass. This is simply a</span>
    <span class="co">// convenience that allows us to use tr() rather than the static</span>
    <span class="co">// QObject::tr() or QCoreApplication::translate().</span>
    <span class="kw">Q_DECLARE_TR_FUNCTIONS</span>(Node)

<span class="kw">public</span>:
    Node();
    ~Node();

    <span class="co">// getters and setters for the private members</span>
    <span class="dt">void</span> setText(<span class="dt">const</span> <span class="ot">QString</span> &amp;text);
    <span class="ot">QString</span> text() <span class="dt">const</span>;
    <span class="dt">void</span> setTextColor(<span class="dt">const</span> <span class="ot">QColor</span> &amp;color);
    <span class="ot">QColor</span> textColor() <span class="dt">const</span>;
    <span class="dt">void</span> setOutlineColor(<span class="dt">const</span> <span class="ot">QColor</span> &amp;color);
    <span class="ot">QColor</span> outlineColor() <span class="dt">const</span>;
    <span class="dt">void</span> setBackgroundColor(<span class="dt">const</span> <span class="ot">QColor</span> &amp;color);
    <span class="ot">QColor</span> backgroundColor() <span class="dt">const</span>;

    <span class="dt">void</span> addLink(Link *link);
    <span class="dt">void</span> removeLink(Link *link);

    <span class="co">// When we create QGraphicsItem subclasses that we want to draw manually,</span>
    <span class="co">// we normally reimplement boundingRect() and paint(). If we don&#39;t</span>
    <span class="co">// reimplement shape(), the base class implementation will fall back on the</span>
    <span class="co">// boundingRect(). In this case, we have reimplemented shape() to return a</span>
    <span class="co">// more accurate shape that takes into account the node&#39;s rounded corners.</span>
    <span class="ot">QRectF</span> boundingRect() <span class="dt">const</span>;
    <span class="ot">QPainterPath</span> shape() <span class="dt">const</span>;
    <span class="dt">void</span> paint(<span class="ot">QPainter</span> *painter,
               <span class="dt">const</span> <span class="ot">QStyleOptionGraphicsItem</span> *option, <span class="ot">QWidget</span> *widget);

<span class="kw">protected</span>:
    <span class="co">// let the user change the text by double-clicking the node</span>
    <span class="dt">void</span> mouseDoubleClickEvent(<span class="ot">QGraphicsSceneMouseEvent</span> *event);
    <span class="ot">QVariant</span> itemChange(GraphicsItemChange change,
                        <span class="dt">const</span> <span class="ot">QVariant</span> &amp;value);

<span class="kw">private</span>:
    <span class="ot">QRectF</span> outlineRect() <span class="dt">const</span>;
    <span class="dt">int</span> roundness(<span class="dt">double</span> size) <span class="dt">const</span>;

    <span class="co">// Just as a Link keeps track of the nodes it connects, a Node keeps track</span>
    <span class="co">// of its links</span>
    <span class="ot">QSet</span>&lt;Link *&gt; myLinks;
    <span class="ot">QString</span> myText;
    <span class="ot">QColor</span> myTextColor;
    <span class="ot">QColor</span> myBackgroundColor;
    <span class="ot">QColor</span> myOutlineColor;
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Node::Node()
{
    ...

    setFlags(ItemIsMovable | ItemIsSelectable);
    <span class="co">// The z value will default to 0, and we leave the node&#39;s position in the</span>
    <span class="co">// scene to be set by the caller</span>
}

Node::~Node()
{
    <span class="co">// We iterate over (a copy of) the set of links rather than use</span>
    <span class="co">// qDeleteAll() to avoid side effects, since the set of links is indirectly</span>
    <span class="co">// accessed by the Link destructor</span>
    <span class="kw">foreach</span> (Link *link, myLinks)
        <span class="kw">delete</span> link;
}

<span class="dt">void</span> Node::setText(<span class="dt">const</span> <span class="ot">QString</span> &amp;text)
{
    <span class="co">// in cases such as this where the item&#39;s bounding rectangle might change</span>
    <span class="co">// (because the new text might be shorter or longer than the current text),</span>
    <span class="co">// we must call prepareGeometryChange() immediately before doing anything</span>
    <span class="co">// that will affect the item&#39;s bounding rectangle</span>
    prepareGeometryChange();
    myText = text;
    <span class="co">// schedule a repaint</span>
    update();
}

<span class="dt">void</span> Node::setText(<span class="dt">const</span> <span class="ot">QString</span> &amp;text)
{
    <span class="co">// We don&#39;t need to call prepareGeometryChange(), because the size of the</span>
    <span class="co">// item is not affected by a color change.</span>
    prepareGeometryChange();
    myText = text;
    update();
}

<span class="dt">void</span> Node::addLink(Link *link)
{
    myLinks.insert(link);
}

<span class="dt">void</span> Node::removeLink(Link *link)
{
    myLinks.remove(link);
}

<span class="ot">QRectF</span> Node::outlineRect() <span class="dt">const</span>
{
    <span class="dt">const</span> <span class="dt">int</span> Padding = <span class="dv">8</span>;
    <span class="ot">QFontMetricsF</span> metrics = <span class="kw">qApp</span>-&gt;font();
    <span class="ot">QRectF</span> rect = metrics.boundingRect(myText);
    rect.adjust(-Padding, -Padding, +Padding, +Padding);
    <span class="co">// translate the rectangle so that its center is at (0, 0)</span>
    rect.translate(-rect.center());
    <span class="kw">return</span> rect;
}

<span class="ot">QRectF</span> Node::boundingRect() <span class="dt">const</span>
{
    <span class="co">// since the rectangle we return from this function must allow for at least</span>
    <span class="co">// half the width of the pen if an outline is going to be drawn.</span>
    <span class="dt">const</span> <span class="dt">int</span> Margin = <span class="dv">1</span>;
    <span class="kw">return</span> outlineRect().adjusted(-Margin, -Margin, +Margin, +Margin);
}

<span class="co">// The shape() function is called by QGraphicsView for fine-grained collision</span>
<span class="co">// detection. Often, we can omit it and leave the item to calculate the shape</span>
<span class="co">// itself based on the bounding rectangle. Here we reimplement it to return a</span>
<span class="co">// QPainterPath that represents a rounded rectangle. As a consequence, clicking</span>
<span class="co">// the corner areas that fall outside the rounded rectangle but inside the</span>
<span class="co">// bounding rectangle won&#39;t select the item.</span>
<span class="ot">QPainterPath</span> Node::shape() <span class="dt">const</span>
{
    <span class="ot">QRectF</span> rect = outlineRect();

    <span class="ot">QPainterPath</span> path;
    <span class="co">// void addRoundRect(const QRectF &amp;rect, int xRnd, int yRnd);</span>
    path.addRoundRect(rect, roundness(rect.width()),
                      roundness(rect.height()));
    <span class="kw">return</span> path;
}</code></pre></div>
<dl>
<dt><code class="sourceCode cpp"><span class="dt">void</span> <span class="ot">QRectF::</span>adjust(<span class="dt">qreal</span> dx1, <span class="dt">qreal</span> dy1, <span class="dt">qreal</span> dx2, <span class="dt">qreal</span> dy2)</code></dt>
<dd><p>Adds dx1, dy1, dx2 and dy2 respectively to the existing coordinates of the rectangle.</p>
</dd>
<dt><code class="sourceCode cpp"><span class="ot">QRectF</span> <span class="ot">QRectF::</span>adjusted(<span class="dt">qreal</span> dx1, <span class="dt">qreal</span> dy1, <span class="dt">qreal</span> dx2, <span class="dt">qreal</span> dy2) <span class="dt">const</span></code></dt>
<dd><p>Returns a new rectangle with dx1, dy1, dx2 and dy2 added respectively to the existing coordinates of this rectangle.</p>
</dd>
</dl>
<div class="figure">
<img src="http://doc.qt.io/qt-4.8/images/qpainterpath-addtext.png" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QLinearGradient</span> myGradient;
<span class="ot">QPen</span> myPen;
<span class="ot">QFont</span> myFont;
<span class="ot">QPointF</span> baseline(x, y);

<span class="ot">QPainterPath</span> myPath;
myPath.addText(baseline, myFont, <span class="fu">tr</span>(<span class="st">&quot;Qt&quot;</span>));

<span class="ot">QPainter</span> painter(<span class="kw">this</span>);
painter.setBrush(myGradient);
painter.setPen(myPen);
painter.drawPath(myPath);</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Node::paint(<span class="ot">QPainter</span> *painter,
                 <span class="dt">const</span> <span class="ot">QStyleOptionGraphicsItem</span> *option,
                 <span class="ot">QWidget</span> * <span class="co">/* widget */</span>)
{
    <span class="ot">QPen</span> pen(myOutlineColor);
    <span class="co">// The option parameter of type QStyleOptionGraphicsItem is an unusual</span>
    <span class="co">// class for Qt because it provides several public member variables. These</span>
    <span class="co">// include the current layout direction, font metrics, palette, rectangle,</span>
    <span class="co">// state (selected, &quot;has focus&quot;, and many others), the transformation</span>
    <span class="co">// matrix, and the level of detail. Here we have checked the state member</span>
    <span class="co">// to see whether the node is selected.</span>
    <span class="kw">if</span> (option-&gt;state &amp; <span class="ot">QStyle::</span>State_Selected) {
        pen.setStyle(<span class="ot">Qt::</span>DotLine);
        pen.setWidth(<span class="dv">2</span>);
    }
    <span class="co">// default: solid 1-pixel line</span>
    painter-&gt;setPen(pen);
    painter-&gt;setBrush(myBackgroundColor);

    <span class="ot">QRectF</span> rect = outlineRect();
    painter-&gt;drawRoundRect(rect, roundness(rect.width()),
                           roundness(rect.height()));

    painter-&gt;setPen(myTextColor);
    painter-&gt;drawText(rect, <span class="ot">Qt::</span>AlignCenter, myText);
}

<span class="ot">QVariant</span> Node::itemChange(GraphicsItemChange change,
                          <span class="dt">const</span> <span class="ot">QVariant</span> &amp;value)
{
    <span class="kw">if</span> (change == ItemPositionHasChanged) {
        <span class="kw">foreach</span> (Link *link, myLinks)
            link-&gt;trackNodes();
    }
    <span class="kw">return</span> <span class="ot">QGraphicsItem::</span>itemChange(change, value);
}

<span class="dt">void</span> Node::mouseDoubleClickEvent(<span class="ot">QGraphicsSceneMouseEvent</span> *event)
{
    <span class="ot">QString</span> text = <span class="ot">QInputDialog::</span>getText(event-&gt;widget(), <span class="co">// event-&gt;widget()</span>
                           <span class="fu">tr</span>(<span class="st">&quot;Edit Text&quot;</span>), <span class="fu">tr</span>(<span class="st">&quot;Enter new text:&quot;</span>),
                           <span class="ot">QLineEdit::</span>Normal, myText);
    <span class="kw">if</span> (!text.isEmpty())
        setText(text);
}

<span class="dt">int</span> Node::roundness(<span class="dt">double</span> size) <span class="dt">const</span>
{
    <span class="co">// returns appropriate rounding factors to ensure that the node&#39;s corners</span>
    <span class="co">// are quarter- circles with diameter 12. The rounding factors must be in</span>
    <span class="co">// the range 0 (square) to 99 (fully rounded).</span>
    <span class="dt">const</span> <span class="dt">int</span> Diameter = <span class="dv">12</span>;
    <span class="kw">return</span> <span class="dv">100</span> * Diameter / <span class="dt">int</span>(size);
}</code></pre></div>
<dl>
<dt><code class="sourceCode cpp"><span class="ot">QGraphicsItem::</span>itemChange</code></dt>
<dd><p>This virtual function is called by QGraphicsItem to notify custom items that some part of the item&#8217;s state changes. By reimplementing this function, your can react to a change, and in some cases, (depending on change,) adjustments can be made.</p>
<p>```cpp // QVariant QGraphicsItem::itemChange(GraphicsItemChange change, // const QVariant &amp; value)</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QVariant</span> Component::itemChange(GraphicsItemChange change, <span class="dt">const</span> <span class="ot">QVariant</span> &amp;value)
{
    <span class="kw">if</span> (change == ItemPositionChange &amp;&amp; scene()) {
        <span class="co">// value is the new position.</span>
        <span class="ot">QPointF</span> newPos = value.toPointF();
        <span class="ot">QRectF</span> rect = scene()-&gt;sceneRect();
        <span class="kw">if</span> (!rect.contains(newPos)) {
            <span class="co">// Keep the item inside the scene rect.</span>
            newPos.setX(<span class="fu">qMin</span>(rect.right(), <span class="fu">qMax</span>(newPos.x(), rect.left())));
            newPos.setY(<span class="fu">qMin</span>(rect.bottom(), <span class="fu">qMax</span>(newPos.y(), rect.top())));
            <span class="kw">return</span> newPos;
        }
    }
    <span class="kw">return</span> <span class="ot">QGraphicsItem::</span>itemChange(change, value);
}</code></pre></div>
</dd>
</dl>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> DiagramWindow : <span class="kw">public</span> <span class="ot">QMainWindow</span>
{
    <span class="kw">Q_OBJECT</span>

<span class="kw">public</span>:
    DiagramWindow();

<span class="kw">private</span> <span class="kw">slots</span>:
    <span class="dt">void</span> addNode();
    <span class="dt">void</span> addLink();
    <span class="dt">void</span> del(); <span class="co">// void cut(); void copy(); void paste();</span>
    <span class="dt">void</span> bringToFront();
    <span class="dt">void</span> sendToBack();
    <span class="dt">void</span> properties();
    <span class="dt">void</span> updateActions();

<span class="kw">private</span>:
    <span class="kw">typedef</span> <span class="ot">QPair</span>&lt;Node *, Node *&gt; NodePair;

    <span class="dt">void</span> createActions();
    <span class="dt">void</span> createMenus();
    <span class="dt">void</span> createToolBars();
    <span class="dt">void</span> setZValue(<span class="dt">int</span> z);
    <span class="dt">void</span> setupNode(Node *node);
    Node *selectedNode() <span class="dt">const</span>;
    Link *selectedLink() <span class="dt">const</span>;
    NodePair selectedNodePair() <span class="dt">const</span>;

    <span class="ot">QMenu</span> *fileMenu;
    <span class="ot">QMenu</span> *editMenu;
    <span class="ot">QToolBar</span> *editToolBar; <span class="co">// QAction *exitAction; QAction *addNodeAction;</span>
    <span class="ot">QAction</span> *addLinkAction; <span class="co">// QAction *deleteAction;</span>
    <span class="ot">QAction</span> *copyAction; <span class="co">// QAction *pasteAction; QAction *cutAction;</span>
    <span class="ot">QAction</span> *bringToFrontAction;
    <span class="ot">QAction</span> *sendToBackAction;
    <span class="ot">QAction</span> *propertiesAction;

    <span class="ot">QGraphicsScene</span> *scene;
    <span class="ot">QGraphicsView</span> *view;

    <span class="dt">int</span> minZ;
    <span class="dt">int</span> maxZ;
    <span class="dt">int</span> seqNumber;
};

DiagramWindow::DiagramWindow()
{
    scene = <span class="kw">new</span> <span class="ot">QGraphicsScene</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">600</span>, <span class="dv">500</span>);

    <span class="co">// create a graphics view to visualize the scene.</span>
    view = <span class="kw">new</span> <span class="ot">QGraphicsView</span>;
    view-&gt;setScene(scene);
    <span class="co">// means that the user can also select items by dragging a rubber band over</span>
    <span class="co">// them</span>
    view-&gt;setDragMode(<span class="ot">QGraphicsView::</span>RubberBandDrag);
    view-&gt;setRenderHints(<span class="ot">QPainter::</span>Antialiasing
                         | <span class="ot">QPainter::</span>TextAntialiasing);
    view-&gt;setContextMenuPolicy(<span class="ot">Qt::</span>ActionsContextMenu);
    setCentralWidget(view);

    minZ = <span class="dv">0</span>;
    maxZ = <span class="dv">0</span>;
    seqNumber = <span class="dv">0</span>;

    createActions();
    createMenus();
    createToolBars();

    <span class="fu">connect</span>(scene, <span class="kw">SIGNAL</span>(selectionChanged()),
            <span class="kw">this</span>, <span class="kw">SLOT</span>(updateActions()));

    setWindowTitle(<span class="fu">tr</span>(<span class="st">&quot;Diagram&quot;</span>));
    updateActions();
}

<span class="dt">void</span> DiagramWindow::addNode()
{
    Node *node = <span class="kw">new</span> Node;
    node-&gt;setText(<span class="fu">tr</span>(<span class="st">&quot;Node %1&quot;</span>).arg(seqNumber + <span class="dv">1</span>));
    setupNode(node);
}

<span class="dt">void</span> DiagramWindow::setupNode(Node *node)
{
    node-&gt;setPos(<span class="ot">QPoint</span>(<span class="dv">80</span> + (<span class="dv">100</span> * (seqNumber % <span class="dv">5</span>)),
                        <span class="dv">80</span> + (<span class="dv">50</span> * ((seqNumber / <span class="dv">5</span>) % <span class="dv">7</span>))));
    scene-&gt;addItem(node);
    ++seqNumber;

    scene-&gt;clearSelection();
    node-&gt;setSelected(<span class="kw">true</span>);
    bringToFront();
}

<span class="dt">void</span> DiagramWindow::bringToFront()
{
    ++maxZ;
    setZValue(maxZ);
}

<span class="dt">void</span> DiagramWindow::sendToBack()
{
    --minZ;
    setZValue(minZ);
}

Node *DiagramWindow::selectedNode() <span class="dt">const</span>
{
    <span class="ot">QList</span>&lt;<span class="ot">QGraphicsItem</span> *&gt; items = scene-&gt;selectedItems();
    <span class="kw">if</span> (items.count() == <span class="dv">1</span>) {
        <span class="kw">return</span> <span class="kw">dynamic_cast</span>&lt;Node *&gt;(items.first());
    } <span class="kw">else</span> {
        <span class="kw">return</span> <span class="dv">0</span>;
    }
}


<span class="dt">void</span> DiagramWindow::addLink()
{
    NodePair nodes = selectedNodePair();
    <span class="kw">if</span> (nodes == NodePair())
        <span class="kw">return</span>;

    Link *link = <span class="kw">new</span> Link(nodes.first, nodes.second);
    scene-&gt;addItem(link);
}

DiagramWindow::NodePair DiagramWindow::selectedNodePair() <span class="dt">const</span>
{
    <span class="ot">QList</span>&lt;<span class="ot">QGraphicsItem</span> *&gt; items = scene-&gt;selectedItems();
    <span class="kw">if</span> (items.count() == <span class="dv">2</span>) {
        Node *first = <span class="kw">dynamic_cast</span>&lt;Node *&gt;(items.first());
        Node *second = <span class="kw">dynamic_cast</span>&lt;Node *&gt;(items.last());
        <span class="kw">if</span> (first &amp;&amp; second)
            <span class="kw">return</span> NodePair(first, second);
    }
    <span class="kw">return</span> NodePair();
}

<span class="dt">void</span> DiagramWindow::del()
{
    <span class="ot">QList</span>&lt;<span class="ot">QGraphicsItem</span> *&gt; items = scene-&gt;selectedItems();
    <span class="ot">QMutableListIterator</span>&lt;<span class="ot">QGraphicsItem</span> *&gt; i(items);
    <span class="kw">while</span> (i.hasNext()) {
        Link *link = <span class="kw">dynamic_cast</span>&lt;Link *&gt;(i.next());
        <span class="kw">if</span> (link) {
            <span class="kw">delete</span> link;
            i.remove();
        }
    }

    <span class="fu">qDeleteAll</span>(items);
}

<span class="dt">void</span> DiagramWindow::properties()
{
    Node *node = selectedNode();
    Link *link = selectedLink();

    <span class="kw">if</span> (node) {
        PropertiesDialog dialog(node, <span class="kw">this</span>);
        dialog.exec();
    } <span class="kw">else</span> <span class="kw">if</span> (link) {
        <span class="ot">QColor</span> color = <span class="ot">QColorDialog::</span>getColor(link-&gt;color(), <span class="kw">this</span>);
        <span class="kw">if</span> (color.isValid())
            link-&gt;setColor(color);
    }
}

<span class="dt">void</span> DiagramWindow::cut()
{
    Node *node = selectedNode();
    <span class="kw">if</span> (!node)
        <span class="kw">return</span>;

    copy();
    <span class="kw">delete</span> node;
}

<span class="dt">void</span> DiagramWindow::copy()
{
    Node *node = selectedNode();
    <span class="kw">if</span> (!node)
        <span class="kw">return</span>;

    <span class="ot">QString</span> str = <span class="ot">QString</span>(<span class="st">&quot;Node %1 %2 %3 %4&quot;</span>)
                  .arg(node-&gt;textColor().name()) <span class="co">// #008000</span>
                  .arg(node-&gt;outlineColor().name())
                  .arg(node-&gt;backgroundColor().name())
                  .arg(node-&gt;text());
    <span class="ot">QApplication::</span>clipboard()-&gt;setText(str);
}

<span class="dt">void</span> DiagramWindow::paste()
{
    <span class="ot">QString</span> str = <span class="ot">QApplication::</span>clipboard()-&gt;text();
    <span class="ot">QStringList</span> parts = str.split(<span class="st">&quot; &quot;</span>);

    <span class="co">// !!! hack</span>
    <span class="kw">if</span> (parts.count() &gt;= <span class="dv">5</span> &amp;&amp; parts.first() == <span class="st">&quot;Node&quot;</span>) {
        Node *node = <span class="kw">new</span> Node;
        <span class="co">// qlist.h: QList&lt;T&gt; mid(int pos, int length = -1) const;</span>
        node-&gt;setText(<span class="ot">QStringList</span>(parts.mid(<span class="dv">4</span>)).join(<span class="st">&quot; &quot;</span>));
        node-&gt;setTextColor(<span class="ot">QColor</span>(parts[<span class="dv">1</span>]));
        node-&gt;setOutlineColor(<span class="ot">QColor</span>(parts[<span class="dv">2</span>]));
        node-&gt;setBackgroundColor(<span class="ot">QColor</span>(parts[<span class="dv">3</span>]));
        setupNode(node);
    }
}

<span class="dt">void</span> DiagramWindow::updateActions()
{
    <span class="dt">bool</span> hasSelection = !scene-&gt;selectedItems().isEmpty();
    <span class="dt">bool</span> isNode = (selectedNode() != <span class="dv">0</span>);
    <span class="dt">bool</span> isNodePair = (selectedNodePair() != NodePair());

    cutAction-&gt;setEnabled(isNode);
    copyAction-&gt;setEnabled(isNode);
    addLinkAction-&gt;setEnabled(isNodePair);
    deleteAction-&gt;setEnabled(hasSelection);
    bringToFrontAction-&gt;setEnabled(isNode);
    sendToBackAction-&gt;setEnabled(isNode);
    propertiesAction-&gt;setEnabled(isNode);

    <span class="co">// get/remove/add action(s) of this view (QGraphicsView)</span>
    <span class="kw">foreach</span> (<span class="ot">QAction</span> *action, view-&gt;actions())
        view-&gt;removeAction(action);

    <span class="kw">foreach</span> (<span class="ot">QAction</span> *action, editMenu-&gt;actions()) {
        <span class="kw">if</span> (action-&gt;isEnabled())
            view-&gt;addAction(action);
    }
}</code></pre></div>
<p>A city block has a kind, a color, and a shape. Since the city blocks are not selectable, we have not bothered to reimplement the <code class="sourceCode cpp">shape()</code> function like we did for the Node class in the previous example.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> CityBlock : <span class="kw">public</span> <span class="ot">QGraphicsItem</span>
{
<span class="kw">public</span>:
    <span class="kw">enum</span> Kind { Park, SmallBuilding, Hospital, Hall, Building, Tower,
                LShapedBlock, LShapedBlockPlusSmallBlock, TwoBlocks,
                BlockPlusTwoSmallBlocks };

    CityBlock(Kind kind);

    <span class="ot">QRectF</span> boundingRect() <span class="dt">const</span>;
    <span class="dt">void</span> paint(<span class="ot">QPainter</span> *painter,
               <span class="dt">const</span> <span class="ot">QStyleOptionGraphicsItem</span> *option, <span class="ot">QWidget</span> *widget);

<span class="kw">private</span>:
    Kind kind;
    <span class="ot">QColor</span> color;
    <span class="ot">QPainterPath</span> shape;
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">CityBlock::CityBlock(Kind kind)
{
    <span class="kw">this</span>-&gt;kind = kind;

    <span class="dt">int</span> green = <span class="dv">96</span> + (std::rand() % <span class="dv">64</span>);
    <span class="dt">int</span> red = <span class="dv">16</span> + green + (std::rand() % <span class="dv">64</span>);
    <span class="dt">int</span> blue = <span class="dv">16</span> + (std::rand() % green);
    color = <span class="ot">QColor</span>(red, green, blue);

    <span class="kw">if</span> (kind == Park) {
        color = <span class="ot">QColor</span>(<span class="dv">192</span> + (std::rand() % <span class="dv">32</span>), <span class="dv">255</span>,
                       <span class="dv">192</span> + (std::rand() % <span class="dv">16</span>));
        shape.addRect(boundingRect());
    } <span class="kw">else</span> <span class="kw">if</span> (kind == SmallBuilding) {
        <span class="ot">QRectF</span> block(<span class="fl">-7.5</span>, <span class="fl">-7.5</span>, <span class="dv">15</span>, <span class="dv">15</span>);
        <span class="co">// Moves the rectangle, leaving the bottom-left corner at the given</span>
        <span class="co">// position. The rectangle&#39;s size is unchanged.</span>
        block.moveBottomLeft(<span class="ot">QPointF</span>((std::rand() % <span class="dv">6</span>) - <span class="dv">3</span>,
                                     (std::rand() % <span class="dv">6</span>) - <span class="dv">3</span>));
        shape.addRect(block);
    } <span class="kw">else</span> <span class="kw">if</span> (kind == Hospital) {
        <span class="dt">int</span> a = (std::rand() % <span class="dv">6</span>) + <span class="dv">10</span>;
        <span class="dt">int</span> b = (std::rand() % <span class="dv">6</span>) + <span class="dv">10</span>;
        <span class="ot">QPolygonF</span> block;
        block &lt;&lt; <span class="ot">QPointF</span>(<span class="dv">-5</span>, -a) &lt;&lt; <span class="ot">QPointF</span>(<span class="dv">-5</span>, <span class="dv">-5</span>) &lt;&lt; <span class="ot">QPointF</span>(<span class="dv">-10</span>, <span class="dv">-5</span>)
              &lt;&lt; <span class="ot">QPointF</span>(<span class="dv">-10</span>, <span class="dv">5</span>) &lt;&lt; <span class="ot">QPointF</span>(<span class="dv">-5</span>, <span class="dv">5</span>)  &lt;&lt; <span class="ot">QPointF</span>(<span class="dv">-5</span>, <span class="dv">10</span>)
              &lt;&lt; <span class="ot">QPointF</span>(<span class="dv">5</span>, <span class="dv">10</span>)  &lt;&lt; <span class="ot">QPointF</span>(<span class="dv">5</span>, <span class="dv">5</span>)   &lt;&lt; <span class="ot">QPointF</span>(b, <span class="dv">5</span>)
              &lt;&lt; <span class="ot">QPointF</span>(b, <span class="dv">-5</span>)  &lt;&lt; <span class="ot">QPointF</span>(<span class="dv">5</span>, <span class="dv">-5</span>)  &lt;&lt; <span class="ot">QPointF</span>(<span class="dv">5</span>, -a);
        shape.addPolygon(block);
    } <span class="kw">else</span> <span class="kw">if</span> (kind == Hall) {
        <span class="dt">int</span> padding1 = (std::rand() % <span class="dv">8</span>) + <span class="dv">2</span>;
        <span class="dt">int</span> padding2 = (std::rand() % <span class="dv">8</span>) + <span class="dv">2</span>;
        shape.addEllipse(boundingRect().adjusted(+padding1, +padding1,
                                                 -padding2, -padding2));
    } <span class="kw">else</span> <span class="kw">if</span> (kind == Building) {
        shape.addRect(boundingRect());
    } <span class="kw">else</span> <span class="kw">if</span> (kind == Tower) {
        <span class="dt">int</span> padding1 = (std::rand() % <span class="dv">8</span>) + <span class="dv">2</span>;
        <span class="dt">int</span> padding2 = (std::rand() % <span class="dv">8</span>) + <span class="dv">2</span>;
        shape.addRect(boundingRect().adjusted(+padding1, +padding1,
                                              -padding2, -padding2));
    } <span class="kw">else</span> <span class="kw">if</span> (kind == LShapedBlock
               || kind == LShapedBlockPlusSmallBlock) {
        <span class="dt">int</span> a = (std::rand() % <span class="dv">6</span>) + <span class="dv">10</span>;
        <span class="dt">int</span> b = (std::rand() % <span class="dv">6</span>) + <span class="dv">10</span>;
        <span class="dt">int</span> s = <span class="fu">qMin</span>(a, b) / <span class="dv">2</span>;
        <span class="ot">QPolygonF</span> block;
        block &lt;&lt; <span class="ot">QPointF</span>(-a, -a) &lt;&lt; <span class="ot">QPointF</span>(-a, +a) &lt;&lt; <span class="ot">QPointF</span>(-s, +a)
              &lt;&lt; <span class="ot">QPointF</span>(-s, -s) &lt;&lt; <span class="ot">QPointF</span>(+b, -s) &lt;&lt; <span class="ot">QPointF</span>(+b, -a);
        shape.addPolygon(block);
        <span class="kw">if</span> (kind == LShapedBlockPlusSmallBlock) {
            <span class="dt">int</span> inset = (std::rand() % <span class="dv">4</span>) + <span class="dv">4</span>;
            shape.addRect(<span class="ot">QRectF</span>(-s + inset, -s + inset, a, b));
        }
    } <span class="kw">else</span> <span class="kw">if</span> (kind == TwoBlocks) {
        <span class="dt">int</span> w1 = (std::rand() % <span class="dv">10</span>) + <span class="dv">8</span>;
        <span class="dt">int</span> h1 = (std::rand() % <span class="dv">28</span>) + <span class="dv">8</span>;
        <span class="dt">int</span> w2 = (std::rand() % <span class="dv">10</span>) + <span class="dv">8</span>;
        <span class="dt">int</span> h2 = (std::rand() % <span class="dv">24</span>) + <span class="dv">8</span>;
        shape.addRect(<span class="ot">QRectF</span>(<span class="dv">-16</span>, <span class="dv">-16</span>, w1, h1));
        shape.addRect(<span class="ot">QRectF</span>(<span class="dv">-16</span> + w1 + <span class="dv">4</span>, <span class="dv">-16</span> + (std::rand() % <span class="dv">4</span>),
                             w2, h2));
    } <span class="kw">else</span> <span class="kw">if</span> (kind == BlockPlusTwoSmallBlocks) {
        <span class="dt">int</span> w1 = (std::rand() % <span class="dv">10</span>) + <span class="dv">8</span>;
        <span class="dt">int</span> h1 = (std::rand() % <span class="dv">28</span>) + <span class="dv">8</span>;
        <span class="dt">int</span> w2 = (std::rand() % <span class="dv">10</span>) + <span class="dv">8</span>;
        <span class="dt">int</span> h2 = (std::rand() % <span class="dv">10</span>) + <span class="dv">8</span>;
        <span class="dt">int</span> w3 = (std::rand() % <span class="dv">6</span>) + <span class="dv">8</span>;
        <span class="dt">int</span> h3 = (std::rand() % <span class="dv">6</span>) + <span class="dv">8</span>;
        <span class="dt">int</span> y = (std::rand() % <span class="dv">4</span>) - <span class="dv">16</span>;
        shape.addRect(<span class="ot">QRectF</span>(<span class="dv">-16</span>, <span class="dv">-16</span>, w1, h1));
        shape.addRect(<span class="ot">QRectF</span>(<span class="dv">-16</span> + w1 + <span class="dv">4</span>, y, w2, h2));
        shape.addRect(<span class="ot">QRectF</span>(<span class="dv">-16</span> + w1 + <span class="dv">4</span>,
                             y + h2 + <span class="dv">4</span> + (std::rand() % <span class="dv">4</span>), w3, h3));
    }
}

<span class="ot">QRectF</span> CityBlock::boundingRect() <span class="dt">const</span>
{
    <span class="kw">return</span> <span class="ot">QRectF</span>(<span class="dv">-20</span>, <span class="dv">-20</span>, <span class="dv">40</span>, <span class="dv">40</span>);
}

<span class="dt">void</span> CityBlock::paint(<span class="ot">QPainter</span> *painter,
                      <span class="dt">const</span> <span class="ot">QStyleOptionGraphicsItem</span> *option,
                      <span class="ot">QWidget</span> * <span class="co">/* widget */</span>)
{
    <span class="kw">if</span> (option-&gt;levelOfDetail &lt; <span class="fl">4.0</span>) {
        <span class="co">// If the zoom factor is less than 4.0, we use a solid color to fill</span>
        <span class="co">// the shape</span>
        painter-&gt;fillPath(shape, color);
    } <span class="kw">else</span> {
        <span class="co">// If the zoom factor is 4.0 or more, we use a QLinearGradient to fill</span>
        <span class="co">// the shape to give a subtle lighting effect.</span>
        <span class="ot">QLinearGradient</span> gradient(<span class="ot">QPoint</span>(<span class="dv">-20</span>, <span class="dv">-20</span>), <span class="ot">QPoint</span>(<span class="dv">+20</span>, <span class="dv">+20</span>));
        <span class="dt">int</span> coeff = <span class="dv">105</span> + <span class="dt">int</span>(std::log(option-&gt;levelOfDetail - <span class="fl">4.0</span>));
        <span class="co">// Setting factor to 150 returns a color that is 50% brighter</span>
        gradient.setColorAt(<span class="fl">0.0</span>, color.lighter(coeff));
        gradient.setColorAt(<span class="fl">1.0</span>, color.darker(coeff));
        <span class="co">// If the factor is greater than 100, this functions returns a darker</span>
        <span class="co">// color. Setting factor to 300 returns a color that has one-third the</span>
        <span class="co">// brightness.</span>
        painter-&gt;fillPath(shape, gradient);
    }
}</code></pre></div>
<p>The <code class="sourceCode cpp">levelOfDetail</code> member of the <code class="sourceCode cpp"><span class="ot">QStyleOptionGraphicsItem</span></code> class stores a floating-point value that tells us what the zoom factor is.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Annotation : <span class="kw">public</span> <span class="ot">QGraphicsItem</span>
{
<span class="kw">public</span>:
    Annotation(<span class="dt">const</span> <span class="ot">QString</span> &amp;text, <span class="dt">bool</span> major = <span class="kw">false</span>);

    <span class="dt">void</span> setText(<span class="dt">const</span> <span class="ot">QString</span> &amp;text);
    <span class="ot">QString</span> text() <span class="dt">const</span>;

    <span class="ot">QRectF</span> boundingRect() <span class="dt">const</span>;
    <span class="dt">void</span> paint(<span class="ot">QPainter</span> *painter,
               <span class="dt">const</span> <span class="ot">QStyleOptionGraphicsItem</span> *option, <span class="ot">QWidget</span> *widget);

<span class="kw">private</span>:
    <span class="ot">QFont</span> font;
    <span class="ot">QString</span> str;
    <span class="dt">bool</span> major;
    <span class="dt">double</span> threshold;
    <span class="dt">int</span> y;
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Annotation::Annotation(<span class="dt">const</span> <span class="ot">QString</span> &amp;text, <span class="dt">bool</span> major)
{
    font = <span class="kw">qApp</span>-&gt;font();
    font.setBold(<span class="kw">true</span>);

    <span class="co">// A part</span>
    <span class="kw">if</span> (major) {
        font.setPointSize(font.pointSize() + <span class="dv">2</span>);
        font.setStretch(<span class="ot">QFont::</span>SemiExpanded);
    }

    <span class="co">// B part</span>
    <span class="kw">if</span> (major) {
        threshold = <span class="fl">0.01</span> * (<span class="dv">40</span> + (std::rand() % <span class="dv">40</span>));
    } <span class="kw">else</span> {
        threshold = <span class="fl">0.01</span> * (<span class="dv">100</span> + (std::rand() % <span class="dv">100</span>));
    }

    str = text;
    <span class="kw">this</span>-&gt;major = major;
    y = <span class="dv">20</span> - (std::rand() % <span class="dv">40</span>);

    <span class="co">// on top</span>
    setZValue(<span class="dv">1000</span>);

    <span class="co">// ensure that the annotation does not change size no matter how much the</span>
    <span class="co">// scene is zoomed</span>
    setFlag(ItemIgnoresTransformations, <span class="kw">true</span>);
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Annotation::setText(<span class="dt">const</span> <span class="ot">QString</span> &amp;text)
{
    prepareGeometryChange();
    str = text;
    update();
}

<span class="co">// We get the font metrics for the annotation&#39;s font, and use them to calculate</span>
<span class="co">// the text&#39;s bounding rectangle. We then move the rectangle&#39;s center point to</span>
<span class="co">// the annotation&#39;s y offset, and make the rectangle slightly wider. The extra</span>
<span class="co">// pixels on the left and right sides of the bounding rectangle will give the</span>
<span class="co">// text some margin from the edges.</span>
<span class="ot">QRectF</span> Annotation::boundingRect() <span class="dt">const</span>
{
    <span class="ot">QFontMetricsF</span> metrics(font);
    <span class="ot">QRectF</span> rect = metrics.boundingRect(str);
    <span class="co">// Moves the rectangle, leaving the center point at the given position. The</span>
    <span class="co">// rectangle&#39;s size is unchanged.</span>
    rect.moveCenter(<span class="ot">QPointF</span>(<span class="dv">0</span>, y));
    rect.adjust(<span class="dv">-4</span>, <span class="dv">0</span>, <span class="dv">+4</span>, <span class="dv">0</span>);
    <span class="kw">return</span> rect;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Annotation::paint(<span class="ot">QPainter</span> *painter,
                       <span class="dt">const</span> <span class="ot">QStyleOptionGraphicsItem</span> *option,
                       <span class="ot">QWidget</span> * <span class="co">/* widget */</span>)
{
    <span class="kw">if</span> (option-&gt;levelOfDetail &lt;= threshold)
        <span class="kw">return</span>;

    painter-&gt;setFont(font);

    <span class="ot">QRectF</span> rect = boundingRect();

    <span class="co">// start by painting a semi-transparent white rectangle; this helps the</span>
    <span class="co">// text stand out when drawn on top of a dark block</span>
    <span class="dt">int</span> alpha = <span class="dt">int</span>(<span class="dv">30</span> * std::log(option-&gt;levelOfDetail));
    <span class="kw">if</span> (alpha &gt;= <span class="dv">32</span>)
        painter-&gt;fillRect(rect, <span class="ot">QColor</span>(<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>, <span class="fu">qMin</span>(alpha, <span class="dv">63</span>)));

    <span class="co">// We draw the text twice, once in white and once in blue. The white text</span>
    <span class="co">// is offset by one pixel horizontally and vertically to create a shadow</span>
    <span class="co">// effect that makes the text easier to read</span>
    painter-&gt;setPen(<span class="ot">Qt::</span>white);
    painter-&gt;drawText(rect.translated(<span class="dv">+1</span>, <span class="dv">+1</span>), str,
                      <span class="ot">QTextOption</span>(<span class="ot">Qt::</span>AlignCenter));
    painter-&gt;setPen(<span class="ot">Qt::</span>blue);
    painter-&gt;drawText(rect, str, <span class="ot">QTextOption</span>(<span class="ot">Qt::</span>AlignCenter));
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> CityView : <span class="kw">public</span> <span class="ot">QGraphicsView</span>
{
    <span class="kw">Q_OBJECT</span>

<span class="kw">public</span>:
    CityView(<span class="ot">QWidget</span> *parent = <span class="dv">0</span>);

<span class="kw">protected</span>:
    <span class="dt">void</span> wheelEvent(<span class="ot">QWheelEvent</span> *event);
};

CityView::CityView(<span class="ot">QWidget</span> *parent)
    : <span class="ot">QGraphicsView</span>(parent)
{
    <span class="co">// Setting the drag mode is all that is required to support scrolling by</span>
    <span class="co">// dragging.</span>
    setDragMode(ScrollHandDrag);
}

<span class="dt">void</span> CityView::wheelEvent(<span class="ot">QWheelEvent</span> *event)
{
    <span class="co">// calculate an appropriate scaling factor and call QGraphicsView::scale()</span>
    <span class="dt">double</span> numDegrees = -event-&gt;delta() / <span class="fl">8.0</span>;
    <span class="dt">double</span> numSteps = numDegrees / <span class="fl">15.0</span>;
    <span class="dt">double</span> factor = std::pow(<span class="fl">1.125</span>, numSteps);
    scale(factor, factor);
}</code></pre></div>
<p>That completes our two graphics view examples. Qt&#8217;s graphics view architecture is very rich, so <strong>bear in mind that it has a lot more to offer than we have had the space to cover</strong>. There is support for drag and drop, and graphics items can have tooltips and custom cursors. Animation effects can be achieved in a number of ways, for example, by associating <code class="sourceCode cpp">QGraphicsItemAnimations</code> with the items that we want to animate and performing the animation using a <code class="sourceCode cpp"><span class="ot">QTimeLine</span></code>. It is also possible to achieve animation by creating custom graphics item subclasses that are derived from <code class="sourceCode cpp"><span class="ot">QObject</span></code> (through multiple inheritance) and that reimplement <code class="sourceCode cpp"><span class="ot">QObject::</span>timerEvent()</code>.</p>
<h4 id="printing">Printing</h4>
<ul>
<li>&#9744; TODO</li>
</ul>
<h3 id="drag-and-drop">9. Drag and Drop</h3>
<p><code class="sourceCode cpp"><span class="ot">QMimeData</span></code>, a class that can provide data in several formats.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">protected</span>:
    <span class="dt">void</span> dragEnterEvent(<span class="ot">QDragEnterEvent</span> *event);
    <span class="dt">void</span> dropEvent(<span class="ot">QDropEvent</span> *event);</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">MainWindow::MainWindow()
{
    textEdit = <span class="kw">new</span> <span class="ot">QTextEdit</span>;
    setCentralWidget(textEdit);
    <span class="co">// In the constructor, we create a QTextEdit and set it as the central</span>
    <span class="co">// widget. By default, QTextEdit accepts textual drags from other</span>
    <span class="co">// applications, and if the user drops a file onto it, it will insert the</span>
    <span class="co">// file name into the text. Since drop events are propagated from child to</span>
    <span class="co">// parent, by disabling dropping on the QTextEdit and enabling it on the</span>
    <span class="co">// main window, we get the drop events for the whole window in MainWindow.</span>
    textEdit-&gt;setAcceptDrops(<span class="kw">false</span>);
    setAcceptDrops(<span class="kw">true</span>);
    setWindowTitle(<span class="fu">tr</span>(<span class="st">&quot;Text Editor&quot;</span>));
}</code></pre></div>
<h4 id="enabling-drag-and-drop">Enabling Drag and Drop</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::dragEnterEvent(<span class="ot">QDragEnterEvent</span> *event)
{
    <span class="co">// The MIME type text/uri-list is used to store a list of uniform resource</span>
    <span class="co">// identifiers (URIs), which can be file names, URLs (such as HTTP or FTP</span>
    <span class="co">// paths), or other global resource identifiers.</span>
    <span class="kw">if</span> (event-&gt;mimeData()-&gt;hasFormat(<span class="st">&quot;text/uri-list&quot;</span>))
        event-&gt;acceptProposedAction();
}

<span class="dt">void</span> MainWindow::dropEvent(<span class="ot">QDropEvent</span> *event)
{
    <span class="ot">QList</span>&lt;<span class="ot">QUrl</span>&gt; urls = event-&gt;mimeData()-&gt;urls();
    <span class="kw">if</span> (urls.isEmpty())
        <span class="kw">return</span>;
    <span class="ot">QString</span> fileName = urls.first().toLocalFile();
    <span class="kw">if</span> (fileName.isEmpty())
        <span class="kw">return</span>;
    <span class="kw">if</span> (readFile(fileName))
        setWindowTitle(<span class="fu">tr</span>(<span class="st">&quot;%1 - %2&quot;</span>).arg(fileName)
                                    .arg(<span class="fu">tr</span>(<span class="st">&quot;Drag File&quot;</span>)));
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ProjectListWidget::mousePressEvent(<span class="ot">QMouseEvent</span> *event)
{
    <span class="kw">if</span> (event-&gt;button() == <span class="ot">Qt::</span>LeftButton)
        startPos = event-&gt;pos();
    <span class="ot">QListWidget::</span>mousePressEvent(event);
}

<span class="dt">void</span> ProjectListWidget::mouseMoveEvent(<span class="ot">QMouseEvent</span> *event)
{
    <span class="kw">if</span> (event-&gt;buttons() &amp; <span class="ot">Qt::</span>LeftButton) {
        <span class="co">// If the distance is greater than or equal to QApplication&#39;s</span>
        <span class="co">// recommended drag start distance (normally four pixels), we call the</span>
        <span class="co">// private function performDrag() to start dragging. This avoids</span>
        <span class="co">// initiating a drag just because the user&#39;s hand shakes.</span>
        <span class="dt">int</span> distance = (event-&gt;pos() - startPos).manhattanLength();
        <span class="kw">if</span> (distance &gt;= <span class="ot">QApplication::</span>startDragDistance()) <span class="co">// 4 px normally</span>
            performDrag();
    }
    <span class="ot">QListWidget::</span>mouseMoveEvent(event);
}

<span class="dt">void</span> ProjectListWidget::performDrag()
{
    <span class="ot">QListWidgetItem</span> *item = currentItem();
    <span class="kw">if</span> (item) {
        <span class="ot">QMimeData</span> *mimeData = <span class="kw">new</span> <span class="ot">QMimeData</span>;
        mimeData-&gt;setText(item-&gt;text());

        <span class="ot">QDrag</span> *drag = <span class="kw">new</span> <span class="ot">QDrag</span>(<span class="kw">this</span>);
        drag-&gt;setMimeData(mimeData);
        drag-&gt;setPixmap(<span class="ot">QPixmap</span>(<span class="st">&quot;:/images/person.png&quot;</span>));
        <span class="co">// The QDrag::exec() call starts the dragging operation and blocks</span>
        <span class="co">// until the user drops or cancels the drag.</span>
        <span class="kw">if</span> (drag-&gt;exec(<span class="ot">Qt::</span>MoveAction) == <span class="ot">Qt::</span>MoveAction)
            <span class="kw">delete</span> item;
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ProjectListWidget::dragEnterEvent(<span class="ot">QDragEnterEvent</span> *event)
{
    <span class="co">// QDragEnterEvent::source() returns a pointer to the widget that initiated</span>
    <span class="co">// the drag if that widget is part of the same application; otherwise, it</span>
    <span class="co">// returns a null pointer.</span>
    ProjectListWidget *source =
            <span class="fu">qobject_cast</span>&lt;ProjectListWidget *&gt;(event-&gt;source());
    <span class="kw">if</span> (source &amp;&amp; source != <span class="kw">this</span>) {
        event-&gt;setDropAction(<span class="ot">Qt::</span>MoveAction);
        event-&gt;accept();
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ProjectListWidget::dragMoveEvent(<span class="ot">QDragMoveEvent</span> *event)
{
    ProjectListWidget *source =
            <span class="fu">qobject_cast</span>&lt;ProjectListWidget *&gt;(event-&gt;source());
    <span class="kw">if</span> (source &amp;&amp; source != <span class="kw">this</span>) {
        event-&gt;setDropAction(<span class="ot">Qt::</span>MoveAction);
        event-&gt;accept();
    }
}

<span class="dt">void</span> ProjectListWidget::dropEvent(<span class="ot">QDropEvent</span> *event)
{
    ProjectListWidget *source =
            <span class="fu">qobject_cast</span>&lt;ProjectListWidget *&gt;(event-&gt;source());
    <span class="kw">if</span> (source &amp;&amp; source != <span class="kw">this</span>) {
        <span class="co">// retrieve the dragged text using QMimeData::text()</span>
        <span class="co">// drag-&gt;setMimeData(mimeData);</span>
        addItem(event-&gt;mimeData()-&gt;text());
        event-&gt;setDropAction(<span class="ot">Qt::</span>MoveAction);
        event-&gt;accept();
    }
}</code></pre></div>
<p>Drag and drop is a powerful mechanism for transferring data between applications. But in some cases, it&#8217;s possible to implement drag and drop without using Qt&#8217;s drag and drop facilities. If all we want to do is to move data within one widget in one application, we can often simply reimplement <code class="sourceCode cpp">mousePressEvent()</code> and <code class="sourceCode cpp">mouseReleaseEvent()</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MyTableWidget::performDrag()
{
    <span class="ot">QString</span> plainText = selectionAsPlainText();
    <span class="kw">if</span> (plainText.isEmpty())
        <span class="kw">return</span>;
    <span class="ot">QMimeData</span> *mimeData = <span class="kw">new</span> <span class="ot">QMimeData</span>;
    mimeData-&gt;setText(plainText);
    mimeData-&gt;setHtml(toHtml(plainText));
    mimeData-&gt;setData(<span class="st">&quot;text/csv&quot;</span>, toCsv(plainText).toUtf8());
    <span class="ot">QDrag</span> *drag = <span class="kw">new</span> <span class="ot">QDrag</span>(<span class="kw">this</span>);
    drag-&gt;setMimeData(mimeData);
    <span class="kw">if</span> (drag-&gt;exec(<span class="ot">Qt::</span>CopyAction | <span class="ot">Qt::</span>MoveAction) == <span class="ot">Qt::</span>MoveAction)
        deleteSelection();
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QString</span> MyTableWidget::toCsv(<span class="dt">const</span> <span class="ot">QString</span> &amp;plainText)
{
    <span class="ot">QString</span> result = plainText;
    result.replace(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\\\\</span><span class="st">&quot;</span>);
    result.replace(<span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\\\&quot;</span><span class="st">&quot;</span>);
    result.replace(<span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">, </span><span class="ch">\&quot;</span><span class="st">&quot;</span>);
    result.replace(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\&quot;\n\&quot;</span><span class="st">&quot;</span>);
    result.prepend(<span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">&quot;</span>);
    result.append(<span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">&quot;</span>);
    <span class="kw">return</span> result;
}</code></pre></div>
<dl>
<dt><code class="sourceCode cpp"><span class="ot">QString</span> <span class="ot">Qt::</span>escape(<span class="dt">const</span> <span class="ot">QString</span> &amp; plain)</code></dt>
<dd><p>Converts the plain text string plain to a HTML string with HTML metacharacters <code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code>, and <code>&quot;</code> replaced by HTML entities.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QString</span> plain = <span class="st">&quot;#include &lt;QtCore&gt;&quot;</span>
<span class="ot">QString</span> html = <span class="ot">Qt::</span>escape(plain);
<span class="co">// html == &quot;#include &amp;lt;QtCore&amp;gt;&quot;</span></code></pre></div>
</dd>
</dl>
<h4 id="supporting-custom-drag-types">Supporting Custom Drag Types</h4>
<p>If we want to drag plain text, HTML text, images, URLs, or colors, we can use <code class="sourceCode cpp"><span class="ot">QMimeData</span></code> without formality. But if we want to drag custom data, we must choose among the following alternatives:</p>
<ol>
<li>We can provide arbitrary data as a <code class="sourceCode cpp"><span class="ot">QByteArray</span></code> using <code class="sourceCode cpp"><span class="ot">QMimeData::</span>setData()</code> and extract it later using <code class="sourceCode cpp"><span class="ot">QMimeData::</span>data()</code>.</li>
<li>We can subclass <code class="sourceCode cpp"><span class="ot">QMimeData</span></code> and reimplement <code class="sourceCode cpp">formats()</code> and <code class="sourceCode cpp">retrieveData()</code> to handle our custom data types.</li>
<li>For drag and drop operations within a single application, we can subclass <code class="sourceCode cpp"><span class="ot">QMimeData</span></code> and store the data using any data structure we want.</li>
</ol>
<h4 id="clipboard-handling">Clipboard Handling</h4>
<dl>
<dt><code class="sourceCode cpp"><span class="ot">QApplication::</span>clipboard()</code></dt>
<dd><ol>
<li><code class="sourceCode cpp">setText()</code>, <code class="sourceCode cpp">text()</code></li>
<li><code class="sourceCode cpp">setImage()</code>, <code class="sourceCode cpp">image()</code></li>
<li><code class="sourceCode cpp">setPixmap()</code>, <code class="sourceCode cpp">pixmap()</code></li>
</ol>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QClipboard</span> *clipboard = <span class="ot">QApplication::</span>clipboard();
<span class="kw">if</span> (clipboard-&gt;supportsSelection()) {
    <span class="co">// enum QClipboard::Mode { Clipboard, Selection, FindBuffer };</span>
    <span class="ot">QString</span> text = clipboard-&gt;text(<span class="ot">QClipboard::</span>Selection);
}</code></pre></div>
<dl>
<dt><code class="sourceCode cpp"><span class="kw">enum</span> <span class="ot">QClipboard::</span>Mode</code></dt>
<dd><code>Clipboard</code>: <kbd>Control+C</kbd>, <kbd>Control+V</kbd>
</dd>
<dd><code>Selection</code>: mouse selection, register <code>*</code> in Vim
</dd>
</dl>
</dd>
</dl>
<p>If we want to be notified whenever the clipboard&#8217;s contents change, we can connect the <code class="sourceCode cpp"><span class="ot">QClipboard::</span>dataChanged()</code> signal to a custom slot. Also, <code class="sourceCode cpp"><span class="dt">void</span> <span class="ot">QClipboard::</span>changed(<span class="ot">QClipboard::</span>Mode mode)</code>.</p>
<h3 id="item-view-classes">10. Item View Classes</h3>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/multiple-views.png" alt="Multiple Views" />
<p class="caption">Multiple Views</p>
</div>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/symbol-picker.png" alt="Symol Picker" />
<p class="caption">Symol Picker</p>
</div>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/coord-setter.png" alt="Coordinate Setter" />
<p class="caption">Coordinate Setter</p>
</div>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/settings-viewer.png" alt="Settings Viewer" />
<p class="caption">Settings Viewer</p>
</div>
<h4 id="using-the-item-view-convenience-classes">Using the Item View Convenience Classes</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> FlowChartSymbolPicker : <span class="kw">public</span> <span class="ot">QDialog</span>
{
    <span class="kw">Q_OBJECT</span>

<span class="kw">public</span>:
    FlowChartSymbolPicker(<span class="dt">const</span> <span class="ot">QMap</span>&lt;<span class="dt">int</span>, <span class="ot">QString</span>&gt; &amp;symbolMap,
                          <span class="ot">QWidget</span> *parent = <span class="dv">0</span>);

    <span class="dt">int</span> selectedId() <span class="dt">const</span> { <span class="kw">return</span> id; }
    <span class="co">// The done() function is reimplemented from QDialog. It is called when the</span>
    <span class="co">// user clicks OK or Cancel</span>
    <span class="dt">void</span> done(<span class="dt">int</span> result);

<span class="kw">private</span>:
    <span class="ot">QIcon</span> iconForSymbol(<span class="dt">const</span> <span class="ot">QString</span> &amp;symbolName);

    <span class="ot">QListWidget</span> *listWidget;
    <span class="ot">QDialogButtonBox</span> *buttonBox;
    <span class="dt">int</span> id;
};

FlowChartSymbolPicker::FlowChartSymbolPicker(
        <span class="dt">const</span> <span class="ot">QMap</span>&lt;<span class="dt">int</span>, <span class="ot">QString</span>&gt; &amp;symbolMap, <span class="ot">QWidget</span> *parent)
    : <span class="ot">QDialog</span>(parent)
{
    id = <span class="dv">-1</span>;

    listWidget = <span class="kw">new</span> <span class="ot">QListWidget</span>;
    <span class="co">// icon size</span>
    listWidget-&gt;setIconSize(<span class="ot">QSize</span>(<span class="dv">60</span>, <span class="dv">60</span>));

    <span class="ot">QMapIterator</span>&lt;<span class="dt">int</span>, <span class="ot">QString</span>&gt; i(symbolMap);
    <span class="kw">while</span> (i.hasNext()) {
        i.next();
        <span class="ot">QListWidgetItem</span> *item = <span class="kw">new</span> <span class="ot">QListWidgetItem</span>(i.value(),
                                                    listWidget);
        item-&gt;setIcon(iconForSymbol(i.value()));
        item-&gt;setData(<span class="ot">Qt::</span>UserRole, i.key());
    }

    buttonBox = <span class="kw">new</span> <span class="ot">QDialogButtonBox</span>(<span class="ot">QDialogButtonBox::</span>Ok
                                     | <span class="ot">QDialogButtonBox::</span>Cancel);

    <span class="co">// plug-in slots</span>
    <span class="fu">connect</span>(buttonBox, <span class="kw">SIGNAL</span>(accepted()), <span class="kw">this</span>, <span class="kw">SLOT</span>(accept()));
    <span class="fu">connect</span>(buttonBox, <span class="kw">SIGNAL</span>(rejected()), <span class="kw">this</span>, <span class="kw">SLOT</span>(reject()));

    <span class="ot">QVBoxLayout</span> *mainLayout = <span class="kw">new</span> <span class="ot">QVBoxLayout</span>;
    mainLayout-&gt;addWidget(listWidget);
    mainLayout-&gt;addWidget(buttonBox);
    setLayout(mainLayout);

    setWindowTitle(<span class="fu">tr</span>(<span class="st">&quot;Flowchart Symbol Picker&quot;</span>));
}

<span class="dt">void</span> FlowChartSymbolPicker::done(<span class="dt">int</span> result)
{
    id = <span class="dv">-1</span>;
    <span class="kw">if</span> (result == <span class="ot">QDialog::</span>Accepted) {
        <span class="ot">QListWidgetItem</span> *item = listWidget-&gt;currentItem();
        <span class="kw">if</span> (item)
            <span class="co">// If we were interested in the item&#39;s text, we could retrieve it</span>
            <span class="co">// by calling item-&gt;data(Qt::DisplayRole).toString() or, more</span>
            <span class="co">// conveniently, item-&gt;text()</span>
            id = item-&gt;data(<span class="ot">Qt::</span>UserRole).toInt();
    }
    <span class="ot">QDialog::</span>done(result);
}

<span class="ot">QIcon</span> FlowChartSymbolPicker::iconForSymbol(<span class="dt">const</span> <span class="ot">QString</span> &amp;symbolName)
{
    <span class="ot">QString</span> fileName = <span class="st">&quot;:/images/&quot;</span> + symbolName.toLower();
    fileName.replace(<span class="st">&#39; &#39;</span>, <span class="st">&#39;-&#39;</span>);
    <span class="kw">return</span> <span class="ot">QIcon</span>(fileName);
}</code></pre></div>
<dl>
<dt><code class="sourceCode cpp"><span class="kw">enum</span> <span class="ot">Qt::</span>ItemDataRole</code></dt>
<dd><p>The <strong>general purpose roles</strong> (and the associated types) are:</p>
<table style="width:38%;">
<colgroup>
<col width="12%" />
<col width="8%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th>Constant</th>
<th align="center">Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>DisplayRole</code></td>
<td align="center">0</td>
<td>The key data to be rendered in the form of text. (<code class="sourceCode cpp"><span class="ot">QString</span></code>)</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>DecorationRole</code></td>
<td align="center">1</td>
<td>The data to be rendered as a decoration in the form of an icon. (<code class="sourceCode cpp"><span class="ot">QColor</span></code>, <code class="sourceCode cpp"><span class="ot">QIcon</span></code> or <code class="sourceCode cpp"><span class="ot">QPixmap</span></code>)</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>EditRole</code></td>
<td align="center">2</td>
<td>The data in a form suitable for editing in an editor. (<code class="sourceCode cpp"><span class="ot">QString</span></code>)</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>ToolTipRole</code></td>
<td align="center">3</td>
<td>The data displayed in the item&#8217;s tooltip. (<code class="sourceCode cpp"><span class="ot">QString</span></code>)</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>StatusTipRole</code></td>
<td align="center">4</td>
<td>The data displayed in the status bar. (<code class="sourceCode cpp"><span class="ot">QString</span></code>)</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>WhatsThisRole</code></td>
<td align="center">5</td>
<td>The data displayed for the item in &#8220;What&#8217;s This?&#8221; mode. (<code class="sourceCode cpp"><span class="ot">QString</span></code>)</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>SizeHintRole</code></td>
<td align="center">13</td>
<td>The size hint for the item that will be supplied to views. (<code class="sourceCode cpp"><span class="ot">QSize</span></code>)</td>
</tr>
</tbody>
</table>
<p>Roles describing <strong>appearance and meta data</strong> (with associated types):</p>
<table style="width:38%;">
<colgroup>
<col width="12%" />
<col width="8%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th>Constant</th>
<th align="center">Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>FontRole</code></td>
<td align="center">6</td>
<td>The font used for items rendered with the default delegate. (<code class="sourceCode cpp"><span class="ot">QFont</span></code>)</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>TextAlignmentRole</code></td>
<td align="center">7</td>
<td>The alignment of the text for items rendered with the default delegate. (<code class="sourceCode cpp"><span class="ot">Qt::</span>AlignmentFlag</code>)</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>BackgroundRole</code></td>
<td align="center">8</td>
<td>The background brush used for items rendered with the default delegate. (<code class="sourceCode cpp"><span class="ot">QBrush</span></code>)</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>BackgroundColorRole</code></td>
<td align="center">8</td>
<td>This role is obsolete. Use BackgroundRole instead.</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>ForegroundRole</code></td>
<td align="center">9</td>
<td>The foreground brush (text color, typically) used for items rendered with the default delegate. (<code class="sourceCode cpp"><span class="ot">QBrush</span></code>)</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>TextColorRole</code></td>
<td align="center">9</td>
<td>This role is obsolete. Use ForegroundRole instead.</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>CheckStateRole</code></td>
<td align="center">10</td>
<td>This role is used to obtain the checked state of an item. (<code class="sourceCode cpp"><span class="ot">Qt::</span>CheckState</code>)</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>InitialSortOrderRole</code></td>
<td align="center">14</td>
<td>This role is used to obtain the initial sort order of a header view section. (<code class="sourceCode cpp"><span class="ot">Qt::</span>SortOrder</code>). This role was introduced in Qt 4.8.</td>
</tr>
</tbody>
</table>
<p><strong>Accessibility roles</strong> (with associated types):</p>
<table style="width:38%;">
<colgroup>
<col width="12%" />
<col width="8%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th>Constant</th>
<th align="center">Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>AccessibleTextRole</code></td>
<td align="center">11</td>
<td>The text to be used by accessibility extensions and plugins, such as screen readers. (<code class="sourceCode cpp"><span class="ot">QString</span></code>)</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>AccessibleDescriptionRole</code></td>
<td align="center">12</td>
<td>A description of the item for accessibility purposes. (<code class="sourceCode cpp"><span class="ot">QString</span></code>)</td>
</tr>
</tbody>
</table>
<p><strong>User roles</strong>:</p>
<table style="width:38%;">
<colgroup>
<col width="12%" />
<col width="8%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th>Constant</th>
<th align="center">Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="ot">Qt::</span>UserRole</code></td>
<td align="center">32</td>
<td>The first role that can be used for application-specific purposes.</td>
</tr>
</tbody>
</table>
<p>For user roles, it is up to the developer to decide which types to use and ensure that components use the correct types when accessing and setting data.</p>
<p>&#20063;&#23601;&#26159;&#35828;&#33258;&#24049;&#30340;&#25968;&#25454;&#21487;&#20197;&#24448;&#36825;&#20799;&#23384;&#65281;</p>
</dd>
</dl>
<p>By default, <code class="sourceCode cpp"><span class="ot">QListWidget</span></code> is read-only. If we wanted the user to edit the items, we could set the view&#8217;s edit triggers using <code class="sourceCode cpp"><span class="ot">QAbstractItemView::</span>setEditTriggers()</code>; for example, a setting of <code class="sourceCode cpp"><span class="ot">QAbstractItemView::</span>AnyKeyPressed</code> means that the user can begin editing an item just by starting to type. Alternatively, we could provide an <kbd>Edit</kbd> button (and perhaps Add and Delete buttons) and use signal&#8211;slot connections so that we can handle the editing operations programmatically.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tableWidget = <span class="kw">new</span> <span class="ot">QTableWidget</span>(<span class="dv">0</span>, <span class="dv">2</span>);
tableWidget-&gt;setHorizontalHeaderLabels(
        <span class="ot">QStringList</span>() &lt;&lt; <span class="fu">tr</span>(<span class="st">&quot;X&quot;</span>) &lt;&lt; <span class="fu">tr</span>(<span class="st">&quot;Y&quot;</span>));

<span class="kw">for</span> (<span class="dt">int</span> row = <span class="dv">0</span>; row &lt; coordinates-&gt;count(); ++row) {
    <span class="ot">QPointF</span> point = coordinates-&gt;at(row);
    addRow();
    tableWidget-&gt;item(row, <span class="dv">0</span>)-&gt;setText(<span class="ot">QString::</span>number(point.x()));
    tableWidget-&gt;item(row, <span class="dv">1</span>)-&gt;setText(<span class="ot">QString::</span>number(point.y()));
}

<span class="dt">void</span> SettingsViewer::readSettings()
{
    <span class="ot">QSettings</span> settings(organization, application);

    treeWidget-&gt;clear();
    addChildSettings(settings, <span class="dv">0</span>, <span class="st">&quot;&quot;</span>);

    treeWidget-&gt;sortByColumn(<span class="dv">0</span>);
    treeWidget-&gt;setFocus();
    setWindowTitle(<span class="fu">tr</span>(<span class="st">&quot;Settings Viewer - %1 by %2&quot;</span>)
                   .arg(application).arg(organization));
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">treeWidget = <span class="kw">new</span> <span class="ot">QTreeWidget</span>;
treeWidget-&gt;setColumnCount(<span class="dv">2</span>);
treeWidget-&gt;setHeaderLabels(
        <span class="ot">QStringList</span>() &lt;&lt; <span class="fu">tr</span>(<span class="st">&quot;Key&quot;</span>) &lt;&lt; <span class="fu">tr</span>(<span class="st">&quot;Value&quot;</span>));
<span class="co">// enum ResizeMode { Interactive, Fixed, Stretch, ResizeToContents, Custom }</span>
<span class="co">// void QHeaderView::setResizeMode(int logicalIndex, ResizeMode mode)</span>
<span class="co">// This setting will be ignored for the last section if the stretchLastSection</span>
<span class="co">// property is set to true. This is the default for the horizontal headers</span>
<span class="co">// provided by QTreeView.</span>
treeWidget-&gt;header()-&gt;setResizeMode(<span class="dv">0</span>, <span class="ot">QHeaderView::</span>Stretch);
treeWidget-&gt;header()-&gt;setResizeMode(<span class="dv">1</span>, <span class="ot">QHeaderView::</span>Stretch);</code></pre></div>
<h4 id="using-predefined-models">Using Predefined Models</h4>
<table>
<thead>
<tr class="header">
<th align="left">Model</th>
<th align="left">Details</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code class="sourceCode cpp"><span class="ot">QStringListModel</span></code></td>
<td align="left">Stores a list of strings</td>
</tr>
<tr class="even">
<td align="left"><code class="sourceCode cpp"><span class="ot">QStandardItemModel</span></code></td>
<td align="left">Stores arbitrary hierarchical data</td>
</tr>
<tr class="odd">
<td align="left"><code class="sourceCode cpp">QDirModel</code></td>
<td align="left">Encapsulates the local file system</td>
</tr>
<tr class="even">
<td align="left"><code class="sourceCode cpp"><span class="ot">QSqlQueryModel</span></code></td>
<td align="left">Encapsulates an SQL result set</td>
</tr>
<tr class="odd">
<td align="left"><code class="sourceCode cpp"><span class="ot">QSqlTableModel</span></code></td>
<td align="left">Encapsulates an SQL table</td>
</tr>
<tr class="even">
<td align="left"><code class="sourceCode cpp"><span class="ot">QSqlRelationalTableModel</span></code></td>
<td align="left">Encapsulates an SQL table with foreign keys</td>
</tr>
<tr class="odd">
<td align="left"><code class="sourceCode cpp"><span class="ot">QSortFilterProxyModel</span></code></td>
<td align="left">Sorts and/or filters another model</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> TeamLeadersDialog::insert()
{
    <span class="dt">int</span> row = listView-&gt;currentIndex().row();
    model-&gt;insertRows(row, <span class="dv">1</span>);

    <span class="ot">QModelIndex</span> index = model-&gt;index(row);
    listView-&gt;setCurrentIndex(index);
    listView-&gt;edit(index);
}</code></pre></div>
<dl>
<dt><code class="sourceCode cpp"><span class="ot">QAbstractItemModel::</span>insertRows()</code></dt>
<dd><p>Note: The base class implementation of this function does nothing and returns false.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> <span class="ot">QAbstractItemModel::</span>insertRows(<span class="dt">int</span> row,
                                    <span class="dt">int</span> count,
                                    <span class="dt">const</span> <span class="ot">QModelIndex</span> &amp; parent
                                            = <span class="ot">QModelIndex</span>())</code></pre></div>
<p>On models that support this, inserts count rows into the model before the given row. Items in the new row will be children of the item represented by the parent model index.</p>
<p>If row is 0, the rows are prepended to any existing rows in the parent.</p>
<p>If row is <code class="sourceCode cpp">rowCount()</code>, the rows are appended to any existing rows in the parent.</p>
<p>If parent has no children, a single column with count rows is inserted.</p>
<p>Returns true if the rows were successfully inserted; otherwise returns false.</p>
<p>If you implement your own model, you can reimplement this function if you want to support insertions. Alternatively, you can provide your own API for altering the data. In either case, you will need to call <code class="sourceCode cpp">beginInsertRows()</code> and <code class="sourceCode cpp">endInsertRows()</code> to notify other components that the model has changed.</p>
</dd>
</dl>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> TeamLeadersDialog::del()
{
    model-&gt;removeRows(listView-&gt;currentIndex().row(), <span class="dv">1</span>);
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">DirectoryViewer::DirectoryViewer(<span class="ot">QWidget</span> *parent)
    : <span class="ot">QDialog</span>(parent)
{
    model = <span class="kw">new</span> QDirModel;
    model-&gt;setReadOnly(<span class="kw">false</span>);
    model-&gt;setSorting(<span class="ot">QDir::</span>DirsFirst | <span class="ot">QDir::</span>IgnoreCase | <span class="ot">QDir::</span>Name);

    treeView = <span class="kw">new</span> <span class="ot">QTreeView</span>;
    treeView-&gt;setModel(model);
    treeView-&gt;header()-&gt;setStretchLastSection(<span class="kw">true</span>);
    treeView-&gt;header()-&gt;setSortIndicator(<span class="dv">0</span>, <span class="ot">Qt::</span>AscendingOrder);
    treeView-&gt;header()-&gt;setSortIndicatorShown(<span class="kw">true</span>);
    treeView-&gt;header()-&gt;setClickable(<span class="kw">true</span>);

    <span class="ot">QModelIndex</span> index = model-&gt;index(<span class="ot">QDir::</span>currentPath());
    treeView-&gt;expand(index);
    treeView-&gt;scrollTo(index);
    treeView-&gt;resizeColumnToContents(<span class="dv">0</span>);

    ...
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">buttonBox = <span class="kw">new</span> <span class="ot">QDialogButtonBox</span>(<span class="ot">Qt::</span>Horizontal);
<span class="ot">QPushButton</span> *mkdirButton = buttonBox-&gt;addButton(
        <span class="fu">tr</span>(<span class="st">&quot;&amp;Create Directory...&quot;</span>), <span class="ot">QDialogButtonBox::</span>ActionRole);
<span class="ot">QPushButton</span> *removeButton = buttonBox-&gt;addButton(<span class="fu">tr</span>(<span class="st">&quot;&amp;Remove&quot;</span>),
        <span class="ot">QDialogButtonBox::</span>ActionRole);
buttonBox-&gt;addButton(<span class="fu">tr</span>(<span class="st">&quot;&amp;Quit&quot;</span>), <span class="ot">QDialogButtonBox::</span>AcceptRole);

<span class="fu">connect</span>(mkdirButton, <span class="kw">SIGNAL</span>(clicked()), <span class="kw">this</span>, <span class="kw">SLOT</span>(createDirectory()));
<span class="fu">connect</span>(removeButton, <span class="kw">SIGNAL</span>(clicked()), <span class="kw">this</span>, <span class="kw">SLOT</span>(remove()));
<span class="fu">connect</span>(buttonBox, <span class="kw">SIGNAL</span>(accepted()), <span class="kw">this</span>, <span class="kw">SLOT</span>(accept()));</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> DirectoryViewer::createDirectory()
{
    <span class="ot">QModelIndex</span> index = treeView-&gt;currentIndex();
    <span class="kw">if</span> (!index.isValid())
        <span class="kw">return</span>;

    <span class="ot">QString</span> dirName = <span class="ot">QInputDialog::</span>getText(<span class="kw">this</span>,
                              <span class="fu">tr</span>(<span class="st">&quot;Create Directory&quot;</span>),
                              <span class="fu">tr</span>(<span class="st">&quot;Directory name&quot;</span>));
    <span class="kw">if</span> (!dirName.isEmpty()) {
        <span class="co">// The QDirModel::mkdir() function takes the parent directory&#39;s index</span>
        <span class="co">// and the name of the new directory, and returns the model index of</span>
        <span class="co">// the directory it created. If the operation fails, it returns an</span>
        <span class="co">// invalid model index.</span>
        <span class="kw">if</span> (!model-&gt;mkdir(index, dirName).isValid())
            <span class="ot">QMessageBox::</span>information(<span class="kw">this</span>, <span class="fu">tr</span>(<span class="st">&quot;Create Directory&quot;</span>),
                    <span class="fu">tr</span>(<span class="st">&quot;Failed to create the directory&quot;</span>));
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> DirectoryViewer::remove()
{
    <span class="ot">QModelIndex</span> index = treeView-&gt;currentIndex();
    <span class="kw">if</span> (!index.isValid())
        <span class="kw">return</span>;

    <span class="dt">bool</span> ok;
    <span class="co">// We could use QDir to accomplish this, but QDirModel offers convenience</span>
    <span class="co">// functions that work on QModelIndexes.</span>
    <span class="kw">if</span> (model-&gt;fileInfo(index).isDir()) {
        ok = model-&gt;rmdir(index);
    } <span class="kw">else</span> {
        ok = model-&gt;remove(index);
    }
    <span class="kw">if</span> (!ok)
        <span class="ot">QMessageBox::</span>information(<span class="kw">this</span>, <span class="fu">tr</span>(<span class="st">&quot;Remove&quot;</span>),
                <span class="fu">tr</span>(<span class="st">&quot;Failed to remove %1&quot;</span>).arg(model-&gt;fileName(index)));
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">sourceModel = <span class="kw">new</span> <span class="ot">QStringListModel</span>(<span class="kw">this</span>);
sourceModel-&gt;setStringList(<span class="ot">QColor::</span>colorNames());

proxyModel = <span class="kw">new</span> <span class="ot">QSortFilterProxyModel</span>(<span class="kw">this</span>);
proxyModel-&gt;setSourceModel(sourceModel);
proxyModel-&gt;setFilterKeyColumn(<span class="dv">0</span>);

listView = <span class="kw">new</span> <span class="ot">QListView</span>;
listView-&gt;setModel(proxyModel);
listView-&gt;setEditTriggers(<span class="ot">QAbstractItemView::</span>NoEditTriggers);

filterLabel = <span class="kw">new</span> <span class="ot">QLabel</span>(<span class="fu">tr</span>(<span class="st">&quot;&amp;Filter:&quot;</span>));
filterLineEdit = <span class="kw">new</span> <span class="ot">QLineEdit</span>;
filterLabel-&gt;setBuddy(filterLineEdit);

syntaxLabel = <span class="kw">new</span> <span class="ot">QLabel</span>(<span class="fu">tr</span>(<span class="st">&quot;&amp;Pattern syntax:&quot;</span>));
syntaxComboBox = <span class="kw">new</span> <span class="ot">QComboBox</span>;
syntaxComboBox-&gt;addItem(<span class="fu">tr</span>(<span class="st">&quot;Regular expression&quot;</span>), <span class="ot">QRegExp::</span>RegExp);
syntaxComboBox-&gt;addItem(<span class="fu">tr</span>(<span class="st">&quot;Wildcard&quot;</span>), <span class="ot">QRegExp::</span>Wildcard);
syntaxComboBox-&gt;addItem(<span class="fu">tr</span>(<span class="st">&quot;Fixed string&quot;</span>), <span class="ot">QRegExp::</span>FixedString);
syntaxLabel-&gt;setBuddy(syntaxComboBox);

<span class="fu">connect</span>(filterLineEdit, <span class="kw">SIGNAL</span>(textChanged(<span class="dt">const</span> <span class="ot">QString</span> &amp;)),
        <span class="kw">this</span>, <span class="kw">SLOT</span>(reapplyFilter()));
<span class="fu">connect</span>(syntaxComboBox, <span class="kw">SIGNAL</span>(currentIndexChanged(<span class="dt">int</span>)),
        <span class="kw">this</span>, <span class="kw">SLOT</span>(reapplyFilter()));

<span class="ot">QGridLayout</span> *mainLayout = <span class="kw">new</span> <span class="ot">QGridLayout</span>;
mainLayout-&gt;addWidget(listView, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>);
mainLayout-&gt;addWidget(filterLabel, <span class="dv">1</span>, <span class="dv">0</span>);
mainLayout-&gt;addWidget(filterLineEdit, <span class="dv">1</span>, <span class="dv">1</span>);
mainLayout-&gt;addWidget(syntaxLabel, <span class="dv">2</span>, <span class="dv">0</span>);
mainLayout-&gt;addWidget(syntaxComboBox, <span class="dv">2</span>, <span class="dv">1</span>);
setLayout(mainLayout);</code></pre></div>
<dl>
<dt><code class="sourceCode cpp"><span class="ot">QComboBox::</span>addItem()</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> <span class="ot">QComboBox::</span>addItem(<span class="dt">const</span> <span class="ot">QString</span> &amp; text, <span class="dt">const</span> <span class="ot">QVariant</span> &amp; userData = <span class="ot">QVariant</span>())
<span class="dt">void</span> <span class="ot">QComboBox::</span>addItem(<span class="dt">const</span> <span class="ot">QIcon</span> &amp; icon, <span class="dt">const</span> <span class="ot">QString</span> &amp; text, <span class="dt">const</span> <span class="ot">QVariant</span> &amp; userData = <span class="ot">QVariant</span>())
<span class="dt">void</span> <span class="ot">QComboBox::</span>addItems(<span class="dt">const</span> <span class="ot">QStringList</span> &amp; texts)</code></pre></div>
</dd>
</dl>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ColorNamesDialog::reapplyFilter()
{
    <span class="ot">QRegExp::</span>PatternSyntax syntax =
            <span class="ot">QRegExp::</span>PatternSyntax(syntaxComboBox-&gt;itemData(
                    syntaxComboBox-&gt;currentIndex()).toInt());
    <span class="ot">QRegExp</span> regExp(filterLineEdit-&gt;text(), <span class="ot">Qt::</span>CaseInsensitive, syntax);
    proxyModel-&gt;setFilterRegExp(regExp);
}</code></pre></div>
<h4 id="implementing-custom-models">Implementing Custom Models</h4>
<div class="figure">
<img src="http://gnat.qiniudn.com/qt/custom-model.png" alt="Custom model" />
<p class="caption">Custom model</p>
</div>
<ul>
<li><code class="sourceCode cpp"><span class="ot">QObject</span></code>
<ul>
<li><code class="sourceCode cpp"><span class="ot">QAbstractItemModel</span></code>
<ul>
<li><code class="sourceCode cpp"><span class="ot">QAbstractListModel</span></code></li>
<li><code class="sourceCode cpp"><span class="ot">QAbstractTableModel</span></code></li>
</ul></li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QMap</span>&lt;<span class="ot">QString</span>, <span class="dt">double</span>&gt; currencyMap;
currencyMap.insert(<span class="st">&quot;AUD&quot;</span>, <span class="fl">1.3259</span>);
currencyMap.insert(<span class="st">&quot;CHF&quot;</span>, <span class="fl">1.2970</span>);
...
currencyMap.insert(<span class="st">&quot;SGD&quot;</span>, <span class="fl">1.6901</span>);
currencyMap.insert(<span class="st">&quot;USD&quot;</span>, <span class="fl">1.0000</span>);
CurrencyModel currencyModel;
currencyModel.setCurrencyMap(currencyMap);
<span class="ot">QTableView</span> tableView;
tableView.setModel(&amp;currencyModel);
tableView.setAlternatingRowColors(<span class="kw">true</span>);</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;QAbstractTableModel&gt;</span>
<span class="ot">#include &lt;QMap&gt;</span>

<span class="co">// We have chosen to subclass QAbstractTableModel for our model since that most</span>
<span class="co">// closely matches our data source.</span>
<span class="kw">class</span> CurrencyModel : <span class="kw">public</span> <span class="ot">QAbstractTableModel</span>
{
<span class="kw">public</span>:
    CurrencyModel(<span class="ot">QObject</span> *parent = <span class="dv">0</span>);

    <span class="co">// For a read-only table model, we must reimplement three functions:</span>
    <span class="co">// rowCount(), columnCount(), and data().  In this case, we have also</span>
    <span class="co">// reimplemented headerData(), and we provide a function to initialize the</span>
    <span class="co">// data (setCurrencyMap()).</span>
    <span class="dt">void</span> setCurrencyMap(<span class="dt">const</span> <span class="ot">QMap</span>&lt;<span class="ot">QString</span>, <span class="dt">double</span>&gt; &amp;map);
    <span class="dt">int</span> rowCount(<span class="dt">const</span> <span class="ot">QModelIndex</span> &amp;parent) <span class="dt">const</span>;
    <span class="dt">int</span> columnCount(<span class="dt">const</span> <span class="ot">QModelIndex</span> &amp;parent) <span class="dt">const</span>;
    <span class="ot">QVariant</span> data(<span class="dt">const</span> <span class="ot">QModelIndex</span> &amp;index, <span class="dt">int</span> role) <span class="dt">const</span>;
    <span class="ot">QVariant</span> headerData(<span class="dt">int</span> section, <span class="ot">Qt::</span>Orientation orientation,
                        <span class="dt">int</span> role) <span class="dt">const</span>;

<span class="kw">private</span>:
    <span class="ot">QString</span> currencyAt(<span class="dt">int</span> offset) <span class="dt">const</span>;
    <span class="ot">QMap</span>&lt;<span class="ot">QString</span>, <span class="dt">double</span>&gt; currencyMap;
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// The parent parameter has no meaning for a table model; it is there because</span>
<span class="co">// rowCount() and columnCount() are inherited from the more generic</span>
<span class="co">// QAbstractItemModel base class, which supports hierarchies.</span>
<span class="dt">int</span> CurrencyModel::rowCount(<span class="dt">const</span> <span class="ot">QModelIndex</span> &amp; <span class="co">/* parent */</span>) <span class="dt">const</span>
{
    <span class="kw">return</span> currencyMap.count();
}

<span class="dt">int</span> CurrencyModel::columnCount(<span class="dt">const</span> <span class="ot">QModelIndex</span> &amp; <span class="co">/* parent */</span>) <span class="dt">const</span>
{
    <span class="kw">return</span> currencyMap.count();
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QVariant</span> CurrencyModel::data(<span class="dt">const</span> <span class="ot">QModelIndex</span> &amp;index, <span class="dt">int</span> role) <span class="dt">const</span>
{
    <span class="kw">if</span> (!index.isValid())
        <span class="kw">return</span> <span class="ot">QVariant</span>();

    <span class="co">// Qt::TextAlignmentRole, we return an alignment suitable for numbers</span>
    <span class="kw">if</span> (role == <span class="ot">Qt::</span>TextAlignmentRole) {
        <span class="kw">return</span> <span class="dt">int</span>(<span class="ot">Qt::</span>AlignRight | <span class="ot">Qt::</span>AlignVCenter);
    } <span class="kw">else</span> <span class="kw">if</span> (role == <span class="ot">Qt::</span>DisplayRole) {
        <span class="ot">QString</span> rowCurrency = currencyAt(index.row());
        <span class="ot">QString</span> columnCurrency = currencyAt(index.column());

        <span class="kw">if</span> (currencyMap.value(rowCurrency) == <span class="fl">0.0</span>)
            <span class="kw">return</span> <span class="st">&quot;####&quot;</span>;

        <span class="dt">double</span> amount = currencyMap.value(columnCurrency)
                        / currencyMap.value(rowCurrency);

        <span class="kw">return</span> <span class="ot">QString</span>(<span class="st">&quot;%1&quot;</span>).arg(amount, <span class="dv">0</span>, <span class="st">&#39;f&#39;</span>, <span class="dv">4</span>);
    }
    <span class="kw">return</span> <span class="ot">QVariant</span>();
}</code></pre></div>
<dl>
<dt><code class="sourceCode cpp"><span class="ot">QString::</span>arg()</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QString</span> <span class="ot">QString::</span>arg(<span class="dt">const</span> <span class="ot">QString</span> &amp; a,
                     <span class="dt">int</span> fieldWidth = <span class="dv">0</span>,
                     <span class="dt">const</span> <span class="ot">QChar</span> &amp; fillChar = <span class="ot">QLatin1Char</span>( <span class="st">&#39; &#39;</span> )) <span class="dt">const</span></code></pre></div>
<ul>
<li>A positive fieldWidth produces <strong>right-aligned</strong> text. A negative fieldWidth produces <strong>left-aligned</strong> text.</li>
<li><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QString</span> i;           <span class="co">// current file&#39;s number</span>
<span class="ot">QString</span> total;       <span class="co">// number of files to process</span>
<span class="ot">QString</span> fileName;    <span class="co">// current file&#39;s name</span>

<span class="ot">QString</span> status = <span class="ot">QString</span>(<span class="st">&quot;Processing file %1 of %2: %3&quot;</span>)
                .arg(i).arg(total).arg(fileName);</code></pre></div></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QString</span> <span class="ot">QString::</span>arg(<span class="dt">const</span> <span class="ot">QString</span> &amp; a1,
                     <span class="dt">const</span> <span class="ot">QString</span> &amp; a2) <span class="dt">const</span></code></pre></div>
<ul>
<li>This function overloads <code class="sourceCode cpp">arg()</code>.</li>
<li><p>This is the same as <code class="sourceCode cpp">str.arg(a1).arg(a2)</code>, except that the strings a1 and a2 are replaced in one pass. This can make a difference if a1 contains e.g. <code>%1</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QString</span> str;
str = <span class="st">&quot;%1 %2&quot;</span>;

str.arg(<span class="st">&quot;</span><span class="ch">%1f</span><span class="st">&quot;</span>, <span class="st">&quot;Hello&quot;</span>);        <span class="co">// returns &quot;%1f Hello&quot;</span>
str.arg(<span class="st">&quot;</span><span class="ch">%1f</span><span class="st">&quot;</span>).arg(<span class="st">&quot;Hello&quot;</span>);    <span class="co">// returns &quot;Hellof %2&quot;</span></code></pre></div></li>
<li><p>similarities</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QString</span> <span class="ot">QString::</span>arg(<span class="dt">const</span> <span class="ot">QString</span> &amp; a1,
                     <span class="dt">const</span> <span class="ot">QString</span> &amp; a2,
                     <span class="dt">const</span> <span class="ot">QString</span> &amp; a3) <span class="dt">const</span>
<span class="ot">QString</span> <span class="ot">QString::</span>arg(<span class="dt">const</span> <span class="ot">QString</span> &amp; a1,
                     <span class="dt">const</span> <span class="ot">QString</span> &amp; a2,
                     <span class="dt">const</span> <span class="ot">QString</span> &amp; a3,
                     <span class="dt">const</span> <span class="ot">QString</span> &amp; a4) <span class="dt">const</span>
a1..a5
a1..a6
...
a1..a9</code></pre></div></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QString</span> <span class="ot">QString::</span>arg({[u]<span class="dt">short</span>,[u]<span class="dt">int</span>,[u]<span class="dt">long</span>,q[u]longlong} a,
                      <span class="dt">int</span> fieldWidth = <span class="dv">0</span>,
                      <span class="dt">int</span> base = <span class="dv">10</span>,
                      <span class="dt">const</span> <span class="ot">QChar</span> &amp; fillChar = <span class="ot">QLatin1Char</span>( <span class="st">&#39; &#39;</span> )) <span class="dt">const</span></code></pre></div>
<ul>
<li><p>The <code>%</code> can be followed by an <code>L</code>, in which case the sequence is replaced with a localized representation of <code>a</code>. The conversion uses the default locale, set by <code class="sourceCode cpp"><span class="ot">QLocale::</span>setDefault()</code>. If no default locale was specified, the <code>C</code> locale is used. The <code>L</code> flag is ignored if base is not 10.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QString</span> str;
str = <span class="ot">QString</span>(<span class="st">&quot;Decimal 63 is %1 in hexadecimal&quot;</span>)
        .arg(<span class="dv">63</span>, <span class="dv">0</span>, <span class="dv">16</span>);
<span class="co">// str == &quot;Decimal 63 is 3f in hexadecimal&quot;</span>

<span class="ot">QLocale::</span>setDefault(<span class="ot">QLocale</span>(<span class="ot">QLocale::</span>English, <span class="ot">QLocale::</span>UnitedStates));
str = <span class="ot">QString</span>(<span class="st">&quot;%1 %L2 %L3&quot;</span>)
        .arg(<span class="dv">12345</span>)
        .arg(<span class="dv">12345</span>)
        .arg(<span class="dv">12345</span>, <span class="dv">0</span>, <span class="dv">16</span>);
<span class="co">// str == &quot;12345 12,345 3039&quot;</span></code></pre></div></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QString</span> <span class="ot">QString::</span>arg({<span class="ot">QChar</span>,<span class="dt">char</span>} a,
                     <span class="dt">int</span> fieldWidth = <span class="dv">0</span>,
                     <span class="dt">const</span> <span class="ot">QChar</span> &amp; fillChar = <span class="ot">QLatin1Char</span>( <span class="st">&#39; &#39;</span> )) <span class="dt">const</span></code></pre></div>
<ul>
<li>This function overloads <code class="sourceCode cpp">arg()</code>.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QString</span> <span class="ot">QString::</span>arg(<span class="dt">double</span> a,
                     <span class="dt">int</span> fieldWidth = <span class="dv">0</span>,
                     <span class="dt">char</span> format = <span class="st">&#39;g&#39;</span>,
                     <span class="dt">int</span> precision = <span class="dv">-1</span>,
                     <span class="dt">const</span> <span class="ot">QChar</span> &amp; fillChar = <span class="ot">QLatin1Char</span>( <span class="st">&#39; &#39;</span> )) <span class="dt">const</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="center">Format</th>
<th align="center">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">e</td>
<td align="center">format as [-]9.9e[+</td>
</tr>
<tr class="even">
<td align="center">E</td>
<td align="center">format as [-]9.9E[+</td>
</tr>
<tr class="odd">
<td align="center">f</td>
<td align="center">format as [-]9.9</td>
</tr>
<tr class="even">
<td align="center">g</td>
<td align="center">use e or f format, whichever is the most concise</td>
</tr>
<tr class="odd">
<td align="center">G</td>
<td align="center">use E or f format, whichever is the most concise</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> d = <span class="fl">12.34</span>;
<span class="ot">QString</span> str = <span class="ot">QString</span>(<span class="st">&quot;delta: %1&quot;</span>).arg(d, <span class="dv">0</span>, <span class="st">&#39;E&#39;</span>, <span class="dv">3</span>);
<span class="co">// str == &quot;delta: 1.234E+01&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;QStringBuilder&gt;</span>

<span class="ot">QString</span> hello(<span class="st">&quot;hello&quot;</span>);
<span class="ot">QStringRef</span> el(&amp;hello, <span class="dv">2</span>, <span class="dv">3</span>);
<span class="ot">QLatin1String</span> world(<span class="st">&quot;world&quot;</span>);
<span class="ot">QString</span> message =  hello % el % world % <span class="ot">QChar</span>(<span class="st">&#39;!&#39;</span>);</code></pre></div>
</dd>
</dl>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// The headerData() function is called by the view to populate its horizontal</span>
<span class="co">// and vertical headers. The section parameter is the row or column number</span>
<span class="co">// (depending on the orientation). Since the rows and columns have the same</span>
<span class="co">// currency codes, we do not care about the orientation and simply return the</span>
<span class="co">// code of the currency for the given section number.</span>
<span class="ot">QVariant</span> CurrencyModel::headerData(<span class="dt">int</span> section,
                                   <span class="ot">Qt::</span>Orientation <span class="co">/* orientation */</span>,
                                   <span class="dt">int</span> role) <span class="dt">const</span>
{
    <span class="kw">if</span> (role != <span class="ot">Qt::</span>DisplayRole)
        <span class="kw">return</span> <span class="ot">QVariant</span>();
    <span class="kw">return</span> currencyAt(section);
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> CurrencyModel::setCurrencyMap(<span class="dt">const</span> <span class="ot">QMap</span>&lt;<span class="ot">QString</span>, <span class="dt">double</span>&gt; &amp;map)
{
    currencyMap = map;
    <span class="co">// tells any views that are using the model that all their data is invalid;</span>
    <span class="co">// this forces them to request fresh data for the items that are visible</span>
    reset();
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QString</span> CurrencyModel::currencyAt(<span class="dt">int</span> offset) <span class="dt">const</span>
{
    <span class="kw">return</span> (currencyMap.begin() + offset).key();
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> CityModel::offsetOf(<span class="dt">int</span> row, <span class="dt">int</span> column) <span class="dt">const</span>
{
    <span class="kw">if</span> (row &lt; column)
        <span class="fu">qSwap</span>(row, column);
    <span class="kw">return</span> (row * (row - <span class="dv">1</span>) / <span class="dv">2</span>) + column;
}</code></pre></div>
<h4 id="implementing-custom-delegates">Implementing Custom Delegates</h4>
<p>If we want to have finer control over the rendering of items, we can often achieve what we want simply by using a custom model: In our <code class="sourceCode cpp">data()</code> reimplementation, we can handle the <code class="sourceCode cpp"><span class="ot">Qt::</span>FontRole</code>, <code class="sourceCode cpp"><span class="ot">Qt::</span>TextAlignmentRole</code>, <code class="sourceCode cpp"><span class="ot">Qt::</span>TextColorRole</code>, and <code class="sourceCode cpp"><span class="ot">Qt::</span>BackgroundColorRole</code>, and these are used by the default delegate. For example, in the Cities and Currencies examples shown earlier, we handled the <code class="sourceCode cpp"><span class="ot">Qt::</span>TextAlignmentRole</code> to get right-aligned numbers.</p>
<p>If we want even greater control, we can create our own delegate class and set it on the views that we want to make use of it. The Track Editor dialog shown in Figure 10.15 makes use of a custom delegate. It shows the titles of music tracks and their durations. The data held by the model will be simply <code class="sourceCode cpp">QStrings</code> (titles) and ints (seconds), but the durations will be separated into minutes and seconds and will be editable using a <code class="sourceCode cpp"><span class="ot">QTimeEdit</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;QItemDelegate&gt;</span>

<span class="kw">class</span> TrackDelegate : <span class="kw">public</span> <span class="ot">QItemDelegate</span>
{
    <span class="kw">Q_OBJECT</span>

<span class="kw">public</span>:
    TrackDelegate(<span class="dt">int</span> durationColumn, <span class="ot">QObject</span> *parent = <span class="dv">0</span>);

    <span class="dt">void</span> paint(<span class="ot">QPainter</span> *painter, <span class="dt">const</span> <span class="ot">QStyleOptionViewItem</span> &amp;option,
               <span class="dt">const</span> <span class="ot">QModelIndex</span> &amp;index) <span class="dt">const</span>;
    <span class="ot">QWidget</span> *createEditor(<span class="ot">QWidget</span> *parent,
                          <span class="dt">const</span> <span class="ot">QStyleOptionViewItem</span> &amp;option,
                          <span class="dt">const</span> <span class="ot">QModelIndex</span> &amp;index) <span class="dt">const</span>;
    <span class="dt">void</span> setEditorData(<span class="ot">QWidget</span> *editor, <span class="dt">const</span> <span class="ot">QModelIndex</span> &amp;index) <span class="dt">const</span>;
    <span class="dt">void</span> setModelData(<span class="ot">QWidget</span> *editor, <span class="ot">QAbstractItemModel</span> *model,
                      <span class="dt">const</span> <span class="ot">QModelIndex</span> &amp;index) <span class="dt">const</span>;

<span class="kw">private</span> <span class="kw">slots</span>:
    <span class="dt">void</span> commitAndCloseEditor();

<span class="kw">private</span>:
    <span class="dt">int</span> durationColumn;
};

<span class="kw">class</span> Track
{
<span class="kw">public</span>:
    Track(<span class="dt">const</span> <span class="ot">QString</span> &amp;title = <span class="st">&quot;&quot;</span>, <span class="dt">int</span> duration = <span class="dv">0</span>);

    <span class="ot">QString</span> title;
    <span class="dt">int</span> duration;
};

<span class="kw">class</span> TrackEditor : <span class="kw">public</span> <span class="ot">QDialog</span>
{
    <span class="kw">Q_OBJECT</span>

<span class="kw">public</span>:
    TrackEditor(<span class="ot">QList</span>&lt;Track&gt; *tracks, <span class="ot">QWidget</span> *parent = <span class="dv">0</span>);

    <span class="dt">void</span> done(<span class="dt">int</span> result);

<span class="kw">private</span> <span class="kw">slots</span>:
    <span class="dt">void</span> addTrack();

<span class="kw">private</span>:
    <span class="ot">QTableWidget</span> *tableWidget;
    <span class="ot">QDialogButtonBox</span> *buttonBox;
    <span class="ot">QList</span>&lt;Track&gt; *tracks;
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tableWidget = <span class="kw">new</span> <span class="ot">QTableWidget</span>(tracks-&gt;count(), <span class="dv">2</span>);
tableWidget-&gt;setItemDelegate(<span class="kw">new</span> TrackDelegate(<span class="dv">1</span>));
tableWidget-&gt;setHorizontalHeaderLabels(
<span class="ot">QStringList</span>() &lt;&lt; <span class="fu">tr</span>(<span class="st">&quot;Track&quot;</span>) &lt;&lt; <span class="fu">tr</span>(<span class="st">&quot;Duration&quot;</span>));</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// hack!</span>
<span class="dt">void</span> TrackDelegate::paint(<span class="ot">QPainter</span> *painter,
                          <span class="dt">const</span> <span class="ot">QStyleOptionViewItem</span> &amp;option,
                          <span class="dt">const</span> <span class="ot">QModelIndex</span> &amp;index) <span class="dt">const</span>
{
    <span class="kw">if</span> (index.column() == durationColumn) {
        <span class="co">// index -&gt; model -&gt; row -&gt; data</span>
        <span class="dt">int</span> secs = index.model()-&gt;data(index, <span class="ot">Qt::</span>DisplayRole).toInt();
        <span class="ot">QString</span> text = <span class="ot">QString</span>(<span class="st">&quot;</span><span class="ch">%1:%</span><span class="st">2&quot;</span>)
                       .arg(secs / <span class="dv">60</span>, <span class="dv">2</span>, <span class="dv">10</span>, <span class="ot">QChar</span>(<span class="st">&#39;0&#39;</span>))
                       .arg(secs % <span class="dv">60</span>, <span class="dv">2</span>, <span class="dv">10</span>, <span class="ot">QChar</span>(<span class="st">&#39;0&#39;</span>));

        <span class="co">// copy the current style options and overwrite the default alignment</span>
        <span class="ot">QStyleOptionViewItem</span> myOption = option;
        myOption.displayAlignment = <span class="ot">Qt::</span>AlignRight | <span class="ot">Qt::</span>AlignVCenter;

        <span class="co">// QItemDelegate::drawDisplay() to draw the text</span>
        drawDisplay(painter, myOption, myOption.rect, text);
        <span class="co">// draw a focus rectangle if the item has focus and will do nothing</span>
        <span class="co">// otherwise</span>
        drawFocus(painter, myOption, myOption.rect);
    } <span class="kw">else</span>{
        <span class="ot">QItemDelegate::</span>paint(painter, option, index);
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QWidget</span> *TrackDelegate::createEditor(<span class="ot">QWidget</span> *parent,
        <span class="dt">const</span> <span class="ot">QStyleOptionViewItem</span> &amp;option,
        <span class="dt">const</span> <span class="ot">QModelIndex</span> &amp;index) <span class="dt">const</span>
{
    <span class="kw">if</span> (index.column() == durationColumn) {
        <span class="ot">QTimeEdit</span> *timeEdit = <span class="kw">new</span> <span class="ot">QTimeEdit</span>(parent);
        timeEdit-&gt;setDisplayFormat(<span class="st">&quot;mm:ss&quot;</span>);
        <span class="fu">connect</span>(timeEdit, <span class="kw">SIGNAL</span>(editingFinished()),
                <span class="kw">this</span>, <span class="kw">SLOT</span>(commitAndCloseEditor()));
        <span class="kw">return</span> timeEdit;
    } <span class="kw">else</span> {
        <span class="kw">return</span> <span class="ot">QItemDelegate::</span>createEditor(parent, option, index);
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> TrackDelegate::commitAndCloseEditor()
{
    <span class="ot">QTimeEdit</span> *editor = <span class="fu">qobject_cast</span>&lt;<span class="ot">QTimeEdit</span> *&gt;(sender());
    <span class="co">// This signal must be emitted when the editor widget has completed editing</span>
    <span class="co">// the data, and wants to write it back into the model.</span>
    <span class="kw">emit</span> commitData(editor);
    <span class="kw">emit</span> closeEditor(editor);
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> TrackDelegate::setModelData(<span class="ot">QWidget</span> *editor,
                                 <span class="ot">QAbstractItemModel</span> *model,
                                 <span class="dt">const</span> <span class="ot">QModelIndex</span> &amp;index) <span class="dt">const</span>
{
    <span class="kw">if</span> (index.column() == durationColumn) {
        <span class="ot">QTimeEdit</span> *timeEdit = <span class="fu">qobject_cast</span>&lt;<span class="ot">QTimeEdit</span> *&gt;(editor);
        <span class="ot">QTime</span> time = timeEdit-&gt;time();
        <span class="dt">int</span> secs = (time.minute() * <span class="dv">60</span>) + time.second();
        model-&gt;setData(index, secs);
    } <span class="kw">else</span> {
        <span class="ot">QItemDelegate::</span>setModelData(editor, model, index);
    }
}</code></pre></div>
<h3 id="container-classes">11. Container Classes</h3>
<p><strong>Implicit sharing</strong>, or &#8220;copy on write&#8221;, is an optimization that makes it possible to pass entire containers as values without any significant performance cost. The Qt containers also feature easy-to-use iterator classes inspired by Java, they can be streamed using <code class="sourceCode cpp"><span class="ot">QDataStream</span></code>, and they usually result in less code in the executable than the corresponding STL containers. Finally, on some hardware platforms supported by Qt/Embedded Linux, the Qt containers are the only ones available.</p>
<p>Qt offers both <strong>sequential containers</strong> such as <code class="sourceCode cpp"><span class="ot">QVector</span>&lt;T&gt;</code>, <code class="sourceCode cpp"><span class="ot">QLinkedList</span>&lt;T&gt;</code>, and <code class="sourceCode cpp"><span class="ot">QList</span>&lt;T&gt;</code>, and <strong>associative containers</strong> such as <code class="sourceCode cpp"><span class="ot">QMap</span>&lt;K, T&gt;</code> and <code class="sourceCode cpp"><span class="ot">QHash</span>&lt;K, T&gt;</code>. Conceptually, the sequential containers store items one after another, whereas the associative containers store key&#8211;value pairs.</p>
<p>Qt also provides <strong>generic algorithms</strong> that perform operations on arbitrary containers. For example, the <code class="sourceCode cpp"><span class="fu">qSort</span>()</code> algorithm sorts a sequential container, and <code class="sourceCode cpp"><span class="fu">qBinaryFind</span>()</code> performs a binary search on a sorted sequential container. These algorithms are similar to those offered by the STL.</p>
<p>In this chapter, we will also look at <code class="sourceCode cpp"><span class="ot">QString</span></code>, <code class="sourceCode cpp"><span class="ot">QByteArray</span></code>, and <code class="sourceCode cpp"><span class="ot">QVariant</span></code>, since they have a lot in common with containers. <code class="sourceCode cpp"><span class="ot">QString</span></code> is a 16-bit Unicode string used throughout Qt&#8217;s API. <code class="sourceCode cpp"><span class="ot">QByteArray</span></code> is an array of 8-bit chars useful for storing raw binary data. <code class="sourceCode cpp"><span class="ot">QVariant</span></code> is a type that can store most C++ and Qt value types.</p>
<h4 id="sequential-containers">Sequential Containers</h4>
<dl>
<dt><code class="sourceCode cpp"><span class="ot">QVector</span>&lt;T&gt;</code></dt>
<dd><p>An array-like data structure that stores its items at adjacent positions in memory.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
    <span class="co">// set value to a key</span>
    <span class="ot">QVector</span>&lt;<span class="dt">double</span>&gt; vect(<span class="dv">3</span>);
    vect[<span class="dv">0</span>] = <span class="fl">1.0</span>;
    vect[<span class="dv">1</span>] = <span class="fl">0.540302</span>;
    vect[<span class="dv">2</span>] = <span class="fl">-0.416147</span>;
}

{
    <span class="co">// append a pair</span>
    <span class="ot">QVector</span>&lt;<span class="dt">double</span>&gt; vect;
    vect.append(<span class="fl">1.0</span>);
    vect.append(<span class="fl">0.540302</span>);
    vect.append(<span class="fl">-0.416147</span>);

    <span class="co">// or use the &lt;&lt; operator</span>
    vect &lt;&lt; <span class="fl">1.0</span> &lt;&lt; <span class="fl">0.540302</span> &lt;&lt; <span class="fl">-0.416147</span>;
}</code></pre></div>
</dd>
<dt><code class="sourceCode cpp"><span class="ot">QLinkedList</span>&lt;T&gt;</code></dt>
<dd><p>Inserting items at the beginning or in the middle of a <code class="sourceCode cpp"><span class="ot">QVector</span>&lt;T&gt;,</code> or removing items from these positions, can be inefficient for large vectors. For this reason, Qt also offers <code class="sourceCode cpp"><span class="ot">QLinkedList</span>&lt;T&gt;,</code> a data structure that stores its items at non-adjacent locations in memory.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QLinkedList</span>&lt;<span class="ot">QString</span>&gt; list;
list.append(<span class="st">&quot;Clash&quot;</span>);
list.append(<span class="st">&quot;Ramones&quot;</span>);

<span class="ot">QLinkedList</span>&lt;<span class="ot">QString</span>&gt;::iterator i = list.find(<span class="st">&quot;Ramones&quot;</span>);
list.insert(i, <span class="st">&quot;Tote Hosen&quot;</span>);</code></pre></div>
</dd>
<dt><code class="sourceCode cpp"><span class="ot">QList</span>&lt;T&gt;</code></dt>
<dd><p>The <code class="sourceCode cpp"><span class="ot">QList</span>&lt;T&gt;</code> sequential container is an &#8220;array-list&#8221; that combines the most important benefits of <code class="sourceCode cpp"><span class="ot">QVector</span>&lt;T&gt;</code> and <code class="sourceCode cpp"><span class="ot">QLinkedList</span>&lt;T&gt;</code> in a single class. It supports random access, and its interface is index-based like QVector&#8217;s. Inserting or removing an item at either end of a <code class="sourceCode cpp"><span class="ot">QList</span>&lt;T&gt;</code> is very fast, and inserting in the middle is fast for lists with up to about one thousand items. Unless we want to perform insertions in the middle of huge lists or need the list&#8217;s items to occupy consecutive addresses in memory, <code class="sourceCode cpp"><span class="ot">QList</span>&lt;T&gt;</code> is usually the most appropriate general-purpose container class to use.</p>
<p>The <code class="sourceCode cpp"><span class="ot">QStringList</span></code> class is a subclass of <code class="sourceCode cpp"><span class="ot">QList</span>&lt;<span class="ot">QString</span>&gt;</code> that is widely used in Qt&#8217;s API.</p>
</dd>
</dl>
<p><code class="sourceCode cpp"><span class="ot">QStack</span>&lt;T&gt;</code> and <code class="sourceCode cpp"><span class="ot">QQueue</span>&lt;T&gt;</code> are two more examples of convenience subclasses.</p>
<p>For all the container classes seen so far, the value type <code>T</code> can be a basic type like int or double, a pointer type, or a class that has a default constructor (a constructor that takes no arguments), a copy constructor, and an assignment operator. Classes that qualify include <code class="sourceCode cpp"><span class="ot">QByteArray</span></code>, <code class="sourceCode cpp"><span class="ot">QDateTime</span></code>, <code class="sourceCode cpp"><span class="ot">QRegExp</span></code>, <code class="sourceCode cpp"><span class="ot">QString</span></code>, and <code class="sourceCode cpp"><span class="ot">QVariant</span></code>. Qt classes that are derived from <code class="sourceCode cpp"><span class="ot">QObject</span></code> do not qualify, because they lack a copy constructor and an assignment operator. This is no problem in practice, since we can simply store pointers to <code class="sourceCode cpp"><span class="ot">QObject</span></code> types rather than the objects themselves.</p>
<p><strong>The Java-style iterators</strong> are easier to use, whereas the <strong>STL-style iterators</strong> can be combined with Qt&#8217;s and STL&#8217;s generic algorithms and are more powerful.</p>
<div class="figure">
<img src="http://doc.qt.io/qt-4.8/images/javaiterators1.png" alt="Java-style iterators" />
<p class="caption">Java-style iterators</p>
</div>
<p><code class="sourceCode cpp"><span class="ot">QVectorIterator</span>&lt;T&gt;,</code> <code class="sourceCode cpp"><span class="ot">QLinkedListIterator</span>&lt;T&gt;,</code> and <code class="sourceCode cpp"><span class="ot">QListIterator</span>&lt;T&gt;.</code> The corresponding read-write iterators have <code>Mutable</code> in their name (e.g., <code class="sourceCode cpp"><span class="ot">QMutableVectorIterator</span>&lt;T&gt;)</code>).</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QList</span>&lt;<span class="dt">double</span>&gt; list;
...
<span class="ot">QMutableListIterator</span>&lt;<span class="dt">double</span>&gt; i(list);
<span class="kw">while</span> (i.hasNext()) {
    <span class="dt">int</span> val = i.next();
    <span class="kw">if</span> (val &lt; <span class="fl">0.0</span>)
        i.setValue(-val);
}

<span class="ot">QMutableListIterator</span>&lt;<span class="dt">double</span>&gt; i(list);
i.toBack();
<span class="kw">while</span> (i.hasPrevious()) {
    <span class="co">//  remove() function always operates on the last item that was jumped</span>
    <span class="co">//  over. It also works when iterating backward</span>
    <span class="kw">if</span> (i.previous() &lt; <span class="fl">0.0</span>)
        i.remove();
}

<span class="co">// It is also possible to insert an item at the current iterator position by</span>
<span class="co">// calling insert(). The iterator is then advanced to point between the new</span>
<span class="co">// item and the following item.</span></code></pre></div>
<p>In addition to the Java-style iterators, every sequential container class <code class="sourceCode cpp">C&lt;T&gt;</code> has two STL-style iterator types: <code class="sourceCode cpp">C&lt;T&gt;::iterator</code> and <code class="sourceCode cpp">C&lt;T&gt;::const_iterator.</code> The difference between the two is that <code class="sourceCode cpp">const_iterator</code> doesn&#8217;t let us modify the data.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QList</span>&lt;<span class="dt">double</span>&gt;::iterator i = list.begin();
<span class="kw">while</span> (i != list.end()) {
    *i = <span class="fu">qAbs</span>(*i);
    ++i;
}</code></pre></div>
<p>A few Qt functions return a container. If we want to iterate over the return value of a function using an STL-style iterator, we must take a copy of the container and iterate over the copy. For example, the following code is the correct way to iterate over the <code class="sourceCode cpp"><span class="ot">QList</span>&lt;<span class="dt">int</span>&gt;</code> returned by <code class="sourceCode cpp"><span class="ot">QSplitter::</span>sizes():</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QList</span>&lt;<span class="dt">int</span>&gt; list = splitter-&gt;sizes();
<span class="ot">QList</span>&lt;<span class="dt">int</span>&gt;::const_iterator i = list.begin();
<span class="kw">while</span> (i != list.end()) {
    do_something(*i);
    ++i;
}</code></pre></div>
<p>The following code is wrong:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// WRONG</span>
<span class="ot">QList</span>&lt;<span class="dt">int</span>&gt;::const_iterator i = splitter-&gt;sizes().begin();
<span class="kw">while</span> (i != splitter-&gt;sizes().end()) {
    do_something(*i);
    ++i;
}</code></pre></div>
<p>This is because <code class="sourceCode cpp"><span class="ot">QSplitter::</span>sizes()</code> returns a new <code class="sourceCode cpp"><span class="ot">QList</span>&lt;<span class="dt">int</span>&gt;</code> by value every time it is called. <strong>If we don&#8217;t store the return value, C++ automatically destroys it before we have even started iterating, leaving us with a dangling <code>['d&#230;&#331;gl&#618;&#331;]</code> iterator.</strong> To make matters worse, each time the loop is run, <code class="sourceCode cpp"><span class="ot">QSplitter::</span>sizes()</code> must generate a new copy of the list because of the <code class="sourceCode cpp">splitter-&gt;sizes().end()</code> call. In summary: <strong>When using STL-style iterators, always iterate on a copy of a container returned by value.</strong></p>
<p>With read-only Java-style iterators, we don&#8217;t need to take a copy. The iterator takes a copy for us behind the scenes, ensuring that we always iterate over the data that the function first returned. For example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QListIterator</span>&lt;<span class="dt">int</span>&gt; i(splitter-&gt;sizes());
<span class="kw">while</span> (i.hasNext()) {
    do_something(i.next());
}</code></pre></div>
<dl>
<dt><code class="sourceCode cpp"><span class="ot">QList</span>&lt;<span class="dt">int</span>&gt; <span class="ot">QSplitter::</span>sizes() <span class="dt">const</span></code></dt>
<dd><p>Returns a list of the size parameters of all the widgets in this splitter.</p>
<p>If the splitter&#8217;s orientation is horizontal, the list contains the widgets width in pixels, from left to right; if the orientation is vertical, the list contains the widgets height in pixels, from top to bottom.</p>
<p>Giving the values to another splitter&#8217;s <code class="sourceCode cpp">setSizes()</code> function will produce a splitter with the same layout as this one.</p>
<p>Note that invisible widgets have a size of 0.</p>
</dd>
</dl>
<p>The beauty of implicit sharing is that it is an optimization that we don&#8217;t need to think about; it simply works, without requiring any programmer intervention. At the same time, implicit sharing encourages a clean programming style where objects are returned by value. Consider the following function:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QVector</span>&lt;<span class="dt">double</span>&gt; sineTable()
{
    <span class="ot">QVector</span>&lt;<span class="dt">double</span>&gt; vect(<span class="dv">360</span>);
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">360</span>; ++i)
    vect[i] = std::sin(i / (<span class="dv">2</span> * M_PI));
    <span class="kw">return</span> vect;
}</code></pre></div>
<p>The call to the function looks like this: <code class="sourceCode cpp"><span class="ot">QVector</span>&lt;<span class="dt">double</span>&gt; table = sineTable();</code>. STL, in comparison, encourages us to pass the vector as a non-const reference to <strong>avoid the copy that takes place when the function&#8217;s return value is stored in a variable</strong>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> sineTable(std::vector&lt;<span class="dt">double</span>&gt; &amp;vect)
{
    vect.resize(<span class="dv">360</span>);
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">360</span>; ++i)
    vect[i] = std::sin(i / (<span class="dv">2</span> * M_PI));
}</code></pre></div>
<p>The call then becomes more tedious to write and less clear to read: <code class="sourceCode cpp">std::vector&lt;<span class="dt">double</span>&gt; table;</code></p>
<p>Qt uses implicit sharing for all of its containers and for many other classes, including <code class="sourceCode cpp"><span class="ot">QByteArray</span></code>, <code class="sourceCode cpp"><span class="ot">QBrush</span></code>, <code class="sourceCode cpp"><span class="ot">QFont</span></code>, <code class="sourceCode cpp"><span class="ot">QImage</span></code>, <code class="sourceCode cpp"><span class="ot">QPixmap</span></code>, and <code class="sourceCode cpp"><span class="ot">QString</span></code>. This makes these classes very efficient to pass by value, both as function parameters and as return values.</p>
<p>Implicit sharing is a guarantee from Qt that the data won&#8217;t be copied if we don&#8217;t modify it. To get the best out of implicit sharing, we can adopt a couple of new programming habits. One habit is to use the <code class="sourceCode cpp">at()</code> function rather than the <code>[] operator</code> for read-only access on a (non-const) vector or list. Since Qt&#8217;s containers cannot tell whether <code>[]</code> appears on the left side of an assignment or not, it assumes the worst and forces a deep copy to occur, whereas <code class="sourceCode cpp">at()</code> isn&#8217;t allowed on the left side of an assignment.</p>
<p>A similar issue arises when we iterate over a container with STL-style iterators. Whenever we call <code class="sourceCode cpp">begin()</code> or <code class="sourceCode cpp">end()</code> on a non-const container, Qt forces a deep copy to occur if the data is shared. To prevent this inefficiency, the solution is to use <code class="sourceCode cpp">const_iterator</code>, <code class="sourceCode cpp">constBegin()</code>, and <code class="sourceCode cpp">constEnd()</code> whenever possible.</p>
<p>Data sharing is often disregarded as an option in multithreaded programs, because of race conditions in the reference counting. With Qt, this is not an issue. Internally, the container classes use assembly language instructions to perform atomic reference counting. This technology is available to Qt users through the <code class="sourceCode cpp"><span class="ot">QSharedData</span></code> and <code class="sourceCode cpp"><span class="ot">QSharedDataPointer</span></code> classes.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QLinkedList</span>&lt;Movie&gt; list;
Movie movie;
...
<span class="kw">foreach</span> (movie, list) {
    <span class="kw">if</span> (movie.title() == <span class="st">&quot;Citizen Kane&quot;</span>) {
        std::cout &lt;&lt; <span class="st">&quot;Found Citizen Kane&quot;</span> &lt;&lt; std::endl;
        <span class="kw">break</span>;
    }
}</code></pre></div>
<h4 id="associative-containers">Associative Containers</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
    <span class="co">// insert a pair</span>
    <span class="ot">QMap</span>&lt;<span class="ot">QString</span>, <span class="dt">int</span>&gt; map;
    map.insert(<span class="st">&quot;eins&quot;</span>, <span class="dv">1</span>);
    map.insert(<span class="st">&quot;sieben&quot;</span>, <span class="dv">7</span>);
    map.insert(<span class="st">&quot;dreiundzwanzig&quot;</span>, <span class="dv">23</span>);

    <span class="co">// assign a value to a given key</span>
    map[<span class="st">&quot;eins&quot;</span>] = <span class="dv">1</span>;
    map[<span class="st">&quot;sieben&quot;</span>] = <span class="dv">7</span>;
    map[<span class="st">&quot;dreiundzwanzig&quot;</span>] = <span class="dv">23</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// If [] is used to retrieve a value for a non-existent key in a non-const map,</span>
<span class="co">// a new item will be created with the given key and an empty value. To avoid</span>
<span class="co">// accidentally creating empty values, we can use the value() function to</span>
<span class="co">// retrieve items instead of []:</span>
<span class="dt">int</span> val = map[<span class="st">&quot;dreiundzwanzig&quot;</span>];        <span class="co">// bad</span>
<span class="dt">int</span> val = map.value(<span class="st">&quot;dreiundzwanzig&quot;</span>);  <span class="co">// better</span>

<span class="co">// specify a default value</span>
<span class="dt">int</span> seconds = map.value(<span class="st">&quot;delay&quot;</span>, <span class="dv">30</span>);   <span class="co">// best</span></code></pre></div>
<p><code class="sourceCode cpp"><span class="ot">QMap</span>&lt;K, T&gt;</code> has a couple of convenience functions, <code class="sourceCode cpp">keys()</code> and <code class="sourceCode cpp">values()</code>, that are especially useful when dealing with small data sets. They return <code class="sourceCode cpp">QLists</code> of a map&#8217;s keys and values.</p>
<p>Maps are normally single-valued: If a new value is assigned to an existing key, the old value is replaced by the new value, ensuring that no two items share the same key. It is possible to have multiple key&#8211;value pairs with the same key by using the <code class="sourceCode cpp">insertMulti()</code> function or the <code class="sourceCode cpp"><span class="ot">QMultiMap</span>&lt;K, T&gt;</code> convenience subclass. <code class="sourceCode cpp"><span class="ot">QMap</span>&lt;K, T&gt;</code> has a <code class="sourceCode cpp">values(<span class="dt">const</span> K &amp;)</code> overload that returns a <code class="sourceCode cpp"><span class="ot">QList</span></code> of all the values for a given key. For example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QMultiMap</span>&lt;<span class="dt">int</span>, <span class="ot">QString</span>&gt; multiMap;
multiMap.insert(<span class="dv">1</span>, <span class="st">&quot;one&quot;</span>);
multiMap.insert(<span class="dv">1</span>, <span class="st">&quot;eins&quot;</span>);
multiMap.insert(<span class="dv">1</span>, <span class="st">&quot;uno&quot;</span>);
<span class="ot">QList</span>&lt;<span class="ot">QString</span>&gt; vals = multiMap.values(<span class="dv">1</span>);</code></pre></div>
<p>A <code class="sourceCode cpp"><span class="ot">QHash</span>&lt;K, T&gt;</code> is a data structure that stores key&#8211;value pairs in a hash table. Its interface is almost identical to that of <code class="sourceCode cpp"><span class="ot">QMap</span>&lt;K, T&gt;</code>, but it has different requirements for the <code>K</code> template type and usually provides much faster lookups than <code class="sourceCode cpp"><span class="ot">QMap</span>&lt;K, T&gt;</code> can achieve. Another difference is that <code class="sourceCode cpp"><span class="ot">QHash</span>&lt;K, T&gt;</code> is unordered.</p>
<p>In addition to the standard requirements on any value type stored in a container, the <code>K</code> type of a <code class="sourceCode cpp"><span class="ot">QHash</span>&lt;K, T&gt;</code> needs to provide an <code class="sourceCode cpp"><span class="kw">operator</span>==()</code> and be supported by a global <code class="sourceCode cpp"><span class="fu">qHash</span>()</code> function that returns a hash value for a key. Qt already provides <code class="sourceCode cpp"><span class="fu">qHash</span>()</code> functions for integer types, pointer types, <code class="sourceCode cpp"><span class="ot">QChar</span></code>, <code class="sourceCode cpp"><span class="ot">QString</span></code>, and <code class="sourceCode cpp"><span class="ot">QByteArray</span></code>.</p>
<p>Fine-tune performance by calling <code class="sourceCode cpp">reserve()</code> to specify the number of items expected to be stored in the hash and <code class="sourceCode cpp">squeeze()</code> to shrink the hash table based on the current number of items. A common idiom is to call <code class="sourceCode cpp">reserve()</code> with the maximum number of items we expect, then insert the data, and finally call <code class="sourceCode cpp">squeeze()</code> to minimize memory usage if there were fewer items than expected.</p>
<p>Besides <code class="sourceCode cpp"><span class="ot">QHash</span>&lt;K, T&gt;</code>, Qt also provides a <code class="sourceCode cpp"><span class="ot">QCache</span>&lt;K, T&gt;</code> class that can be used to cache objects associated with a key, and a <code class="sourceCode cpp"><span class="ot">QSet</span>&lt;K&gt;</code> container that only stores keys. Internally, both rely on <code class="sourceCode cpp"><span class="ot">QHash</span>&lt;K, T&gt;</code> and both have the same requirements for the <code>K</code> type as <code class="sourceCode cpp"><span class="ot">QHash</span>&lt;K, T&gt;</code>.</p>
<p>The easiest way to iterate through all the key&#8211;value pairs stored in an associative container is to use a Java- style iterator. Because the iterators must give access to both a key and a value, the Java-style iterators for associative containers work slightly differently from their sequential counterparts. The main difference is that the <code class="sourceCode cpp">next()</code> and <code class="sourceCode cpp">previous()</code> functions return an object that represents a key&#8211;value pair, rather than simply a value. The key and value components are accessible from this object as <code class="sourceCode cpp">key()</code> and <code class="sourceCode cpp">value()</code>. For example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QMap</span>&lt;<span class="ot">QString</span>, <span class="dt">int</span>&gt; map;
...
<span class="dt">int</span> sum = <span class="dv">0</span>;
<span class="ot">QMapIterator</span>&lt;<span class="ot">QString</span>, <span class="dt">int</span>&gt; i(map);
<span class="kw">while</span> (i.hasNext())
sum += i.next().value();</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QMapIterator</span>&lt;<span class="ot">QString</span>, <span class="dt">int</span>&gt; i(map);
<span class="kw">while</span> (i.hasNext()) {
    i.next();
    <span class="kw">if</span> (i.value() &gt; largestValue) {
        largestKey = i.key();
        largestValue = i.value();
    }
}

<span class="co">// QMutableMapIterator&lt;K, T&gt; i(container);</span>
i.setValue(-t); <span class="co">// value of this key reversed</span></code></pre></div>
<p>STL-style iterators also provide <code class="sourceCode cpp">key()</code> and <code class="sourceCode cpp">value()</code> functions. With the non-const iterator types, <code class="sourceCode cpp">value()</code> returns a non-const reference, allowing us to change the value as we iterate. Note that although these iterators are called &#8220;STL-style&#8221;, they deviate significantly from the <code class="sourceCode cpp">std::map&lt;K, T&gt;</code> iterators, which are based on <code class="sourceCode cpp">std::pair&lt;K, T&gt;</code>.</p>
<p>The foreach loop also works on associative containers, but only on the value component of the key&#8211;value pairs. If we need both the key and the value components of the items, we can call the <code class="sourceCode cpp">keys()</code> and <code class="sourceCode cpp">values(<span class="dt">const</span> K &amp;)</code> functions in nested foreach loops as follows:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QMultiMap</span>&lt;<span class="ot">QString</span>, <span class="dt">int</span>&gt; map;
...
<span class="kw">foreach</span> (<span class="ot">QString</span> key, map.keys()) {
    <span class="kw">foreach</span> (<span class="dt">int</span> value, map.values(key)) {
        do_something(key, value);
    }
}</code></pre></div>
<h4 id="generic-algorithms">Generic Algorithms</h4>
<p>The <code>&lt;QtAlgorithms&gt;</code> header declares a set of global template functions that implement basic algorithms on containers. Most of these functions operate on STL-style iterators.</p>
<p>The STL <code>&lt;algorithm&gt;</code> header provides a more complete set of generic algorithms. These algorithms can be used on Qt containers as well as STL containers.</p>
<dl>
<dt><code class="sourceCode cpp"><span class="fu">qFind</span></code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QStringList</span> list;
list &lt;&lt; <span class="st">&quot;Emma&quot;</span> &lt;&lt; <span class="st">&quot;Karl&quot;</span> &lt;&lt; <span class="st">&quot;James&quot;</span> &lt;&lt; <span class="st">&quot;Mariette&quot;</span>;
<span class="ot">QStringList::</span>iterator i = <span class="fu">qFind</span>(list.begin(), list.end(), <span class="st">&quot;Karl&quot;</span>);
<span class="ot">QStringList::</span>iterator j = <span class="fu">qFind</span>(list.begin(), list.end(), <span class="st">&quot;Petra&quot;</span>);</code></pre></div>
</dd>
<dt><code class="sourceCode cpp"><span class="fu">qBinaryFind</span></code></dt>
<dd><p>The <code class="sourceCode cpp"><span class="fu">qBinaryFind</span>()</code> algorithm performs a search just like <code class="sourceCode cpp"><span class="fu">qFind</span>()</code>, except that it assumes that the items are sorted in ascending order and uses fast binary searching rather than <code class="sourceCode cpp"><span class="fu">qFind</span>()</code>&#8217;s linear searching.</p>
</dd>
<dt><code class="sourceCode cpp"><span class="fu">qFill</span></code></dt>
<dd><p>The <code class="sourceCode cpp"><span class="fu">qFill</span>()</code> algorithm populates a container with a particular value:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QLinkedList</span>&lt;<span class="dt">int</span>&gt; list(<span class="dv">10</span>);
<span class="fu">qFill</span>(list.begin(), list.end(), <span class="dv">1009</span>);

<span class="ot">QVector</span>&lt;<span class="dt">int</span>&gt; vect(<span class="dv">10</span>);
<span class="fu">qFill</span>(vect.begin(), vect.begin() + <span class="dv">5</span>, <span class="dv">1009</span>);
<span class="fu">qFill</span>(vect.end() - <span class="dv">5</span>, vect.end(), <span class="dv">2013</span>);</code></pre></div>
</dd>
<dt><code class="sourceCode cpp"><span class="fu">qCopy</span></code></dt>
<dd><p>The qCopy() algorithm copies values from one container to another:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QVector</span>&lt;<span class="dt">int</span>&gt; vect(list.count());
<span class="fu">qCopy</span>(list.begin(), list.end(), vect.begin());

<span class="co">// should not don&#39;t overlap</span>
<span class="fu">qCopy</span>(list.begin(), list.begin() + <span class="dv">2</span>, list.end() - <span class="dv">2</span>);</code></pre></div>
</dd>
<dt><code class="sourceCode cpp"><span class="fu">qSort</span></code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="fu">qSort</span>(list.begin(), list.end(), <span class="fu">qGreater</span>&lt;<span class="dt">int</span>&gt;());</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> insensitiveLessThan(<span class="dt">const</span> <span class="ot">QString</span> &amp;str1, <span class="dt">const</span> <span class="ot">QString</span> &amp;str2)
{
    <span class="kw">return</span> str1.toLower() &lt; str2.toLower();
}

<span class="co">// The call to qSort() then becomes QStringList list;</span>
...
<span class="fu">qSort</span>(list.begin(), list.end(), insensitiveLessThan);</code></pre></div>
<p>The qStableSort() algorithm is similar to qSort(), except it guarantees that items that compare equal appear in the same order after the sort as before. This is useful if the sort criterion takes into account only parts of the value and the results are visible to the user.</p>
</dd>
</dl>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="fu">qDeleteAll</span>(list);
list.clear();</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// The qSwap() algorithm exchanges the value of two variables. For example:</span>
<span class="dt">int</span> x1 = line.x1();
<span class="dt">int</span> x2 = line.x2();
<span class="kw">if</span> (x1 &gt; x2)
    <span class="fu">qSwap</span>(x1, x2);</code></pre></div>
<dl>
<dt><code class="sourceCode cpp">&lt;QtGlobal&gt;</code></dt>
<dd><p><code class="sourceCode cpp"><span class="fu">qAbs</span>()</code></p>
</dd>
</dl>
<h4 id="strings-byte-arrays-and-variants">Strings, Byte Arrays, and Variants</h4>
<p>When using QString, we don&#8217;t need to worry about such arcane details as allocating enough memory or ensuring that the data is <code>'\0'-terminated</code>. Conceptually, <code class="sourceCode cpp">QStrings</code> can be thought of as a vector of <code class="sourceCode cpp">QChars</code>. A <code class="sourceCode cpp"><span class="ot">QString</span></code> can embed <code>'\0'</code> characters. The <code class="sourceCode cpp">length()</code> function returns the size of the entire string, including embedded <code>'\0'</code> characters.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> ok;
<span class="dt">double</span> d = str.toDouble(&amp;ok);</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// The conversion from const char * strings to QString is automatic in most</span>
<span class="co">// cases, for example:</span>
str += <span class="st">&quot; (1870)&quot;</span>;
mid(<span class="dt">int</span> start, <span class="dt">int</span> len);
mid(<span class="dt">int</span> start);

<span class="co">// left, right n char</span>
left(<span class="dt">int</span> n);
right(<span class="dt">int</span> n);

<span class="ot">QString</span> str = <span class="st">&quot;the middle bit&quot;</span>;
<span class="dt">int</span> i = str.indexOf(<span class="st">&quot;middle&quot;</span>);

startWith(), endWith()
toUpper() <span class="kw">or</span> toLower()

<span class="ot">QString</span> str = <span class="st">&quot;a cloudy day&quot;</span>;
str.replace(<span class="dv">2</span>, <span class="dv">6</span>, <span class="st">&quot;sunny&quot;</span>);

str.remove(<span class="dv">2</span>, <span class="dv">6</span>);
str.insert(<span class="dv">2</span>, <span class="st">&quot;sunny&quot;</span>);
str.replace(<span class="st">&quot;&amp;&quot;</span>, <span class="st">&quot;&amp;amp;&quot;</span>);

<span class="ot">QString</span> str = <span class="st">&quot; BOB </span><span class="ch">\t</span><span class="st"> THE </span><span class="ch">\n</span><span class="st">DOG </span><span class="ch">\n</span><span class="st">&quot;</span>;
<span class="fu">qDebug</span>() &lt;&lt; str.trimmed();
<span class="fu">qDebug</span>() &lt;&lt; str.simplified();

<span class="ot">QString</span> str = <span class="st">&quot;polluter pays principle&quot;</span>;
<span class="ot">QStringList</span> words = str.split(<span class="st">&quot; &quot;</span>);
words.sort();
str = words.join(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);

isEmpty() <span class="kw">or</span> by checking whether length() is <span class="fl">0.</span></code></pre></div>
<p>The conversion from <code>const char *</code> strings to <code class="sourceCode cpp"><span class="ot">QString</span></code> is automatic in most cases, for example: <code class="sourceCode cpp">str += <span class="st">&quot; (1870)&quot;</span>;</code></p>
<p>To explicitly convert a <code>const char *</code> to a <code class="sourceCode cpp"><span class="ot">QString</span></code>, simply use a <code class="sourceCode cpp"><span class="ot">QString</span></code> cast, or call <code class="sourceCode cpp">fromAscii()</code> or <code class="sourceCode cpp">fromLatin1()</code>. (See Chapter 18 for an explanation of handling literal strings in other encodings.) To convert a QString to a const char *, use <code class="sourceCode cpp">toAscii()</code> or <code class="sourceCode cpp">toLatin1()</code>. These functions return a <code class="sourceCode cpp"><span class="ot">QByteArray</span></code>, which can be converted into a <code>const char *</code> using <code class="sourceCode cpp"><span class="ot">QByteArray::</span>data()</code> or <code class="sourceCode cpp"><span class="ot">QByteArray::</span>constData()</code>. For example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">printf(<span class="st">&quot;User: </span><span class="ch">%s\n</span><span class="st">&quot;</span>, str.toAscii().data());
printf(<span class="st">&quot;User: </span><span class="ch">%s\n</span><span class="st">&quot;</span>, <span class="fu">qPrintable</span>(str)); <span class="co">// toAscii().constData();</span></code></pre></div>
<p>Qt provides a much cleaner way of handling variables that can hold different types: <code class="sourceCode cpp"><span class="ot">QVariant</span></code>.</p>
<p>The <code class="sourceCode cpp"><span class="ot">QVariant</span></code> class can hold values of many Qt types, including <code class="sourceCode cpp"><span class="ot">QBrush</span></code>, <code class="sourceCode cpp"><span class="ot">QColor</span></code>, <code class="sourceCode cpp"><span class="ot">QCursor</span></code>, <code class="sourceCode cpp"><span class="ot">QDateTime</span></code>, <code class="sourceCode cpp"><span class="ot">QFont</span></code>, <code class="sourceCode cpp"><span class="ot">QKeySequence</span></code>, <code class="sourceCode cpp"><span class="ot">QPalette</span></code>, <code class="sourceCode cpp"><span class="ot">QPen</span></code>, <code class="sourceCode cpp"><span class="ot">QPixmap</span></code>, <code class="sourceCode cpp"><span class="ot">QPoint</span></code>, <code class="sourceCode cpp"><span class="ot">QRect</span></code>, <code class="sourceCode cpp"><span class="ot">QRegion</span></code>, <code class="sourceCode cpp"><span class="ot">QSize</span></code>, and <code class="sourceCode cpp"><span class="ot">QString</span></code>, as well as basic C++ numeric types such as double and int. The <code class="sourceCode cpp"><span class="ot">QVariant</span></code> class can also hold containers: <code class="sourceCode cpp"><span class="ot">QMap</span>&lt;<span class="ot">QString</span>, <span class="ot">QVariant</span>&gt;</code>, <code class="sourceCode cpp"><span class="ot">QStringList</span></code>, and <code class="sourceCode cpp"><span class="ot">QList</span>&lt;<span class="ot">QVariant</span>&gt;</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QMap</span>&lt;<span class="ot">QString</span>, <span class="ot">QVariant</span>&gt; pearMap;
pearMap[<span class="st">&quot;Standard&quot;</span>] = <span class="fl">1.95</span>;
pearMap[<span class="st">&quot;Organic&quot;</span>] = <span class="fl">2.25</span>;

<span class="ot">QMap</span>&lt;<span class="ot">QString</span>, <span class="ot">QVariant</span>&gt; fruitMap;
fruitMap[<span class="st">&quot;Orange&quot;</span>] = <span class="fl">2.10</span>;
fruitMap[<span class="st">&quot;Pineapple&quot;</span>] = <span class="fl">3.85</span>;
fruitMap[<span class="st">&quot;Pear&quot;</span>] = pearMap;</code></pre></div>
<p>For convenience, <code class="sourceCode cpp"><span class="ot">QByteArray</span></code> automatically ensures that the &#8220;one past the last&#8221; byte is always <code>'\0'</code>, making it easy to pass a <code class="sourceCode cpp"><span class="ot">QByteArray</span></code> to a function taking a <code>const char *</code>. <code class="sourceCode cpp"><span class="ot">QByteArray</span></code> also supports embedded <code>'\0'</code> characters, allowing us to use it to store arbitrary binary data.</p>
<p><code class="sourceCode cpp"><span class="ot">QVariant</span></code> is used by Qt&#8217;s meta-object system and is therefore part of the QtCore module. Nonetheless, when we link against the QtGui module, <code class="sourceCode cpp"><span class="ot">QVariant</span></code> can store GUI-related types such as <code class="sourceCode cpp"><span class="ot">QColor</span></code>, <code class="sourceCode cpp"><span class="ot">QFont</span></code>, <code class="sourceCode cpp"><span class="ot">QIcon</span></code>, <code class="sourceCode cpp"><span class="ot">QImage</span></code>, and <code class="sourceCode cpp"><span class="ot">QPixmap</span></code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QIcon</span> icon(<span class="st">&quot;open.png&quot;</span>);
<span class="ot">QVariant</span> variant = icon;

<span class="co">// retrieve</span>
<span class="ot">QIcon</span> icon = variant.value&lt;<span class="ot">QIcon</span>&gt;();</code></pre></div>
<p><code class="sourceCode cpp"><span class="ot">QVariant</span></code> can also be used to store custom data types, <strong>assuming they provide a default constructor and a copy constructor</strong>. For this to work, we must first register the type using the <code class="sourceCode cpp"><span class="kw">Q_DECLARE_METATYPE</span>()</code> macro, typically in a header file below the class definition: <code class="sourceCode cpp"><span class="kw">Q_DECLARE_METATYPE</span>(BusinessCard)</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">BusinessCard businessCard;
<span class="ot">QVariant</span> variant = <span class="ot">QVariant::</span>fromValue(businessCard);
...
<span class="kw">if</span> (variant.canConvert&lt;BusinessCard&gt;()) {
    BusinessCard card = variant.value&lt;BusinessCard&gt;();
    ...
}

<span class="co">// qRegisterMetaTypeStreamOperators&lt;BusinessCard&gt;(&quot;BusinessCard&quot;);</span></code></pre></div>
<p>This chapter focused on the Qt containers, as well as on <code class="sourceCode cpp"><span class="ot">QString</span></code>, <code class="sourceCode cpp"><span class="ot">QByteArray</span></code>, and <code class="sourceCode cpp"><span class="ot">QVariant</span></code>. In addition to these classes, Qt also provides a few other containers. One is <code class="sourceCode cpp"><span class="ot">QPair</span>&lt;T1, T2&gt;</code>, which simply stores two values and is similar to <code class="sourceCode cpp">std::pair&lt;T1, T2&gt;</code>. Another is <code class="sourceCode cpp"><span class="ot">QBitArray</span></code>, which we will use in the first section of Chapter 21. Finally, there is <code class="sourceCode cpp"><span class="ot">QVarLengthArray</span>&lt;T, Prealloc&gt;</code>, a low-level alternative to <code class="sourceCode cpp"><span class="ot">QVector</span>&lt;T&gt;</code>. Because it preallocates memory on the stack and isn&#8217;t implicitly shared, its overhead is less than that of <code class="sourceCode cpp"><span class="ot">QVector</span>&lt;T&gt;,</code> making it more appropriate for tight loops.</p>
<h3 id="inputoutput">12. Input/Output</h3>
<p>Qt provides excellent support for I/O through <code class="sourceCode cpp"><span class="ot">QIODevice</span></code>, a powerful abstraction that encapsulates &#8220;devices&#8221; capable of reading and writing blocks of bytes. Qt includes the following <code class="sourceCode cpp"><span class="ot">QIODevice</span></code> subclasses:</p>
<table style="width:38%;">
<colgroup>
<col width="13%" />
<col width="23%" />
</colgroup>
<thead>
<tr class="header">
<th>ClassName</th>
<th>ClassDescription</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="ot">QFile</span></code></td>
<td>Accesses files in the local file system and in embedded resources</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="ot">QTemporaryFile</span></code></td>
<td>Creates and accesses temporary files in the local file system</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="ot">QBuffer</span></code></td>
<td>Reads data from or writes data to a QByteArray</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="ot">QProcess</span></code></td>
<td>Runs external programs and handles inter-process communication</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="ot">QTcpSocket</span></code></td>
<td>Transfers a stream of data over the network using TCP</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="ot">QUdpSocket</span></code></td>
<td>Sends or receives UDP datagrams over the network</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="ot">QSslSocket</span></code></td>
<td>Transfers an encrypted data stream over the network using SSL/TLS</td>
</tr>
</tbody>
</table>
<h4 id="reading-and-writing-binary-data">Reading and Writing Binary Data</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// write</span>
<span class="ot">QImage</span> image(<span class="st">&quot;philip.png&quot;</span>);
<span class="ot">QMap</span>&lt;<span class="ot">QString</span>, <span class="ot">QColor</span>&gt; map;
map.insert(<span class="st">&quot;red&quot;</span>, <span class="ot">Qt::</span>red);
map.insert(<span class="st">&quot;green&quot;</span>, <span class="ot">Qt::</span>green);
map.insert(<span class="st">&quot;blue&quot;</span>, <span class="ot">Qt::</span>blue);
<span class="ot">QFile</span> file(<span class="st">&quot;facts.dat&quot;</span>);
<span class="kw">if</span> (!file.open(<span class="ot">QIODevice::</span>WriteOnly)) {
    <span class="co">// file.errorString()</span>
    std::cerr &lt;&lt; <span class="st">&quot;Cannot open file for writing: &quot;</span>
              &lt;&lt; <span class="fu">qPrintable</span>(file.errorString()) &lt;&lt; std::endl;
    <span class="kw">return</span>;
}
<span class="co">// QDataStream standardizes on big-endian by default; this can be changed by</span>
<span class="co">// calling setByteOrder()</span>
<span class="ot">QDataStream</span> out(&amp;file);
out.setVersion(<span class="ot">QDataStream::</span>Qt_4_3);
out &lt;&lt; <span class="dt">quint32</span>(<span class="bn">0x12345678</span>) &lt;&lt; image &lt;&lt; map;

<span class="co">// read</span>
<span class="ot">QFile</span> file(<span class="st">&quot;facts.dat&quot;</span>);
<span class="kw">if</span> (!file.open(<span class="ot">QIODevice::</span>ReadOnly)) {
    std::cerr &lt;&lt; <span class="st">&quot;Cannot open file for reading: &quot;</span>
              &lt;&lt; <span class="fu">qPrintable</span>(file.errorString()) &lt;&lt; std::endl;
    <span class="kw">return</span>;
}
<span class="ot">QDataStream</span> in(&amp;file);
in.setVersion(<span class="ot">QDataStream::</span>Qt_4_3);
in &gt;&gt; n &gt;&gt; image &gt;&gt; map;

<span class="co">// QDataStream can also be used to read and write raw bytes, without any byte</span>
<span class="co">// count header, using readRawBytes() and writeRawBytes()</span></code></pre></div>
<p>The stream has a <code class="sourceCode cpp">status()</code> value that can be <code class="sourceCode cpp"><span class="ot">QDataStream::</span>Ok</code>, <code class="sourceCode cpp"><span class="ot">QDataStream::</span>ReadPastEnd</code>, or <code class="sourceCode cpp"><span class="ot">QDataStream::</span>ReadCorruptData</code>. Once an error has occurred, the <code>&gt;&gt;</code> operator always reads zero or empty values. This means that we can often simply read an entire file without worrying about potential errors and check the <code class="sourceCode cpp">status()</code> value at the end to see if what we read was valid.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// header file</span>
<span class="ot">QDataStream</span> &amp;<span class="kw">operator</span>&lt;&lt;(<span class="ot">QDataStream</span> &amp;out, <span class="dt">const</span> Painting &amp;painting);
<span class="ot">QDataStream</span> &amp;<span class="kw">operator</span>&gt;&gt;(<span class="ot">QDataStream</span> &amp;in, Painting &amp;painting);

<span class="co">// source file</span>
<span class="ot">QDataStream</span> &amp;<span class="kw">operator</span>&lt;&lt;(<span class="ot">QDataStream</span> &amp;out, <span class="dt">const</span> Painting &amp;painting)
{
    out &lt;&lt; painting.title() &lt;&lt; painting.artist()
        &lt;&lt; <span class="dt">quint32</span>(painting.year());
    <span class="kw">return</span> out;
}

<span class="ot">QDataStream</span> &amp;<span class="kw">operator</span>&gt;&gt;(<span class="ot">QDataStream</span> &amp;in, Painting &amp;painting)
{
    <span class="ot">QString</span> title;
    <span class="ot">QString</span> artist;
    <span class="dt">quint32</span> year;
    in &gt;&gt; title &gt;&gt; artist &gt;&gt; year;
    painting = Painting(title, artist, year);
    <span class="kw">return</span> in;
}

<span class="ot">QList</span>&lt;Painting&gt; paintings;
in &gt;&gt; paintings;</code></pre></div>
<p>If the <code class="sourceCode cpp"><span class="ot">QDataStream</span></code> is being used purely to read and write basic C++ data types, we don&#8217;t even need to call <code class="sourceCode cpp">setVersion</code>().</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">The first approach is to embed the <span class="ot">QDataStream</span> version number in the file:
<span class="ot">QDataStream</span> out(&amp;file);
out &lt;&lt; <span class="dt">quint32</span>(MagicNumber) &lt;&lt; <span class="dt">quint16</span>(out.version());

<span class="dt">quint32</span> magic;
<span class="dt">quint16</span> streamVersion;
<span class="ot">QDataStream</span> in(&amp;file);
in &gt;&gt; magic &gt;&gt; streamVersion;
<span class="kw">if</span> (magic != MagicNumber) {
    std::cerr &lt;&lt; <span class="st">&quot;File is not recognized by this application&quot;</span>
              &lt;&lt; std::endl;
} <span class="kw">else</span> <span class="kw">if</span> (streamVersion &gt; in.version()) {
    std::cerr &lt;&lt; <span class="st">&quot;File is from a more recent version of the &quot;</span>
              &lt;&lt; <span class="st">&quot;application&quot;</span> &lt;&lt; std::endl;
    <span class="kw">return</span> <span class="kw">false</span>;
}

in.setVersion(streamVersion);</code></pre></div>
<p>In summary, there are three policies for handling <code class="sourceCode cpp"><span class="ot">QDataStream</span></code> versions:</p>
<ol>
<li>hard-coding the version number,</li>
<li>explicitly writing and reading the version number, and</li>
<li>using different hard-coded version numbers depending on the application&#8217;s version.</li>
</ol>
<p>Any of these policies can be used to ensure that data written by an old version of an application can be read by a new version, even if the new version links against a more recent version of Qt. Once we have chosen a policy for handling <code class="sourceCode cpp"><span class="ot">QDataStream</span></code> versions, reading and writing binary data using Qt is both simple and reliable.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> copyFile(<span class="dt">const</span> <span class="ot">QString</span> &amp;source, <span class="dt">const</span> <span class="ot">QString</span> &amp;dest)
{
<span class="ot">QFile</span> sourceFile(source);
<span class="kw">if</span> (!sourceFile.open(<span class="ot">QIODevice::</span>ReadOnly))
    <span class="kw">return</span> <span class="kw">false</span>;
<span class="ot">QFile</span> destFile(dest);
<span class="kw">if</span> (!destFile.open(<span class="ot">QIODevice::</span>WriteOnly))
    <span class="kw">return</span> <span class="kw">false</span>;
destFile.write(sourceFile.readAll());
<span class="kw">return</span> sourceFile.error() == <span class="ot">QFile::</span>NoError
       &amp;&amp; destFile.error() == <span class="ot">QFile::</span>NoError;
}</code></pre></div>
<p><code class="sourceCode cpp">peek()</code>, <code class="sourceCode cpp">seek()</code>, <code class="sourceCode cpp">ungetChar()</code>.</p>
<h4 id="reading-and-writing-text">Reading and Writing Text</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QFile</span> file(<span class="st">&quot;sf-book.txt&quot;</span>);
<span class="kw">if</span> (!file.open(<span class="ot">QIODevice::</span>WriteOnly)) {
    std::cerr &lt;&lt; <span class="st">&quot;Cannot open file for writing: &quot;</span>
              &lt;&lt; <span class="fu">qPrintable</span>(file.errorString()) &lt;&lt; std::endl;
    <span class="kw">return</span>;
}
<span class="ot">QTextStream</span> out(&amp;file);
out &lt;&lt; <span class="st">&quot;Thomas M. Disch: &quot;</span> &lt;&lt; <span class="dv">334</span> &lt;&lt; endl;</code></pre></div>
<p><code class="sourceCode cpp"><span class="ot">QTextStream::</span>readAll()</code>, <code class="sourceCode cpp">stream.setCodec(<span class="st">&quot;UTF-8&quot;</span>);</code></p>
<p><code class="sourceCode cpp">showbase</code>, <code class="sourceCode cpp">uppercasedigits</code>, and <code class="sourceCode cpp">hex</code> options before it outputs the integer 12345678, producing the text &#8220;0xBC614E&#8221;:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Options can also be set using member functions</span>
out.setNumberFlags(<span class="ot">QTextStream::</span>ShowBase
                    | <span class="ot">QTextStream::</span>UppercaseDigits);
out.setIntegerBase(<span class="dv">16</span>);
out &lt;&lt; <span class="dv">12345678</span>;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QTextStream</span> in(<span class="st">&quot;0x50 0x20&quot;</span>);
<span class="dt">int</span> firstNumber, secondNumber;

in &gt;&gt; firstNumber;             <span class="co">// firstNumber == 80</span>
in &gt;&gt; dec &gt;&gt; secondNumber;     <span class="co">// secondNumber == 0</span>

<span class="dt">char</span> ch;
in &gt;&gt; ch;                      <span class="co">// ch == &#39;x&#39;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QTextStream</span> stream(stdin);
<span class="ot">QString</span> line;
<span class="kw">do</span> {
    <span class="co">// read chunk: readLine() or readAll()</span>
    line = stream.readLine();
} <span class="kw">while</span> (!line.isNull());</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QTextStream</span> in(<span class="st">&quot;0x50 0x20&quot;</span>);
<span class="dt">int</span> firstNumber, secondNumber;

in &gt;&gt; firstNumber;             <span class="co">// firstNumber == 80</span>
in &gt;&gt; dec &gt;&gt; secondNumber;     <span class="co">// secondNumber == 0</span>

<span class="dt">char</span> ch;
in &gt;&gt; ch;                      <span class="co">// ch == &#39;x&#39;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
    <span class="co">// read numeric arguments (123, 0x20, 4.5...)</span>
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; argc; ++i) {
        <span class="dt">int</span> number;
        <span class="ot">QTextStream</span> in(argv[i]);
        in &gt;&gt; number;
        ...
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QTextStream</span> out(&amp;file);
out.setCodec(<span class="st">&quot;UTF-8&quot;</span>);</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QString</span> s;
<span class="ot">QTextStream</span> out(&amp;s);
out.setFieldWidth(<span class="dv">10</span>);
out.setFieldAlignment(<span class="ot">QTextStream::</span>AlignCenter);
out.setPadChar(<span class="st">&#39;-&#39;</span>);
out &lt;&lt; <span class="st">&quot;Qt&quot;</span> &lt;&lt; <span class="st">&quot;rocks!&quot;</span>;
<span class="co">// ----Qt------rocks!--</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">stream &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span> &lt;&lt; flush;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QTextStream</span> in(&amp;file);
<span class="kw">while</span> (!in.atEnd()) {
    <span class="ot">QString</span> line = in.readLine();
    <span class="ot">QStringList</span> fields = line.split(<span class="st">&#39; &#39;</span>);
    <span class="kw">if</span> (fields.size() &gt;= <span class="dv">3</span>) {
        <span class="co">// T QLinkedList::takeFirst(), Removes the first item in the list and</span>
        <span class="co">// returns it</span>
        <span class="dt">int</span> row = fields.takeFirst().toInt();
        <span class="dt">int</span> column = fields.takeFirst().toInt();
        setFormula(row, column, fields.join(<span class="st">&#39; &#39;</span>));
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> tidyFile(<span class="ot">QIODevice</span> *inDevice, <span class="ot">QIODevice</span> *outDevice)
{
    <span class="ot">QTextStream</span> in(inDevice);
    <span class="ot">QTextStream</span> out(outDevice);

    <span class="dt">const</span> <span class="dt">int</span> TabSize = <span class="dv">8</span>;
    <span class="dt">int</span> endlCount = <span class="dv">0</span>;
    <span class="dt">int</span> spaceCount = <span class="dv">0</span>;
    <span class="dt">int</span> column = <span class="dv">0</span>;
    <span class="ot">QChar</span> ch;

    <span class="kw">while</span> (!in.atEnd()) {
        in &gt;&gt; ch;

        <span class="kw">if</span> (ch == <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>) {
            ++endlCount;
            spaceCount = <span class="dv">0</span>;
            column = <span class="dv">0</span>;
        } <span class="kw">else</span> <span class="kw">if</span> (ch == <span class="st">&#39;</span><span class="ch">\t</span><span class="st">&#39;</span>) {
            <span class="dt">int</span> size = TabSize - (column % TabSize);
            spaceCount += size;
            column += size;
        } <span class="kw">else</span> <span class="kw">if</span> (ch == <span class="st">&#39; &#39;</span>) {
            ++spaceCount;
            ++column;
        } <span class="kw">else</span> {
            <span class="kw">while</span> (endlCount &gt; <span class="dv">0</span>) {
                out &lt;&lt; endl;
                --endlCount;
                column = <span class="dv">0</span>;
            }
            <span class="kw">while</span> (spaceCount &gt; <span class="dv">0</span>) {
                out &lt;&lt; <span class="st">&#39; &#39;</span>;
                --spaceCount;
                ++column;
            }
            out &lt;&lt; ch;
            ++column;
        }
    }
    out &lt;&lt; endl;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QFile</span> inFile;
<span class="ot">QFile</span> outFile;

inFile.open(stdin, <span class="ot">QFile::</span>ReadOnly);
outFile.open(stdout, <span class="ot">QFile::</span>WriteOnly);

tidyFile(&amp;inFile, &amp;outFile);</code></pre></div>
<h4 id="traversing-directories">Traversing Directories</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;QtGui&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">qlonglong</span> imageSpace(<span class="dt">const</span> <span class="ot">QString</span> &amp;path)
{
    <span class="co">// QDir::homePath()</span>
    <span class="ot">QDir</span> dir(path);
    <span class="dt">qlonglong</span> size = <span class="dv">0</span>;

    <span class="ot">QStringList</span> filters;
    <span class="kw">foreach</span> (<span class="ot">QByteArray</span> format, <span class="ot">QImageReader::</span>supportedImageFormats())
        filters += <span class="st">&quot;*.&quot;</span> + format;

    <span class="co">// QDir treats &#39;/&#39; as a directory separator on all platforms, in addition</span>
    <span class="co">// to recognizing &#39;\&#39; on Windows</span>
    <span class="kw">foreach</span> (<span class="ot">QString</span> file, dir.entryList(filters, <span class="ot">QDir::</span>Files))
        size += <span class="ot">QFileInfo</span>(dir, file).size();

    <span class="kw">foreach</span> (<span class="ot">QString</span> subDir, dir.entryList(<span class="ot">QDir::</span>Dirs
                                           | <span class="ot">QDir::</span>NoDotAndDotDot))
        size += imageSpace(path + <span class="ot">QDir::</span>separator() + subDir);

    <span class="kw">return</span> size;
}

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
    <span class="ot">QCoreApplication</span> app(argc, argv);
    <span class="ot">QStringList</span> args = <span class="ot">QCoreApplication::</span>arguments();

    <span class="ot">QString</span> path = <span class="ot">QDir::</span>currentPath();
    <span class="kw">if</span> (args.count() &gt; <span class="dv">1</span>)
        path = args[<span class="dv">1</span>];

    std::cout &lt;&lt; <span class="st">&quot;Space used by images in &quot;</span> &lt;&lt; <span class="fu">qPrintable</span>(path)
              &lt;&lt; <span class="st">&quot; and its subdirectories is &quot;</span>
              &lt;&lt; (imageSpace(path) / <span class="dv">1024</span>) &lt;&lt; <span class="st">&quot; KB&quot;</span> &lt;&lt; std::endl;

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p><code class="sourceCode cpp"><span class="ot">QDir::</span>toNativeSeparators()</code></p>
<p>And the <code class="sourceCode cpp"><span class="ot">QFileSystemWatcher</span></code> class can notify us when a change occurs to a directory or to a file, by emitting <code class="sourceCode cpp">directoryChanged()</code> and <code class="sourceCode cpp">fileChanged()</code> signals.</p>
<h4 id="embedding-resources">Embedding Resources</h4>
<p><code>.pro</code></p>
<pre><code>RESOURCES = myresourcefile.qrc</code></pre>
<p><code>.qrc</code></p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;RCC&gt;</span>
<span class="kw">&lt;qresource&gt;</span>
<span class="kw">&lt;file&gt;</span>datafiles/phone-codes.dat<span class="kw">&lt;/file&gt;</span>
<span class="kw">&lt;/qresource&gt;</span>
<span class="kw">&lt;/RCC&gt;</span></code></pre></div>
<h4 id="inter-process-communication">Inter-Process Communication</h4>
<p>The <code class="sourceCode cpp"><span class="ot">QProcess</span></code> class allows us to run external programs and to interact with them. The class works asynchronously, doing its work in the background so that the user interface remains responsive. <code class="sourceCode cpp"><span class="ot">QProcess</span></code> emits signals to notify us when the external process has data or has finished.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;QDialog&gt;</span>
<span class="ot">#include &lt;QProcess&gt;</span>

<span class="ot">#include &quot;ui_convertdialog.h&quot;</span>

<span class="kw">class</span> ConvertDialog : <span class="kw">public</span> <span class="ot">QDialog</span>, <span class="kw">private</span> Ui::ConvertDialog
{
    <span class="kw">Q_OBJECT</span>

<span class="kw">public</span>:
    ConvertDialog(<span class="ot">QWidget</span> *parent = <span class="dv">0</span>);

<span class="kw">private</span> <span class="kw">slots</span>:
    <span class="dt">void</span> on_browseButton_clicked();
    <span class="dt">void</span> convertImage();
    <span class="dt">void</span> updateOutputTextEdit();
    <span class="dt">void</span> processFinished(<span class="dt">int</span> exitCode, <span class="ot">QProcess::</span>ExitStatus exitStatus);
    <span class="dt">void</span> processError(<span class="ot">QProcess::</span>ProcessError error);

<span class="kw">private</span>:
    <span class="ot">QProcess</span> process;
    <span class="ot">QString</span> targetFile;
};

<span class="co">// The Browse button&#39;s clicked() signal is automatically connected to the</span>
<span class="co">// on_browseButton_clicked() slot by setupUi()</span>
<span class="fu">connect</span>(&amp;process, <span class="kw">SIGNAL</span>(readyReadStandardError()),
        <span class="kw">this</span>, <span class="kw">SLOT</span>(updateOutputTextEdit()));
<span class="fu">connect</span>(&amp;process, <span class="kw">SIGNAL</span>(finished(<span class="dt">int</span>, <span class="ot">QProcess::</span>ExitStatus)),
        <span class="kw">this</span>, <span class="kw">SLOT</span>(processFinished(<span class="dt">int</span>, <span class="ot">QProcess::</span>ExitStatus)));
<span class="fu">connect</span>(&amp;process, <span class="kw">SIGNAL</span>(error(<span class="ot">QProcess::</span>ProcessError)),
        <span class="kw">this</span>, <span class="kw">SLOT</span>(processError(<span class="ot">QProcess::</span>ProcessError)));

fileName = <span class="ot">QDir::</span>toNativeSeparators(fileName);

<span class="dt">void</span> ConvertDialog::convertImage()
{
    <span class="ot">QString</span> sourceFile = sourceFileEdit-&gt;text();
    targetFile = <span class="ot">QFileInfo</span>(sourceFile).path() + <span class="ot">QDir::</span>separator()
                 + <span class="ot">QFileInfo</span>(sourceFile).baseName() + <span class="st">&quot;.&quot;</span>
                 + targetFormatComboBox-&gt;currentText().toLower();
    buttonBox-&gt;button(<span class="ot">QDialogButtonBox::</span>Ok)-&gt;setEnabled(<span class="kw">false</span>);
    outputTextEdit-&gt;clear();

    <span class="ot">QStringList</span> args;
    <span class="kw">if</span> (enhanceCheckBox-&gt;isChecked())
        args &lt;&lt; <span class="st">&quot;-enhance&quot;</span>;
    <span class="kw">if</span> (monochromeCheckBox-&gt;isChecked())
        args &lt;&lt; <span class="st">&quot;-monochrome&quot;</span>;
    args &lt;&lt; sourceFile &lt;&lt; targetFile;

    <span class="co">// Async: QProcess:start( cmd, args(stringList) );</span>
    process.start(<span class="st">&quot;convert&quot;</span>, args);
}

<span class="dt">void</span> ConvertDialog::processFinished(<span class="dt">int</span> exitCode,
                                    <span class="ot">QProcess::</span>ExitStatus exitStatus)
{
    <span class="kw">if</span> (exitStatus == <span class="ot">QProcess::</span>CrashExit) {
        outputTextEdit-&gt;append(<span class="fu">tr</span>(<span class="st">&quot;Conversion program crashed&quot;</span>));
    } <span class="kw">else</span> <span class="kw">if</span> (exitCode != <span class="dv">0</span>) {
        outputTextEdit-&gt;append(<span class="fu">tr</span>(<span class="st">&quot;Conversion failed&quot;</span>));
    } <span class="kw">else</span> {
        outputTextEdit-&gt;append(<span class="fu">tr</span>(<span class="st">&quot;File %1 created&quot;</span>).arg(targetFile));
    }
    <span class="co">// button of buttonBox</span>
    buttonBox-&gt;button(<span class="ot">QDialogButtonBox::</span>Ok)-&gt;setEnabled(<span class="kw">true</span>);
}

<span class="co">// Whenever the external process writes to cerr, the updateOutputTextEdit()</span>
<span class="co">// slot is called. We read the error text and add it to the QTextEdit&#39;s</span>
<span class="co">// existing text.</span>
<span class="dt">void</span> ConvertDialog::updateOutputTextEdit()
{
    <span class="ot">QByteArray</span> newData = process.readAllStandardError();
    <span class="ot">QString</span> text = outputTextEdit-&gt;toPlainText()
                   + <span class="ot">QString::</span>fromLocal8Bit(newData);
    outputTextEdit-&gt;setPlainText(text);
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">process-&gt;execute(<span class="st">&quot;C:/Users/Administrator/Documents/build-DogHouse-NTFS-Debug/d.exe&quot;</span>, <span class="ot">QStringList</span>()&lt;&lt;<span class="st">&quot;a&quot;</span>&lt;&lt;<span class="st">&quot;b&quot;</span>);</code></pre></div>
<p><code class="sourceCode cpp"><span class="ot">QTemporaryFile::</span>open()</code>, since it conveniently defaults to opening in read-write mode, there is no need to specify filename and mode. The <code class="sourceCode cpp"><span class="ot">QProcess::</span>execute()</code> static function runs an external process and blocks until the process has finished.</p>
<p>In this section, we used <code class="sourceCode cpp"><span class="ot">QProcess</span></code> to give us access to preexisting functionality. Using applications that already exist can save development time and can insulate us from the details of issues that are of marginal interest to our main application&#8217;s purpose. Another way to access preexisting functionality is to link against a library that provides it. But where no suitable library exists, wrapping a console application using <code class="sourceCode cpp"><span class="ot">QProcess</span></code> can work well. Another use of QProcess is to launch other GUI applications. However, if our aim is communication between applications rather than simply running one from another, we might be better off having them communicate directly, using Qt&#8217;s networking classes or the ActiveQt extension on Windows. And if we want to launch the user&#8217;s preferred web browser or email client, we can simply call <code class="sourceCode cpp"><span class="ot">QDesktopServices::</span>openUrl()</code>.</p>
<h3 id="databases">13. Databases</h3>
<ul>
<li>&#9744; TODO</li>
</ul>
<h4 id="connecting-and-querying">Connecting and Querying</h4>
<h4 id="viewing-tables">Viewing Tables</h4>
<h4 id="editing-records-using-forms">Editing Records Using Forms</h4>
<h4 id="presenting-data-in-tabular-forms">Presenting Data in Tabular Forms</h4>
<h3 id="multithreading">14. Multithreading</h3>
<h4 id="creating-threads">Creating Threads</h4>
<h4 id="synchronizing-threads">Synchronizing Threads</h4>
<h4 id="communicating-with-the-main-thread">Communicating with the Main Thread</h4>
<h4 id="using-qts-classes-in-secondary-threads">Using Qt&#8217;s Classes in Secondary Threads</h4>
<h3 id="networking">15. Networking</h3>
<h4 id="writing-ftp-clients">Writing FTP Clients</h4>
<h4 id="writing-http-clients">Writing HTTP Clients</h4>
<h4 id="writing-tcp-clientserver-applications">Writing TCP Client&#8211;Server Applications</h4>
<h4 id="sending-and-receiving-udp-datagrams">Sending and Receiving UDP Datagrams</h4>
<h3 id="xml">16. XML</h3>
<p>[DO!!!]</p>
<h4 id="reading-xml-with-qxmlstreamreader">Reading XML with QXmlStreamReader</h4>
<h4 id="reading-xml-with-dom">Reading XML with DOM</h4>
<h4 id="reading-xml-with-sax">Reading XML with SAX</h4>
<h4 id="writing-xml">Writing XML</h4>
<h3 id="providing-online-help">17. Providing Online Help</h3>
<h4 id="tooltips-status-tips-and-whats-this-help">Tooltips, Status Tips, and &#8220;What&#8217;s This?&#8221; Help</h4>
<p>A tooltip is a small piece of text that appears when the mouse hovers over a widget for a certain period of time. Tooltips are presented with black text on a yellow background. Their primary use is to provide textual descriptions of toolbar buttons.</p>
<p>We can add tooltips to arbitrary widgets in code using <code class="sourceCode cpp"><span class="ot">QWidget::</span>setToolTip()</code>. For example: <code class="sourceCode cpp">findButton-&gt;setToolTip(<span class="fu">tr</span>(<span class="st">&quot;Find next&quot;</span>));</code>.</p>
<p>If we don&#8217;t explicitly set a tooltip, <code class="sourceCode cpp"><span class="ot">QAction</span></code> will automatically use the action text. A status tip is also a short piece of descriptive text, usually a little longer than a tooltip. When the mouse hovers over a toolbar button or a menu option, a status tip appears in the status bar. Call <code class="sourceCode cpp">setStatusTip()</code> to add a status tip to an action or to a widget: <code class="sourceCode cpp">newAction-&gt;setStatusTip(<span class="fu">tr</span>(<span class="st">&quot;Create a new document&quot;</span>));</code>.</p>
<p>To enter &#8220;What&#8217;s This?&#8221; mode, the user can either click the <kbd>?</kbd> button in the dialog&#8217;s title bar (on Windows and KDE) or press <kbd>Shift+F1<kbd>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">dialog-&gt;setWhatsThis(<span class="fu">tr</span>(<span class="st">&quot;&lt;img  src=</span><span class="ch">\&quot;</span><span class="st">:/images/icon.png</span><span class="ch">\&quot;</span><span class="st">&gt;&quot;</span>
        <span class="st">&quot;&amp;nbsp;The meaning of the Source field depends &quot;</span>
        <span class="st">&quot;on the Type field:&quot;</span>
        <span class="st">&quot;&lt;ul&gt;&quot;</span>
        <span class="st">&quot;&lt;li&gt;&lt;b&gt;Books&lt;/b&gt; have a Publisher&quot;</span>
        <span class="st">&quot;&lt;li&gt;&lt;b&gt;Articles&lt;/b&gt; have a Journal name with &quot;</span>
        <span class="st">&quot;volume and issue number&quot;</span>
        <span class="st">&quot;&lt;li&gt;&lt;b&gt;Theses&lt;/b&gt; have an Institution name &quot;</span>
        <span class="st">&quot;and a Department name&quot;</span>
        <span class="st">&quot;&lt;/ul&gt;&quot;</span>));</code></pre></div>
<h4 id="using-a-web-browser-to-provide-online-help">Using a Web Browser to Provide Online Help</h4>
<p>The application&#8217;s main window will typically have a <code class="sourceCode cpp">help()</code> slot that is called when the user presses F1 or clicks the <kbd>Help|Help</kbd> menu option.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::help()
{
    <span class="ot">QUrl</span> url(directoryOf(<span class="st">&quot;doc&quot;</span>).absoluteFilePath(<span class="st">&quot;index.html&quot;</span>));
    url.setScheme(<span class="st">&quot;file&quot;</span>);
    <span class="ot">QDesktopServices::</span>openUrl(url); <span class="co">// launch the user&#39;s web browser</span>
}

<span class="ot">QDir</span> MainWindow::directoryOf(<span class="dt">const</span> <span class="ot">QString</span> &amp;subdir)
{
    <span class="ot">QDir</span> dir(<span class="ot">QApplication::</span>applicationDirPath());
<span class="ot">#if defined(Q_OS_WIN)</span>
    <span class="kw">if</span> (dir.dirName().toLower() == <span class="st">&quot;debug&quot;</span>
        || dir.dirName().toLower() == <span class="st">&quot;release&quot;</span>)
        dir.cdUp();
<span class="ot">#elif defined(Q_OS_MAC)</span>
    <span class="kw">if</span> (dir.dirName() == <span class="st">&quot;MacOS&quot;</span>) {
        dir.cdUp();
        dir.cdUp();
        dir.cdUp();
    }
<span class="ot">#endif</span>
    dir.cd(subdir);
    <span class="kw">return</span> dir;
}

<span class="dt">void</span> EntryDialog::help()
{
    <span class="ot">QUrl</span> url(directoryOf(<span class="st">&quot;doc&quot;</span>).absoluteFilePath(<span class="st">&quot;forms.html&quot;</span>));
    url.setScheme(<span class="st">&quot;file&quot;</span>);                  <span class="co">// scheme: file://path/to/html</span>
    url.setFragment(<span class="st">&quot;editing&quot;</span>);             <span class="co">// #editing</span>
    <span class="ot">QDesktopServices::</span>openUrl(url);
}</code></pre></div>
<h4 id="using-qtextbrowser-as-a-simple-help-engine">Using QTextBrowser as a Simple Help Engine</h4>
<p>We set the <code class="sourceCode cpp"><span class="ot">Qt::</span>WA_GroupLeader</code> attribute because we want to pop up HelpBrowser windows from modal dialogs in addition to the main window. Modal dialogs normally prevent the user from interacting with any other window in the application. However, after requesting help, the user must obviously be allowed to interact with both the modal dialog and the help browser. Setting the <code class="sourceCode cpp"><span class="ot">Qt::</span>WA_GroupLeader</code> attribute makes this interaction possible.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> HelpBrowser::updateWindowTitle()
{
    setWindowTitle(<span class="fu">tr</span>(<span class="st">&quot;Help: %1&quot;</span>).arg(textBrowser-&gt;documentTitle()));
}</code></pre></div>
<h4 id="using-qt-assistant-for-powerful-online-help">Using Qt Assistant for Powerful Online Help</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> (!assistant)
    assistant = <span class="kw">new</span> QAssistantClient(<span class="st">&quot;&quot;</span>);
    assistant-&gt;showPage(path);</code></pre></div>
<h2 id="part-iii-advanced-qt">Part III: Advanced Qt</h2>
<h3 id="internationalization">18. Internationalization</h3>
<h4 id="working-with-unicode">Working with Unicode</h4>
<dl>
<dt><code class="sourceCode cpp"><span class="ot">QTextCodec::</span>setCodecForTr(<span class="ot">QTextCodec::</span>codecForName(<span class="st">&quot;utf8&quot;</span>));</code></dt>
<dd><p>This must be done before the first call to <code class="sourceCode cpp"><span class="fu">tr</span>()</code>. Typically, we would do this in <code class="sourceCode cpp">main()</code>, immediately after the <code class="sourceCode cpp"><span class="ot">QCoreApplication</span></code> or <code class="sourceCode cpp"><span class="ot">QApplication</span></code> object is created.</p>
<p>Alternatively, they can tell Qt to use a specific codec when converting between <code>const char *</code> and <code class="sourceCode cpp"><span class="ot">QString</span></code> by calling <code class="sourceCode cpp"><span class="ot">QTextCodec::</span>setCodecForCStrings()</code>, e.g., <code class="sourceCode cpp"><span class="ot">QTextCodec::</span>setCodecForCStrings(<span class="ot">QTextCodec::</span>codecForName(<span class="st">&quot;utf8&quot;</span>));</code>.</p>
</dd>
</dl>
<h4 id="making-applications-translation-aware">Making Applications Translation-Aware</h4>
<p>A <code class="sourceCode cpp"><span class="fu">tr</span>()</code> call has the following general syntax: <code class="sourceCode cpp">Context::<span class="fu">tr</span>(sourceText, comment)</code></p>
<p>The most general way of translating a string in Qt is to use the <code class="sourceCode cpp"><span class="ot">QCoreApplication::</span>translate()</code> function, which accepts up to three arguments: the context, the source text, and the optional comment. For example, here&#8217;s another way to translate &#8220;Hello Qt!&#8221;: <code class="sourceCode cpp"><span class="ot">QCoreApplication::</span>translate(<span class="st">&quot;Global Stuff&quot;</span>, <span class="st">&quot;Hello Qt!&quot;</span>)</code> This time, we put the text in the &#8220;Global Stuff&#8221; context.</p>
<p>See <code class="sourceCode cpp">statusBar()-&gt;showMessage(<span class="fu">tr</span>(<span class="st">&quot;Host &quot;</span> + hostName + <span class="st">&quot; found&quot;</span>));</code>. Here, the string we pass to <code class="sourceCode cpp"><span class="fu">tr</span>()</code> varies depending on the value of hostName, so we can&#8217;t reasonably expect <code class="sourceCode cpp"><span class="fu">tr</span>()</code> to translate it correctly. The solution is to use <code class="sourceCode cpp"><span class="ot">QString::</span>arg()</code>: <code class="sourceCode cpp">statusBar()-&gt;showMessage(<span class="fu">tr</span>(<span class="st">&quot;Host %1 found&quot;</span>).arg(hostName));</code>.</p>
<p>Although it is generally inadvisable to call <code class="sourceCode cpp"><span class="fu">tr</span>()</code> on a variable, it can be made to work. We must use the <code class="sourceCode cpp"><span class="kw">QT_TR_NOOP</span>()</code> macro to mark the string literals for translation before we assign them to a variable. This is mostly useful for static arrays of strings. For example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> OrderForm::init()
{
<span class="dt">static</span> <span class="dt">const</span> <span class="dt">char</span> * <span class="dt">const</span> flowers[] = {
    <span class="kw">QT_TR_NOOP</span>(<span class="st">&quot;Medium Stem Pink Roses&quot;</span>),
    <span class="kw">QT_TR_NOOP</span>(<span class="st">&quot;One Dozen Boxed Roses&quot;</span>),
    <span class="kw">QT_TR_NOOP</span>(<span class="st">&quot;Calypso Orchid&quot;</span>),
    <span class="kw">QT_TR_NOOP</span>(<span class="st">&quot;Dried Red Rose Bouquet&quot;</span>),
    <span class="kw">QT_TR_NOOP</span>(<span class="st">&quot;Mixed Peonies Bouquet&quot;</span>),
    <span class="dv">0</span>
};

<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; flowers[i]; ++i)
    comboBox-&gt;addItem(<span class="fu">tr</span>(flowers[i]));
}</code></pre></div>
<p>Here is also a <code class="sourceCode cpp"><span class="kw">QT_TRANSLATE_NOOP</span>()</code> macro that works like <code class="sourceCode cpp"><span class="kw">QT_TR_NOOP</span>()</code> but also takes a context. This macro is useful when initializing variables outside of a class:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">static</span> <span class="dt">const</span> <span class="dt">char</span> * <span class="dt">const</span> flowers[] = {
    <span class="kw">QT_TRANSLATE_NOOP</span>(<span class="st">&quot;OrderForm&quot;</span>, <span class="st">&quot;Medium Stem Pink Roses&quot;</span>),
    <span class="kw">QT_TRANSLATE_NOOP</span>(<span class="st">&quot;OrderForm&quot;</span>, <span class="st">&quot;One Dozen Boxed Roses&quot;</span>),
    <span class="kw">QT_TRANSLATE_NOOP</span>(<span class="st">&quot;OrderForm&quot;</span>, <span class="st">&quot;Calypso Orchid&quot;</span>),
    <span class="kw">QT_TRANSLATE_NOOP</span>(<span class="st">&quot;OrderForm&quot;</span>, <span class="st">&quot;Dried Red Rose Bouquet&quot;</span>),
    <span class="kw">QT_TRANSLATE_NOOP</span>(<span class="st">&quot;OrderForm&quot;</span>, <span class="st">&quot;Mixed Peonies Bouquet&quot;</span>),
    <span class="dv">0</span>
};</code></pre></div>
<p>Telling Qt to forbid implicit conversions from <code>const char *</code> to <code class="sourceCode cpp"><span class="ot">QString</span></code>, we do this by defining the <code class="sourceCode cpp"><span class="kw">QT_NO_CAST_FROM_ASCII</span></code> preprocessor symbol before including any Qt header. The easiest way to ensure that this symbol is set is to add the following line to the application&#8217;s <code>.pro</code> file:</p>
<pre><code>DEFINES += QT_NO_CAST_FROM_ASCII</code></pre>
<h4 id="dynamic-language-switching">Dynamic Language Switching</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
    <span class="ot">QApplication</span> app(argc, argv);
    ...
    <span class="ot">QTranslator</span> appTranslator;
    appTranslator.load(<span class="st">&quot;myapp_&quot;</span> + <span class="ot">QLocale::</span>system().name(), qmPath);
    app.installTranslator(&amp;appTranslator);
    ...
    <span class="kw">return</span> app.exec();
}</code></pre></div>
<p><code class="sourceCode cpp"><span class="ot">QString::</span>localeAwareCompare()</code> compares two strings in a locale-dependent manner. It is useful for sorting user-visible items. The <code class="sourceCode cpp">toString()</code> function provided by <code class="sourceCode cpp"><span class="ot">QDate</span></code>, <code class="sourceCode cpp"><span class="ot">QTime</span></code>, and <code class="sourceCode cpp"><span class="ot">QDateTime</span></code> returns a string in a local format when called with <code class="sourceCode cpp"><span class="ot">Qt::</span>LocalDate</code> as its argument. By default, the <code class="sourceCode cpp"><span class="ot">QDateEdit</span></code> and <code class="sourceCode cpp"><span class="ot">QDateTimeEdit</span></code> widgets present dates in the local format.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">qApp</span>-&gt;installTranslator(&amp;appTranslator);
<span class="kw">qApp</span>-&gt;installTranslator(&amp;qtTranslator);</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> MainWindow::createLanguageMenu()
{
    languageMenu = <span class="kw">new</span> <span class="ot">QMenu</span>(<span class="kw">this</span>);
    languageActionGroup = <span class="kw">new</span> <span class="ot">QActionGroup</span>(<span class="kw">this</span>);
    <span class="fu">connect</span>(languageActionGroup, <span class="kw">SIGNAL</span>(triggered(<span class="ot">QAction</span> *)),
    <span class="kw">this</span>, <span class="kw">SLOT</span>(switchLanguage(<span class="ot">QAction</span> *)));
    <span class="ot">QDir</span> qmDir = directoryOf(<span class="st">&quot;translations&quot;</span>);
    <span class="ot">QStringList</span> fileNames =
    qmDir.entryList(<span class="ot">QStringList</span>(<span class="st">&quot;callcenter_*.qm&quot;</span>));
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; fileNames.size(); ++i) {
        <span class="ot">QString</span> locale = fileNames[i];
        locale.remove(<span class="dv">0</span>, locale.indexOf(<span class="st">&#39;_&#39;</span>) + <span class="dv">1</span>);
        locale.chop(<span class="dv">3</span>);
        <span class="ot">QTranslator</span> translator;
        translator.load(fileNames[i], qmDir.absolutePath());
        <span class="ot">QString</span> language = translator.translate(<span class="st">&quot;MainWindow&quot;</span>, <span class="st">&quot;English&quot;</span>);
        <span class="ot">QAction</span> *action = <span class="kw">new</span> <span class="ot">QAction</span>(
                <span class="fu">tr</span>(<span class="st">&quot;&amp;%1 %2&quot;</span>).arg(i + <span class="dv">1</span>).arg(language), <span class="kw">this</span>);
        action-&gt;setCheckable(<span class="kw">true</span>);
        action-&gt;setData(locale);
        languageMenu-&gt;addAction(action);
        languageActionGroup-&gt;addAction(action);
        <span class="kw">if</span> (language == <span class="st">&quot;English&quot;</span>)
            action-&gt;setChecked(<span class="kw">true</span>);
    }
}

<span class="dt">void</span> MainWindow::switchLanguage(<span class="ot">QAction</span> *action)
{
    <span class="ot">QString</span> locale = action-&gt;data().toString();
    <span class="ot">QString</span> qmPath = directoryOf(<span class="st">&quot;translations&quot;</span>).absolutePath();
    appTranslator.load(<span class="st">&quot;callcenter_&quot;</span> + locale, qmPath);
    qtTranslator.load(<span class="st">&quot;qt_&quot;</span> + locale, qmPath);
    retranslateUi();
}

<span class="dt">void</span> JournalView::changeEvent(<span class="ot">QEvent</span> *event)
{
    <span class="kw">if</span> (event-&gt;type() == <span class="ot">QEvent::</span>LanguageChange)
        retranslateUi();
    <span class="ot">QTableWidget::</span>changeEvent(event);
}</code></pre></div>
<h4 id="translating-applications">Translating Applications</h4>
<p>Translating a Qt application that contains <code class="sourceCode cpp"><span class="fu">tr</span>()</code> calls is a three-step process:</p>
<ol style="list-style-type: decimal">
<li>Run <code class="sourceCode bash"><span class="kw">lupdate</span></code> to extract all the user-visible strings from the application&#8217;s source code. (developers)</li>
<li>Translate the application using Qt Linguist. (translators)</li>
<li>Run <code class="sourceCode bash"><span class="kw">lrelease</span></code> to generate binary <code>.qm</code> files that the application can load using QTranslator. (developers)</li>
</ol>
<pre><code>TRANSLATIONS = spreadsheet_zh.ts</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">lupdate</span> -verbose spreadsheet.pro
<span class="kw">//</span> outcame ts files

$ <span class="kw">lrelease</span> -verbose spreadsheet.pro
<span class="kw">//</span> outcame qm files</code></pre></div>
<h3 id="look-and-feel-customization">19. Look and Feel Customization</h3>
<h4 id="using-qt-style-sheets">Using Qt Style Sheets</h4>
<ol>
<li>cmd: <code class="sourceCode bash"><span class="kw">qtprogram.exe</span> -stylesheet file.qss</code></li>
<li>Qt Designer&#8217;s style sheet editor</li>
<li>embedding a <code class="sourceCode cpp"><span class="ot">QTextEdit</span></code> inside our application during development</li>
</ol>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">qApp</span>-&gt;setStyleSheet(<span class="st">&quot;QLineEdit { background-color: yellow; }&quot;</span>);</code></pre></div>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css">QCheckBox, QComboBox, QLineEdit, QListView, QRadioButton, QSpinBox <span class="kw">{</span>
    <span class="kw">color:</span> <span class="dt">#050505</span><span class="kw">;</span>
    <span class="kw">background-color:</span> <span class="dt">yellow</span><span class="kw">;</span>
<span class="kw">}</span></code></pre></div>
<p><code class="sourceCode cpp"><span class="ot">QColor::</span>setNamedColor()</code></p>
<p>Instead of a uniform color, we can also specify a palette entry or a gradient:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QLineEdit</span> {
    color: palette(Base);
    background-color: qlineargradient(x1: <span class="dv">0</span>, y1: <span class="dv">0</span>, x2: <span class="dv">1</span>, y2: <span class="dv">1</span>, stop: <span class="dv">0</span> white, stop: <span class="fl">0.4</span> gray, stop: <span class="dv">1</span> green);
    background-image: url(:/images/yellow-bg.png);
    background-position: top right;
    background-repeat: repeat-y;
}

<span class="ot">QPushButton</span>[text=<span class="st">&quot;OK&quot;</span>] {
    color: green;
}
<span class="ot">QPushButton</span>[text=<span class="st">&quot;Cancel&quot;</span>] {
    color: red;
}

QFrame<span class="er">#</span>frame &gt; <span class="ot">QPushButton</span>[x=<span class="st">&quot;0&quot;</span>][y=<span class="st">&quot;0&quot;</span>]<span class="er">#</span>okButton {
    ...
}</code></pre></div>
<ol>
<li><code class="sourceCode cpp">qlineargradient()</code></li>
<li><code class="sourceCode cpp">qradialgradient()</code></li>
<li><code class="sourceCode cpp">qconicalgradient()</code></li>
</ol>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css">*<span class="ch">[mandatoryField=</span><span class="st">&quot;true&quot;</span><span class="ch">]</span> <span class="kw">{</span>
    <span class="kw">background-color:</span> <span class="dt">yellow</span><span class="kw">;</span>
<span class="kw">}</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">nameLineEdit-&gt;setProperty(<span class="st">&quot;mandatoryField&quot;</span>, <span class="kw">true</span>);
genderComboBox-&gt;setProperty(<span class="st">&quot;mandatoryField&quot;</span>, <span class="kw">true</span>);
ageSpinBox-&gt;setProperty(<span class="st">&quot;mandatoryField&quot;</span>, <span class="kw">true</span>);</code></pre></div>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css">QCheckBox<span class="dv">::</span>indicator, QRadioButton<span class="dv">::</span>indicator <span class="kw">{</span>
    <span class="kw">width:</span> <span class="dt">20px</span><span class="kw">;</span>
    <span class="kw">height:</span> <span class="dt">20px</span><span class="kw">;</span>
<span class="kw">}</span>

QCheckBox, QRadioButton <span class="kw">{</span>
    <span class="kw">spacing:</span> <span class="dt">8px</span><span class="kw">;</span>
<span class="kw">}</span>

QCheckBox<span class="dv">:checked:hover</span> <span class="kw">{</span>
    <span class="kw">color:</span> <span class="dt">white</span><span class="kw">;</span>
<span class="kw">}</span></code></pre></div>
<p>A <code>border.png</code> border image with cuts at 4, 8, 12, and 16 pixels from the top, right, bottom, and left edges would be specified as <code class="sourceCode css">border-image<span class="dv">:</span> url(border<span class="fl">.png</span>) 4 8 12 16;</code>.</p>
<p>To make some room for the push button&#8217;s text, we specify a vertical padding of <code>-16</code> pixels.</p>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css">QComboBox<span class="dv">:</span>editable,
QLineEdit,
QListView <span class="kw">{</span>
    <span class="kw">color:</span> <span class="dt">rgb(127</span>, <span class="dt">0</span>, <span class="dt">63)</span><span class="kw">;</span>
    <span class="kw">background-color:</span> <span class="dt">rgb(255</span>, <span class="dt">255</span>, <span class="dt">241)</span><span class="kw">;</span>
    <span class="kw">selection-color:</span> <span class="dt">white</span><span class="kw">;</span>
    <span class="kw">selection-background-color:</span> <span class="dt">rgb(191</span>, <span class="dt">31</span>, <span class="dt">127)</span><span class="kw">;</span>
    <span class="kw">border:</span> <span class="dt">2px</span> <span class="dt">groove</span> <span class="dt">gray</span><span class="kw">;</span>
    <span class="kw">border-radius:</span> <span class="dt">10px</span><span class="kw">;</span>
    <span class="kw">padding:</span> <span class="dt">2px</span> <span class="dt">4px</span><span class="kw">;</span>
<span class="kw">}</span></code></pre></div>
<h4 id="subclassing-qstyle">Subclassing QStyle</h4>
<p>The <code class="sourceCode cpp"><span class="ot">QStyle</span></code> API consists of functions for drawing graphical elements <code class="sourceCode cpp">(drawPrimitive()</code>, <code class="sourceCode cpp">drawControl()</code>, <code class="sourceCode cpp">drawComplexControl()</code>, etc.) and for querying the style <code class="sourceCode cpp">(pixelMetrics()</code>, <code class="sourceCode cpp">styleHint()</code>, <code class="sourceCode cpp">hitTest()</code>, etc.). The <code class="sourceCode cpp"><span class="ot">QStyle</span></code> member functions typically take a <code class="sourceCode cpp"><span class="ot">QStyleOption</span></code> object that holds both general information about the widget to be drawn (such as its palette) and widget-specific information (e.g., the text of a button). The functions also take an optional pointer to a <code class="sourceCode cpp"><span class="ot">QWidget</span></code>, to cater to situations when the <code class="sourceCode cpp"><span class="ot">QStyleOption</span></code> doesn&#8217;t provide all the necessary information.</p>
<p>The <code class="sourceCode cpp"><span class="ot">QStyleOption::</span>initFrom()</code> function initializes the fundamental member variables that represent a widget, such as rect, state (enabled, focused, etc.), and palette. Member variables specific to <code class="sourceCode cpp"><span class="ot">QStyleOptionButton</span></code> must be initialized manually. In the <code class="sourceCode cpp">MyPushButton</code> example, we initialize features and text and let icon and iconSize take their default values.</p>
<p>The <code class="sourceCode cpp"><span class="ot">QWidget::</span>style()</code> function returns the appropriate style for drawing the widget. The style is normally set for the entire application using <code class="sourceCode cpp"><span class="ot">QApplication::</span>setStyle()</code>, but it is also possible to override it for individual widgets using <code class="sourceCode cpp"><span class="ot">QWidget::</span>setStyle()</code>.</p>
<p>The <code class="sourceCode cpp">drawControl()</code> function is reimplemented by the various <code class="sourceCode cpp"><span class="ot">QStyle</span></code> subclasses to draw <code class="sourceCode cpp"><span class="ot">QPushButton</span></code> and other simple widgets.</p>
<h3 id="d-graphics-1">20. 3D Graphics</h3>
<h4 id="drawing-using-opengl">Drawing Using OpenGL</h4>
<h4 id="combining-opengl-and-qpainter">Combining OpenGL and QPainter</h4>
<h4 id="doing-overlays-using-framebuffer-objects">Doing Overlays Using Framebuffer Objects</h4>
<h3 id="creating-plugins">21. Creating Plugins</h3>
<h4 id="extending-qt-with-plugins">Extending Qt with Plugins</h4>
<h4 id="making-applications-plugin-aware">Making Applications Plugin-Aware</h4>
<h4 id="writing-application-plugins">Writing Application Plugins</h4>
<h3 id="application-scripting">22. Application Scripting</h3>
<h4 id="overview-of-the-ecmascript-language">Overview of the ECMAScript Language</h4>
<h4 id="extending-qt-applications-with-scripts">Extending Qt Applications with Scripts</h4>
<h4 id="implementing-gui-extensions-using-scripts">Implementing GUI Extensions Using Scripts</h4>
<h4 id="automating-tasks-through-scripting">Automating Tasks through Scripting</h4>
<h3 id="platform-specific-features">23. Platform-Specific Features</h3>
<h4 id="interfacing-with-native-apis">Interfacing with Native APIs</h4>
<h4 id="using-activex-on-windows">Using ActiveX on Windows</h4>
<h4 id="handling-x11-session-management">Handling X11 Session Management</h4>
<h3 id="embedded-programming">24. Embedded Programming</h3>
<h4 id="getting-started-with-qtembedded-linux">Getting Started with Qt/Embedded Linux</h4>
<h4 id="customizing-qtembedded-linux">Customizing Qt/Embedded Linux</h4>
<h4 id="integrating-qt-applications-with-qtopia">Integrating Qt Applications with Qtopia</h4>
<h4 id="using-qtopia-apis">Using Qtopia APIs</h4>
<h2 id="part-iv-appendixes">Part IV: Appendixes</h2>
<h3 id="appendix-a">Appendix A</h3>
<h4 id="obtaining-and-installing-qt">Obtaining and Installing Qt</h4>
<h4 id="a-note-on-licensing">A Note on Licensing</h4>
<h4 id="installing-qtwindows">Installing Qt/Windows</h4>
<h4 id="installing-qtmac">Installing Qt/Mac</h4>
<h4 id="installing-qtx11">Installing Qt/X11</h4>
<h3 id="appendix-b">Appendix B</h3>
<h4 id="building-qt-applications">Building Qt Applications</h4>
<h4 id="using-qmake">Using qmake</h4>
<h4 id="using-third-party-build-tools">Using Third-Party Build Tools</h4>
<h3 id="appendix-c">Appendix C</h3>
<h4 id="introduction-to-qt-jambi">Introduction to Qt Jambi</h4>
<h4 id="getting-started-with-qt-jambi">Getting Started with Qt Jambi</h4>
<h4 id="using-qt-jambi-in-the-eclipse-ide">Using Qt Jambi in the Eclipse IDE</h4>
<h4 id="integrating-c-components-with-qt-jambi">Integrating C++ Components with Qt Jambi</h4>
<h3 id="appendix-d">Appendix D</h3>
<h4 id="introduction-to-c-for-java-and-c-programmers">Introduction to C++ for Java and C# Programmers</h4>
<h4 id="getting-started-with-c">Getting Started with C++</h4>
<h4 id="main-language-differences">Main Language Differences</h4>
<h4 id="the-standard-c-library">The Standard C++ Library</h4>
<hr />
<h2 id="extra-useful-notes">Extra Useful Notes</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// flow</span>
Flow flow () <span class="dt">const</span>
<span class="dt">void</span> setFlow ( Flow flow )
<span class="co">// QListView::LeftToRight, QListView::TopToBottom</span>

<span class="co">// wrapping</span>
<span class="dt">bool</span> isWrapping () <span class="dt">const</span>
<span class="dt">void</span> setWrapping ( <span class="dt">bool</span> enable )</code></pre></div>
<table style="width:38%;">
<colgroup>
<col width="12%" />
<col width="8%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Qt::DisplayRole</td>
<td>0</td>
<td>The key data to be rendered in the form of text. (QString)</td>
</tr>
<tr class="even">
<td>Qt::DecorationRole</td>
<td>1</td>
<td>The data to be rendered as a decoration in the form of an icon. (QColor, QIcon or QPixmap)</td>
</tr>
<tr class="odd">
<td>Qt::EditRole</td>
<td>2</td>
<td>The data in a form suitable for editing in an editor. (QString)</td>
</tr>
<tr class="even">
<td>Qt::ToolTipRole</td>
<td>3</td>
<td>The data displayed in the item&#8217;s tooltip. (QString)</td>
</tr>
<tr class="odd">
<td>Qt::StatusTipRole</td>
<td>4</td>
<td>The data displayed in the status bar. (QString)</td>
</tr>
<tr class="even">
<td>Qt::WhatsThisRole</td>
<td>5</td>
<td>The data displayed for the item in &#8220;What&#8217;s This?&#8221; mode. (QString)</td>
</tr>
<tr class="odd">
<td>Qt::SizeHintRole</td>
<td>13</td>
<td>The size hint for the item that will be supplied to views. (QSize)</td>
</tr>
</tbody>
</table>
<p>Refs</p>
<ol>
<li><a href="http://doc.qt.io/qt-4.8/qabstractitemmodel.html">QAbstractItemModel Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qapplication.html">QApplication Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qboxlayout.html#addStretch">QBoxLayout Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qfileinfo.html">QFileInfo Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qheaderview.html">QHeaderView Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qkeysequence.html">QKeySequence Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qobject.html">QObject Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qpainter.html">QPainter Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qpainterpath.html#addRoundedRect">QPainterPath Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qpen.html#QPen-4">QPen Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qpixmap.html">QPixmap Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qpolygonf.html">QPolygonF Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qrectf.html#adjust">QRectF Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qsettings.html">QSettings Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qsplitter.html">QSplitter Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qstringlist.html">QStringList Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qtextcodec.html">QTextCodec Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qtextstream.html#QTextStream">QTextStream Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qtreewidget.html">QTreeWidget Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qvariant.html">QVariant Class | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qt.html#mightBeRichText">Qt Namespace | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/qt.html">Qt Namespace | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/stylesheet.html">Qt Style Sheets | Qt 4.8</a></li>
<li><a href="http://doc.qt.io/qt-4.8/stylesheet-syntax.html">The Style Sheet Syntax | Qt 4.8</a></li>
</ol>
<hr />
<ul>
<li>properties</li>
<li>dual map (most fast, most easy to use), id(string)-&gt;prop(*), prop-&gt;id</li>
<li>but property matters (id for just reference), prop = type + title</li>
<li>treeview</li>
<li>browser items (key value pairs), item-&gt;property</li>
<li>property value -&gt; QVariant -&gt; toDouble(), toString(), etc</li>
<li>value changed -&gt; update</li>
<li>emit -&gt; focus</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">QString</span> id = propertyToId[property];
<span class="kw">if</span> (id == <span class="ot">QLatin1String</span>(<span class="st">&quot;xpos&quot;</span>)) {
    currentItem-&gt;setX(value.toDouble());
} <span class="kw">else</span> <span class="kw">if</span> (id == <span class="ot">QLatin1String</span>(<span class="st">&quot;text&quot;</span>)) {
    <span class="kw">if</span> (currentItem-&gt;rtti() == QtCanvasItem::Rtti_Text) {
        QtCanvasText *i = (QtCanvasText *)currentItem;
        i-&gt;setText(qVariantValue&lt;<span class="ot">QString</span>&gt;(value));
    }
} <span class="kw">else</span> <span class="kw">if</span> (id == <span class="ot">QLatin1String</span>(<span class="st">&quot;color&quot;</span>)) {
    <span class="kw">if</span> (currentItem-&gt;rtti() == QtCanvasItem::Rtti_Text) {
        QtCanvasText *i = (QtCanvasText *)currentItem;
        i-&gt;setColor(qVariantValue&lt;<span class="ot">QColor</span>&gt;(value));
    }
} <span class="kw">else</span> <span class="kw">if</span> (id == <span class="ot">QLatin1String</span>(<span class="st">&quot;size&quot;</span>)) {
    <span class="kw">if</span> (currentItem-&gt;rtti() == QtCanvasItem::Rtti_Rectangle) {
        QtCanvasRectangle *i = (QtCanvasRectangle *)currentItem;
        <span class="ot">QSize</span> s = qVariantValue&lt;<span class="ot">QSize</span>&gt;(value);
        i-&gt;setSize(s.width(), s.height());
    } <span class="kw">else</span> <span class="kw">if</span> (currentItem-&gt;rtti() == QtCanvasItem::Rtti_Ellipse) {
        QtCanvasEllipse *i = (QtCanvasEllipse *)currentItem;
        <span class="ot">QSize</span> s = qVariantValue&lt;<span class="ot">QSize</span>&gt;(value);
        i-&gt;setSize(s.width(), s.height());
    }
}</code></pre></div>
<pre><code>void MainWindow::addProperty(QtVariantProperty *property, const QString &amp;id)
{
    // dual maps
    propertyToId[property] = id;
    idToProperty[id] = property;

    // add property
    QtBrowserItem *item = propertyEditor-&gt;addProperty(property);

    // ?
    if (idToExpanded.contains(id))
        propertyEditor-&gt;setExpanded(item, idToExpanded[id]);
}</code></pre>
<pre><code>void MainWindow::itemClicked(QtCanvasItem *item)
{
    updateExpandState();

    QMap&lt;QtProperty *, QString&gt;::ConstIterator itProp = propertyToId.constBegin();
    while (itProp != propertyToId.constEnd()) {
        delete itProp.key();
        itProp++;
    }
    propertyToId.clear();
    idToProperty.clear();

    currentItem = item;
    if (!currentItem) {
        deleteAction-&gt;setEnabled(false);
        return;
    }

    deleteAction-&gt;setEnabled(true);

    QtVariantProperty *property;

    property = variantManager-&gt;addProperty(QVariant::Double, tr(&quot;Position X&quot;));
    property-&gt;setAttribute(QLatin1String(&quot;minimum&quot;), 0);
    property-&gt;setAttribute(QLatin1String(&quot;maximum&quot;), canvas-&gt;width());
    property-&gt;setValue(item-&gt;x());
    addProperty(property, QLatin1String(&quot;xpos&quot;));

    property = variantManager-&gt;addProperty(QVariant::Double, tr(&quot;Position Y&quot;));
    property-&gt;setAttribute(QLatin1String(&quot;minimum&quot;), 0);
    property-&gt;setAttribute(QLatin1String(&quot;maximum&quot;), canvas-&gt;height());
    property-&gt;setValue(item-&gt;y());
    addProperty(property, QLatin1String(&quot;ypos&quot;));

    property = variantManager-&gt;addProperty(QVariant::Double, tr(&quot;Position Z&quot;));
    property-&gt;setAttribute(QLatin1String(&quot;minimum&quot;), 0);
    property-&gt;setAttribute(QLatin1String(&quot;maximum&quot;), 256);
    property-&gt;setValue(item-&gt;z());
    addProperty(property, QLatin1String(&quot;zpos&quot;));

    if (item-&gt;rtti() == QtCanvasItem::Rtti_Rectangle) {
        QtCanvasRectangle *i = (QtCanvasRectangle *)item;

        property = variantManager-&gt;addProperty(QVariant::Color, tr(&quot;Brush Color&quot;));
        property-&gt;setValue(i-&gt;brush().color());
        addProperty(property, QLatin1String(&quot;brush&quot;));

        property = variantManager-&gt;addProperty(QVariant::Color, tr(&quot;Pen Color&quot;));
        property-&gt;setValue(i-&gt;pen().color());
        addProperty(property, QLatin1String(&quot;pen&quot;));

        property = variantManager-&gt;addProperty(QVariant::Size, tr(&quot;Size&quot;));
        property-&gt;setValue(i-&gt;size());
        addProperty(property, QLatin1String(&quot;size&quot;));
    } else if (item-&gt;rtti() == QtCanvasItem::Rtti_Line) {
        QtCanvasLine *i = (QtCanvasLine *)item;

        property = variantManager-&gt;addProperty(QVariant::Color, tr(&quot;Pen Color&quot;));
        property-&gt;setValue(i-&gt;pen().color());
        addProperty(property, QLatin1String(&quot;pen&quot;));

        property = variantManager-&gt;addProperty(QVariant::Point, tr(&quot;Vector&quot;));
        property-&gt;setValue(i-&gt;endPoint());
        addProperty(property, QLatin1String(&quot;endpoint&quot;));
    } else if (item-&gt;rtti() == QtCanvasItem::Rtti_Ellipse) {
        QtCanvasEllipse *i = (QtCanvasEllipse *)item;

        property = variantManager-&gt;addProperty(QVariant::Color, tr(&quot;Brush Color&quot;));
        property-&gt;setValue(i-&gt;brush().color());
        addProperty(property, QLatin1String(&quot;brush&quot;));

        property = variantManager-&gt;addProperty(QVariant::Size, tr(&quot;Size&quot;));
        property-&gt;setValue(QSize(i-&gt;width(), i-&gt;height()));
        addProperty(property, QLatin1String(&quot;size&quot;));
    } else if (item-&gt;rtti() == QtCanvasItem::Rtti_Text) {
        QtCanvasText *i = (QtCanvasText *)item;

        property = variantManager-&gt;addProperty(QVariant::Color, tr(&quot;Color&quot;));
        property-&gt;setValue(i-&gt;color());
        addProperty(property, QLatin1String(&quot;color&quot;));

        property = variantManager-&gt;addProperty(QVariant::String, tr(&quot;Text&quot;));
        property-&gt;setValue(i-&gt;text());
        addProperty(property, QLatin1String(&quot;text&quot;));

        property = variantManager-&gt;addProperty(QVariant::Font, tr(&quot;Font&quot;));
        property-&gt;setValue(i-&gt;font());
        addProperty(property, QLatin1String(&quot;font&quot;));
    }
}</code></pre>
<pre><code>variantManager-&gt;setValue(idToProperty[QLatin1String(&quot;xpos&quot;)], item-&gt;x());
// variantManager-&gt;setValue(idToProperty[QString(&quot;xpos&quot;)], item-&gt;x());
// variantManager-&gt;setValue(idToProperty[QString(&quot;X &#20540;&quot;)], item-&gt;x()); // &#20013;&#25991;works</code></pre>
<pre><code>void MainWindow::updateExpandState()
{
    QList&lt;QtBrowserItem *&gt; list = propertyEditor-&gt;topLevelItems();
    QListIterator&lt;QtBrowserItem *&gt; it(list);
    while (it.hasNext()) {
        QtBrowserItem *item = it.next();
        QtProperty *prop = item-&gt;property();
        idToExpanded[propertyToId[prop]] = propertyEditor-&gt;isExpanded(item);
    }
}</code></pre>
<p>QtPropertyBrowser/qtpropertymanager.cpp</p>
<pre><code>void QtColorPropertyManager::initializeProperty(QtProperty *property)
{
    QColor val;
    d_ptr-&gt;m_values[property] = val;

    QtProperty *rProp = d_ptr-&gt;m_intPropertyManager-&gt;addProperty();
    rProp-&gt;setPropertyName(tr(&quot;Red&quot;));
    d_ptr-&gt;m_intPropertyManager-&gt;setValue(rProp, val.red());
    d_ptr-&gt;m_intPropertyManager-&gt;setRange(rProp, 0, 0xFF);
    d_ptr-&gt;m_propertyToR[property] = rProp;
    d_ptr-&gt;m_rToProperty[rProp] = property;
    property-&gt;addSubProperty(rProp);

    QtProperty *gProp = d_ptr-&gt;m_intPropertyManager-&gt;addProperty();
    gProp-&gt;setPropertyName(tr(&quot;Green&quot;));
    d_ptr-&gt;m_intPropertyManager-&gt;setValue(gProp, val.green());
    d_ptr-&gt;m_intPropertyManager-&gt;setRange(gProp, 0, 0xFF);
    d_ptr-&gt;m_propertyToG[property] = gProp;
    d_ptr-&gt;m_gToProperty[gProp] = property;
    property-&gt;addSubProperty(gProp);

    QtProperty *bProp = d_ptr-&gt;m_intPropertyManager-&gt;addProperty();
    bProp-&gt;setPropertyName(tr(&quot;Blue&quot;));
    d_ptr-&gt;m_intPropertyManager-&gt;setValue(bProp, val.blue());
    d_ptr-&gt;m_intPropertyManager-&gt;setRange(bProp, 0, 0xFF);
    d_ptr-&gt;m_propertyToB[property] = bProp;
    d_ptr-&gt;m_bToProperty[bProp] = property;
    property-&gt;addSubProperty(bProp);

    QtProperty *aProp = d_ptr-&gt;m_intPropertyManager-&gt;addProperty();
    aProp-&gt;setPropertyName(tr(&quot;Alpha&quot;));
    d_ptr-&gt;m_intPropertyManager-&gt;setValue(aProp, val.alpha());
    d_ptr-&gt;m_intPropertyManager-&gt;setRange(aProp, 0, 0xFF);
    d_ptr-&gt;m_propertyToA[property] = aProp;
    d_ptr-&gt;m_aToProperty[aProp] = property;
    property-&gt;addSubProperty(aProp);
}</code></pre>
<pre><code>QString QtSizePropertyManager::valueText(const QtProperty *property) const
{
    const QtSizePropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr-&gt;m_values.constFind(property);
    if (it == d_ptr-&gt;m_values.constEnd())
        return QString();
    const QSize v = it.value().val;
    return QString(tr(&quot;%1 x %2&quot;).arg(QString::number(v.width()))
                                .arg(QString::number(v.height())));
}</code></pre>
<pre><code>// declares
class QtVariantProperty;
class QtProperty;
class QtBrowserIndex;

// vars
class QtVariantPropertyManager *variantManager;
class QtTreePropertyBrowser *propertyEditor;
QMap&lt;QtProperty *, QString&gt; propertyToId;
QMap&lt;QString, QtVariantProperty *&gt; idToProperty;
QMap&lt;QString, bool&gt; idToExpanded;

// headers
#include &quot;qtvariantproperty.h&quot;
#include &quot;qttreepropertybrowser.h&quot;

// manager
variantManager = new QtVariantPropertyManager( this );
connect( variantManager, SIGNAL(valueChanged(QtProperty *, const QVariant &amp;)),
         this, SLOT(valueChanged(QtProperty *, const QVariant &amp;)) );

// editor factory
QtVariantEditorFactory *variantFactory = new QtVariantEditorFactory( this );

// editor
propertyEditor = new QtTreePropertyBrowser( dock );
propertyEditor-&gt;setFactoryForManager( variantManager, variantFactory );
dock-&gt;setWidget( propertyEditor );</code></pre>
<p>&#22312;&#26174;&#31034;&#19978;&#35013;&#39280;&#65306;</p>
<pre><code>QtDoublePropertyManager *undecoratedManager = new QtDoublePropertyManager();
QtProperty *undecoratedProperty = undecoratedManager-&gt;addProperty(&quot;Undecorated&quot;);
undecoratedManager-&gt;setValue(undecoratedProperty, 123.45);

DecoratedDoublePropertyManager *decoratedManager = new DecoratedDoublePropertyManager();
QtProperty *decoratedProperty = decoratedManager-&gt;addProperty(&quot;Decorated&quot;);
decoratedManager-&gt;setPrefix(decoratedProperty, &quot;speed: &quot;);
decoratedManager-&gt;setSuffix(decoratedProperty, &quot; km/h&quot;);
decoratedManager-&gt;setValue(decoratedProperty, 123.45);

QtDoubleSpinBoxFactory *undecoratedFactory = new QtDoubleSpinBoxFactory();
DecoratedDoubleSpinBoxFactory *decoratedFactory = new DecoratedDoubleSpinBoxFactory();

QtTreePropertyBrowser *editor = new QtTreePropertyBrowser();
editor-&gt;setFactoryForManager(undecoratedManager, undecoratedFactory);
editor-&gt;setFactoryForManager(decoratedManager, decoratedFactory);
editor-&gt;addProperty(undecoratedProperty);
editor-&gt;addProperty(decoratedProperty);
editor-&gt;show();</code></pre>
<p>variant vs typed</p>
<dl>
<dt>typed:</dt>
<dd><pre><code>// define
doubleManager = new QtDoublePropertyManager(this);
propertyEditor = new QtTreePropertyBrowser(dock);
QtDoubleSpinBoxFactory *doubleSpinBoxFactory = new QtDoubleSpinBoxFactory(this);
propertyEditor-&gt;setFactoryForManager(doubleManager, doubleSpinBoxFactory);

// new property
property = doubleManager-&gt;addProperty(tr(&quot;Position X&quot;));
// config property
doubleManager-&gt;setRange(property, 0, canvas-&gt;width());

// add property
propertyToId[property] = id;
idToProperty[id] = property;
QtBrowserItem *item = propertyEditor-&gt;addProperty(property);

// set value, &#29992; manager &#26469; set&#65292; property &#19981;&#33021;&#33258;&#24049;&#35774;&#32622;&#20540;
doubleManager-&gt;setValue(property, item-&gt;x()); // &#36890;&#24120;&#29992; idToProperty &#36716;&#21270;
// get value
connect(doubleManager, SIGNAL(valueChanged(QtProperty *, double)),
        this, SLOT(valueChanged(QtProperty *, double)));</code></pre>
</dd>
<dt>variant:</dt>
<dd><pre><code>// define
variantManager = new QtVariantPropertyManager(this);
QtVariantEditorFactory *variantFactory = new QtVariantEditorFactory(this);
propertyEditor-&gt;setFactoryForManager(variantManager, variantFactory);

// new property
property = variantManager-&gt;addProperty(QVariant::Double, tr(&quot;Position X&quot;));
property-&gt;setAttribute(QLatin1String(&quot;minimum&quot;), 0);
property-&gt;setAttribute(QLatin1String(&quot;maximum&quot;), canvas-&gt;width());
property-&gt;setValue(item-&gt;x()); // property &#33258;&#24049;&#35774;&#32622;&#20540;

// add property
propertyToId[property] = id;
idToProperty[id] = property;
QtBrowserItem *item = propertyEditor-&gt;addProperty(property);

// set
variantManager-&gt;setValue(idToProperty[QLatin1String(&quot;xpos&quot;)], item-&gt;x());
// get
connect(variantManager, SIGNAL(valueChanged(QtProperty *, const QVariant &amp;)),
            this, SLOT(valueChanged(QtProperty *, const QVariant &amp;)));
/*
    QString id = propertyToId[property];
    if (id == QLatin1String(&quot;xpos&quot;)) {
        currentItem-&gt;setX(value.toDouble());
    }
*/</code></pre>
</dd>
</dl>
<p>managers</p>
<pre><code>int main(int argc, char **argv)
{
    QApplication app(argc, argv);

    QWidget *w = new QWidget();

    // managers
    QtBoolPropertyManager *boolManager = new QtBoolPropertyManager(w);
    QtIntPropertyManager *intManager = new QtIntPropertyManager(w);
    QtStringPropertyManager *stringManager = new QtStringPropertyManager(w);
    QtSizePropertyManager *sizeManager = new QtSizePropertyManager(w);
    QtRectPropertyManager *rectManager = new QtRectPropertyManager(w);
    QtSizePolicyPropertyManager *sizePolicyManager = new QtSizePolicyPropertyManager(w);
    QtEnumPropertyManager *enumManager = new QtEnumPropertyManager(w);
    QtGroupPropertyManager *groupManager = new QtGroupPropertyManager(w);

    // properties
    QtProperty *item0 = groupManager-&gt;addProperty(&quot;QObject&quot;);

    QtProperty *item1 = stringManager-&gt;addProperty(&quot;objectName&quot;);
    item0-&gt;addSubProperty(item1);

    QtProperty *item2 = boolManager-&gt;addProperty(&quot;enabled&quot;);
    item0-&gt;addSubProperty(item2);

    QtProperty *item3 = rectManager-&gt;addProperty(&quot;geometry&quot;);
    item0-&gt;addSubProperty(item3);

    QtProperty *item4 = sizePolicyManager-&gt;addProperty(&quot;sizePolicy&quot;);
    item0-&gt;addSubProperty(item4);

    QtProperty *item5 = sizeManager-&gt;addProperty(&quot;sizeIncrement&quot;);
    item0-&gt;addSubProperty(item5);

    QtProperty *item7 = boolManager-&gt;addProperty(&quot;mouseTracking&quot;);
    item0-&gt;addSubProperty(item7);

    // enum, &#21487;&#20197;&#35774;&#32622; string &#21644; &#22270;&#26631;
    QtProperty *item8 = enumManager-&gt;addProperty(&quot;direction&quot;);
    QStringList enumNames;
    enumNames &lt;&lt; &quot;Up&quot; &lt;&lt; &quot;Right&quot; &lt;&lt; &quot;Down&quot; &lt;&lt; &quot;Left&quot;;
    enumManager-&gt;setEnumNames(item8, enumNames);
    QMap&lt;int, QIcon&gt; enumIcons;
    enumIcons[0] = QIcon(&quot;:/demo/images/up.png&quot;);
    enumIcons[1] = QIcon(&quot;:/demo/images/right.png&quot;);
    enumIcons[2] = QIcon(&quot;:/demo/images/down.png&quot;);
    enumIcons[3] = QIcon(&quot;:/demo/images/left.png&quot;);
    enumManager-&gt;setEnumIcons(item8, enumIcons);
    item0-&gt;addSubProperty(item8);

    QtProperty *item9 = intManager-&gt;addProperty(&quot;value&quot;);
    intManager-&gt;setRange(item9, -100, 100);
    item0-&gt;addSubProperty(item9);

    // factories
    QtCheckBoxFactory *checkBoxFactory = new QtCheckBoxFactory(w);
    QtSpinBoxFactory *spinBoxFactory = new QtSpinBoxFactory(w);
    QtSliderFactory *sliderFactory = new QtSliderFactory(w);
    QtScrollBarFactory *scrollBarFactory = new QtScrollBarFactory(w);
    QtLineEditFactory *lineEditFactory = new QtLineEditFactory(w);
    QtEnumEditorFactory *comboBoxFactory = new QtEnumEditorFactory(w);

    // editor, &#26368;&#26222;&#36890;&#30340; treeview&#65292;configure factory for manager of editor
    QtAbstractPropertyBrowser *editor1 = new QtTreePropertyBrowser();
    editor1-&gt;setFactoryForManager(boolManager, checkBoxFactory);
    editor1-&gt;setFactoryForManager(intManager, spinBoxFactory);
    editor1-&gt;setFactoryForManager(stringManager, lineEditFactory);
    editor1-&gt;setFactoryForManager(sizeManager-&gt;subIntPropertyManager(), spinBoxFactory);
    editor1-&gt;setFactoryForManager(rectManager-&gt;subIntPropertyManager(), spinBoxFactory);
    editor1-&gt;setFactoryForManager(sizePolicyManager-&gt;subIntPropertyManager(), spinBoxFactory);
    editor1-&gt;setFactoryForManager(sizePolicyManager-&gt;subEnumPropertyManager(), comboBoxFactory);
    editor1-&gt;setFactoryForManager(enumManager, comboBoxFactory);

    editor1-&gt;addProperty(item0);

    // editor2, &#19981;&#21152; manager &#30340;&#35805;&#65292;&#23601;&#21482;&#35835;
    QtAbstractPropertyBrowser *editor2 = new QtTreePropertyBrowser();
    editor2-&gt;addProperty(item0);

    // editor3&#65292;groupbox
    QtAbstractPropertyBrowser *editor3 = new QtGroupBoxPropertyBrowser();
    editor3-&gt;setFactoryForManager(boolManager, checkBoxFactory);
    editor3-&gt;setFactoryForManager(intManager, spinBoxFactory);
    editor3-&gt;setFactoryForManager(stringManager, lineEditFactory);
    editor3-&gt;setFactoryForManager(sizeManager-&gt;subIntPropertyManager(), spinBoxFactory);
    editor3-&gt;setFactoryForManager(rectManager-&gt;subIntPropertyManager(), spinBoxFactory);
    editor3-&gt;setFactoryForManager(sizePolicyManager-&gt;subIntPropertyManager(), spinBoxFactory);
    editor3-&gt;setFactoryForManager(sizePolicyManager-&gt;subEnumPropertyManager(), comboBoxFactory);
    editor3-&gt;setFactoryForManager(enumManager, comboBoxFactory);

    editor3-&gt;addProperty(item0);

    QScrollArea *scroll3 = new QScrollArea();
    scroll3-&gt;setWidgetResizable(true);
    scroll3-&gt;setWidget(editor3);

    // editor4&#65292;groupbox
    QtAbstractPropertyBrowser *editor4 = new QtGroupBoxPropertyBrowser();
    editor4-&gt;setFactoryForManager(boolManager, checkBoxFactory);
    // &#36825;&#37324;&#29305;&#21035;&#36148;&#24515;&#22320;&#65292;&#29992;&#20102; scrollBarFactory &#32780;&#19981;&#26159; spinBoxFactory
    editor4-&gt;setFactoryForManager(intManager, scrollBarFactory);
    editor4-&gt;setFactoryForManager(stringManager, lineEditFactory);
    editor4-&gt;setFactoryForManager(sizeManager-&gt;subIntPropertyManager(), spinBoxFactory);
    editor4-&gt;setFactoryForManager(rectManager-&gt;subIntPropertyManager(), spinBoxFactory);
    // &#29992;&#20102; sliderFactory
    editor4-&gt;setFactoryForManager(sizePolicyManager-&gt;subIntPropertyManager(), sliderFactory);
    editor4-&gt;setFactoryForManager(sizePolicyManager-&gt;subEnumPropertyManager(), comboBoxFactory);
    editor4-&gt;setFactoryForManager(enumManager, comboBoxFactory);

    editor4-&gt;addProperty(item0);

    QScrollArea *scroll4 = new QScrollArea();
    scroll4-&gt;setWidgetResizable(true);
    scroll4-&gt;setWidget(editor4);

    // editor, button!
    QtAbstractPropertyBrowser *editor5 = new QtButtonPropertyBrowser();
    editor5-&gt;setFactoryForManager(boolManager, checkBoxFactory);
    editor5-&gt;setFactoryForManager(intManager, scrollBarFactory);
    editor5-&gt;setFactoryForManager(stringManager, lineEditFactory);
    editor5-&gt;setFactoryForManager(sizeManager-&gt;subIntPropertyManager(), spinBoxFactory);
    editor5-&gt;setFactoryForManager(rectManager-&gt;subIntPropertyManager(), spinBoxFactory);
    editor5-&gt;setFactoryForManager(sizePolicyManager-&gt;subIntPropertyManager(), sliderFactory);
    editor5-&gt;setFactoryForManager(sizePolicyManager-&gt;subEnumPropertyManager(), comboBoxFactory);
    editor5-&gt;setFactoryForManager(enumManager, comboBoxFactory);

    editor5-&gt;addProperty(item0);

    QScrollArea *scroll5 = new QScrollArea();
    scroll5-&gt;setWidgetResizable(true);
    scroll5-&gt;setWidget(editor5);

    QGridLayout *layout = new QGridLayout(w);
    QLabel *label1 = new QLabel(&quot;Editable Tree Property Browser&quot;);
    QLabel *label2 = new QLabel(&quot;Read Only Tree Property Browser, editor factories are not set&quot;);
    QLabel *label3 = new QLabel(&quot;Group Box Property Browser&quot;);
    QLabel *label4 = new QLabel(&quot;Group Box Property Browser with different editor factories&quot;);
    QLabel *label5 = new QLabel(&quot;Button Property Browser&quot;);
    label1-&gt;setWordWrap(true);
    label2-&gt;setWordWrap(true);
    label3-&gt;setWordWrap(true);
    label4-&gt;setWordWrap(true);
    label5-&gt;setWordWrap(true);
    label1-&gt;setFrameShadow(QFrame::Sunken);
    label2-&gt;setFrameShadow(QFrame::Sunken);
    label3-&gt;setFrameShadow(QFrame::Sunken);
    label4-&gt;setFrameShadow(QFrame::Sunken);
    label5-&gt;setFrameShadow(QFrame::Sunken);
    label1-&gt;setFrameShape(QFrame::Panel);
    label2-&gt;setFrameShape(QFrame::Panel);
    label3-&gt;setFrameShape(QFrame::Panel);
    label4-&gt;setFrameShape(QFrame::Panel);
    label5-&gt;setFrameShape(QFrame::Panel);
    label1-&gt;setAlignment(Qt::AlignCenter);
    label2-&gt;setAlignment(Qt::AlignCenter);
    label3-&gt;setAlignment(Qt::AlignCenter);
    label4-&gt;setAlignment(Qt::AlignCenter);
    label5-&gt;setAlignment(Qt::AlignCenter);

    layout-&gt;addWidget(label1, 0, 0);
    layout-&gt;addWidget(label2, 0, 1);
    layout-&gt;addWidget(label3, 0, 2);
    layout-&gt;addWidget(label4, 0, 3);
    layout-&gt;addWidget(label5, 0, 4);
    layout-&gt;addWidget(editor1, 1, 0);
    layout-&gt;addWidget(editor2, 1, 1);
    layout-&gt;addWidget(scroll3, 1, 2);
    layout-&gt;addWidget(scroll4, 1, 3);
    layout-&gt;addWidget(scroll5, 1, 4);
    w-&gt;show();

    int ret = app.exec();
    delete w;
    return ret;
}</code></pre>
<pre><code>QDialogButtonBox *buttonBox = new QDialogButtonBox(this);
connect(buttonBox, SIGNAL(rejected()), this, SLOT(reject()));
buttonBox-&gt;setStandardButtons(QDialogButtonBox::Close);
layout-&gt;addWidget(buttonBox);

    QWidget *newWidget = qobject_cast&lt;QWidget *&gt;(newObject);
    if (newWidget) {
        QRect r = newWidget-&gt;geometry();
        r.setSize(newWidget-&gt;sizeHint());
        r.setWidth(qMax(r.width(), 150));
        r.setHeight(qMax(r.height(), 50));
        r.moveCenter(QApplication::desktop()-&gt;geometry().center());
        newWidget-&gt;setGeometry(r);
        newWidget-&gt;setWindowTitle(tr(&quot;Controlled Object: %1&quot;).arg(className));
        newWidget-&gt;show();
    }

    if (theControlledObject)
        delete theControlledObject;

    theControlledObject = newObject;
    theController-&gt;setObject(theControlledObject);
</code></pre>
<p>bridge controllers.</p>
<p>remove properties:</p>
<pre><code>d_ptr-&gt;m_browser-&gt;removeProperty(it.next());</code></pre>
<p>file:///C:/Users/Administrator/Downloads/QtPropertyBrowser-master/doc/html/qtabstractpropertybrowser-members.html</p>
<p>besides propertyToId &amp; idToProperty, you need idToActions, too</p>
<pre><code>// assign actions
idToActions[&quot;xpos&quot;] = QList&lt;QAction *&gt;()
    &lt;&lt; new QAction(&quot;one&quot;, this)
    &lt;&lt; new QAction(&quot;two&quot;, this)
    &lt;&lt; new QAction(&quot;three&quot;, this);

// right click event
propertyEditor-&gt;setContextMenuPolicy( Qt::CustomContextMenu );
connect(propertyEditor, SIGNAL(customContextMenuRequested(const QPoint&amp;)),
    this, SLOT(popupMenu(const QPoint&amp;)));

void MainWindow::popupMenu(const QPoint &amp;pos)
{
    static int i = 0;
    if(popMenu &amp;&amp; propertyEditor){
        foreach ( QAction *action, popMenu-&gt;actions() ) {
            popMenu-&gt;removeAction( action );
        }
        QtProperty *prop = propertyEditor-&gt;currentItem()-&gt;property();
        popMenu-&gt;addActions( idToActions[propertyToId[prop]] );
        // TODO, if not any actions, try get parent&#39;s actions
        popMenu-&gt;exec(QCursor::pos());
    }
}</code></pre>
<table style="width:38%;">
<colgroup>
<col width="12%" />
<col width="8%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">Constant</th>
<th align="center">Value</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">Qt::NoContextMenu</td>
<td align="center">0</td>
<td align="center">the widget does not feature a context menu, context menu handling is deferred to the widget&#8217;s parent.</td>
</tr>
<tr class="even">
<td align="center">Qt::PreventContextMenu</td>
<td align="center">4</td>
<td align="center">the widget does not feature a context menu, and in contrast to NoContextMenu, the handling is not deferred to the widget&#8217;s parent. This means that all right mouse button events are guaranteed to be delivered to the widget itself through mousePressEvent(), and mouseReleaseEvent().</td>
</tr>
<tr class="odd">
<td align="center">Qt::DefaultContextMenu</td>
<td align="center">1</td>
<td align="center">the widget&#8217;s QWidget::contextMenuEvent() handler is called.</td>
</tr>
<tr class="even">
<td align="center">Qt::ActionsContextMenu</td>
<td align="center">2</td>
<td align="center">the widget displays its QWidget::actions() as context menu.</td>
</tr>
<tr class="odd">
<td align="center">Qt::CustomContextMenu</td>
<td align="center">3</td>
<td align="center">the widget emits the QWidget::customContextMenuRequested() signal.</td>
</tr>
</tbody>
</table>
<p>commandlineargs</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[]) {
    <span class="ot">QApplication</span> app(argc, argv, <span class="kw">false</span>);
    <span class="fu">qDebug</span>() &lt;&lt; <span class="st">&quot;QApp arg test app&quot;</span>;

    <span class="ot">QStringList</span> args = app.arguments();

    <span class="dt">int</span> pid = <span class="dv">0</span>;

    <span class="ot">QRegExp</span> rxArgPid(<span class="st">&quot;--pid=([0-9]{1,})&quot;</span>);
    <span class="ot">QRegExp</span> rxArgFooEna(<span class="st">&quot;--enable-foo&quot;</span>);
    <span class="ot">QRegExp</span> rxArgFooDis(<span class="st">&quot;--disable-foo&quot;</span>);

    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; args.size(); ++i) {
        <span class="kw">if</span> (rxArgPid.indexIn(args.at(i)) != <span class="dv">-1</span> ) {
            pid =  rxArgPid.cap(<span class="dv">1</span>).toInt();
            <span class="fu">qDebug</span>() &lt;&lt; i &lt;&lt; <span class="st">&quot;:&quot;</span> &lt;&lt; args.at(i) &lt;&lt; rxArgPid.cap(<span class="dv">1</span>) &lt;&lt; pid;
        }
        <span class="kw">else</span> <span class="kw">if</span> (rxArgFooEna.indexIn(args.at(i)) != <span class="dv">-1</span> ) {
            <span class="fu">qDebug</span>() &lt;&lt; i &lt;&lt; <span class="st">&quot;:&quot;</span> &lt;&lt; args.at(i) &lt;&lt; <span class="st">&quot;Enable Foo&quot;</span>;
        }
        <span class="kw">else</span> <span class="kw">if</span> (rxArgFooDis.indexIn(args.at(i)) != <span class="dv">-1</span> ) {
            <span class="fu">qDebug</span>() &lt;&lt; i &lt;&lt; <span class="st">&quot;:&quot;</span> &lt;&lt; args.at(i) &lt;&lt; <span class="st">&quot;Disable Foo&quot;</span>;
        }
        <span class="kw">else</span> {
            <span class="fu">qDebug</span>() &lt;&lt; <span class="st">&quot;Uknown arg:&quot;</span> &lt;&lt; args.at(i);
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div></li>
</ul>
</div>
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="blur-svg">
    <defs>
        <filter id="blur-filter">
            <feGaussianBlur stdDeviation="3"></feGaussianBlur>
        </filter>
    </defs>
</svg>
<script src="../lazyload.min.js"></script>
<script src="../jquery-3.0.0.min.js"></script>
<script src="../jquery.idTabs.min.js"></script>
<script src="../egg.min.js"></script>
<script src="../clipboard.min.js"></script>
<script src="../notes.js"></script>
</body>
</html>
