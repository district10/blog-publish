<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="author" content="district10" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>C &amp; C++ Notes</title>
    <link rel="stylesheet" href="../github-markdown.css" type="text/css" />
    <link rel="stylesheet" href="../highlight.css" type="text/css" />
    <link rel="stylesheet" href="../notes.css" type="text/css" />
</head>
<body class="markdown-body">
<a href="https://github.com/district10/notes">
    <img
        style="position: absolute; top: 0; right: 0; border: 0; width: 149px; height: 149px;"
        src="../fork-me-on-github.png" alt="Fork me on GitHub"></a>
<div id="navigator">
    <a id="gotoindex" href="index.html" title="&#12304;&#22238;&#21040;&#31508;&#35760;&#32034;&#24341; | Back to Index&#12305;">&#9763;</a></div>
<span id="help">&#25353;&#19979; "h" &#33719;&#21462;&#39029;&#38754;&#24110;&#21161;&#12290;</span>
<div id="main-body">
<h1 id="c-c-notes">C &amp; C++ Notes</h1>
<blockquote>
<p>Talk is cheap. Show me your achievements.</p>
</blockquote>
<p>Tips&#65306;</p>
<ul>
<li>&#22312;&#32447;&#32534;&#35793;&#22120;&#65306;<a href="http://coliru.stacked-crooked.com/">Coliru</a>&#65292;&#21487;&#20197;&#29992;&#26469;&#27979;&#35797;&#20195;&#30721;</li>
<li>&#20195;&#30721;&#27169;&#26495;&#65306;<a href="https://github.com/district10/neteaseintern">district10/NetEaseIntern: &#32534;&#31243;&#39064;&#27169;&#26495;</a></li>
<li>freopen&#65306;<code class="sourceCode cpp">freopen( <span class="st">&quot;input.txt&quot;</span>, <span class="st">&quot;r&quot;</span>, stdin )</code></li>
</ul>
<dl>
<dt>C++ &#31616;&#20171; | Intro</dt>
<dd><p>C++ (pronounced as cee plus plus, <code>/&#712;si&#720; pl&#652;s pl&#652;s/</code>) is a general-purpose programming language. It has imperative, object-oriented and generic programming features, while also providing facilities for low-level memory manipulation.</p>
<p>&#22312; 37 &#24180;&#21069; (1979 &#24180;)&#65292;&#19968;&#21517;&#21018;&#33719;&#24471;&#21338;&#22763;&#23398;&#20301;&#30340;&#30740;&#31350;&#21592;&#65292;&#20026;&#20102;&#24320;&#21457;&#19968;&#20010;&#36719;&#20214;&#39033;&#30446;&#21457;&#26126;&#20102;&#19968;&#38376;&#26032;&#32534;&#31243;&#35821;&#35328;&#65292;&#35813;&#30740;&#31350;&#21592;&#21517;&#20026; Bjarne Stroustrup&#65292;&#35813;&#38376;&#35821;&#35328;&#21017;&#21629;&#21517;&#20026;&#8212;&#8212;C with classes&#65292;&#22235;&#24180;&#21518;&#25913;&#31216;&#20026; C++&#12290;C++ &#26159;&#19968;&#38376;&#36890;&#29992;&#32534;&#31243;&#35821;&#35328;&#65292;&#25903;&#25345;&#22810;&#31181;&#32534;&#31243;&#33539;&#24335;&#65292;&#21253;&#25324;&#36807;&#31243;&#24335;&#12289;&#38754;&#21521;&#23545;&#35937; (object-oriented programming, OP)&#12289;&#27867;&#22411; (generic programming, GP)&#65292;&#21518;&#26469;&#20026;&#27867;&#22411;&#32780;&#35774;&#35745;&#30340;&#27169;&#29256;&#65292;&#34987;&#21457;&#29616;&#21450;&#35777;&#26126;&#26159;&#22270;&#28789;&#23436;&#22791;&#30340;&#65292;&#22240;&#27492;&#20351; C++ &#20134;&#21487;&#25903;&#25345;&#27169;&#29256;&#20803;&#32534;&#31243;&#33539;&#24335; (template metaprogramming, TMP)&#12290;C++ &#32487;&#25215;&#20102; C &#30340;&#29305;&#33394;&#65292;&#26082;&#20026;&#39640;&#32423;&#35821;&#35328;&#65292;&#21448;&#21547;&#20302;&#32423;&#35821;&#35328;&#21151;&#33021;&#65292;&#21487;&#21516;&#26102;&#20316;&#20026;&#31995;&#32479;&#21644;&#24212;&#29992;&#32534;&#31243;&#35821;&#35328;&#12290;</p>
<p><a href="http://www.stroustrup.com/">Bjarne Stroustrup&#8217;s Homepage</a>.</p>
<dl>
<dt>see more <code class="fold">@</code></dt>
<dd><p>&#19981;&#21487;&#20197;&#37325;&#36733;&#30340;&#25805;&#20316;&#31526;&#65306;</p>
<table style="width:74%;">
<colgroup>
<col width="55%" />
<col width="18%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Operator</th>
<th align="left">Symbol</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Scope resolution operator</td>
<td align="left"><code>::</code></td>
</tr>
<tr class="even">
<td align="left">Conditional operator</td>
<td align="left"><code>?:</code></td>
</tr>
<tr class="odd">
<td align="left">dot operator</td>
<td align="left"><code>.</code></td>
</tr>
<tr class="even">
<td align="left">Member selection operator</td>
<td align="left"><code>.*</code></td>
</tr>
<tr class="odd">
<td align="left">&#8220;sizeof&#8221; operator</td>
<td align="left"><code>sizeof</code></td>
</tr>
<tr class="even">
<td align="left">&#8220;typeid&#8221; operator</td>
<td align="left"><code>typeid</code></td>
</tr>
</tbody>
</table>
<p>more at <a href="https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B">Operators in C and C++ - Wikipedia, the free encyclopedia</a>.</p>
<p>&#19968;&#23450;&#35201;&#21040; <a href="http://en.cppreference.com/w/">cppreference.com</a> &#22810;&#30475;&#30475;&#65292;&#19978;&#38754;&#26377;&#20989;&#25968;&#35828;&#26126;&#65292;&#26377; demo &#20195;&#30721;&#65292;&#36824;&#26377; Possible implementation &#20160;&#20040;&#30340;&#65281;&#31616;&#30452;&#20102;&#12290;</p>
<dl>
<dt>oj utils&#65292;&#19968;&#20123;&#38754;&#35797;&#20013;&#29992;&#24471;&#21040;&#30340;&#27169;&#26495;&#31243;&#24207; <code class="fold">@</code></dt>
<dd><p>&#25105;&#20027;&#35201;&#29992;&#26469;&#26412;&#22320;&#28155;&#21152;&#27979;&#35797;&#29992;&#20363;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::string trim( std::string s )
{
    <span class="kw">if</span> ( s.empty() ) {
        <span class="kw">return</span> s;
    }

    s.erase( <span class="dv">0</span>, s.find_first_not_of(<span class="st">&quot; &quot;</span>) );
    s.erase( s.find_last_not_of(<span class="st">&quot; &quot;</span>) + <span class="dv">1</span> );
    <span class="kw">return</span> s;
}

<span class="dt">void</span> split( <span class="dt">const</span> std::string s,
            <span class="dt">const</span> std::string &amp;delim,
            std::vector&lt; std::string &gt; &amp;ret )
{
    size_t last = <span class="dv">0</span>;
    size_t index = s.find_first_of( delim, last );
    <span class="kw">while</span> ( index != std::string::npos ) {
        ret.push_back( s.substr(last,index-last) );
        last = index + delim.size();
        index = s.find_first_of( delim, last );
    }
    <span class="kw">if</span> ( index-last&gt;<span class="dv">0</span> ) {
        ret.push_back( s.substr(last,index-last) );
    }
}

<span class="dt">void</span> line2vec( <span class="dt">const</span> std::string &amp;s, std::vector&lt; std::string &gt; &amp;ret )
{
    size_t left, right;
    left = s.find_first_of( std::string(<span class="st">&quot;[[&quot;</span>), <span class="dv">0</span> );
    <span class="kw">if</span> ( left == std::string::npos ) {
        <span class="kw">return</span>;
    }

    left  = s.find_first_of( std::string(<span class="st">&quot;[&quot;</span>), left<span class="dv">+1</span> );
    right = s.find_first_of( std::string(<span class="st">&quot;]&quot;</span>), left );
    <span class="kw">while</span> ( left != std::string::npos &amp;&amp; right != std::string::npos ) {
        std::string p = s.substr( left<span class="dv">+1</span>, right-left<span class="dv">-1</span> );
        ret.push_back( p );
        left  = s.find_first_of( std::string(<span class="st">&quot;[&quot;</span>), right );
        right = s.find_first_of( std::string(<span class="st">&quot;]&quot;</span>), left  );
    }
}

<span class="dt">void</span> str2ints( <span class="dt">const</span> std::string &amp;s, std::vector&lt;<span class="dt">int</span>&gt; &amp;ret )
{
    <span class="dt">int</span> i;
    <span class="kw">if</span> ( <span class="dv">1</span> != sscanf(s.c_str(), <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;i) ) {
        <span class="kw">return</span>;
    }
    ret.push_back(i);

    size_t left;
    left = s.find_first_of( std::string(<span class="st">&quot;,&quot;</span>), <span class="dv">0</span> );
    <span class="kw">while</span>( left != std::string::npos ) {
        <span class="kw">if</span> ( <span class="dv">1</span> == sscanf(s.substr(left).c_str(), <span class="st">&quot;</span><span class="ch">%*c%d</span><span class="st">&quot;</span>, &amp;i) ) {
            ret.push_back(i);
        }
        left = s.find_first_of(std::string(<span class="st">&quot;,&quot;</span>), left<span class="dv">+1</span>);
    }
}</code></pre></div>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/C%2B%2B">C++ - Wikipedia, the free encyclopedia</a></li>
<li><a href="http://www.cnblogs.com/miloyip/archive/2010/09/17/behind_cplusplus.html">C++ &#24378;&#22823;&#32972;&#21518; - Milo Yip - &#21338;&#23458;&#22253;</a></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<h2 id="cc-&#25342;&#36951;-pearls">C/C++ &#25342;&#36951; | Pearls</h2>
<ul>
<li><dl>
<dt>typedef <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">int</span> Point;

<span class="kw">typedef</span> <span class="kw">struct</span> {
    Point x, y;
} Point2d;

<span class="kw">typedef</span> Point2d Triangle[<span class="dv">3</span>];    <span class="co">// Triangle tri;    // 6 ints inside</span>

<span class="kw">typedef</span> Point2d (*FuncPtr)( Point2d p1, Point2d p2 );</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>ambiguity: declaration or multiplication? <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Class::X *p;
<span class="co">// X can be object of Class, or a nested class.</span>
<span class="co">// so ambi&#39;guity occurs</span>
Type::NestedType   * p;         <span class="co">// declare</span>
Type::object * p;               <span class="co">// multiplication</span></code></pre></div>
<p>&#36890;&#24120;&#22312;&#29992; template &#30340;&#26102;&#20505;&#21487;&#33021;&#32534;&#35793;&#22120;&#26080;&#27861;&#30693;&#36947;&#21040;&#24213;&#26159;&#20309;&#31181;&#24773;&#20917;&#65292;&#21487;&#20197;&#21152;&#19978; <code>typename</code> &#21363;&#29992; <code>typename Type::NestedType *p</code>&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>2d-vector is esier to use <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// c</span>
<span class="dt">int</span> **ary = <span class="kw">new</span> <span class="dt">int</span>*[row_num];
<span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; row_num; ++i) {
    ary[i] = <span class="kw">new</span> <span class="dt">int</span>[col_num];
    <span class="co">// delete[] ary[i];</span>
}
<span class="co">// delete[] ary;</span>

<span class="co">// cpp</span>
vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; ary(row_num, vector&lt;<span class="dt">int</span>&gt;(col_num, <span class="dv">0</span>));</code></pre></div>
<p>make sure to clear it&#8217;s contents when necessary.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vec.clear();                <span class="co">// the performance depends on how&#39;s your dtor</span>

<span class="co">// or</span>
vector&lt;T&gt;().swap( x );      <span class="co">// clear x reallocating</span></code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://www.cplusplus.com/reference/vector/vector/clear/">vector::clear - C++ Reference</a></li>
<li><a href="http://stackoverflow.com/questions/16420357/c-fastest-way-to-clear-or-erase-a-vector">performance - C++ fastest way to clear or erase a vector - Stack Overflow</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#20351;&#29992; reserve &#26469;&#36991;&#20813;&#19981;&#24517;&#35201;&#30340;&#37325;&#26032;&#20998;&#37197; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// void std::vector::reserve( size_type new_cap );</span>
vector&lt;<span class="dt">int</span>&gt; nums;
nums.reserve( <span class="dv">25</span> );</code></pre></div>
<p>&#20294;&#19981;&#35201;&#20197;&#20026; <code>size()</code> &#20063;&#21464;&#20102;&#12290;&#20320;&#21487;&#20197;&#29992; <code>resize( int num )</code>&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/container/vector/reserve">std::vector::reserve - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>tolower, toupper, isalpha <code class="fold">@</code></dt>
<dd><p>defined in <code>&lt;ctype.h&gt;</code> or <code>&lt;cctype&gt;</code> (<code>std::tolower</code>).</p>
<p><strong>tolower, touppper</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;ctype.h&gt;</span>

<span class="dt">int</span> toupper( <span class="dt">int</span> c );
<span class="dt">int</span> tolower( <span class="dt">int</span> c );</code></pre></div>
<p>converts the letter c to upper/lower case, if possible.</p>
<p>if not ASCII, or EOF, the behavior is undefined.</p>
<p><strong>isalpha, isspace, isdigit, isalnum, isxdigit</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> isalnum(    <span class="dt">int</span> c   );
<span class="dt">int</span> isalpha(    <span class="dt">int</span> c   );
<span class="dt">int</span> isascii(    <span class="dt">int</span> c   );
<span class="dt">int</span> isblank(    <span class="dt">int</span> c   );
<span class="dt">int</span> iscntrl(    <span class="dt">int</span> c   );
<span class="dt">int</span> isdigit(    <span class="dt">int</span> c   );
<span class="dt">int</span> isgraph(    <span class="dt">int</span> c   );
<span class="dt">int</span> isprint(    <span class="dt">int</span> c   );
<span class="dt">int</span> ispunct(    <span class="dt">int</span> c   );
<span class="dt">int</span> isspace(    <span class="dt">int</span> c   );
<span class="dt">int</span> isxdigit(   <span class="dt">int</span> c   );</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>even <em>vs</em> odd&#65292;&#22855;&#20598;&#25968;&#21028;&#26029; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// even</span>
x % <span class="dv">2</span>
<span class="co">// odd</span>
x % <span class="dv">2</span> != <span class="dv">0</span>
x &amp; <span class="bn">0x1</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>equal? float/double &#25968;&#30340;&#21028;&#31561; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// for int</span>
a == b
<span class="co">// for double</span>
fabs(a-b) &lt; <span class="fl">1e-9</span>        <span class="co">// math.h</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#25991;&#20214;&#35835;&#20889;&#65292;&#29992; FILE&#65292;fscanf &#25110;&#32773; ifstream&#65292;getline <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>

FILE *fp = fopen(filename, <span class="st">&quot;r&quot;</span>);
<span class="kw">while</span>( <span class="dv">2</span> == fscanf( fp, <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%s</span><span class="st">&quot;</span>, &amp;index, buf ) ) {
    <span class="co">// ...</span>
}
fclose(fp);

size_t fread(        <span class="dt">void</span> *ptr, size_t size, size_t nmemb, FILE *stream );
size_t fwrite( <span class="dt">const</span> <span class="dt">void</span> *ptr, size_t size, size_t nmemb, FILE *stream );</code></pre></div>
<p>&#34429;&#28982;&#20320;&#21487;&#33021;&#21916;&#27426; <code>fopen</code>&#65288;&#23601;&#36319;&#25105;&#20197;&#21069;&#19968;&#26679;&#65289;&#65292;&#20294;&#25105;&#25512;&#33616;&#29992; C++ &#30340; stream&#65292;&#22240;&#20026;&#23427;&#26356;&#23433;&#20840;&#65288;&#19981;&#26159;&#25351;&#38024;&#65292;&#27809;&#26377;&#27844;&#38706;&#21361;&#38505;&#65289;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;fstream&gt;</span>

std::ifstream file( filename.c_str(), ifstream::in );
<span class="co">// &#25110;&#32773;&#65306;std::ifstream file; file.open( filename.c_str(), ifstream::in );</span>

<span class="kw">if</span> ( !file ) { exit(<span class="dv">-1</span>); }
<span class="co">// &#25110;&#32773;&#65306;if ( !file.is_open() ) { exit(-1); }</span>

string line;
<span class="kw">while</span> ( getline(file, line) ) {
    <span class="co">// ...</span>
}</code></pre></div>
<p>&#36825;&#20010; <code>if( !file )</code> &#26159;&#22240;&#20026; file &#37325;&#36733;&#20102; <code>operator void *</code>&#65292;&#36825;&#21477;&#35805;&#31561;&#21516;&#20110; <code>if( NULL == (void *)file )</code>&#65292;&#35265; <a href="http://program.upc.edu.cn/CLibrary/iostream/ios/operator_voidpt.html">ios::operator void* - C++ Reference</a>&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/4421706/operator-overloading/4421708#4421708">c++ - Operator overloading - Stack Overflow</a></li>
<li><a href="http://en.cppreference.com/w/cpp/io/basic_ios/operator_bool">std::basic_ios::operator bool - cppreference.com</a></li>
</ul>
<dl>
<dt><a href="http://www.artima.com/cppsource/safebool.html">The Safe Bool Idiom</a> <code class="fold">@</code></dt>
<dd><p><strong>Learn how to validate objects in a boolean context without the usual harmful side effects.</strong></p>
<dl>
<dt>The Goal <code class="fold">@</code></dt>
<dd><p>Test their validity in Boolean contexts</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// method 1</span>
<span class="kw">if</span> (some_type* p=get_some_type()) {
    <span class="co">// p is valid, use it</span>
}
<span class="kw">else</span> {
    <span class="co">// p is not valid, take proper action</span>
}

<span class="co">// method 2</span>
smart_ptr&lt;some_type&gt; p(get_some_type());
<span class="kw">if</span> (p.is_valid()) {
    <span class="co">// p is valid, use it</span>
}
<span class="kw">else</span> {
    <span class="co">// p is not valid, take proper action</span>
}</code></pre></div>
</dd>
<dt>The Obvious Approach Is <code>operator bool</code>, and also, the Not Exactly Obvious, <code>operator!</code> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// operator bool version</span>
<span class="kw">class</span> Testable {
    <span class="dt">bool</span> ok_;
<span class="kw">public</span>:
    <span class="kw">explicit</span> Testable(<span class="dt">bool</span> b=<span class="kw">true</span>):ok_(b) {}

    <span class="kw">operator</span> <span class="dt">bool</span>() <span class="dt">const</span> {
        <span class="kw">return</span> ok_;
    }
    <span class="dt">bool</span> <span class="kw">operator</span>!() <span class="dt">const</span> {
        <span class="kw">return</span> !ok_;
    }
};</code></pre></div>
</dd>
<dt>A Seemingly Innocent Approach: <code>operator void *</code> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">operator</span> <span class="dt">void</span>*() <span class="dt">const</span> {
    <span class="kw">return</span> ok_==<span class="kw">true</span> ? <span class="kw">this</span> : <span class="dv">0</span>;
}</code></pre></div>
<p>good? see this:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Testable test;

<span class="co">// oops...</span>
<span class="kw">delete</span> test;</code></pre></div>
<p>If you think that this situation can be saved with a little const trickery, think again: The C++ Standard explicitly allows delete expressions with pointers to const types.</p>
</dd>
<dt>Almost Getting There with a Nested Class <code class="fold">@</code></dt>
<dd><p>In 1996, Don Box wrote about a very clever technique in his C++ Report column a technique originally created to support testing for nullness that almost does what we came here for. It involves a conversion function to a nested type (that doesn&#8217;t even need to be defined), like so:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Testable {
    <span class="dt">bool</span> ok_;
<span class="kw">public</span>:
    <span class="kw">explicit</span> Testable(<span class="dt">bool</span> b=<span class="kw">true</span>):ok_(b) {}
    <span class="kw">class</span> nested_class;         <span class="co">// no need to implement;</span>
    <span class="kw">operator</span> <span class="dt">const</span> nested_class*() <span class="dt">const</span> {
      <span class="kw">return</span> ok_ ? <span class="kw">reinterpret_cast</span>&lt;<span class="dt">const</span> nested_class*&gt;(<span class="kw">this</span>) : <span class="dv">0</span>;
    }
};</code></pre></div>
</dd>
<dt>The Safe Bool Idiom <code class="fold">@</code></dt>
<dd><p>It&#8217;s time to make these tests safe. Remember that we need to avoid unsafe conversions that allow for erroneous usage. We must also avoid overloading issues, and we definitely shouldn&#8217;t allow deletion through the conversion. So, what do we do? Without further ado, let me give you the solution in code.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Testable {
    <span class="dt">bool</span> ok_;
    <span class="kw">typedef</span> <span class="dt">void</span> (Testable::*bool_type)() <span class="dt">const</span>;
    <span class="dt">void</span> this_type_does_not_support_comparisons() <span class="dt">const</span> {}
<span class="kw">public</span>:
    <span class="kw">explicit</span> Testable(<span class="dt">bool</span> b=<span class="kw">true</span>):ok_(b) {}
    <span class="kw">operator</span> bool_type() <span class="dt">const</span> {
        <span class="kw">return</span> ok_==<span class="kw">true</span> ?  &amp;Testable::this_type_does_not_support_comparisons : <span class="dv">0</span>;
    }
};</code></pre></div>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/6242768/is-the-safe-bool-idiom-obsolete-in-c11">c++ - Is the safe-bool idiom obsolete in C++11? - Stack Overflow</a></li>
</ul>
</dd>
</dl>
<p>&#29992; getline &#33719;&#21462;&#20869;&#23481;&#21040; string &#21518;&#65292;&#21487;&#20197;&#20877;&#29992; C &#35821;&#35328;&#30340; scanf &#26469;&#35835;&#21462;&#23383;&#27573;&#65306; <code>sscanf( string.c_str(), format, ...)</code>&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">ofstream myfile;
myfile.open (<span class="st">&quot;example.txt&quot;</span>);
myfile &lt;&lt; <span class="st">&quot;Writing this to a file.</span><span class="ch">\n</span><span class="st">&quot;</span>;
myfile.close();</code></pre></div>
<table style="width:99%;">
<colgroup>
<col width="22%" />
<col width="76%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">ios::in</td>
<td align="left">Open for input operations.</td>
</tr>
<tr class="even">
<td align="left">ios::out</td>
<td align="left">Open for output operations.</td>
</tr>
<tr class="odd">
<td align="left">ios::binary</td>
<td align="left">Open in binary mode.</td>
</tr>
<tr class="even">
<td align="left">ios::ate</td>
<td align="left">Set the initial position at the end of the file. If this flag is not set, the initial position is the beginning of the file.</td>
</tr>
<tr class="odd">
<td align="left">ios::app</td>
<td align="left">All output operations are performed at the end of the file, appending the content to the current content of the file.</td>
</tr>
<tr class="even">
<td align="left">ios::trunc</td>
<td align="left">If the file is opened for output operations and it already existed, its previous content is deleted and replaced by the new one.</td>
</tr>
</tbody>
</table>
<table style="width:53%;">
<colgroup>
<col width="22%" />
<col width="30%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">class</th>
<th>default mode parameter</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">ofstream</td>
<td>ios::out</td>
</tr>
<tr class="even">
<td align="left">ifstream</td>
<td>ios::in</td>
</tr>
<tr class="odd">
<td align="left">fstream</td>
<td>ios::in | ios::out</td>
</tr>
</tbody>
</table>
<p>The following member functions exist to check for specific states of a stream (all of them return a bool value):</p>
<ul>
<li><dl>
<dt><code>bad()</code> <code class="fold">@</code></dt>
<dd>Returns true if a reading or writing operation fails. For example, in the case that we try to write to a file that is not open for writing or if the device where we try to write has no space left.
</dd>
</dl></li>
<li><dl>
<dt><code>fail()</code> <code class="fold">@</code></dt>
<dd>Returns true in the same cases as bad(), but also in the case that a format error happens, like when an alphabetical character is extracted when we are trying to read an integer number.
</dd>
</dl></li>
<li><dl>
<dt><code>eof()</code> <code class="fold">@</code></dt>
<dd>Returns true if a file open for reading has reached the end.
</dd>
</dl></li>
<li><dl>
<dt><code>good()</code> <code class="fold">@</code></dt>
<dd>It is the most generic state flag: it returns false in the same cases in which calling any of the previous functions would return true. Note that good and bad are not exact opposites (good checks more state flags at once).
</dd>
</dl></li>
</ul>
<p>&#33719;&#21462;&#25991;&#20214;&#23383;&#33410;&#25968;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// C version</span>
FILE *ifp = fopen( <span class="st">&quot;example.bin&quot;</span>, <span class="st">&quot;rb&quot;</span> );
fseek( ifp, <span class="dv">0</span>, SEEK_END );
size_t len = ftell( ifp );
fseek( ifp, <span class="dv">0</span>, SEEK_SET );
fclose( ifp );
printf( <span class="st">&quot;size is: </span><span class="ch">%d</span><span class="st"> bytes.</span><span class="ch">\n</span><span class="st">&quot;</span>, len );

<span class="co">// C++ version</span>
streampos begin,end;
ifstream ifs( <span class="st">&quot;example.bin&quot;</span>, ios::binary );
begin = ifs.tellg();
ifs.seekg( <span class="dv">0</span>, ios::end ); <span class="co">// ifs.seekg( 0 ); &#22238;&#21040;&#24320;&#22836;</span>
end   = ifs.tellg();
ifs.close();
cout &lt;&lt; <span class="st">&quot;size is: &quot;</span> &lt;&lt; (end-begin) &lt;&lt; <span class="st">&quot; bytes.</span><span class="ch">\n</span><span class="st">&quot;</span>;</code></pre></div>
<ul>
<li>get/read: <code>seekg ( position );</code>, <code>seekg ( offset, direction );</code>, <code>tellg()</code></li>
<li>put/write: <code>seekp ( position );</code>, <code>seekp ( offset, direction );</code>, <code>tellp()</code></li>
</ul>
<table>
<colgroup>
<col width="40%" />
<col width="59%" />
</colgroup>
<tbody>
<tr class="odd">
<td><code>ios::beg</code>, <code>SEEK_SET</code></td>
<td>offset counted from the beginning of the stream</td>
</tr>
<tr class="even">
<td><code>ios::cur</code>, <code>SEEK_CUR</code></td>
<td>offset counted from the current position</td>
</tr>
<tr class="odd">
<td><code>ios::end</code>, <code>SEEK_END</code></td>
<td>offset counted from the end of the stream</td>
</tr>
</tbody>
</table>
<p>reading an entire binary file</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;fstream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main () {
    streampos size;
    <span class="dt">char</span> * memblock;

    ifstream file( <span class="st">&quot;example.bin&quot;</span>, ios::in|ios::binary|ios::ate );
    <span class="kw">if</span> ( file.is_open() ) {
        size = file.tellg();
        memblock = <span class="kw">new</span> <span class="dt">char</span>[size];
        file.seekg( <span class="dv">0</span>, ios::beg );
        file.read( memblock, size );
        file.close();

        cout &lt;&lt; <span class="st">&quot;the entire file content is in memory&quot;</span>;
        <span class="kw">delete</span>[] memblock;
    } <span class="kw">else</span> { cout &lt;&lt; <span class="st">&quot;Unable to open file&quot;</span>; }
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://github.com/district10/raw2pts/blob/master/raw2pts.c">raw2pts/raw2pts.c at master &#183; district10/raw2pts</a></li>
<li><a href="http://www.cplusplus.com/doc/tutorial/files/">Input/output with files - C++ Tutorials</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>operators <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1</span>
cout &lt;&lt; phone &lt;&lt; endl;
<span class="co">// 2</span>
(cout &lt;&lt; phone) &lt;&lt; endl;
<span class="co">// 3</span>
<span class="kw">operator</span>&lt;&lt;(cout, phone).<span class="kw">operator</span>&lt;&lt;(endl);</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>fgets <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> main() {
    <span class="dt">char</span> buf[<span class="dv">5</span>];
    fgets( buf, <span class="kw">sizeof</span>(buf), stdin );
    printf( <span class="st">&quot;buf is: </span><span class="ch">%s\n</span><span class="st">&quot;</span>, buf );
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">gcc</span> main.cpp -o main
$ <span class="kw">echo</span> abcdef <span class="kw">|</span> <span class="kw">./main</span>
<span class="kw">buf</span> is: abcd</code></pre></div>
<p>&#21487;&#20197;&#30475;&#20986;&#65292;<code>buf, sizeof(buf)</code> &#24456;&#23433;&#20840;&#65292;&#19981;&#20250;&#28322;&#20986;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>atoi, strtol, strtof, atof, etc <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>atoi, atol, atoll <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>       atoi(  <span class="dt">const</span> <span class="dt">char</span> *str );
<span class="dt">long</span>      atol(  <span class="dt">const</span> <span class="dt">char</span> *str );
<span class="dt">long</span> <span class="dt">long</span> atoll( <span class="dt">const</span> <span class="dt">char</span> *str );

printf( <span class="st">&quot;</span><span class="ch">%i\n</span><span class="st">&quot;</span>, atoi(<span class="st">&quot; -123junk&quot;</span>) ); <span class="co">// -123</span></code></pre></div>
<p><code>atoi(nptr)</code> &#21644; <code>strtol(nptr, NULL, 10);</code> &#19968;&#26679;&#30340;&#65292;&#38500;&#20102;&#23427;&#19981; detect errors&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>atof <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="dt">double</span> atof( <span class="dt">const</span> <span class="dt">char</span> *str );</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main()
{
    std::cout &lt;&lt; std::atof(<span class="st">&quot;0.0000000123&quot;</span>) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
              &lt;&lt; std::atof(<span class="st">&quot;0.012&quot;</span>) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
              &lt;&lt; std::atof(<span class="st">&quot;15e16&quot;</span>) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
              &lt;&lt; std::atof(<span class="st">&quot;-0x1afp-2&quot;</span>) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
              &lt;&lt; std::atof(<span class="st">&quot;inF&quot;</span>) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
              &lt;&lt; std::atof(<span class="st">&quot;Nan&quot;</span>) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
}</code></pre></div>
<pre><code>1.23e-08
0.012
1.5e+17
-107.75
inf
nan</code></pre>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/c/string/byte/strtof">strtof, strtod, strtold - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>strtol, strtoll, strtoul, strtoull <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">long</span>      strtol(  <span class="dt">const</span> <span class="dt">char</span>          *str, <span class="dt">char</span>          **str_end, <span class="dt">int</span> base );
<span class="dt">long</span>      strtol(  <span class="dt">const</span> <span class="dt">char</span> *restrict str, <span class="dt">char</span> **restrict str_end, <span class="dt">int</span> base );
<span class="dt">long</span> <span class="dt">long</span> strtoll( <span class="dt">const</span> <span class="dt">char</span> *restrict str, <span class="dt">char</span> **restrict str_end, <span class="dt">int</span> base );</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;errno.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">const</span> <span class="dt">char</span> *p = <span class="st">&quot;10 200000000000000000000000000000 30 -40&quot;</span>;
    printf(<span class="st">&quot;Parsing &#39;</span><span class="ch">%s</span><span class="st">&#39;:</span><span class="ch">\n</span><span class="st">&quot;</span>, p);
    <span class="dt">char</span> *end;
    <span class="kw">for</span> (<span class="dt">long</span> i = strtol(p, &amp;end, <span class="dv">10</span>);
         p != end;
         i = strtol(p, &amp;end, <span class="dv">10</span>))
    {
        printf(<span class="st">&quot;&#39;</span><span class="ch">%.*s</span><span class="st">&#39; -&gt; &quot;</span>, (<span class="dt">int</span>)(end-p), p);
        p = end;
        <span class="kw">if</span> (errno == ERANGE){
            printf(<span class="st">&quot;range error, got &quot;</span>);
            errno = <span class="dv">0</span>;
        }
        printf(<span class="st">&quot;</span><span class="ch">%ld\n</span><span class="st">&quot;</span>, i);
    }
}</code></pre></div>
<p>&#19978;&#38754;&#37027;&#24120;&#24120;&#30340;&#20195;&#30721;&#23601;&#30528;&#20004;&#21477;&#26159;&#21313;&#20998;&#37325;&#35201;&#30340;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">long</span> i = strtol(p, &amp;end, <span class="dv">10</span>);   <span class="co">// 1. &#36716;&#21270;</span>
p = end;                        <span class="co">// 2. &#31227;&#21160;&#20301;&#32622;&#65292;&#22238;&#21040; 1. &#20877;&#23581;&#35797;&#36716;&#21270;</span>
p != end;                       <span class="co">// 3. &#21028;&#26029;&#26159;&#21542;&#27809;&#24471;&#36716;&#21270;&#20102;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">long</span>      strtoul(  <span class="dt">const</span> <span class="dt">char</span>          *str, <span class="dt">char</span>          **str_end, <span class="dt">int</span> base );
<span class="dt">unsigned</span> <span class="dt">long</span>      strtoul(  <span class="dt">const</span> <span class="dt">char</span> *restrict str, <span class="dt">char</span> **restrict str_end, <span class="dt">int</span> base );
<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> strtoull( <span class="dt">const</span> <span class="dt">char</span> *restrict str, <span class="dt">char</span> **restrict str_end, <span class="dt">int</span> base );</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/c/string/byte/strtol">strtol, strtoll - cppreference.com</a></li>
<li><a href="http://en.cppreference.com/w/c/string/byte/strtoul">strtoul, strtoull - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>strtof, strtod, strtold <code class="fold">@</code></dt>
<dd><p>&#36825;&#19977;&#20010;&#20989;&#25968;&#30340;&#20351;&#29992;&#21644; <code>strtol</code> &#31867;&#20284;&#65292;&#38500;&#20102;&#23427;&#26080;&#38656;&#25552;&#20379; base&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span>       strtof(  <span class="dt">const</span> <span class="dt">char</span> *restrict str, <span class="dt">char</span> **restrict str_end );
<span class="dt">double</span>      strtod(  <span class="dt">const</span> <span class="dt">char</span> *         str, <span class="dt">char</span> **         str_end );
<span class="dt">double</span>      strtod(  <span class="dt">const</span> <span class="dt">char</span> *restrict str, <span class="dt">char</span> **restrict str_end );
<span class="dt">long</span> <span class="dt">double</span> strtold( <span class="dt">const</span> <span class="dt">char</span> *restrict str, <span class="dt">char</span> **restrict str_end );</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;errno.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">const</span> <span class="dt">char</span> *p = <span class="st">&quot;111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz&quot;</span>;
    printf(<span class="st">&quot;Parsing &#39;</span><span class="ch">%s</span><span class="st">&#39;:</span><span class="ch">\n</span><span class="st">&quot;</span>, p);
    <span class="dt">char</span> *end;
    <span class="kw">for</span> (<span class="dt">double</span> f = strtod(p, &amp;end); p != end; f = strtod(p, &amp;end))
    {
        printf(<span class="st">&quot;&#39;</span><span class="ch">%.*s</span><span class="st">&#39; -&gt; &quot;</span>, (<span class="dt">int</span>)(end-p), p);
        p = end;
        <span class="kw">if</span> (errno == ERANGE){
            printf(<span class="st">&quot;range error, got &quot;</span>);
            errno = <span class="dv">0</span>;
        }
        printf(<span class="st">&quot;</span><span class="ch">%f\n</span><span class="st">&quot;</span>, f);
    }
}
<span class="co">//          Parsing &#39;111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz&#39;:</span>
<span class="co">//          &#39;111.11&#39; -&gt; 111.110000</span>
<span class="co">//          &#39; -2.22&#39; -&gt; -2.220000</span>
<span class="co">//          &#39; 0X1.BC70A3D70A3D7P+6&#39; -&gt; 111.110000</span>
<span class="co">//          &#39;  1.18973e+4932&#39; -&gt; range error, got inf</span></code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/string/byte/atof">std::atof - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>itoa &#65288;&#19981;&#26159;&#26631;&#20934;&#24211;&#20989;&#25968;&#65289;<code class="fold">@</code></dt>
<dd><p>&#36825;&#26159;&#38472;&#30805;&#20070;&#37324;&#32473;&#30340;&#20195;&#30721;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">const</span> <span class="dt">char</span>* convert(<span class="dt">char</span> buf[], <span class="dt">int</span> value)
{
    <span class="dt">static</span> <span class="dt">char</span> digits =
    { <span class="st">&#39;9&#39;</span>, <span class="st">&#39;8&#39;</span>, <span class="st">&#39;7&#39;</span>, <span class="st">&#39;6&#39;</span>, <span class="st">&#39;5&#39;</span>, <span class="st">&#39;4&#39;</span>, <span class="st">&#39;3&#39;</span>, <span class="st">&#39;2&#39;</span>, <span class="st">&#39;1&#39;</span>, <span class="st">&#39;0&#39;</span>,
        <span class="st">&#39;1&#39;</span>, <span class="st">&#39;2&#39;</span>, <span class="st">&#39;3&#39;</span>, <span class="st">&#39;4&#39;</span>, <span class="st">&#39;5&#39;</span>, <span class="st">&#39;6&#39;</span>, <span class="st">&#39;7&#39;</span>, <span class="st">&#39;8&#39;</span>, <span class="st">&#39;9&#39;</span> };
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">char</span> *<span class="dt">const</span> zero = digits + <span class="dv">9</span>; <span class="co">// zero &#25351;&#21521; &#39;0&#39;</span>
    <span class="co">// works for -2147483648 .. 2147483647</span>
    <span class="dt">int</span> i = value;
    <span class="dt">char</span>* p = buf;
    <span class="kw">do</span> {
        <span class="co">// lsd - least significant digit</span>
        <span class="dt">int</span> lsd = i % <span class="dv">10</span>; <span class="co">// lsd &#21487;&#33021;&#23567;&#20110; 0</span>
        <span class="co">// &#26159;&#21521;&#19979;&#21462;&#25972;&#36824;&#26159;&#21521;&#38646;&#21462;&#25972;?</span>
        *p++ = zero[lsd]; <span class="co">// &#19979;&#26631;&#21487;&#33021;&#20026;&#36127;</span>
        i /= <span class="dv">10</span>;
    } <span class="kw">while</span> (i != <span class="dv">0</span>);
    <span class="kw">if</span> (value &lt; <span class="dv">0</span>) {
        *p++ = <span class="st">&#39;-&#39;</span>;
    }
    *p = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>;
    std::reverse(buf, p);
    <span class="kw">return</span> p; <span class="co">// p - buf &#21363;&#20026;&#25972;&#25968;&#38271;&#24230;</span>
}

<span class="dt">int</span> main() {
    <span class="dt">char</span> buf;
    <span class="dt">int</span> num;
    <span class="kw">while</span>( <span class="dv">1</span> == scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;num ) ) {
        convert( buf, num );
        printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> -&gt; </span><span class="ch">\&quot;%s\&quot;\n</span><span class="st">&quot;</span>, num, buf );
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">g++</span> itoa.cpp -o itoa
$ <span class="kw">echo</span> <span class="st">&quot;23 235982743 -23432&quot;</span> <span class="kw">|</span> <span class="kw">./itoa</span>
<span class="kw">23</span> -<span class="kw">&gt;</span> <span class="st">&quot;23&quot;</span>
<span class="kw">235982743</span> -<span class="kw">&gt;</span> <span class="st">&quot;235982743&quot;</span>
<span class="kw">-23432</span> -<span class="kw">&gt;</span> <span class="st">&quot;-23432&quot;</span></code></pre></div>
<p>C &#35821;&#35328;&#20013;&#30340;&#25972;&#25968;&#38500;&#27861; (/) &#21644;&#21462;&#27169; (%) &#36816;&#31639;&#22312;&#25805;&#20316;&#25968;&#20026;&#36127;&#30340;&#26102;&#20505;&#65292;&#32467;&#26524;&#26159; implementation-defined&#12290;&#20063;&#23601;&#26159;&#35828;&#65292;&#22914;&#26524; m&#12289;d &#37117;&#26159;&#25972;&#25968;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> q = m / d;
<span class="dt">int</span> r = m % d;</code></pre></div>
<p>&#37027;&#20040; C &#35821;&#35328;&#21482;&#20445;&#35777; m = q &#215; d + r&#12290;&#22914;&#26524; m&#12289;d &#24403;&#20013;&#26377;&#36127;&#25968;,&#37027;&#20040; q &#21644; r &#30340;&#27491;&#36127;&#21495;&#26159;&#30001;&#23454;&#29616;&#20915;&#23450;&#30340;&#12290;&#27604;&#22914; (&#8722;13)/4 = (&#8722;3) &#25110; (&#8722;13)/4 = (&#8722;4) &#37117;&#26159;&#21512;&#27861;&#30340;&#12290;&#22914;&#26524;&#37319;&#29992;&#21518;&#19968;&#31181;&#23454;&#29616;,&#37027;&#20040;&#36825;&#27573;&#36716;&#25442;&#20195;&#30721;&#23601;&#38169;&#20102;(&#22240;&#20026;&#23558;&#26377; (&#8722;1)%10 = 9 )&#12290;&#21482;&#26377;&#21830;&#21521; 0 &#21462;&#25972;,&#20195;&#30721;&#25165;&#33021;&#27491;&#24120;&#24037;&#20316;&#12290;</p>
<p>GCC always follows the C99 requirement that the result of division is truncated towards zero. G++ &#19968;&#30452;&#36981;&#24490; C99 &#35268;&#33539;&#65292;&#21830;&#21521; 0 &#21462;&#25972;&#65292;&#31639;&#27861;&#33021;&#27491;&#24120;&#24037;&#20316;&#12290;</p>
<p>Visual C++ 2008, The sign of the remainder is the same as the sign of the dividend. &#36825;&#20010;&#35828;&#27861;&#19982;&#21830;&#21521; 0 &#21462;&#25972;&#26159;&#31561;&#20215;&#30340;&#65292;&#31639;&#27861;&#20063;&#33021;&#27491;&#24120;&#24037;&#20316;&#12290;</p>
<p>&#19981;&#36807;&#65292;&#25105;&#35273;&#24471;&#38472;&#30805;&#36825;&#20010;&#31243;&#24207;&#40635;&#28902;&#20102;&#65292;&#20854;&#23454;&#21487;&#20197;&#21152;&#19968;&#20010;&#31616;&#21333;&#30340;&#21028;&#26029;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span>( value &lt; <span class="dv">0</span> ) {
    buf[<span class="dv">0</span>] = <span class="st">&#39;-&#39;</span>;
    <span class="kw">return</span> convert( buf<span class="dv">+1</span>, -value );    <span class="co">// &#26426;&#26234;&#22914;&#25105;&#21704;&#21704;</span>
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#20301;&#36816;&#31639; #1 <code class="fold">@</code></dt>
<dd><p>&#26469;&#33258;&#25105;&#30340; issue&#65306;<a href="https://github.com/district10/notes/issues/1" class="uri">https://github.com/district10/notes/issues/1</a></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="ot">#define PRINT(x) printf(&quot;hex: 0x%08x, dec: %12d, str: \&quot;%s\&quot;\n&quot;, x, x, #x)</span>

<span class="dt">int</span> main()
{
    puts( <span class="st">&quot;&#20840; 0 &amp; &#20840; 1&quot;</span> );
    PRINT( <span class="dv">0</span> );
    PRINT( -<span class="dv">1</span> );

    puts( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&#20840; 1 &#30340;&#24038;&#21491; shift&quot;</span> );
    PRINT( -<span class="dv">1</span>&gt;&gt;<span class="dv">1</span> );
    PRINT( -<span class="dv">1</span>&lt;&lt;<span class="dv">1</span> );

    puts( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&#20943;&#27861;&#20248;&#20808;&#32423;&#26356;&#39640;&quot;</span> );
    PRINT( <span class="dv">1</span>&lt;&lt;<span class="dv">31-1</span> );
    PRINT( <span class="dv">1</span>&lt;&lt;<span class="dv">30</span> );

    puts( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&#24590;&#20040;&#24471;&#21040; int &#30340;&#26368;&#22823;&#27491;&#25968;&quot;</span> );
    PRINT( <span class="dv">1</span>&lt;&lt;<span class="dv">31</span> );
    PRINT( (<span class="dv">1</span>&lt;&lt;<span class="dv">31</span>)-<span class="dv">1</span> );
    PRINT( ((<span class="dt">unsigned</span> <span class="dt">int</span>)<span class="dv">1</span>&lt;&lt;<span class="dv">31</span>)-<span class="dv">1</span> );
    PRINT( ((<span class="dt">unsigned</span> <span class="dt">int</span>)-<span class="dv">1</span>)&gt;&gt;<span class="dv">1</span> );
    PRINT( -<span class="dv">1</span>&gt;&gt;<span class="dv">1</span> );
    PRINT( <span class="bn">0x7FFFFFFF</span> );
}</code></pre></div>
<p>&#32534;&#35793;&#65306;<code>gcc test.c -o test</code>&#65292;</p>
<p>&#36816;&#34892;&#65306;<code>./test</code></p>
<p>&#32467;&#26524;&#65306;</p>
<pre><code>&#20840; 0 &amp; &#20840; 1
hex: 0x00000000, dec:            0, str: &quot;0&quot;
hex: 0xffffffff, dec:           -1, str: &quot;-1&quot;

&#20840; 1 &#30340;&#24038;&#21491; shift
hex: 0xffffffff, dec:           -1, str: &quot;-1&gt;&gt;1&quot;
hex: 0xfffffffe, dec:           -2, str: &quot;-1&lt;&lt;1&quot;

&#20943;&#27861;&#20248;&#20808;&#32423;&#26356;&#39640;
hex: 0x40000000, dec:   1073741824, str: &quot;1&lt;&lt;31-1&quot;
hex: 0x40000000, dec:   1073741824, str: &quot;1&lt;&lt;30&quot;

&#24590;&#20040;&#24471;&#21040; int &#30340;&#26368;&#22823;&#27491;&#25968;
hex: 0x80000000, dec:  -2147483648, str: &quot;1&lt;&lt;31&quot;
hex: 0x7fffffff, dec:   2147483647, str: &quot;(1&lt;&lt;31)-1&quot;
hex: 0x7fffffff, dec:   2147483647, str: &quot;((unsigned int)1&lt;&lt;31)-1&quot;
hex: 0x7fffffff, dec:   2147483647, str: &quot;((unsigned int)-1)&gt;&gt;1&quot;
hex: 0xffffffff, dec:           -1, str: &quot;-1&gt;&gt;1&quot;
hex: 0x7fffffff, dec:   2147483647, str: &quot;0x7FFFFFFF&quot;</code></pre>
</dd>
</dl></li>
<li><dl>
<dt>&#19981;&#35201;&#34987;&#21035;&#20154;&#30340; <code>memset(buf, -1, sizeof(buf))</code> &#36855;&#24785;&#20102; #2 <code class="fold">@</code></dt>
<dd><p>&#26469;&#33258;&#25105;&#30340; issue&#65306;<a href="https://github.com/district10/notes/issues/2" class="uri">https://github.com/district10/notes/issues/2</a></p>
<p>&#26377;&#25991;&#20214; <code>test.c</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="dt">int</span> main(){
    <span class="dt">int</span> m;
    printf( <span class="st">&quot;sizeof(m): </span><span class="ch">%lu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(m) );

    memset( m, <span class="dv">-1</span>, <span class="kw">sizeof</span>(m) );
    printf( <span class="st">&quot;after memset(m,   -1, sizeof(m)): </span><span class="ch">%20d</span><span class="st"> (0x</span><span class="ch">%08x</span><span class="st">), </span><span class="ch">%20d</span><span class="st"> (0x</span><span class="ch">%08x</span><span class="st">)</span><span class="ch">\n</span><span class="st">&quot;</span>, m, m, m, m );

    memset( m,  <span class="dv">1</span>, <span class="kw">sizeof</span>(m) );
    printf( <span class="st">&quot;after memset(m,    1, sizeof(m)): </span><span class="ch">%20d</span><span class="st"> (0x</span><span class="ch">%08x</span><span class="st">), </span><span class="ch">%20d</span><span class="st"> (0x</span><span class="ch">%08x</span><span class="st">)</span><span class="ch">\n</span><span class="st">&quot;</span>, m, m, m, m );

    memset( m, <span class="bn">0xFF</span>, <span class="kw">sizeof</span>(m) );
    printf( <span class="st">&quot;after memset(m, 0xFF, sizeof(m)): </span><span class="ch">%20d</span><span class="st"> (0x</span><span class="ch">%08x</span><span class="st">), </span><span class="ch">%20d</span><span class="st"> (0x</span><span class="ch">%08x</span><span class="st">)</span><span class="ch">\n</span><span class="st">&quot;</span>, m, m, m, m );

    memset( m, <span class="bn">0xA5</span>, <span class="kw">sizeof</span>(m) );
    printf( <span class="st">&quot;after memset(m, 0xA5, sizeof(m)): </span><span class="ch">%20d</span><span class="st"> (0x</span><span class="ch">%08x</span><span class="st">), </span><span class="ch">%20d</span><span class="st"> (0x</span><span class="ch">%08x</span><span class="st">)</span><span class="ch">\n</span><span class="st">&quot;</span>, m, m, m, m );
}</code></pre></div>
<p>&#32534;&#35793;&#36816;&#34892;</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">gcc</span> test.c -o test
$ <span class="kw">./test</span>
<span class="kw">sizeof</span>(m)<span class="kw">:</span> 8
<span class="kw">after</span> memset(m,   -1, sizeof(m))<span class="kw">:</span>                   -1 (0xffffffff),                   <span class="kw">-1</span> (0xffffffff)
<span class="kw">after</span> memset(m,    1, sizeof(m))<span class="kw">:</span>             16843009 (0x01010101),             <span class="kw">16843009</span> (0x01010101)
<span class="kw">after</span> memset(m, 0xFF, sizeof(m))<span class="kw">:</span>                   -1 (0xffffffff),                   <span class="kw">-1</span> (0xffffffff)
<span class="kw">after</span> memset(m, 0xA5, sizeof(m))<span class="kw">:</span>          -1515870811 (0xa5a5a5a5),          <span class="kw">-1515870811</span> (0xa5a5a5a5)</code></pre></div>
<p>&#25152;&#20197;&#65292;&#35201;&#23567;&#24515;&#20102;&#12290;&#21035;&#20154;&#29992; <code>memset(buf, -1, sizeof(buf))</code> &#26469;&#21021;&#22987;&#21270; buf&#65292;&#20320;&#29992; -2 &#21487;&#19981;&#26159; -2 &#21834;&#65281;</p>
<p>&#36825;&#28041;&#21450;&#21040; two&#8217;s compliment &#32534;&#30721;&#12290;</p>
<p>&#21478;&#19968;&#20010;&#19981;&#31526;&#21512;&#30452;&#35273;&#30340;&#26159; <code>int buf = { 0 };</code> &#30830;&#23454;&#20250;&#25226;&#25152;&#26377;&#20803;&#32032;&#21021;&#22987;&#21270;&#20026; 0&#65292;&#20294;&#26159; <code>int buf = { 3 };</code> &#21482;&#22238;&#21021;&#22987;&#21270;&#31532;&#19968;&#20010;&#20803;&#32032;&#20026; 3&#65292;&#20854;&#23427;&#37117;&#26159; 0&#8230;&#8230;&#33267;&#23569;&#22312;&#25105;&#30340; <code>gcc</code> &#21644; <code>g++</code> &#19978;&#37117;&#26159;&#22914;&#27492;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>std::fill <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt; <span class="kw">class</span> ForwardIt, <span class="kw">class</span> T &gt;
<span class="dt">void</span> fill( ForwardIt first, ForwardIt last, <span class="dt">const</span> T&amp; value );</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v{<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>};

    std::fill(v.begin(), v.end(), <span class="dv">-1</span>);

    <span class="kw">for</span> (<span class="kw">auto</span> elem : v) {
        std::cout &lt;&lt; elem &lt;&lt; <span class="st">&quot; &quot;</span>;   <span class="co">// -1 -1 -1 -1 -1 -1 -1 -1 -1 -1</span>
    }
    std::cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/algorithm/fill">std::fill - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">size_t x = ...;
ssize_t y = ...;
printf(<span class="st">&quot;</span><span class="ch">%zu\n</span><span class="st">&quot;</span>, x);  <span class="co">// prints as unsigned decimal</span>
printf(<span class="st">&quot;</span><span class="ch">%zx\n</span><span class="st">&quot;</span>, x);  <span class="co">// prints as hex</span>
printf(<span class="st">&quot;</span><span class="ch">%zd\n</span><span class="st">&quot;</span>, y);  <span class="co">// prints as signed decimal</span></code></pre></div>
<ul>
<li><code>%s</code>, <code>%20s</code> &#65288;&#26368;&#22810; scanf 20 char&#65292;&#38656;&#35201;&#26377; 21 &#38271;&#24230;&#30340; buf&#65289;</li>
<li><code>%d</code> (decimal integer), strtol(ptr, &amp;end, 10)</li>
<li><code>%i</code> (integer), strtol(ptr, &amp;end, 0)</li>
<li><code>%u</code> (unsigned decimal integer), strtoul(ptr, &amp;end, 10)</li>
<li><code>%o</code> (unsigned octal integer), strtoul(ptr, &amp;end, 8)</li>
<li><code>%x</code>, <code>%X</code> (unsigned hexadecimal integer), strtoul(ptr, &amp;end, 16)</li>
<li><code>%a</code>, <code>%A</code>, <code>%e</code>, <code>%E</code>, <code>%f</code>, <code>%F</code>, <code>%g</code>, <code>%G</code>, same as strtof</li>
<li><code>%p</code>, pointer</li>
<li>&#36755;&#20837;&#21644;&#36755;&#20986;&#29992;&#30340;&#26684;&#24335;&#23383;&#31526;&#20018;&#19981;&#19968;&#26679;&#12290;&#36755;&#20837; short &#35201;&#29992; %hd,&#36755;&#20986;&#29992; %d;&#36755;&#20837; double &#35201;&#29992; %lf,&#36755;&#20986;&#29992; %f&#12290;</li>
<li><code>%lu</code>&#65292;<code>size_t</code> &#30340;&#25171;&#21360;</li>
</ul>
<p>&#27491;&#30830;&#32780;&#23433;&#20840;&#30340;&#20570;&#27861;&#22914; Bjarne Stroustrup &#22312;&#12298;Learning Standard C++ as a New Language&#12299;&#25152;&#31034;:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> main()
{
    <span class="dt">const</span> <span class="dt">int</span> max_name = <span class="dv">80</span>;
    <span class="dt">char</span> name[max_name];
    <span class="dt">char</span> fmt;
    sprintf(fmt, <span class="st">&quot;</span><span class="ch">%%%d</span><span class="st">s&quot;</span>, max_name - <span class="dv">1</span>);
    scanf(fmt, name);
    printf(<span class="st">&quot;</span><span class="ch">%s\n</span><span class="st">&quot;</span>, name);
}</code></pre></div>
<p>&#25105;&#27809;&#30475;&#25026;&#8230;&#8230;&#32780;&#19988;&#25105;&#36816;&#34892;&#19981;&#20986;&#26469;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;a);
scanf(<span class="st">&quot; </span><span class="ch">%c</span><span class="st">&quot;</span>, &amp;c); <span class="co">// ignore the endline after %d, then read a char</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define __STDC_WANT_LIB_EXT1__ 1</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stddef.h&gt;</span>
<span class="ot">#include &lt;locale.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">int</span> i, j;
    <span class="dt">float</span> x, y;
    <span class="dt">char</span> str1, str2;
    <span class="dt">wchar_t</span> warr;
    setlocale(LC_ALL, <span class="st">&quot;en_US.utf8&quot;</span>);

    <span class="dt">char</span> input[] = <span class="st">&quot;25 54.32E-1 Thompson 56789 0123 56&#223;&#27700;&quot;</span>;
    <span class="co">/* parse as follows:</span>
<span class="co">       %d: an integer</span>
<span class="co">       %f: a floating-point value</span>
<span class="co">       %9s: a string of at most 9 non-whitespace characters</span>
<span class="co">       %2d: two-digit integer (digits 5 and 6)</span>
<span class="co">       %f:  a floating-point value (digits 7, 8, 9)</span>
<span class="co">       %*d: an integer which isn&#39;t stored anywhere</span>
<span class="co">       &#39; &#39;: all consecutive whitespace</span>
<span class="co">       %3[0-9]: a string of at most 3 decimal digits (digits 5 and 6)</span>
<span class="co">       %2lc: two wide characters, using multibyte to wide conversion  */</span>
    <span class="dt">int</span> ret = sscanf(input, <span class="st">&quot;</span><span class="ch">%d%f%9s%2d%f%*d</span><span class="st"> </span><span class="ch">%3[0-9]%</span><span class="st">2lc&quot;</span>,
                     &amp;i, &amp;x, str1, &amp;j, &amp;y, str2, warr);

    printf(<span class="st">&quot;Converted </span><span class="ch">%d</span><span class="st"> fields:</span><span class="ch">\n</span><span class="st">i = </span><span class="ch">%d\n</span><span class="st">x = </span><span class="ch">%f\n</span><span class="st">str1 = </span><span class="ch">%s\n</span><span class="st">&quot;</span>
           <span class="st">&quot;j = </span><span class="ch">%d\n</span><span class="st">y = </span><span class="ch">%f\n</span><span class="st">str2 = </span><span class="ch">%s\n</span><span class="st">&quot;</span>
           <span class="st">&quot;warr = U+</span><span class="ch">%x</span><span class="st"> warr = U+</span><span class="ch">%x\n</span><span class="st">&quot;</span>,
           ret, i, x, str1, j, y, str2, warr, warr);

<span class="ot">#ifdef __STDC_LIB_EXT1__</span>
    <span class="dt">int</span> n = sscanf_s(input, <span class="st">&quot;</span><span class="ch">%d%f%s</span><span class="st">&quot;</span>, &amp;i, &amp;x, str1, (rsize_t)<span class="kw">sizeof</span> str1);
    <span class="co">// writes 25 to i, 5.432 to x, the 9 bytes &quot;thompson\0&quot; to str1, and 3 to n.</span>
<span class="ot">#endif</span>
}</code></pre></div>
<pre><code>Converted 7 fields:
i = 25
x = 5.432000
str1 = Thompson
j = 56
y = 789.000000
str2 = 56
warr = U+df warr = U+6c34</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">sprintf(dst, <span class="st">&quot;</span><span class="ch">%s</span><span class="st"> and </span><span class="ch">%s</span><span class="st">&quot;</span>, dst, t); <span class="co">// &lt;- broken: undefined behavior</span>

<span class="dt">const</span> <span class="dt">char</span> *fmt = <span class="st">&quot;sqrt(2) = </span><span class="ch">%f</span><span class="st">&quot;</span>;
<span class="dt">int</span> sz = snprintf(NULL, <span class="dv">0</span>, fmt, sqrt(<span class="dv">2</span>));
<span class="dt">char</span> buf[sz + <span class="dv">1</span>]; <span class="co">// note +1 for terminating null byte</span>
snprintf(buf, <span class="kw">sizeof</span> buf, fmt, sqrt(<span class="dv">2</span>));</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/2524611/how-can-one-print-a-size-t-variable-portably-using-the-printf-family">c - How can one print a size_t variable portably using the printf family? - Stack Overflow</a></li>
<li><a href="http://en.cppreference.com/w/c/io/fscanf">scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s - cppreference.com</a></li>
<li><a href="http://en.cppreference.com/w/c/io/fprintf">printf, fprintf, sprintf, snprintf, printf_s, fprintf_s - cppreference.com</a></li>
<li><a href="http://en.cppreference.com/w/c/io/vfscanf">vscanf, vfscanf, vsscanf, vscanf_s, vfscanf_s, vsscanf_s - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>T::iterator, T::const_iterator, begin, end, for_each <code class="fold">@</code></dt>
<dd><ul>
<li>begin, end, cbegin, cend, rbegin, rend</li>
<li>iterator, const_iterator, reverse_iterator</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> Container, <span class="kw">typename</span> Function&gt;
<span class="dt">void</span> for_each(Container&amp;&amp; cont, Function f) {
    <span class="kw">using</span> std::begin;
    <span class="kw">auto</span> it = begin(cont);
    <span class="kw">using</span> std::end;
    <span class="kw">auto</span> end_it = end(cont);
    <span class="kw">while</span> (it != end_it) {
        f(*it);
        ++it;
    }
}</code></pre></div>
<p>&#36845;&#20195;&#22120;&#19981;&#29992; <code>&lt;</code> &#32780;&#29992; <code>!=</code> &#30340;&#22909;&#22788;&#26377;&#65306;</p>
<ul>
<li><p>&#26377;&#26102;&#20505; reverse iterator &#24212;&#35813;&#29992; <code>&lt;</code> &#36824;&#26159; <code>&gt;</code> &#26159;&#19968;&#20214;&#30683;&#30462;&#30340;&#20107;&#65306;</p>
<p>&#20174; end &#22238;&#21040; begin&#65292;&#37027;&#25105;&#20204;&#26159; ++iter&#65292;&#37027; iter &#26159;&#21464;&#22823;&#20102;&#65292;&#36824;&#26159;&#21464;&#23567;&#20102;&#65311;&#37027;&#25105;&#20204;&#26368;&#21518;&#24212;&#35813;&#29992; iter &gt;= begin &#36824;&#26159; iter &lt; begin &#21602;&#65311;</p>
<p>&#29992; != &#23601;&#19981;&#35201;&#32771;&#34385;&#36825;&#20010;&#38382;&#39064;&#65292;&#22240;&#20026;&#25105;&#20204;&#19981; care iter++ &#21040;&#24213;&#26159;&#21464;&#22823;&#36824;&#26159;&#21464;&#23567;&#65292;&#21453;&#27491;&#26159;&#21040;&#19979;&#19968;&#20010;&#20301;&#32622;&#8230;&#8230;</p></li>
<li><p>&#36824;&#26377;&#20123; container&#65292;&#26681;&#26412;&#27809;&#26377;&#39034;&#24207;&#65292;&#27604;&#22914; list &#21644; map&#65292;&#26681;&#26412;&#27809;&#26377;&#21150;&#27861;&#29992; &lt;&#12290;</p></li>
</ul>
<p>&#29031;&#39038;&#21040;&#19978;&#38754;&#20004;&#28857;&#65292;&#20110;&#26159;&#22823;&#23478;&#32479;&#19968;&#29992; != &#32780;&#19981;&#26159;&#27604;&#36739;&#22823;&#23567;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>

<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span> };
    <span class="kw">auto</span> vi = std::begin(v);
    std::cout &lt;&lt; *vi &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;

    <span class="dt">int</span> a[] = { <span class="dv">-5</span>, <span class="dv">10</span>, <span class="dv">15</span> };
    <span class="kw">auto</span> ai = std::begin(a);
    std::cout &lt;&lt; *ai &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre></div>
<div class="figure">
<img src="http://upload.cppreference.com/mwiki/images/3/39/range-rbegin-rend.svg" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>

<span class="dt">int</span> main()
{
    std::string s = <span class="st">&quot;Hello, world&quot;</span>;

    <span class="co">// &#19968;&#26679;&#30340;&#65306;std::string::reverse_iterator r = s.rbegin();</span>
    std::reverse_iterator&lt;std::string::iterator&gt; r = s.rbegin();
    *r = <span class="st">&#39;O&#39;</span>; <span class="co">// replaces &#39;o&#39; with &#39;O&#39;</span>
    r += <span class="dv">7</span>; <span class="co">// iterator now points at &#39;O&#39;</span>
    std::string rev(r, s.rend());
    std::cout &lt;&lt; rev &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>; <span class="co">// &quot;OlleH&quot;</span>
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">struct</span> Sum
{
    Sum(): sum{<span class="dv">0</span>} { }
    <span class="dt">void</span> <span class="kw">operator</span>()(<span class="dt">int</span> n) { sum += n; }
    <span class="dt">int</span> sum;
};

<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; nums{<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">8</span>, <span class="dv">15</span>, <span class="dv">267</span>};

    std::cout &lt;&lt; <span class="st">&quot;before:&quot;</span>;
    <span class="kw">for</span> (<span class="kw">auto</span> <span class="dt">const</span> &amp;n : nums)
    {
        std::cout &lt;&lt; <span class="st">&#39; &#39;</span> &lt;&lt; n;
    }
    std::cout &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;

    std::for_each(nums.begin(), nums.end(), [](<span class="dt">int</span> &amp;n){ n++; });

    <span class="co">// calls Sum::operator() for each number</span>
    Sum s = std::for_each(nums.begin(), nums.end(), Sum());

    std::cout &lt;&lt; <span class="st">&quot;after: &quot;</span>;
    <span class="kw">for</span> (<span class="kw">auto</span> <span class="dt">const</span> &amp;n : nums)
    {
        std::cout &lt;&lt; <span class="st">&#39; &#39;</span> &lt;&lt; n;
    }
    std::cout &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
    std::cout &lt;&lt; <span class="st">&quot;sum: &quot;</span> &lt;&lt; s.sum &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre></div>
<p>Output:</p>
<pre><code>before: 3 4 2 8 15 267
after:  4 5 3 9 16 268
sum: 305</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> (<span class="kw">auto</span>&amp;&amp; [first,second] : mymap) {
    <span class="co">// use first and second</span>
}

std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>};
<span class="kw">for</span> (<span class="dt">const</span> <span class="dt">int</span> &amp;i : v) <span class="co">// access by const reference</span>
<span class="kw">for</span> (<span class="kw">auto</span> i : v) <span class="co">// access by value, the type of i is int</span>
<span class="kw">for</span> (<span class="kw">auto</span>&amp;&amp; i : v) <span class="co">// access by reference, the type of i is int&amp;</span>
<span class="kw">for</span> (<span class="dt">int</span> n : {<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>}) <span class="co">// the initializer may be a braced-init-list</span>

<span class="dt">int</span> a[] = {<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>};
<span class="kw">for</span> (<span class="dt">int</span> n : a) <span class="co">// the initializer may be an array</span></code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/iterator/iterator">std::iterator - cppreference.com</a></li>
<li><a href="http://en.cppreference.com/w/cpp/iterator/begin">std::begin - cppreference.com</a></li>
<li><a href="http://en.cppreference.com/w/cpp/iterator/end">std::end - cppreference.com</a></li>
<li><a href="http://en.cppreference.com/w/cpp/iterator/reverse_iterator">std::reverse_iterator - cppreference.com</a></li>
<li><a href="http://en.cppreference.com/w/cpp/iterator/ostream_iterator">std::ostream_iterator - cppreference.com</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/range-for">Range-based for loop (since C++11) - cppreference.com</a></li>
<li><a href="http://en.cppreference.com/w/cpp/algorithm/for_each">std::for_each - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::min, std::max, std::minmax, std::max_element <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// misc</span>
std::max(<span class="dv">1</span>, <span class="dv">9999</span>)
std::max(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>)
std::max( { <span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;hello&quot;</span> },
        [](<span class="dt">const</span> std::string&amp; s1, <span class="dt">const</span> std::string&amp; s2) {
            <span class="kw">return</span> s1.size() &lt; s2.size();
        });</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> T, <span class="kw">class</span> Compare&gt;
std::pair&lt;<span class="dt">const</span> T&amp;, <span class="dt">const</span> T&amp;&gt; minmax( <span class="dt">const</span> T&amp; a, <span class="dt">const</span> T&amp; b, Compare comp )
{
    <span class="kw">return</span> comp(b, a) ? std::pair&lt;<span class="dt">const</span> T&amp;, <span class="dt">const</span> T&amp;&gt;(b, a)
                      : std::pair&lt;<span class="dt">const</span> T&amp;, <span class="dt">const</span> T&amp;&gt;(a, b);
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;ctime&gt;</span>

<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v {<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">9</span>, <span class="dv">2</span>, <span class="dv">6</span>};
    <span class="co">// or, std::vector&lt;int&gt; v = {3, 1, 4, 1, 5, 9, 2, 6};</span>
    std::srand(std::time(<span class="dv">0</span>));
    std::pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; bounds = std::minmax(std::rand() % v.size(),
                                             std::rand() % v.size());

    std::cout &lt;&lt; <span class="st">&quot;v[&quot;</span> &lt;&lt; bounds.first &lt;&lt; <span class="st">&quot;,&quot;</span> &lt;&lt; bounds.second &lt;&lt; <span class="st">&quot;]: &quot;</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = bounds.first; i &lt; bounds.second; ++i) {
        std::cout &lt;&lt; v[i] &lt;&lt; <span class="st">&#39; &#39;</span>;
    }
    std::cout &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}

<span class="co">/*</span>
<span class="co">Possible output:</span>

<span class="co">v[2,7]: 4 1 5 9 2</span>
<span class="co">*/</span></code></pre></div>
<p>max_element, returns a iterator!</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;algorithm&gt;        </span><span class="co">// max_element</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>

<span class="dt">static</span> <span class="dt">bool</span> abs_compare(<span class="dt">int</span> a, <span class="dt">int</span> b)
{
    <span class="kw">return</span> (std::abs(a) &lt; std::abs(b));
}

<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v{ <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">-14</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">9</span> };
    std::vector&lt;<span class="dt">int</span>&gt;::iterator result;

    result = std::max_element(v.begin(), v.end());
    std::cout &lt;&lt; <span class="st">&quot;max element at: &quot;</span> &lt;&lt; std::distance(v.begin(), result) &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;

    result = std::max_element(v.begin(), v.end(), abs_compare);
    std::cout &lt;&lt; <span class="st">&quot;max element (absolute) at: &quot;</span> &lt;&lt; std::distance(v.begin(), result);
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/algorithm/max">std::max - cppreference.com</a></li>
<li><a href="http://en.cppreference.com/w/cpp/algorithm/minmax">std::minmax - cppreference.com</a></li>
<li><a href="http://en.cppreference.com/w/cpp/algorithm/max_element">std::max_element - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::map <code class="fold">@</code></dt>
<dd><p><code class="sourceCode cpp">std::map</code> is a sorted associative container that contains key-value pairs with unique keys. Keys are sorted by using the comparison function Compare. Search, removal, and insertion operations have logarithmic complexity. Maps are usually implemented as red-black trees.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;map&gt;</span>

<span class="dt">int</span> main()
{
    std::map&lt;<span class="dt">int</span>,<span class="dt">char</span>&gt; example = {{<span class="dv">1</span>,<span class="st">&#39;a&#39;</span>},{<span class="dv">2</span>,<span class="st">&#39;b&#39;</span>}};

    <span class="kw">auto</span> search = example.find(<span class="dv">2</span>);      <span class="co">// &#20851;&#38190;&#26159; map.find(key) != map.end()</span>
    <span class="kw">if</span>(search != example.end()) {
        std::cout &lt;&lt; <span class="st">&quot;Found (&quot;</span> &lt;&lt; search-&gt;first &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; search-&gt;second &lt;&lt; <span class="st">&#39;)</span><span class="ch">\n</span><span class="st">&#39;</span>;
    } <span class="kw">else</span> {
        std::cout &lt;&lt; <span class="st">&quot;Not found</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
}</code></pre></div>
<p>Output:</p>
<pre><code>Found (2, b)</code></pre>
<p>map &#30340;&#21478;&#19968;&#20010;&#20851;&#38190;&#26159;&#65292;&#22914;&#26524;&#20320;&#29992;&#20102; map[&#8220;key&#8221;]&#65292;key &#23601;&#20250;&#34987;&#33258;&#21160;&#21019;&#24314;&#12290;&#24456;&#21487;&#33021;&#36825;&#19981;&#26159;&#20320;&#24819;&#35201;&#30340;&#12290;&#20294;&#26377;&#26102;&#20505;&#27604;&#36739;&#26377;&#29992;&#65292;&#27604;&#22914;&#32479;&#35745; word frequency&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">map&lt;string, <span class="dt">int</span>&gt; m;
++m[key];       <span class="co">// &#31532;&#19968;&#27425;&#20351;&#29992;&#20063;&#19981;&#29992;&#21019;&#24314;&#65292;&#22240;&#20026;&#27809;&#26377;&#36825;&#20010; key &#30340;&#26102;&#20505;&#65292;&#20250;&#33258;&#21160;&#29983;&#25104;&#24182;&#25226; int &#21021;&#22987;&#21270;&#20026; 0&#12290;</span></code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/container/map">std::map - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::swap <code class="fold">@</code></dt>
<dd><p><code>swap( int &amp;a, int &amp;b )</code> &#20043;&#31867;&#30340;&#20351;&#29992;&#12290;&#24456;&#22909;&#29992;&#12290;</p>
<p>&#19968;&#20010;&#25216;&#24039;&#65306;&#30001;&#20110; <code>vector.clear()</code> &#24182;&#19981;&#20250;&#30495;&#30340;&#37322;&#25918;&#20869;&#23384;&#65292;&#21487;&#20197;&#29992;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;T&gt;().swap( v );</code></pre></div>
<p>&#26469;&#37322;&#25918; vector v &#30340;&#20869;&#23384;&#12290;&#65288;&#22240;&#20026;&#26032;&#24314;&#30340;&#20020;&#26102;&#21464;&#37327;&#25343;&#21040;&#20102; v &#30340;&#20869;&#23384;&#21306;&#22495;&#65292;&#24453;&#23427;&#20986;&#20102;&#20316;&#29992;&#22495;&#65292;&#23427;&#34987;&#26512;&#26500;&#65292;&#20869;&#23384;&#23601;&#34987;&#37322;&#25918;&#20102;&#12290;&#65289;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/algorithm/swap">std::swap - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::partial_sum <code class="fold">@</code></dt>
<dd><p>&#36825;&#23601;&#26159;&#19968;&#20010;&#32047;&#35745;&#30452;&#26041;&#22270;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Defined in header &lt;numeric&gt;
<span class="kw">template</span>&lt; <span class="kw">class</span> InputIt, <span class="kw">class</span> OutputIt &gt;
OutputIt partial_sum( InputIt first, InputIt last, OutputIt d_first );

<span class="kw">template</span>&lt; <span class="kw">class</span> InputIt, <span class="kw">class</span> OutputIt, <span class="kw">class</span> BinaryOperation &gt;
OutputIt partial_sum( InputIt first, InputIt last, OutputIt d_first, BinaryOperation op );

<span class="co">// Defined in header &lt;numeric&gt;</span>
*(d_first)   = *first;
*(d_first<span class="dv">+1</span>) = *first + *(first<span class="dv">+1</span>);
*(d_first<span class="dv">+2</span>) = *first + *(first<span class="dv">+1</span>) + *(first<span class="dv">+2</span>);
*(d_first<span class="dv">+3</span>) = *first + *(first<span class="dv">+1</span>) + *(first<span class="dv">+2</span>) + *(first<span class="dv">+3</span>);
...</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;sstream&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>
<span class="ot">#include &lt;numeric&gt;</span>

<span class="dt">int</span> main()
{
    std::istringstream str(<span class="st">&quot;0.1 0.2 0.3 0.4&quot;</span>);
    std::partial_sum( std::istream_iterator&lt;<span class="dt">double</span>&gt;(str),
                      std::istream_iterator&lt;<span class="dt">double</span>&gt;(),
                      std::ostream_iterator&lt;<span class="dt">double</span>&gt;(std::cout, <span class="st">&quot; &quot;</span>) );          <span class="co">// 0.1 0.3 0.6 1</span>
                      <span class="co">// &#20063;&#21487;&#20197;&#25554;&#20837;&#21040;&#21035;&#30340; vec &#37324;&#65306;std::back_inserter( vec ) );</span>

    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>};

    std::partial_sum( v.begin(), v.end(),
                      std::ostream_iterator&lt;<span class="dt">int</span>&gt;(std::cout, <span class="st">&quot; &quot;</span>) );             <span class="co">// 1, 1+2, 1+2+3, ...</span>
    std::cout &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;

    std::partial_sum( v.begin(), v.end(), v.begin(), std::multiplies&lt;<span class="dt">int</span>&gt;() );  <span class="co">// 1, 1*2, 1*2*3, ...</span>
    <span class="kw">for</span> (<span class="kw">auto</span> n : v) {
        std::cout &lt;&lt; n &lt;&lt; <span class="st">&quot; &quot;</span>;
    }
    std::cout &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>stringstream <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;iomanip&gt;</span>
<span class="ot">#include &lt;sstream&gt;</span>

<span class="dt">int</span> main()
{
    std::string input = <span class="st">&quot;41 3.14 false hello world&quot;</span>;
    std::istringstream stream(input);
    <span class="dt">int</span> n;
    <span class="dt">double</span> f;
    <span class="dt">bool</span> b;

    stream &gt;&gt; n &gt;&gt; f &gt;&gt; std::boolalpha &gt;&gt; b;
    std::cout &lt;&lt; <span class="st">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>
              &lt;&lt; <span class="st">&quot;f = &quot;</span> &lt;&lt; f &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>
              &lt;&lt; <span class="st">&quot;b = &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; b &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;

    <span class="co">// extract the rest using the streambuf overload</span>
    stream &gt;&gt; std::cout.rdbuf();
    std::cout &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre></div>
<pre><code>n = 41
f = 3.14
b = false
hello world</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;bitset&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;sstream&gt;</span>

<span class="dt">int</span> main()
{
    std::string bit_string = <span class="st">&quot;001101&quot;</span>;
    std::istringstream bit_stream(bit_string);

    std::bitset&lt;<span class="dv">3</span>&gt; b1;
    bit_stream &gt;&gt; b1; <span class="co">// reads &quot;001&quot;, stream still holds &quot;101&quot;</span>
    std::cout &lt;&lt; b1 &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;

    std::bitset&lt;<span class="dv">8</span>&gt; b2;
    bit_stream &gt;&gt; b2; <span class="co">// reads &quot;101&quot;, populates the 8-bit set as &quot;00000101&quot;</span>
    std::cout &lt;&lt; b2 &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre></div>
<p><code>stringstream.str()</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;sstream&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="dt">int</span> main()
{
    <span class="dt">int</span> n;

    std::istringstream in;  <span class="co">// could also use in(&quot;1 2&quot;)</span>
    in.str(<span class="st">&quot;1 2&quot;</span>);
    in &gt;&gt; n;
    std::cout &lt;&lt; <span class="st">&quot;after reading the first int from </span><span class="ch">\&quot;</span><span class="st">1 2</span><span class="ch">\&quot;</span><span class="st">, the int is &quot;</span>
              &lt;&lt; n &lt;&lt; <span class="st">&quot;, str() = </span><span class="ch">\&quot;</span><span class="st">&quot;</span> &lt;&lt; in.str() &lt;&lt; <span class="st">&quot;</span><span class="ch">\&quot;\n</span><span class="st">&quot;</span>;
    <span class="co">//  after reading the first int from &quot;1 2&quot;, the int is 1, str() = &quot;1 2&quot;</span>

    std::ostringstream out(<span class="st">&quot;1 2&quot;</span>);
    out &lt;&lt; <span class="dv">3</span>;
    std::cout &lt;&lt; <span class="st">&quot;after writing the int &#39;3&#39; to output stream </span><span class="ch">\&quot;</span><span class="st">1 2</span><span class="ch">\&quot;</span><span class="st">&quot;</span>
              &lt;&lt; <span class="st">&quot;, str() = </span><span class="ch">\&quot;</span><span class="st">&quot;</span> &lt;&lt; out.str() &lt;&lt; <span class="st">&quot;</span><span class="ch">\&quot;\n</span><span class="st">&quot;</span>;
    <span class="co">//  after writing the int &#39;3&#39; to output stream &quot;1 2&quot;, str() = &quot;3 2&quot;</span>

    std::ostringstream ate(<span class="st">&quot;1 2&quot;</span>, std::ios_base::ate);
    ate &lt;&lt; <span class="dv">3</span>;
    std::cout &lt;&lt; <span class="st">&quot;after writing the int &#39;3&#39; to append stream </span><span class="ch">\&quot;</span><span class="st">1 2</span><span class="ch">\&quot;</span><span class="st">&quot;</span>
              &lt;&lt; <span class="st">&quot;, str() = </span><span class="ch">\&quot;</span><span class="st">&quot;</span> &lt;&lt; ate.str() &lt;&lt; <span class="st">&quot;</span><span class="ch">\&quot;\n</span><span class="st">&quot;</span>;
    <span class="co">//  after writing the int &#39;3&#39; to append stream &quot;1 2&quot;, str() = &quot;1 23&quot;</span>
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/io/basic_istringstream">std::basic_istringstream - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::equal_range <code class="fold">@</code></dt>
<dd><p><strong>Returns a range containing all elements equivalent to value in the range <code>[first, last)</code>.</strong></p>
<p>&#36825;&#21483;&#8220;&#25253;&#22242;&#25214;&#35748;&#21516;&#8221;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> ForwardIt, <span class="kw">class</span> T, <span class="kw">class</span> Compare&gt;
std::pair&lt;ForwardIt,ForwardIt&gt;
    equal_range(ForwardIt first, ForwardIt last,
                <span class="dt">const</span> T&amp; value, Compare comp);
{
    <span class="kw">return</span> std::make_pair(std::lower_bound(first, last, value, comp),
                          std::upper_bound(first, last, value, comp));
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">struct</span> S
{
    <span class="dt">int</span> number;
    <span class="dt">char</span> name;

    S ( <span class="dt">int</span> number, <span class="dt">char</span> name  )
        : number ( number ), name ( name )
    {}

    <span class="co">// only the number is relevant with this comparison</span>
    <span class="dt">bool</span> <span class="kw">operator</span>&lt; ( <span class="dt">const</span> S&amp; s ) <span class="dt">const</span>
    {
        <span class="kw">return</span> number &lt; s.number;
    }
};


<span class="dt">int</span> main()
{
    <span class="co">// note: not ordered, only partitioned w.r.t. S defined below</span>
    std::vector&lt;S&gt; vec = { {<span class="dv">1</span>,<span class="st">&#39;A&#39;</span>}, {<span class="dv">2</span>,<span class="st">&#39;B&#39;</span>}, {<span class="dv">2</span>,<span class="st">&#39;C&#39;</span>}, {<span class="dv">2</span>,<span class="st">&#39;D&#39;</span>}, {<span class="dv">4</span>,<span class="st">&#39;G&#39;</span>}, {<span class="dv">3</span>,<span class="st">&#39;F&#39;</span>} };

    S value ( <span class="dv">2</span>, <span class="st">&#39;?&#39;</span> );

    <span class="kw">auto</span> p = std::equal_range(vec.begin(),vec.end(),value);

    <span class="kw">for</span> ( <span class="kw">auto</span> i = p.first; i != p.second; ++i )
        std::cout &lt;&lt; i-&gt;name &lt;&lt; <span class="st">&#39; &#39;</span>;
        <span class="co">// &#36755;&#20986;&#20026; B C D</span>
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstddef&gt;</span>
<span class="ot">#include &lt;new&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="co">// minimal C++11 allocator with debug output</span>
<span class="kw">template</span> &lt;<span class="kw">class</span> Tp&gt;
<span class="kw">struct</span> NAlloc {
    <span class="kw">typedef</span> Tp value_type;
    NAlloc() = <span class="kw">default</span>;
    <span class="kw">template</span> &lt;<span class="kw">class</span> T&gt; NAlloc(<span class="dt">const</span> NAlloc&lt;T&gt;&amp;) {}
    Tp* allocate(std::size_t n) {
        n *= <span class="kw">sizeof</span>(Tp);
        std::cout &lt;&lt; <span class="st">&quot;allocating &quot;</span> &lt;&lt; n &lt;&lt; <span class="st">&quot; bytes</span><span class="ch">\n</span><span class="st">&quot;</span>;
        <span class="kw">return</span> <span class="kw">static_cast</span>&lt;Tp*&gt;(::<span class="kw">operator</span> <span class="kw">new</span>(n));
    }
    <span class="dt">void</span> deallocate(Tp* p, std::size_t n) {
        std::cout &lt;&lt; <span class="st">&quot;deallocating &quot;</span> &lt;&lt; n*<span class="kw">sizeof</span>*p &lt;&lt; <span class="st">&quot; bytes</span><span class="ch">\n</span><span class="st">&quot;</span>;
        ::<span class="kw">operator</span> <span class="kw">delete</span>(p);
    }
};
<span class="kw">template</span> &lt;<span class="kw">class</span> T, <span class="kw">class</span> U&gt;
<span class="dt">bool</span> <span class="kw">operator</span>==(<span class="dt">const</span> NAlloc&lt;T&gt;&amp;, <span class="dt">const</span> NAlloc&lt;U&gt;&amp;) { <span class="kw">return</span> <span class="kw">true</span>; }
<span class="kw">template</span> &lt;<span class="kw">class</span> T, <span class="kw">class</span> U&gt;
<span class="dt">bool</span> <span class="kw">operator</span>!=(<span class="dt">const</span> NAlloc&lt;T&gt;&amp;, <span class="dt">const</span> NAlloc&lt;U&gt;&amp;) { <span class="kw">return</span> <span class="kw">false</span>; }

<span class="dt">int</span> main()
{
    <span class="dt">int</span> sz = <span class="dv">100</span>;
    std::cout &lt;&lt; <span class="st">&quot;using reserve: </span><span class="ch">\n</span><span class="st">&quot;</span>;
    {
        std::vector&lt;<span class="dt">int</span>, NAlloc&lt;<span class="dt">int</span>&gt;&gt; v1;
        v1.reserve(sz);
        <span class="kw">for</span>(<span class="dt">int</span> n = <span class="dv">0</span>; n &lt; sz; ++n)
            v1.push_back(n);
    }
    std::cout &lt;&lt; <span class="st">&quot;not using reserve: </span><span class="ch">\n</span><span class="st">&quot;</span>;
    {
        std::vector&lt;<span class="dt">int</span>, NAlloc&lt;<span class="dt">int</span>&gt;&gt; v1;
        <span class="kw">for</span>(<span class="dt">int</span> n = <span class="dv">0</span>; n &lt; sz; ++n)
            v1.push_back(n);
    }
}</code></pre></div>
<p>Possible output:</p>
<pre><code>using reserve:
allocating 400 bytes
deallocating 400 bytes
not using reserve:
allocating 4 bytes
allocating 8 bytes
deallocating 4 bytes
allocating 16 bytes
deallocating 8 bytes
allocating 32 bytes
deallocating 16 bytes
allocating 64 bytes
deallocating 32 bytes
allocating 128 bytes
deallocating 64 bytes
allocating 256 bytes
deallocating 128 bytes
allocating 512 bytes
deallocating 256 bytes
deallocating 512 bytes</code></pre>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/algorithm/equal_range">std::equal_range - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::binary_search <code class="fold">@</code></dt>
<dd><p>Defined in header <algorithm></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt; <span class="kw">class</span> ForwardIt, <span class="kw">class</span> T &gt;
<span class="dt">bool</span> binary_search( ForwardIt first, ForwardIt last, <span class="dt">const</span> T&amp; value );

<span class="kw">template</span>&lt; <span class="kw">class</span> ForwardIt, <span class="kw">class</span> T, <span class="kw">class</span> Compare &gt;
<span class="dt">bool</span> binary_search( ForwardIt first, ForwardIt last, <span class="dt">const</span> T&amp; value, Compare comp );</code></pre></div>
<p>Checks if an element equivalent to value appears within the range <code>[first, last)</code>.</p>
<p>For <code>std::binary_search</code> to succeed, the range <code>[first, last)</code> must be at least partially ordered, i.e.&#160;it must satisfy all of the following requirements:</p>
<ul>
<li>partitioned with respect to <code>element &lt; value</code> or <code>comp(element, value)</code></li>
<li>partitioned with respect to <code>!(value &lt; element)</code> or <code>!comp(value, element)</code></li>
<li>for all elements, if <code>element &lt; value</code> or <code>comp(element, value)</code> is true then <code>!(value &lt; element)</code> or <code>!comp(value, element)</code> is also true</li>
</ul>
<p>A fully-sorted range meets these criteria, as does a range resulting from a call to <code>std::partition</code>.</p>
<p>Possible implementation</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//  First version</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> ForwardIt, <span class="kw">class</span> T&gt;
<span class="dt">bool</span> binary_search(ForwardIt first, ForwardIt last, <span class="dt">const</span> T&amp; value) {
    first = std::lower_bound(first, last, value);
    <span class="kw">return</span> (!(first == last) &amp;&amp; !(value &lt; *first));
}

<span class="co">//  Second version</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> ForwardIt, <span class="kw">class</span> T, <span class="kw">class</span> Compare&gt;
<span class="dt">bool</span> binary_search(ForwardIt first, ForwardIt last, <span class="dt">const</span> T&amp; value, Compare comp) {
    first = std::lower_bound(first, last, value, comp);
    <span class="kw">return</span> (!(first == last) &amp;&amp; !(comp(value, *first)));
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; haystack {<span class="dv">1</span>,    <span class="dv">3</span>,     <span class="dv">4</span>,    <span class="dv">5</span>,    <span class="dv">9</span>};
    std::vector&lt;<span class="dt">int</span>&gt; needles  {<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>};

    <span class="kw">for</span> (<span class="kw">auto</span> needle : needles) {
        std::cout &lt;&lt; <span class="st">&quot;Searching for &quot;</span> &lt;&lt; needle &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
        <span class="kw">if</span> (std::binary_search(haystack.begin(), haystack.end(), needle)) {
            std::cout &lt;&lt; <span class="st">&quot;Found &quot;</span> &lt;&lt; needle &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
        } <span class="kw">else</span> {
            std::cout &lt;&lt; <span class="st">&quot;no dice!</span><span class="ch">\n</span><span class="st">&quot;</span>;
        }
    }
}

<span class="co">//  Searching for 1</span>
<span class="co">//  Found 1</span>
<span class="co">//  Searching for 2</span>
<span class="co">//  no dice!</span>
<span class="co">//  Searching for 3</span>
<span class="co">//  Found 3</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>std::search <code class="fold">@</code></dt>
<dd><p>Defined in header <algorithm></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt; <span class="kw">class</span> ForwardIt1, <span class="kw">class</span> ForwardIt2 &gt;
ForwardIt1 search( ForwardIt1 first, ForwardIt1 last,
                   ForwardIt2 s_first, ForwardIt2 s_last );

<span class="kw">template</span>&lt; <span class="kw">class</span> ForwardIt1, <span class="kw">class</span> ForwardIt2, <span class="kw">class</span> BinaryPredicate &gt;
ForwardIt1 search( ForwardIt1 first, ForwardIt1 last,
                   ForwardIt2 s_first, ForwardIt2 s_last, BinaryPredicate p );</code></pre></div>
<p>Searches for the first occurrence of the subsequence of elements <code>[s_first, s_last)</code> in the range <code>[first, last - (s_last - s_first))</code>. The first version uses <code>operator==</code> to compare the elements, the second version uses the given binary predicate p.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//  First version</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> ForwardIt1, <span class="kw">class</span> ForwardIt2&gt;
ForwardIt1 search(ForwardIt1 first, ForwardIt1 last,
                  ForwardIt2 s_first, ForwardIt2 s_last)
{
    <span class="kw">for</span> (; ; ++first) {
        ForwardIt1 it = first;
        <span class="kw">for</span> (ForwardIt2 s_it = s_first; ; ++it, ++s_it) {
            <span class="kw">if</span> (s_it == s_last) {
                <span class="kw">return</span> first;
            }
            <span class="kw">if</span> (it == last) {
                <span class="kw">return</span> last;
            }
            <span class="kw">if</span> (!(*it == *s_it)) {
                <span class="kw">break</span>;
            }
        }
    }
}

<span class="co">// Second version</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> ForwardIt1, <span class="kw">class</span> ForwardIt2, <span class="kw">class</span> BinaryPredicate&gt;
ForwardIt1 search(ForwardIt1 first, ForwardIt1 last,
                  ForwardIt2 s_first, ForwardIt2 s_last,
                  BinaryPredicate p)
{
    <span class="kw">for</span> (; ; ++first) {
        ForwardIt1 it = first;
        <span class="kw">for</span> (ForwardIt2 s_it = s_first; ; ++it, ++s_it) {
            <span class="kw">if</span> (s_it == s_last) {
                <span class="kw">return</span> first;
            }
            <span class="kw">if</span> (it == last) {
                <span class="kw">return</span> last;
            }
            <span class="kw">if</span> (!p(*it, *s_it)) {
                <span class="kw">break</span>;
            }
        }
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">template</span>&lt;<span class="kw">typename</span> Container&gt;
<span class="dt">bool</span> in_quote(<span class="dt">const</span> Container&amp; cont, <span class="dt">const</span> std::string&amp; s)
{
    <span class="kw">return</span> std::search(cont.begin(), cont.end(), s.begin(), s.end()) != cont.end();
}

<span class="dt">int</span> main()
{
    std::string str = <span class="st">&quot;why waste time learning, when ignorance is instantaneous?&quot;</span>;
    <span class="co">// str.find() can be used as well</span>
    std::cout &lt;&lt; std::boolalpha &lt;&lt; in_quote(str, <span class="st">&quot;learning&quot;</span>) &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>
                                &lt;&lt; in_quote(str, <span class="st">&quot;lemming&quot;</span>)  &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;

    std::vector&lt;<span class="dt">char</span>&gt; vec(str.begin(), str.end());
    std::cout &lt;&lt; std::boolalpha &lt;&lt; in_quote(vec, <span class="st">&quot;learning&quot;</span>) &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>
                                &lt;&lt; in_quote(vec, <span class="st">&quot;lemming&quot;</span>)  &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}
<span class="co">//  true</span>
<span class="co">//  false</span>
<span class="co">//  true</span>
<span class="co">//  false</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdio&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="dv">32</span>;
    vector&lt;<span class="dt">int</span>&gt; vi = { <span class="dv">10</span>, <span class="dv">21</span>, <span class="dv">32</span>, <span class="dv">43</span> };
    <span class="kw">auto</span> it1 = search( vi.begin(), vi.end(), &amp;i, &amp;i<span class="dv">+1</span> );
    printf( <span class="st">&quot;index: </span><span class="ch">%d</span><span class="st">, value: </span><span class="ch">%d\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>)distance(vi.begin(), it1), *it1 );
    <span class="co">//  index: 2, value: 32</span>

    string s = <span class="st">&quot;two&quot;</span>;
    vector&lt;string&gt; vs = { <span class="st">&quot;zero&quot;</span>, <span class="st">&quot;one&quot;</span>, <span class="st">&quot;two&quot;</span>, <span class="st">&quot;three&quot;</span> };
    <span class="kw">auto</span> it2 = search( vs.begin(), vs.end(), &amp;s, &amp;s<span class="dv">+1</span> );
    printf( <span class="st">&quot;index: </span><span class="ch">%d</span><span class="st">, value: </span><span class="ch">%s\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>)distance(vs.begin(), it2), it2-&gt;c_str() );
    <span class="co">//  index: 2, value: two</span>
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>print out queue, stack <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// stack &#26159;&#20010;&#40657;&#30418;&#65292;&#21482;&#33021;&#23436;&#20840;&#25343;&#19968;&#20010;&#25335;&#36125;</span>
<span class="kw">for</span>( std::stack&lt;<span class="dt">int</span>&gt; dump = stack; !dump.empty(); dump.pop() ) {
    std::cout &lt;&lt; dump.top() &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}

<span class="co">// deque &#21487;&#20197; iterate</span>
<span class="kw">for</span>( deque&lt;<span class="dt">int</span>&gt;::iterator it = q.begin(); it != q.end(); ++it )
    cout &lt;&lt; *it &lt;&lt; endl;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>upper_bound &amp; lower_bound <code class="fold">@</code></dt>
<dd><p>Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is greater than value.</p>
<p>&#36825;&#20010;&#20854;&#23454;&#20551;&#35774;&#20102;&#21306;&#38388;&#26159; incremental&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; data = { <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">6</span> };

    <span class="kw">auto</span> lower = std::lower_bound(data.begin(), data.end(), <span class="dv">4</span>); <span class="co">// &#20174;&#21491;&#24448;&#24038;&#65292;&#30475;&#33021;&#19981;&#33021;&#20877;&#20302;&#65292;&#25214;&#19981;&#21040;&#65311;&#37027;&#23601; begin</span>
    <span class="kw">auto</span> upper = std::upper_bound(data.begin(), data.end(), <span class="dv">4</span>); <span class="co">// &#20174;&#24038;&#24448;&#21491;&#65292;&#30475;&#33021;&#19981;&#33021;&#20877;&#39640;&#65292;&#25214;&#19981;&#21040;&#65311;&#37027;&#23601; end</span>

    std::copy(lower, upper, std::ostream_iterator&lt;<span class="dt">int</span>&gt;(std::cout, <span class="st">&quot; &quot;</span>));
}</code></pre></div>
<p>output: 4 4 4</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> ForwardIt, <span class="kw">class</span> T&gt;
ForwardIt upper_bound(ForwardIt first, ForwardIt last, <span class="dt">const</span> T&amp; value)
{
    ForwardIt it;
    <span class="kw">typename</span> std::iterator_traits&lt;ForwardIt&gt;::difference_type count, step;
    count = std::distance(first,last);

    <span class="kw">while</span> (count &gt; <span class="dv">0</span>) {
        it = first;
        step = count / <span class="dv">2</span>;
        std::advance(it, step);
        <span class="kw">if</span> (!(value &lt; *it)) {
            first = ++it;
            count -= step + <span class="dv">1</span>;
        } <span class="kw">else</span> count = step;
    }
    <span class="kw">return</span> first;
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/algorithm/upper_bound">std::upper_bound - cppreference.com</a></li>
<li><a href="http://en.cppreference.com/w/cpp/algorithm/partial_sum">std::partial_sum - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::transform <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;cctype&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main()
{
    std::string s(<span class="st">&quot;hello&quot;</span>);
    <span class="co">// std::transform( s.begin(), s.end(), s.begin(), ::toupper );</span>
    std::transform( s.begin(), s.end(), s.begin(),
                    <span class="co">// &#21311;&#21517;&#20989;&#25968;</span>
                    [](<span class="dt">unsigned</span> <span class="dt">char</span> c) { <span class="kw">return</span> std::toupper(c); } );
    std::cout &lt;&lt; s;
}</code></pre></div>
<p>&#25110;&#32773; function object&#12290;&#65288;function object &#27604; C &#35821;&#35328;&#30340; function pointer &#25928;&#29575;&#26356;&#22909;&#65292;&#22240;&#20026;&#23427;&#26159; by reference&#65292;&#32780;&#19988;&#21487;&#20197; inline&#65289;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#23601;&#26159;&#22312;&#19968;&#20010; struct &#37324;&#23454;&#29616; operator()</span>
<span class="kw">struct</span> ToUpper {
    <span class="dt">unsigned</span> <span class="dt">char</span> <span class="kw">operator</span>()( <span class="dt">unsigned</span> <span class="dt">char</span> c ) {
        <span class="kw">return</span> <span class="st">&#39;a&#39;</span> &lt;= c &amp;&amp; c &lt;= <span class="st">&#39;z&#39;</span> ?  c-<span class="st">&#39;a&#39;</span>+<span class="st">&#39;A&#39;</span> : c;
    }
};
<span class="co">// ToUpper tu; tu(); // tu() --&gt; ToUpper::operator();</span>

std::transform(s.begin(), s.end(), s.begin(), ToUpper());   <span class="co">// &#28982;&#21518;&#20256;&#20837;&#19968;&#20010;&#23454;&#20363;</span></code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/algorithm/transform">std::transform - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::prev, std::next <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> ForwardIt&gt;
ForwardIt next(ForwardIt it,
               <span class="kw">typename</span> std::iterator_traits&lt;ForwardIt&gt;::difference_type n = <span class="dv">1</span>)
{
    std::advance(it, n);
    <span class="kw">return</span> it;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v{ <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span> };

    <span class="kw">auto</span> it = v.begin();

    <span class="kw">auto</span> nx = std::next(it, <span class="dv">2</span>);

    std::cout &lt;&lt; *it &lt;&lt; <span class="st">&#39; &#39;</span> &lt;&lt; *nx &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt; v{ <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span> };
std::cout &lt;&lt; *std::prev(v.end(), <span class="dv">3</span>) &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/iterator/prev">std::prev - cppreference.com</a></li>
<li><a href="http://en.cppreference.com/w/cpp/iterator/next">std::next - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::advance <code class="fold">@</code></dt>
<dd><p>Increments given iterator it by n elements.</p>
<p>If n is negative, the iterator is decremented. In this case, InputIt must meet the requirements of BidirectionalIterator, otherwise the behavior is undefined.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v{ <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span> };
    <span class="kw">auto</span> vi = v.begin();
    std::advance(vi, <span class="dv">2</span>);
    std::cout &lt;&lt; *vi &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}
<span class="co">// output: 4</span></code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/iterator/advance">std::advance - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::distance <code class="fold">@</code></dt>
<dd><p>&#21487;&#20197;&#30452;&#25509;&#29702;&#35299;&#25104;&#20004;&#20010; iterator &#30340;&#36317;&#31163;&#12290;</p>
<p>Defined in header <code>&lt;iterator&gt;</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v{ <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span> };
    std::cout &lt;&lt; <span class="st">&quot;distance(first, last) = &quot;</span>
              &lt;&lt; std::distance(v.begin(), v.end()) &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>
              &lt;&lt; <span class="st">&quot;distance(last, first) = &quot;</span>
              &lt;&lt; std::distance(v.end(), v.begin()) &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}

<span class="co">/*</span>
<span class="co"> *  Output:</span>
<span class="co"> *</span>
<span class="co"> *              distance(first, last) = 3</span>
<span class="co"> *              distance(last, first) = -3</span>
<span class="co">**/</span></code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/iterator/distance">std::distance - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::remove, std::remove_if <code class="fold">@</code></dt>
<dd><p>erase-remove &#22823;&#27861;&#22909;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cctype&gt;</span>

<span class="dt">int</span> main()
{
    std::string str1 = <span class="st">&quot;Text with some   spaces&quot;</span>;
    str1.erase(std::remove(str1.begin(), str1.end(), <span class="st">&#39; &#39;</span>),
               str1.end());
    std::cout &lt;&lt; str1 &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;

    std::string str2 = <span class="st">&quot;Text</span><span class="ch">\n</span><span class="st"> with</span><span class="ch">\t</span><span class="st">some </span><span class="ch">\t</span><span class="st">  whitespaces</span><span class="ch">\n\n</span><span class="st">&quot;</span>;
    str2.erase(std::remove_if(str2.begin(),
                              str2.end(),
                              [](<span class="dt">char</span> x){<span class="kw">return</span> std::isspace(x);}),
               str2.end());
    std::cout &lt;&lt; str2 &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre></div>
<p>Output:</p>
<pre><code>Textwithsomespaces
Textwithsomewhitespaces</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> n = <span class="dv">10</span>;
<span class="dt">int</span> A[n];
std::remove_if(A, A+n, <span class="st">&#39; &#39;</span>);</code></pre></div>
<p>&#20877;&#20030;&#19968;&#20010;&#20363;&#23376;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;cstdio&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> S {
    <span class="dt">int</span> x, y;
    S(<span class="dt">int</span> x = <span class="dv">0</span>, <span class="dt">int</span> y = <span class="dv">0</span>) : x(x), y(y) { }
};

<span class="kw">struct</span> Comp {
    <span class="dt">int</span> r, m;
    Comp(<span class="dt">int</span> r = <span class="dv">0</span>, <span class="dt">int</span> m = <span class="dv">3</span>) : r(r), m(m) {}
    <span class="dt">bool</span> <span class="kw">operator</span>()( <span class="dt">const</span> S &amp;s) {
        <span class="kw">return</span> s.x%m == r;
    }
};

<span class="dt">void</span> print( vector&lt;S&gt; &amp;s) {
    <span class="kw">for</span>( <span class="kw">auto</span> i : s ) {
        printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, i.x);
        <span class="co">// printf(&quot;(%d, %d) &quot;, i.x, i.y);</span>
    }
    printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
}

<span class="dt">int</span> main()
{
    vector&lt;S&gt; s(<span class="dv">20</span>, S());
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; s.size(); ++i ) {
        s[i].x = s[i].y = i;
    }
    s.erase( remove_if( s.begin(), s.end(), Comp() ), s.end() );
    print(s);
    s.erase( remove_if( s.begin(), s.end(), Comp(<span class="dv">1</span>) ), s.end() );
    print(s);
    s.erase( remove_if( s.begin(), s.end(), Comp(<span class="dv">0</span>, <span class="dv">2</span>) ), s.end() );
    print(s);

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<pre><code>1 2 4 5 7 8 10 11 13 14 16 17 19
2 5 8 11 14 17
5 11 17</code></pre>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/algorithm/remove">std::remove, std::remove_if - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::vector::erase <code class="fold">@</code></dt>
<dd><p><code>std::vector::erase</code> &#21644; <code>std::erase</code> &#24847;&#24605;&#24046;&#19981;&#22810;&#12290;&#19981;&#36807;&#36890;&#24120;&#32780;&#35328;&#65292;&#23481;&#22120;&#33258;&#24102;&#30340;&#26041;&#27861;&#25928;&#29575;&#26356;&#22909;&#65288;&#26356;&#36866;&#29992;&#20110;&#33258;&#36523;&#23481;&#22120;&#65289;&#12290;&#20294; <code>std::erase</code> &#26159;&#36890;&#29992;&#30340;&#12290;</p>
<p>synopsis</p>
<ul>
<li><code>iterator erase( iterator pos );</code></li>
<li><code>iterator erase( const_iterator pos );</code></li>
<li><code>iterator erase( iterator first, iterator last );</code></li>
<li><code>iterator erase( const_iterator first, const_iterator last );</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main( )
{
    std::vector&lt;<span class="dt">int</span>&gt; c{<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>};
    <span class="kw">for</span> (<span class="kw">auto</span> &amp;i : c) {
        std::cout &lt;&lt; i &lt;&lt; <span class="st">&quot; &quot;</span>;
    }
    std::cout &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;

    c.erase(c.begin());

    <span class="kw">for</span> (<span class="kw">auto</span> &amp;i : c) {
        std::cout &lt;&lt; i &lt;&lt; <span class="st">&quot; &quot;</span>;
    }
    std::cout &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;

    c.erase(c.begin()<span class="dv">+2</span>, c.begin()<span class="dv">+5</span>);

    <span class="kw">for</span> (<span class="kw">auto</span> &amp;i : c) {
        std::cout &lt;&lt; i &lt;&lt; <span class="st">&quot; &quot;</span>;
    }
    std::cout &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/container/vector/erase">std::vector::erase - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::copy <code class="fold">@</code></dt>
<dd><p>Defined in header <code>&lt;algorithm&gt;</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt; <span class="kw">class</span> InputIt, <span class="kw">class</span> OutputIt &gt;
OutputIt copy(      InputIt first,  InputIt last,   OutputIt d_first );

<span class="kw">template</span>&lt; <span class="kw">class</span> InputIt, <span class="kw">class</span> OutputIt, <span class="kw">class</span> UnaryPredicate &gt;
OutputIt copy_if(   InputIt first,  InputIt last,   OutputIt d_first,   UnaryPredicate pred );</code></pre></div>
<p>Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at <code>d_first</code>.</p>
<ul>
<li><ol style="list-style-type: decimal">
<li>Copies all elements in the range <code>[first, last)</code>. The behavior is undefined if d_first is within the range <code>[first, last)</code>. In this case, <code>std::copy_backward</code> may be used instead.</li>
</ol></li>
<li><ol start="3" style="list-style-type: decimal">
<li>Only copies the elements for which the predicate pred returns true. The order of the elements that are not removed is preserved. The behavior is undefined if the source and the destination ranges overlap.</li>
</ol></li>
<li>2,4) Same as (1,3), but executed according to policy. These overloads do not participate in overload resolution unless <code>std::is_execution_policy_v&lt;std::decay_t&lt;ExecutionPolicy&gt;&gt;</code> is true</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>
<span class="ot">#include &lt;numeric&gt;</span>

<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; from_vector(<span class="dv">10</span>);
    std::iota(from_vector.begin(), from_vector.end(), <span class="dv">0</span>);

    std::vector&lt;<span class="dt">int</span>&gt; to_vector;
    std::copy(from_vector.begin(), from_vector.end(),
              std::back_inserter(to_vector));   <span class="co">// &#20174;&#21518;&#38754;&#25554;&#20837;</span>

    {
        <span class="co">// &#25110;&#32773;&#36825;&#26679;</span>
        std::vector&lt;<span class="dt">int</span>&gt; to_vector(from_vector.size());         <span class="co">// &#19968;&#23450;&#35201;&#33258;&#24049;&#25226; size &#35843;&#22909;&#12290;</span>
        std::copy(from_vector.begin(), from_vector.end(), to_vector.begin());

        <span class="co">// &#25110;&#32773;&#36825;&#26679;</span>
        std::vector&lt;<span class="dt">int</span>&gt; to_vector = from_vector;
    }

    std::cout &lt;&lt; <span class="st">&quot;to_vector contains: &quot;</span>;

    std::copy(to_vector.begin(), to_vector.end(),
              std::ostream_iterator&lt;<span class="dt">int</span>&gt;(std::cout, <span class="st">&quot; &quot;</span>));
    std::cout &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre></div>
<p>output: to_vector contains: 0 1 2 3 4 5 6 7 8 9</p>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/algorithm/copy">std::copy, std::copy_if - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::move <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;utility&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="dt">int</span> main()
{
    std::string str = <span class="st">&quot;Hello&quot;</span>;
    std::vector&lt;std::string&gt; v;

    <span class="co">// uses the push_back(const T&amp;) overload, which means</span>
    <span class="co">// we&#39;ll incur the cost of copying str</span>
    v.push_back(str);
    std::cout &lt;&lt; <span class="st">&quot;After copy, str is </span><span class="ch">\&quot;</span><span class="st">&quot;</span> &lt;&lt; str &lt;&lt; <span class="st">&quot;</span><span class="ch">\&quot;\n</span><span class="st">&quot;</span>;

    <span class="co">// uses the rvalue reference push_back(T&amp;&amp;) overload,</span>
    <span class="co">// which means no strings will be copied; instead, the contents</span>
    <span class="co">// of str will be moved into the vector.  This is less</span>
    <span class="co">// expensive, but also means str might now be empty.</span>
    v.push_back(std::move(str));
    std::cout &lt;&lt; <span class="st">&quot;After move, str is </span><span class="ch">\&quot;</span><span class="st">&quot;</span> &lt;&lt; str &lt;&lt; <span class="st">&quot;</span><span class="ch">\&quot;\n</span><span class="st">&quot;</span>;

    std::cout &lt;&lt; <span class="st">&quot;The contents of the vector are </span><span class="ch">\&quot;</span><span class="st">&quot;</span> &lt;&lt; v
                                         &lt;&lt; <span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">, </span><span class="ch">\&quot;</span><span class="st">&quot;</span> &lt;&lt; v &lt;&lt; <span class="st">&quot;</span><span class="ch">\&quot;\n</span><span class="st">&quot;</span>;
}</code></pre></div>
<p>output:</p>
<pre><code>After copy, str is &quot;Hello&quot;
After move, str is &quot;&quot;
The contents of the vector are &quot;Hello&quot;, &quot;Hello&quot;</code></pre>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/utility/move">std::move - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::unique <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;cctype&gt;</span>

<span class="dt">int</span> main()
{
    <span class="co">// remove duplicate elements (normal use)</span>
    std::vector&lt;<span class="dt">int</span>&gt; v{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>};
    std::sort(v.begin(), v.end()); <span class="co">// 1 1 2 2 3 3 3 4 4 5 5 6 7</span>
    <span class="kw">auto</span> last = std::unique(v.begin(), v.end());
    <span class="co">// v now holds {1 2 3 4 5 6 7 x x x x x x}, where &#39;x&#39; is indeterminate</span>
    v.erase(last, v.end());
    <span class="kw">for</span> (<span class="dt">int</span> i : v)
      std::cout &lt;&lt; i &lt;&lt; <span class="st">&quot; &quot;</span>;
    std::cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;

    <span class="co">// remove consecutive spaces</span>
    std::string s = <span class="st">&quot;wanna go    to      space?&quot;</span>;
    <span class="kw">auto</span> end = std::unique(s.begin(), s.end(), [](<span class="dt">char</span> l, <span class="dt">char</span> r){  <span class="co">// &#30456;&#21516;&#65311;&#37027;&#25105;&#25226; r &#21435;&#25481;&#12290;</span>
        <span class="kw">return</span> std::isspace(l) &amp;&amp; std::isspace(r) &amp;&amp; l == r;
    });
    <span class="co">// s now holds &quot;wanna go to space?xxxxxxxx&quot;, where &#39;x&#39; is indeterminate</span>
    std::cout &lt;&lt; std::string(s.begin(), end) &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre></div>
<p>Output:</p>
<pre><code>1 2 3 4 5 6 7
wanna go to space?</code></pre>
<p>&#36825;&#20010;&#23454;&#29616;&#27809;&#26377;&#30475;&#25026;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> ForwardIt, <span class="kw">class</span> BinaryPredicate&gt;
ForwardIt unique(ForwardIt first, ForwardIt last, BinaryPredicate p)
{
    <span class="kw">if</span> (first == last)
        <span class="kw">return</span> last;

    ForwardIt result = first;
    <span class="kw">while</span> (++first != last) {
        <span class="kw">if</span> (!p(*result, *first) &amp;&amp; ++result != first) {
            *result = std::move(*first);
        }
    }
    <span class="kw">return</span> ++result;
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/algorithm/unique">std::unique - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::iota <code class="fold">@</code></dt>
<dd><p>Iota <code>/a&#618;&#712;o&#650;t&#601;/</code> (uppercase &#921;, lowercase &#953;; Greek: &#921;&#974;&#964;&#945;) is the ninth letter of the Greek alphabet. It was derived from the Phoenician letter Yodh.</p>
<p>For example, the integer function denoted by &#953; produces a vector of the first N integers when applied to the argument N, &#8230;</p>
<p>Fills the range <code>[first, last)</code> with sequentially increasing values, starting with value and repetitively evaluating ++value.</p>
<p>Equivalent operation:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">*(d_first)   = value;
*(d_first<span class="dv">+1</span>) = ++value;
*(d_first<span class="dv">+2</span>) = ++value;
*(d_first<span class="dv">+3</span>) = ++value;
...</code></pre></div>
<p>&#25152;&#20197;&#65292;&#20854;&#23454;&#23601;&#26159;&#19968;&#20010;&#31561;&#24046;&#25968;&#21015;&#12290;&#36755;&#20837;&#26159;&#36215;&#28857;&#65292;&#27599;&#27425; increment 1&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;list&gt;</span>
<span class="ot">#include &lt;numeric&gt;</span>
<span class="ot">#include &lt;random&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="dt">int</span> main()
{
    std::list&lt;<span class="dt">int</span>&gt; l(<span class="dv">10</span>);
    std::iota(l.begin(), l.end(), <span class="dv">-4</span>);  <span class="co">// l &#20013;&#30340;&#20803;&#32032;&#20026;&#65306;-4, -3, -2, -1, 0, 1, 2, 3, 4, 5</span>

    std::vector&lt;std::list&lt;<span class="dt">int</span>&gt;::iterator&gt; v(l.size());          <span class="co">// &#37324;&#38754;&#30340;&#20803;&#32032;&#26159; iterator&#8230;&#8230;</span>
    std::iota(v.begin(), v.end(), l.begin());                   <span class="co">// &#20174; begin &#24320;&#22987;&#23384;&#65292;&#28982;&#21518; ++iter &#22909;&#20687;&#26159;&#36825;&#20010;&#36947;&#29702;&#21769;&#12290;</span>

    std::copy( v.begin(), v.end(), std::stream_iterator&lt;<span class="dt">int</span>&gt;(std::cout, <span class="st">&quot; &quot;</span>) );
    std::cout &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;

    std::shuffle(v.begin(), v.end(), std::mt19937{std::random_device{}()});

    std::cout &lt;&lt; <span class="st">&quot;Contents of the list: &quot;</span>;
    <span class="kw">for</span>(<span class="kw">auto</span> n: l) std::cout &lt;&lt; n &lt;&lt; <span class="st">&#39; &#39;</span>;           <span class="co">// &#23545; list &#26469;&#35828;&#65292;&#36825;&#26159;&#20803;&#32032;</span>
    std::cout &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;

    std::cout &lt;&lt; <span class="st">&quot;Contents of the list, shuffled: &quot;</span>;
    <span class="kw">for</span>(<span class="kw">auto</span> i: v) std::cout &lt;&lt; *i &lt;&lt; <span class="st">&#39; &#39;</span>;          <span class="co">// &#23545; vector &#37324;&#38754;&#23384;&#30340;&#23601;&#26159; iterator&#65292;&#25152;&#20197; *i</span>
    std::cout &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre></div>
<p>Possible output:</p>
<pre><code>Contents of the list: -4 -3 -2 -1 0 1 2 3 4 5
Contents of the list, shuffled: 0 -1 3 4 -4 1 -2 -3 2 5</code></pre>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/algorithm/iota">std::iota - cppreference.com</a></li>
<li><a href="http://stackoverflow.com/questions/9244879/what-does-iota-of-stdiota-stand-for">c++ - What does iota of std::iota stand for? - Stack Overflow</a> <code class="fold">@</code></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>numeric limits <code class="fold">@</code></dt>
<dd><p>limits</p>
<table>
<thead>
<tr class="header">
<th align="center"><code>std::numeric_limits&lt;T&gt;::max()</code></th>
<th align="center">MACROs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">bool</td>
<td align="center">true</td>
</tr>
<tr class="even">
<td align="center">char</td>
<td align="center">CHAR_MAX</td>
</tr>
<tr class="odd">
<td align="center">signed char</td>
<td align="center">SCHAR_MAX</td>
</tr>
<tr class="even">
<td align="center">unsigned char</td>
<td align="center">UCHAR_MAX</td>
</tr>
<tr class="odd">
<td align="center">wchar_t</td>
<td align="center">WCHAR_MAX</td>
</tr>
<tr class="even">
<td align="center">char16_t</td>
<td align="center">UINT_LEAST16_MAX</td>
</tr>
<tr class="odd">
<td align="center">char32_t</td>
<td align="center">UINT_LEAST32_MAX</td>
</tr>
<tr class="even">
<td align="center">short</td>
<td align="center">SHRT_MAX</td>
</tr>
<tr class="odd">
<td align="center">unsigned short</td>
<td align="center">USHRT_MAX</td>
</tr>
<tr class="even">
<td align="center">int</td>
<td align="center">INT_MAX</td>
</tr>
<tr class="odd">
<td align="center">unsigned int</td>
<td align="center">UINT_MAX</td>
</tr>
<tr class="even">
<td align="center">long</td>
<td align="center">LONG_MAX</td>
</tr>
<tr class="odd">
<td align="center">unsigned long</td>
<td align="center">ULONG_MAX</td>
</tr>
<tr class="even">
<td align="center">long long</td>
<td align="center">LLONG_MAX</td>
</tr>
<tr class="odd">
<td align="center">unsigned long long</td>
<td align="center">ULLONG_MAX</td>
</tr>
<tr class="even">
<td align="center">float</td>
<td align="center">FLT_MAX</td>
</tr>
<tr class="odd">
<td align="center">double</td>
<td align="center">DBL_MAX</td>
</tr>
<tr class="even">
<td align="center">long double</td>
<td align="center">LDBL_MAX</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;limits&gt;</span>
<span class="ot">#include &lt;cstddef&gt;</span>
std::numeric_limits&lt;<span class="dt">int</span>&gt;::max()
std::numeric_limits&lt;std::streamsize&gt;::max()</code></pre></div>
<p>short</p>
<pre><code>short:                       32767 or               0x7fff
int:                    2147483647 or           0x7fffffff
size_t:       18446744073709551615 or   0xffffffffffffffff
streamsize:    9223372036854775807 or   0x7fffffffffffffff
float:                 3.40282e+38 or   0x1.fffffep+127
double:               1.79769e+308 or   0x1.fffffffffffffp+1023</code></pre>
<dl>
<dt>72 &#27861;&#21017;</dt>
<dd><p>&#8220;&#20551;&#35774;&#20197;&#24180;&#21033;&#29575;r%&#25237;&#36164;&#19968;&#31508;&#38065;y&#24180;&#65292;&#22914;&#26524;r&#215;y=72&#65292;&#37027;&#20040;&#20320;&#30340;&#25237;&#36164;&#24046;&#19981;&#22810;&#20250;&#32763;&#20493;&#12290;&#8221;&#27604;&#22914;&#24180;&#21033;&#29575;6%&#25237;&#36164;1000&#32654;&#20803;12&#24180;&#65292;&#21487;&#20197;&#24471;&#21040; 2012&#32654;&#20803;&#12290;&#24456;&#26377;&#24847;&#24605;&#65374;</p>
<p>&#20551;&#35774;&#19968;&#20010;&#31243;&#24207;n=40&#26102;&#38656;&#35201;10&#31186;&#65292;&#24182;&#19988;n&#22686;&#21152;1&#65292;&#26102;&#38388;&#23601;&#22686;&#21152;12%&#65292;&#26681;&#25454;72&#27861;&#21017;&#65292;&#27599;&#24403;n&#22686;&#21152;6&#65292;&#36816;&#34892;&#26102;&#38388;&#23601;&#21152;&#20493;&#65292;n&#27599;&#22686;&#21152;60&#65292;&#36816;&#34892;&#26102;&#38388;&#23601;&#26159;&#21407;&#26469;&#30340;1000&#20493;&#65288;n&#22686;&#21152;60&#65292;&#20063;&#23601;&#26159;&#35828;&#32763;10&#20493;&#65292;2&#30340;10&#27425;&#26041;&#26159;1024&#65289;</p>
<p>tip&#65306;&#960;&#31186; = 1&#32435;&#19990;&#32426;&#31186; = 10^-9 * 100 s = 10^-7 s</p>
<p>&#19968;&#24180;&#26377; pi * 10^7 &#31186;&#12290;</p>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/types/numeric_limits/max">std::numeric_limits::max - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::priority_queue, std::greater <code class="fold">@</code></dt>
<dd><p>A priority queue is a container adaptor that provides constant time lookup of <strong>the largest (by default)</strong> element, at the expense of logarithmic insertion and extraction.</p>
<p><strong>Max heap.</strong></p>
<p>A user-provided Compare can be supplied to change the ordering, e.g.&#160;using <code>std::greater&lt;T&gt;</code> would cause the smallest element to appear as the <code>top()</code>.</p>
<p>Working with a priority_queue is similar to managing a heap in some random access container, with the benefit of not being able to accidentally invalidate the heap.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;   <span class="kw">class</span> T,
            <span class="kw">class</span> Container = std::vector&lt;T&gt;,
            <span class="kw">class</span> Compare = std::less&lt;<span class="kw">typename</span> Container::value_type&gt;   &gt;
<span class="kw">class</span> priority_queue;

<span class="kw">template</span>&lt;   <span class="kw">class</span> T,
            <span class="kw">class</span> Container = std::vector&lt;T&gt;,
            <span class="kw">class</span> Compare = std::default_order_t&lt;<span class="kw">typename</span> Container::value_type&gt;    &gt;
<span class="kw">class</span> priority_queue;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;functional&gt;               </span><span class="co">// std::greater</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="dt">void</span> print_queue(T&amp; q) {
    <span class="kw">while</span>(!q.empty()) {
        std::cout &lt;&lt; q.top() &lt;&lt; <span class="st">&quot; &quot;</span>;
        q.pop();
    }
    std::cout &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}

<span class="dt">int</span> main() {
    std::priority_queue&lt;<span class="dt">int</span>&gt; q;

    <span class="kw">for</span>(<span class="dt">int</span> n : {<span class="dv">1</span>,<span class="dv">8</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">7</span>,<span class="dv">2</span>}) {
        q.push(n);
    }

    print_queue(q);

    std::priority_queue&lt;<span class="dt">int</span>, std::vector&lt;<span class="dt">int</span>&gt;, std::greater&lt;<span class="dt">int</span>&gt; &gt; q2;

    <span class="kw">for</span>(<span class="dt">int</span> n : {<span class="dv">1</span>,<span class="dv">8</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">7</span>,<span class="dv">2</span>})
        q2.push(n);

    print_queue(q2);

    <span class="co">// Using lambda to compare elements.</span>
    <span class="kw">auto</span> cmp = [](<span class="dt">int</span> left, <span class="dt">int</span> right) { <span class="kw">return</span> (left ^ <span class="dv">1</span>) &lt; (right ^ <span class="dv">1</span>);};
    std::priority_queue&lt;<span class="dt">int</span>, std::vector&lt;<span class="dt">int</span>&gt;, <span class="kw">decltype</span>(cmp)&gt; q3(cmp);

    <span class="kw">for</span>(<span class="dt">int</span> n : {<span class="dv">1</span>,<span class="dv">8</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">7</span>,<span class="dv">2</span>})
        q3.push(n);

    print_queue(q3);

}</code></pre></div>
<pre><code>9 8 7 6 5 4 3 2 1 0
0 1 2 3 4 5 6 7 8 9
8 9 6 7 4 5 2 3 0 1</code></pre>
<p>In computer science, a priority queue is an abstract data type which is like a regular queue or stack data structure, but where additionally each element has a &#8220;priority&#8221; associated with it. In a priority queue, an element with high priority is served before an element with low priority. If two elements have the same priority, they are served according to their order in the queue.</p>
<p>While priority queues are often implemented with heaps, they are conceptually distinct from heaps. A priority queue is an abstract concept like &#8220;a list&#8221; or &#8220;a map&#8221;; just as a list can be implemented with a linked list or an array, a priority queue can be implemented with a heap or a variety of other methods such as an unordered array.</p>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Priority_queue">Priority queue - Wikipedia, the free encyclopedia</a></li>
<li><a href="http://en.cppreference.com/w/cpp/container/priority_queue">std::priority_queue - cppreference.com</a></li>
<li><a href="http://en.cppreference.com/w/cpp/utility/functional/greater">std::greater - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>std::set <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>set_union <code class="fold">@</code></dt>
<dd><p>Defined in header <algorithm></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt; <span class="kw">class</span> InputIt1, <span class="kw">class</span> InputIt2, <span class="kw">class</span> OutputIt &gt;
OutputIt set_union( InputIt1 first1, InputIt1 last1,
                    InputIt2 first2, InputIt2 last2,
                    OutputIt d_first );

<span class="kw">template</span>&lt; <span class="kw">class</span> ExecutionPolicy, <span class="kw">class</span> InputIt1, <span class="kw">class</span> InputIt2, <span class="kw">class</span> OutputIt &gt;
OutputIt set_union( ExecutionPolicy&amp;&amp; policy, InputIt1 first1, InputIt1 last1,
                    InputIt2 first2, InputIt2 last2,
                    OutputIt d_first );

<span class="kw">template</span>&lt; <span class="kw">class</span> InputIt1, <span class="kw">class</span> InputIt2,
          <span class="kw">class</span> OutputIt, <span class="kw">class</span> Compare &gt;
OutputIt set_union( InputIt1 first1, InputIt1 last1,
                    InputIt2 first2, InputIt2 last2,
                    OutputIt d_first, Compare comp );

<span class="kw">template</span>&lt; <span class="kw">class</span> ExecutionPolicy, <span class="kw">class</span> InputIt1, <span class="kw">class</span> InputIt2,
          <span class="kw">class</span> OutputIt, <span class="kw">class</span> Compare &gt;
OutputIt set_union( ExecutionPolicy&amp;&amp; policy, InputIt1 first1, InputIt1 last1,
                    InputIt2 first2, InputIt2 last2,
                    OutputIt d_first, Compare comp );</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;set&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>

<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v1 = {<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>};
    std::vector&lt;<span class="dt">int</span>&gt; v2 = {      <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>};
    std::vector&lt;<span class="dt">int</span>&gt; dest1;

    std::set_union(v1.begin(), v1.end(),
                   v2.begin(), v2.end(),
                   std::back_inserter(dest1));

    <span class="kw">for</span> (<span class="dt">const</span> <span class="kw">auto</span> &amp;i : dest1) {
        std::cout &lt;&lt; i &lt;&lt; <span class="st">&#39; &#39;</span>;
    }
    std::cout &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre></div>
<p>output:</p>
<pre><code>1 2 3 4 5 6 7</code></pre>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>binary_search <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> (any_of(v.begin(), v.end(), bind2nd(equal_to&lt;string&gt;(), item)))
   do_this();
<span class="kw">else</span>
   do_that();</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/algorithm/binary_search">std::binary_search - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>find <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// vector</span>
vector&lt;<span class="dt">int</span>&gt;::iterator result = find( v.begin( ), v.end( ), <span class="dv">3</span> );

<span class="co">// map</span>
map.find(<span class="dv">5</span>) != map.end()
map.count(<span class="dv">5</span>)

<span class="co">// set</span>
set.find(<span class="dv">5</span>) != set.end()
set.count(<span class="dv">5</span>)</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/571394/how-to-find-if-an-item-is-present-in-a-stdvector">c++ - How to find if an item is present in a std::vector? - Stack Overflow</a></li>
<li><a href="http://en.cppreference.com/w/cpp/container/map/find">std::map::find - cppreference.com</a></li>
<li><a href="http://en.cppreference.com/w/cpp/container/set/count">std::set::count - cppreference.com</a></li>
<li><a href="http://en.cppreference.com/w/cpp/container/map/count">std::map::count - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>MISC, unordered_map, find, unordered_multimap <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">unordered_map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; map;
<span class="kw">if</span> (map.find(num[i]) != map.end()) { <span class="kw">continue</span>; }
<span class="kw">else</span> { map[num[i]] = <span class="dv">1</span>; }

map.find(gap) != map.end() &amp;&amp; map[gap] &gt; i

sort(num.begin(), num.end());

vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; result;
result.push_back({ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> });

unordered_map&lt;<span class="dt">int</span>, vector&lt;pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; &gt; &gt; cache;
<span class="kw">for</span> (size_t a = <span class="dv">0</span>; a &lt; num.size(); ++a) {
    <span class="kw">for</span> (size_t b = a + <span class="dv">1</span>; b &lt; num.size(); ++b) {
        cache[num[a] + num[b]].push_back(pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;(a, b));
    }
}

unordered_multimap&lt;<span class="dt">int</span>, pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;&gt; cache;
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i + <span class="dv">1</span> &lt; num.size(); ++i)
    <span class="kw">for</span> (<span class="dt">int</span> j = i + <span class="dv">1</span>; j &lt; num.size(); ++j)
        cache.insert(make_pair(num[i] + num[j], make_pair(i, j)));
    }
}

<span class="dt">int</span> trap(<span class="dt">int</span> A[], <span class="dt">int</span> n) {
    <span class="dt">int</span> *max_left = <span class="kw">new</span> <span class="dt">int</span>[n]();   <span class="co">// &#21021;&#22987;&#21270;&#20026; 0&#65292;&#29992; new int[n] &#21017;&#19981;&#21021;&#22987;&#21270;&#12290;</span>
    <span class="dt">int</span> *max_right = <span class="kw">new</span> <span class="dt">int</span>[n]();
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; n; i++) {
        max_left[i] = max(max_left[i - <span class="dv">1</span>], A[i - <span class="dv">1</span>]);
        <span class="co">// &#19968;&#19979;&#23601;&#25226;&#20004;&#36793;&#37117;&#32771;&#34385;&#20102;&#8230;&#8230;&#22909;&#29275;&#36924;&#65281;</span>
        max_right[n - <span class="dv">1</span> - i] = max(max_right[n - i], A[n - i]);
    }
    <span class="dt">int</span> sum = <span class="dv">0</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
        <span class="dt">int</span> height = min(max_left[i], max_right[i]);
        <span class="kw">if</span> (height &gt; A[i]) {
            sum += height - A[i];
        }
    }
    <span class="kw">delete</span>[] max_left;
    <span class="kw">delete</span>[] max_right;
    <span class="kw">return</span> sum;
}

<span class="kw">class</span> Solution  {
<span class="kw">public</span>:
    vector&lt;<span class="dt">int</span>&gt; plusOne(vector&lt;<span class="dt">int</span>&gt; &amp;digits) {
        add(digits, <span class="dv">1</span>);
        <span class="kw">return</span> digits;
    }

<span class="kw">private</span>:
    <span class="co">// 0 &lt;= digit &lt;= 9</span>
    <span class="dt">void</span> add(vector&lt;<span class="dt">int</span>&gt; &amp;digits, <span class="dt">int</span> digit) {
        <span class="dt">int</span> c = digit; <span class="co">// carry, &#36827;&#20301;</span>

        <span class="co">// method 1</span>
        <span class="kw">for</span> (<span class="kw">auto</span> it = digits.rbegin(); it != digits.rend(); ++it) {
            *it += c;
            c = *it / <span class="dv">10</span>;
            *it %= <span class="dv">10</span>;
        }

        <span class="co">// method 2</span>
        for_each(digits.rbegin(), digits.rend(), [&amp;c](<span class="dt">int</span> &amp;d){
            d += c;
            c = d / <span class="dv">10</span>;
            d %= <span class="dv">10</span>;
        });

        <span class="kw">if</span> (c &gt; <span class="dv">0</span>) { digits.insert(digits.begin(), <span class="dv">1</span>) }; <span class="co">// &#36825;&#37324;&#26159; insert c &#27604;&#36739;&#22909;&#12290;</span>
    }
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#8220;&#20540;&#35821;&#20041;&#8221; &#19982; &#8220;&#23545;&#35937;&#35821;&#20041;&#8221; <code class="fold">@</code></dt>
<dd><p>&#36825;&#20010;&#27010;&#24565;&#24456;&#37325;&#35201;&#65292;&#22312;&#26412;&#31508;&#35760;&#19979;&#25991; chenshuo &#37096;&#20998;&#26377;&#20171;&#32461;&#12290;</p>
<p>&#31616;&#21333;&#35828;&#65292;&#19968;&#33324;&#32780;&#35328;&#65292;&#33258;&#24049;&#35774;&#35745;&#30340; class &#23545;&#35937;&#21487;&#33021;&#26159; object semantics &#30340;&#65292;&#32780;&#19968;&#33324;&#30340; vector &#20869;&#23481;&#37117;&#26159; value semantics &#30340;&#65292;&#21069;&#32773;&#19981;&#33021;&#22797;&#21046;&#65288;&#27809;&#26377;&#24847;&#20041;&#65289;&#65292;&#21518;&#32773;&#21487;&#20197;&#22797;&#21046;&#65292;&#32780;&#19988;&#22797;&#21046;&#21518;&#20004;&#32773;&#33073;&#31163;&#20851;&#31995;&#12290;&#21069;&#32773;&#21482;&#33021;&#29992; pointer &#21644; reference &#26469;&#8220;&#25351;&#20195;&#8221;&#12290;</p>
</dd>
</dl></li>
</ul>
<h2 id="&#24555;&#38382;&#24555;&#31572;-faq">&#24555;&#38382;&#24555;&#31572; | FAQ</h2>
<ul>
<li><dl>
<dt>struct &#21644; class &#30340;&#21306;&#21035;&#65311; <code class="fold">@</code></dt>
<dd><p><strong>7.8 What&#8217;s the difference between the keywords struct and class?</strong></p>
<blockquote>
<p>The members and base classes of a struct are <strong>public by default</strong>, while in class, they <strong>default to private</strong>. Note: you should make your base classes explicitly public, private, or protected, rather than relying on the defaults.</p>
<p>Struct and class are <strong>otherwise functionally equivalent</strong>.</p>
<p>OK, enough of that squeaky clean techno talk. Emotionally, most developers make a strong distinction between a class and a struct. A struct simply feels like an open pile of bits with very little in the way of encapsulation or functionality. A class feels like a living and responsible member of society with intelligent services, a strong encapsulation barrier, and a well defined interface. Since that&#8217;s the connotation most people already have, you should probably use the struct keyword if you have a class that has very few methods and has public data (such things do exist in well designed systems!), but otherwise you should probably use the class keyword.</p>
</blockquote>
<p>According to Stroustrup in the C++ Programming Language:</p>
<blockquote>
<p>Which style you use depends on circumstances and taste. I usually prefer to use struct for classes that have all data public. I think of such classes as &#8220;not quite proper types, just data structures.&#8221;</p>
</blockquote>
<p>Functionally, there is no difference other than the public / private</p>
<p>&#8220;&#35828; struct &#21644; class &#31867;&#20284;&#21482;&#26159;&#20026;&#20102;&#35753;&#33756; b &#23481;&#26131;&#29702;&#35299;&#8221;&#65292;&#37027;&#35831;&#38382;&#37027;&#20301;&#8220;&#39640;&#25163;&#8221;&#24110;&#24537;&#35828;&#20986;&#38500;&#20102;</p>
<ul>
<li><strong>&#35775;&#38382;&#26435;&#38480;</strong>,</li>
<li><strong>&#32487;&#25215;&#26435;&#38480;</strong>, &#21644;</li>
<li><strong>template &#37324; type parameter &#20851;&#38190;&#23383;&#21487;&#20197;&#29992; class &#19981;&#33021;&#29992; struct</strong></li>
</ul>
<p>&#20043;&#22806;&#30340;&#20854;&#23427;&#19981;&#21516;&#20043;&#22788;&#21543;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> SB {
    <span class="dt">int</span> sbx;    <span class="co">// public by default</span>
};

<span class="kw">struct</span> SD : SB {    <span class="co">// public by default</span>
};

<span class="kw">class</span> CB {
<span class="kw">public</span>:
    <span class="dt">int</span> cbx;
<span class="kw">private</span>:
    <span class="dt">int</span> pri;
};

<span class="kw">class</span> CD : CB {
    <span class="co">// `class CD: public CB&#39; --&gt; tmp.cpp:13:9: error: &#8216;int CB::cbx&#8217; is inaccessible</span>
<span class="kw">public</span>:
    <span class="kw">using</span> CB::cbx;      <span class="co">// in base, it&#39;s public, so using it, will be a public</span>
    <span class="co">// using CB::pri;   // it&#39;s private, so can not inhenrite</span>
};

<span class="dt">int</span> main() {

    SD sd;
    cout &lt;&lt; sd.sbx &lt;&lt; endl;

    CD cd;
    cout &lt;&lt; cd.cbx &lt;&lt; endl;
    <span class="co">// cout &lt;&lt; cd.pri &lt;&lt; endl;</span>
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/92859/what-are-the-differences-between-struct-and-class-in-c">oop - What are the differences between struct and class in C++? - Stack Overflow</a></li>
<li><a href="http://www.faqs.org/faqs/C++-faq/part3/">C++ FAQ (part 03 of 14)</a></li>
<li><a href="https://www.zhihu.com/question/33700942">&#20851;&#20110;&#38463;&#37324;&#24052;&#24052;2011&#24180;&#19968;&#36947;C++&#31508;&#35797;&#39064;&#65288;struct&#21644;class&#65289;&#30340;&#30097;&#38382;? - &#30693;&#20046;</a></li>
<li><a href="http://blog.csdn.net/nocky/article/details/6195556">C++&#20013;struct&#19982;class&#30340;&#21306;&#21035; - &#20154;&#22312;&#26053;&#36884; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#20026;&#20160;&#20040; alignment &#21487;&#20197;&#25552;&#39640;&#24635;&#32447;&#65288;bus&#65289;&#30340;&#36816;&#36755;&#25928;&#29575;&#65311; <code class="fold">@</code></dt>
<dd><p>It&#8217;s a limitation of many underlying processors. It can usually be worked around by doing 4 inefficient single byte fetches rather than one efficient word fetch, but many language specifiers decided <strong>it would be easier just to outlaw them and force everything to be aligned</strong>.</p>
<p>&#22240;&#20026; bulk read/write memory &#35201;&#24555;&#20123;&#12290;&#20869;&#23384;&#23545;&#40784;&#20102;&#25968;&#25454;&#23601;&#25335;&#36125;&#24471;&#24555;&#20102;&#12290;</p>
<dl>
<dt><a href="http://www.ibm.com/developerworks/library/pa-dalign/" class="heart">Data alignment: Straighten up and fly right</a> <code class="fold">@</code></dt>
<dd><p><img src="http://www.ibm.com/developerworks/library/pa-dalign/howProgrammersSeeMemory.jpg" /> <img src="http://www.ibm.com/developerworks/library/pa-dalign/howProcessorsSeeMemory.jpg" /></p>
<p>Figure 1. How programmers see memory &amp; Figure 2. How processors see memory</p>
<p>However, your computer&#8217;s processor does not read from and write to memory in byte-sized chunks. Instead, it accesses memory in two-, four-, eight- 16- or even 32-byte chunks. We&#8217;ll call the size in which a processor accesses memory its memory access granularity.</p>
<div class="figure">
<img src="http://www.ibm.com/developerworks/library/pa-dalign/singleByteAccess.jpg" alt="Figure 3. Single-byte memory access granularity&#65288;[gr&#230;nj&#650;&#39;l&#230;r&#618;t&#618;]&#65292;&#31890;&#24230;&#65289;" />
<p class="caption">Figure 3. Single-byte memory access granularity&#65288;<code>[gr&#230;nj&#650;'l&#230;r&#618;t&#618;]</code>&#65292;&#31890;&#24230;&#65289;</p>
</div>
<p>&#20320;&#35273;&#24471;&#23601;&#35813;&#36825;&#26679;&#65311;</p>
<p>&#20294;&#26159;&#20004;&#20010;&#23383;&#33410;&#19968;&#35835;&#26356;&#24555;&#65292;&#22235;&#20010;&#36824;&#35201;&#24555;&#65281;</p>
<div class="figure">
<img src="http://www.ibm.com/developerworks/library/pa-dalign/doubleByteAccess.jpg" alt="Figure 4. Double-byte memory access granularity" />
<p class="caption">Figure 4. Double-byte memory access granularity</p>
</div>
<div class="figure">
<img src="http://www.ibm.com/developerworks/library/pa-dalign/quadByteAccess.jpg" alt="Figure 5. Quad-byte memory access granularity" />
<p class="caption">Figure 5. Quad-byte memory access granularity</p>
</div>
<div class="figure">
<img src="http://www.ibm.com/developerworks/library/pa-dalign/unalignedAccess.jpg" alt="Figure 6. How processors handle unaligned memory access" />
<p class="caption">Figure 6. How processors handle unaligned memory access</p>
</div>
<div class="figure">
<img src="http://www.ibm.com/developerworks/library/pa-dalign/horrorChartWhole.jpg" alt="&#22914;&#26524;&#37117;&#19981;&#23545;&#40784;&#30340;&#35805;&#8230;&#8230;8 &#23383;&#33410;&#21453;&#32780;&#24930;&#24471;&#35201;&#27515;&#12290;" />
<p class="caption">&#22914;&#26524;&#37117;&#19981;&#23545;&#40784;&#30340;&#35805;&#8230;&#8230;8 &#23383;&#33410;&#21453;&#32780;&#24930;&#24471;&#35201;&#27515;&#12290;</p>
</div>
<div class="figure">
<img src="http://www.ibm.com/developerworks/library/pa-dalign/horrorChartHeadless.jpg" alt="4 &#23383;&#33410; align" />
<p class="caption">4 &#23383;&#33410; align</p>
</div>
<div class="figure">
<img src="http://www.ibm.com/developerworks/library/pa-dalign/horrorChartHeadlessHilited.jpg" alt="8 &#23383;&#33410; align&#65292;&#25928;&#26524;&#23601;&#26356;&#22909;&#20102;&#12290;" />
<p class="caption">8 &#23383;&#33410; align&#65292;&#25928;&#26524;&#23601;&#26356;&#22909;&#20102;&#12290;</p>
</div>
</dd>
<dt><a href="https://github.com/ludx/The-Lost-Art-of-C-Structure-Packing">ludx/The-Lost-Art-of-C-Structure-Packing: The Lost Art of C Structure Packing&#20013;&#25991;&#32763;&#35793;</a> <code class="fold">@</code></dt>
<dd><p>&#23383;&#31526;&#25968;&#32452; <code>pad</code> &#24847;&#21619;&#30528;&#22312;&#36825;&#20010;&#32467;&#26500;&#20307;&#20013;&#65292;&#26377; 3 &#20010;&#23383;&#33410;&#30340;&#31354;&#38388;&#34987;&#28010;&#36153;&#25481;&#20102;&#12290;&#32769;&#27966;&#26415;&#35821;&#23558;&#20854;&#31216;&#20043;&#20026;<strong>&#8220;&#24223;&#28082;&#65288;slop&#65292;<code>[sl&#593;t]</code>&#65289;&#8221;</strong>&#12290;&#39318;&#20808;&#65292;&#22312;&#27492;&#20363;&#20013;&#65292;N &#23558;&#20026; 0&#65292;x &#30340;&#22320;&#22336;&#32039;&#38543; p &#20043;&#21518;&#65292;&#33021;&#30830;&#20445;&#26159;&#19982;&#25351;&#38024;&#23545;&#40784;&#30340;&#65292;&#22240;&#20026;&#25351;&#38024;&#30340;&#23545;&#40784;&#35201;&#27714;&#24635;&#27604; int &#20005;&#26684;&#12290;</p>
<p>&#20504;&#33509;&#20320;&#24076;&#26395;&#36825;&#20123;&#21464;&#37327;&#21344;&#29992;&#30340;&#31354;&#38388;&#26356;&#23569;&#65292;&#37027;&#20040;&#21487;&#20197;&#20132;&#25442;x&#19982;c&#30340;&#27425;&#24207;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> *p;     <span class="co">/* 8 bytes */</span>
<span class="dt">long</span> x;      <span class="co">/* 8 bytes */</span>
<span class="dt">char</span> c;      <span class="co">/* 1 byte */</span>
<span class="co">// &#28982;&#32780;&#22312;&#25105; x64 Linux &#19978;&#65292;g++ 4.8 &#32534;&#35793;&#32467;&#26524;&#26159; sizeof(struct) = 24</span>
<span class="co">// &#20869;&#23481;&#24182;&#27809;&#26377;&#20943;&#23569;&#12290;</span></code></pre></div>
<p>ANSI C &#25552;&#20379;&#20102;&#19968;&#20010; <code>offsetof()</code> &#23439;&#65292;&#21487;&#29992;&#20110;&#35835;&#21462;&#32467;&#26500;&#20307;&#25104;&#21592;&#20301;&#31227;&#12290;&#65288;&#26469;&#33258; stddef.h&#65289;</p>
<p>&#65288;&#21520;&#27133;&#65292;offsetof &#21487;&#33021;&#25343;&#21040; bigfield &#30340;&#22320;&#22336;==&#65292;<code>&amp;</code> &#20063;&#19981;&#34892;&#12290;&#22909;&#25226;&#65292;&#22320;&#22336;&#37117;&#26159;&#25353; byte &#26469;&#30340;&#8230;&#8230;&#36825;&#20063;&#26159;&#20026;&#20160;&#20040; <code>std::vector&lt;bool&gt;</code> &#19981;&#26159;&#19968;&#20010;&#27491;&#24120;&#30340;&#23481;&#22120;&#30340;&#21407;&#22240;&#12290;&#65289;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stddef.h&gt;</span>

<span class="kw">struct</span> X {
        <span class="dt">char</span> *p;     <span class="co">/* 8 bytes */</span>
        <span class="dt">char</span> e;      <span class="co">/* 1 byte */</span>
        <span class="dt">long</span> x;      <span class="co">/* 8 bytes */</span>
        <span class="dt">char</span> c;      <span class="co">/* 1 byte */</span>
        <span class="dt">char</span> d;      <span class="co">/* 1 byte */</span>
};

<span class="dt">int</span> main()
{
    printf(<span class="st">&quot;offsetof(X, x): </span><span class="ch">%d\n</span><span class="st">&quot;</span>, offsetof(<span class="kw">struct</span> X, x));  <span class="co">// 16</span>
}</code></pre></div>
<p>&#29616;&#22312;&#65292;&#25105;&#20204;&#26469;&#35848;&#35848;&#32467;&#26500;&#20307;&#30340;<strong>&#23614;&#22635;&#20805;&#65288;trailing padding&#65289;</strong>&#12290;&#20026;&#20102;&#35299;&#37322;&#23427;&#65292;&#38656;&#35201;&#24341;&#20837;&#19968;&#20010;&#22522;&#26412;&#27010;&#24565;&#65292;&#25105;&#23558;&#20854;&#31216;&#20026;&#32467;&#26500;&#20307;&#30340;&#8220;&#36328;&#27493;&#22320;&#22336;&#65288;stride address&#65289;&#8221;&#12290;&#23427;&#26159;&#22312;&#32467;&#26500;&#20307;&#25968;&#25454;&#20043;&#21518;&#65292;&#19982;&#32467;&#26500;&#20307;&#23545;&#40784;&#19968;&#33268;&#30340;&#39318;&#20010;&#22320;&#22336;&#12290;</p>
<p>&#32467;&#26500;&#20307;&#23614;&#22635;&#20805;&#30340;&#36890;&#29992;&#27861;&#21017;&#26159;&#65306;&#32534;&#35793;&#22120;&#23558;&#20250;&#23545;&#32467;&#26500;&#20307;&#36827;&#34892;&#23614;&#22635;&#20805;&#65292;&#30452;&#33267;&#23427;&#30340;&#36328;&#27493;&#22320;&#22336;&#12290;&#36825;&#26465;&#27861;&#21017;&#20915;&#23450;&#20102;sizeof()&#30340;&#36820;&#22238;&#20540;&#12290;</p>
<p>&#21363;&#20351;&#22312; 64 &#20301;&#31995;&#32479;&#19978;&#65292;sizeof(foo4) &#20063;&#26159; 4&#65288;&#32780;&#19981;&#26159;&#26356;&#28010;&#36153;&#31354;&#38388;&#20294;&#26356;&#25972;&#40784;&#30340; 8&#65289;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> foo4 {
    <span class="dt">short</span> s;     <span class="co">/* 2 bytes */</span>
    <span class="dt">char</span> c;      <span class="co">/* 1 byte */</span>
};</code></pre></div>
<p>&#29616;&#22312;&#25105;&#20204;&#32771;&#34385;&#20301;&#22495;&#65288;bitfields&#65289;&#12290;&#21033;&#29992;&#20301;&#22495;&#65292;&#20320;&#33021;&#22768;&#26126;&#27604;&#23383;&#31526;&#23485;&#24230;&#26356;&#23567;&#30340;&#25104;&#21592;&#65292;&#20302;&#33267;&#65297;&#20301;&#65292;&#20363;&#22914;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> foo5 {
    <span class="dt">short</span> s;
    <span class="dt">char</span> c;
    <span class="dt">int</span> flip:<span class="dv">1</span>;
    <span class="dt">int</span> nybble:<span class="dv">4</span>;
    <span class="dt">int</span> septet:<span class="dv">7</span>;
};</code></pre></div>
<p>&#20851;&#20110;&#20301;&#22495;&#38656;&#35201;&#20102;&#35299;&#30340;&#26159;&#65292;&#23427;&#20204;&#26159;&#30001;&#23383;&#65288;&#25110;&#23383;&#33410;&#65289;&#23618;&#38754;&#30340;&#25513;&#30721;&#21644;&#31227;&#20301;&#25351;&#20196;&#23454;&#29616;&#30340;&#12290;&#20174;&#32534;&#35793;&#22120;&#30340;&#35282;&#24230;&#26469;&#30475;&#65292;struct foo5&#20013;&#30340;&#20301;&#22495;&#23601;&#20687;&#65298;&#23383;&#33410;&#12289;16&#20301;&#30340;&#23383;&#31526;&#25968;&#32452;&#65292;&#21482;&#29992;&#21040;&#20102;&#20854;&#20013;12&#20301;&#12290;&#20026;&#20102;&#20351;&#32467;&#26500;&#20307;&#30340;&#38271;&#24230;&#26159;&#20854;&#26368;&#23485;&#25104;&#21592;&#38271;&#24230;sizeof(short)&#30340;&#25972;&#25968;&#20493;&#65292;&#25509;&#19979;&#26469;&#36827;&#34892;&#20102;&#22635;&#20805;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> foo5 {
    <span class="dt">short</span> s;       <span class="co">/* 2 bytes */</span>
    <span class="dt">char</span> c;        <span class="co">/* 1 byte */</span>
    <span class="dt">int</span> flip:<span class="dv">1</span>;    <span class="co">/* total 1 bit */</span>
    <span class="dt">int</span> nybble:<span class="dv">4</span>;  <span class="co">/* total 5 bits */</span>
    <span class="dt">int</span> septet:<span class="dv">7</span>;  <span class="co">/* total 12 bits */</span>
    <span class="dt">int</span> pad1:<span class="dv">4</span>;    <span class="co">/* total 16 bits = 2 bytes */</span>
    <span class="dt">char</span> pad2;     <span class="co">/* 1 byte */</span>
};</code></pre></div>
<p>&#20869;&#23618;&#32467;&#26500;&#20307;&#25104;&#21592; <code>char *p</code> &#24378;&#36843;&#22806;&#23618;&#32467;&#26500;&#20307;&#19982;&#20869;&#23618;&#32467;&#26500;&#20307;&#25351;&#38024;&#23545;&#40784;&#19968;&#33268;&#12290;&#22312; 64 &#20301;&#31995;&#32479;&#20013;&#65292;&#23454;&#38469;&#30340;&#20869;&#23384;&#20998;&#24067;&#23558;&#31867;&#20284;&#36825;&#26679;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> foo6 {
    <span class="dt">char</span> c;           <span class="co">/* 1 byte */</span>
    <span class="dt">char</span> pad1;     <span class="co">/* 7 bytes */</span>
    <span class="kw">struct</span> foo6_inner {
        <span class="dt">char</span> *p;      <span class="co">/* 8 bytes */</span>
        <span class="dt">short</span> x;      <span class="co">/* 2 bytes */</span>
        <span class="dt">char</span> pad2; <span class="co">/* 6 bytes */</span>
    } inner;
};</code></pre></div>
<p>&#29702;&#35299;&#20102;&#32534;&#35793;&#22120;&#22312;&#32467;&#26500;&#20307;&#20013;&#38388;&#21644;&#23614;&#37096;&#25554;&#20837;&#22635;&#20805;&#30340;&#21407;&#22240;&#19982;&#26041;&#24335;&#21518;&#65292;&#25105;&#20204;&#26469;&#30475;&#30475;&#22914;&#20309;&#27048;&#20986;&#36825;&#20123;&#24223;&#28082;&#12290;&#27492;&#21363;&#32467;&#26500;&#20307;&#25171;&#21253;&#30340;&#25216;&#33402;&#12290;</p>
<p>&#28040;&#38500;&#24223;&#28082;&#26368;&#31616;&#21333;&#30340;&#26041;&#24335;&#65292;&#26159;&#25353;&#23545;&#40784;&#20540;&#36882;&#20943;&#37325;&#26032;&#23545;&#32467;&#26500;&#20307;&#25104;&#21592;&#25490;&#24207;&#12290;&#21363;&#35753;&#25152;&#26377;&#25351;&#38024;&#23545;&#40784;&#25104;&#21592;&#25490;&#22312;&#26368;&#21069;&#38754;&#65292;&#22240;&#20026;&#22312; 64 &#20301;&#31995;&#32479;&#20013;&#23427;&#20204;&#21344;&#29992; 8 &#23383;&#33410;&#65307;&#28982;&#21518;&#26159; 4 &#23383;&#33410;&#30340; int&#65307;&#20877;&#28982;&#21518;&#26159; 2 &#23383;&#33410;&#30340; short&#65292;&#26368;&#21518;&#26159;&#23383;&#31526;&#12290;</p>
<p>&#31528;&#25305;&#22320;&#12289;&#26426;&#26800;&#22320;&#37325;&#25490;&#32467;&#26500;&#20307;&#21487;&#33021;&#26377;&#25439;&#21487;&#35835;&#24615;&#12290;&#20504;&#33509;&#26377;&#21487;&#33021;&#65292;&#26368;&#22909;&#36825;&#26679;&#37325;&#25490;&#25104;&#21592;&#65306;&#23558;&#35821;&#20041;&#30456;&#20851;&#30340;&#25968;&#25454;&#25918;&#22312;&#19968;&#36215;&#65292;&#24418;&#25104;&#36830;&#36143;&#30340;&#32452;&#12290;&#26368;&#29702;&#24819;&#30340;&#24773;&#20917;&#26159;&#65292;&#32467;&#26500;&#20307;&#30340;&#35774;&#35745;&#24212;&#19982;&#31243;&#24207;&#30340;&#35774;&#35745;&#30456;&#36890;&#12290;</p>
<p>&#26368;&#20882;&#38505;&#30340;&#25171;&#21253;&#26041;&#27861;&#26159;&#20351;&#29992; union&#12290;&#20551;&#22914;&#20320;&#30693;&#36947;&#32467;&#26500;&#20307;&#20013;&#30340;&#26576;&#20123;&#22495;&#27704;&#36828;&#19981;&#20250;&#36319;&#21478;&#19968;&#20123;&#22495;&#20849;&#21516;&#20351;&#29992;&#65292;&#21487;&#20197;&#32771;&#34385;&#29992; union &#20849;&#20139;&#23427;&#20204;&#23384;&#20648;&#31354;&#38388;&#12290;&#19981;&#36807;&#35831;&#29305;&#21035;&#23567;&#24515;&#24182;&#29992;&#22238;&#24402;&#27979;&#35797;&#39564;&#35777;&#12290;&#22240;&#20026;&#22914;&#26524;&#20998;&#26512;&#20986;&#29616;&#19968;&#19969;&#28857;&#20799;&#38169;&#35823;&#65292;&#23601;&#20250;&#24341;&#21457;&#20174;&#31243;&#24207;&#23849;&#28291;&#21040;&#24494;&#22937;&#25968;&#25454;&#25439;&#22351;&#65288;&#36825;&#31181;&#24773;&#20917;&#31967;&#24471;&#22810;&#65289;&#38388;&#30340;&#21508;&#31181;&#38169;&#35823;&#12290;</p>
<p>clang &#32534;&#35793;&#22120;&#26377;&#20010; Wpadded &#36873;&#39033;&#65292;&#21487;&#20197;&#29983;&#25104;&#26377;&#20851;&#23545;&#40784;&#21644;&#22635;&#20805;&#30340;&#20449;&#24687;&#12290;</p>
</dd>
<dt>rms&#8217;s code to test memory alignment <code class="fold">@</code></dt>
<dd><p>see <a href="http://www.catb.org/esr/structure-packing/packtest.c">packtest.c</a></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdbool.h&gt;</span>

<span class="kw">struct</span> foo1 {
    <span class="dt">char</span> *p;
    <span class="dt">char</span> c;
    <span class="dt">long</span> x;
};
<span class="co">// sizeof(struct foo1)   = 24</span>

<span class="kw">struct</span> foo2 {
    <span class="dt">char</span> c;      <span class="co">/* 1 byte */</span>
    <span class="dt">char</span> pad; <span class="co">/* 7 bytes */</span>
    <span class="dt">char</span> *p;     <span class="co">/* 8 bytes */</span>
    <span class="dt">long</span> x;      <span class="co">/* 8 bytes */</span>
};
<span class="co">// sizeof(struct foo2)   = 24</span>

<span class="kw">struct</span> foo3 {
    <span class="dt">char</span> *p;     <span class="co">/* 8 bytes */</span>
    <span class="dt">char</span> c;      <span class="co">/* 1 byte */</span>
};
<span class="co">// sizeof(struct foo3)   = 16</span>

<span class="kw">struct</span> foo4 {
    <span class="dt">short</span> s;     <span class="co">/* 2 bytes */</span>
    <span class="dt">char</span> c;      <span class="co">/* 1 byte */</span>
};
<span class="co">// sizeof(struct foo4)   = 4</span>

<span class="kw">struct</span> foo5 {
    <span class="dt">char</span> c;
    <span class="kw">struct</span> foo5_inner {
        <span class="dt">char</span> *p;
        <span class="dt">short</span> x;
    } inner;
};
<span class="co">// sizeof(struct foo5)   = 24</span>

<span class="kw">struct</span> foo6 {
    <span class="dt">short</span> s;
    <span class="dt">char</span> c;
    <span class="dt">int</span> flip:<span class="dv">1</span>;
    <span class="dt">int</span> nybble:<span class="dv">4</span>;
    <span class="dt">int</span> septet:<span class="dv">7</span>;
};
<span class="co">// sizeof(struct foo6)   = 8</span>

<span class="kw">struct</span> foo7 {
    <span class="dt">int</span> bigfield:<span class="dv">31</span>;
    <span class="dt">int</span> littlefield:<span class="dv">1</span>;
};
<span class="co">// sizeof(struct foo7)   = 4</span>

<span class="kw">struct</span> foo8 {
    <span class="dt">int</span> bigfield1:<span class="dv">31</span>;
    <span class="dt">int</span> littlefield1:<span class="dv">1</span>;
    <span class="dt">int</span> bigfield2:<span class="dv">31</span>;
    <span class="dt">int</span> littlefield2:<span class="dv">1</span>;
};
<span class="co">// sizeof(struct foo8)   = 8</span>

<span class="kw">struct</span> foo9 {
    <span class="dt">int</span> bigfield1:<span class="dv">31</span>;
    <span class="dt">int</span> bigfield2:<span class="dv">31</span>;
    <span class="dt">int</span> littlefield1:<span class="dv">1</span>;
    <span class="dt">int</span> littlefield2:<span class="dv">1</span>;
};
<span class="co">// sizeof(struct foo9)   = 12</span>


<span class="kw">struct</span> foo10 {
    <span class="dt">char</span> c;
    <span class="kw">struct</span> foo10 *p;
    <span class="dt">short</span> x;
};
<span class="co">// sizeof(struct foo10)   = 24</span>

<span class="kw">struct</span> foo11 {
    <span class="kw">struct</span> foo11 *p;
    <span class="dt">short</span> x;
    <span class="dt">char</span> c;
};
<span class="co">// sizeof(struct foo11)   = 16</span>

<span class="kw">struct</span> foo12 {
    <span class="kw">struct</span> foo12_inner {
        <span class="dt">char</span> *p;
        <span class="dt">short</span> x;
    } inner;
    <span class="dt">char</span> c;
};
<span class="co">// sizeof(struct foo12)   = 24</span>

main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv)
{
    printf(<span class="st">&quot;sizeof(char *)        = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="dt">char</span> *));
    printf(<span class="st">&quot;sizeof(long)          = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="dt">long</span>));
    printf(<span class="st">&quot;sizeof(int)           = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="dt">int</span>));
    printf(<span class="st">&quot;sizeof(short)         = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="dt">short</span>));
    printf(<span class="st">&quot;sizeof(char)          = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="dt">char</span>));
    printf(<span class="st">&quot;sizeof(float)         = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="dt">float</span>));
    printf(<span class="st">&quot;sizeof(double)        = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="dt">double</span>));
    printf(<span class="st">&quot;sizeof(struct foo1)   = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> foo1));
    printf(<span class="st">&quot;sizeof(struct foo2)   = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> foo2));
    printf(<span class="st">&quot;sizeof(struct foo3)   = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> foo3));
    printf(<span class="st">&quot;sizeof(struct foo4)   = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> foo4));
    printf(<span class="st">&quot;sizeof(struct foo5)   = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> foo5));
    printf(<span class="st">&quot;sizeof(struct foo6)   = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> foo6));
    printf(<span class="st">&quot;sizeof(struct foo7)   = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> foo7));
    printf(<span class="st">&quot;sizeof(struct foo8)   = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> foo8));
    printf(<span class="st">&quot;sizeof(struct foo9)   = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> foo9));
    printf(<span class="st">&quot;sizeof(struct foo10)   = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> foo10));
    printf(<span class="st">&quot;sizeof(struct foo11)   = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> foo11));
    printf(<span class="st">&quot;sizeof(struct foo12)   = </span><span class="ch">%zu\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> foo12));
}</code></pre></div>
<p>output:</p>
<pre><code>sizeof(char *)        = 8
sizeof(long)          = 8
sizeof(int)           = 4
sizeof(short)         = 2
sizeof(char)          = 1
sizeof(float)         = 4
sizeof(double)        = 8
sizeof(struct foo1)   = 24
sizeof(struct foo2)   = 24
sizeof(struct foo3)   = 16
sizeof(struct foo4)   = 4
sizeof(struct foo5)   = 24
sizeof(struct foo6)   = 8
sizeof(struct foo7)   = 4
sizeof(struct foo8)   = 8
sizeof(struct foo9)   = 12
sizeof(struct foo10)   = 24
sizeof(struct foo11)   = 16
sizeof(struct foo12)   = 24</code></pre>
</dd>
<dt>Computer Systems: A Programmer&#8217;s Perspective: <code class="fold">@</code></dt>
<dd><blockquote>
<p><strong>3.9.3 Data Alignment</strong></p>
<p>Many computer systems place restrictions on the allowable addresses for the primitive data types, requiring that the address for some type of object must be a multiple of some value K (typically 2, 4, or 8). Such alignment restrictions <strong>simplify the design of the hardware</strong> forming the interface between the processor and the memory system. For example, suppose a processor always fetches 8 bytes from memory with an address that must be a multiple of 8. If we can guarantee that any double will be aligned to have its address be a multiple of 8, then the value can be read or written with a single memory operation. Otherwise, we may need to perform two memory accesses, since the object might be split across two 8-byte memory blocks.</p>
<p>The IA32 hardware will work correctly regardless of the alignment of data. However, Intel recommends that data be aligned to improve memory system performance. Linux follows an alignment policy where 2-byte data types (e.g., short) must have an address that is a multiple of 2, while any larger data types (e.g., int, int *, float, and double) must have an address that is a multiple of 4. Note that this requirement means that the least significant bit of the address of an object of type short must equal zero. Similarly, any object of type int, or any pointer, must be at an address having the low-order 2 bits equal to zero.</p>
</blockquote>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/381244/purpose-of-memory-alignment">Purpose of memory alignment - Stack Overflow</a></li>
<li><a href="http://stackoverflow.com/questions/826569/compelling-examples-of-custom-c-allocators">memory management - Compelling examples of custom C++ allocators? - Stack Overflow</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#20026;&#20160;&#20040; fread&#12289;fwrite &#35201;&#20004;&#20010;&#21442;&#25968;&#65288;sizeof(element) + number of element&#65289; <code class="fold">@</code></dt>
<dd><p>two questions, how big? how many?</p>
<p>fread&#12289;fwrite &#30340; signature &#26159;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">size_t fread(        <span class="dt">void</span> *ptr, size_t size, size_t nmemb, FILE *stream );
size_t fwrite( <span class="dt">const</span> <span class="dt">void</span> *ptr, size_t size, size_t nmemb, FILE *stream );</code></pre></div>
<p>&#20854;&#20013;&#36820;&#22238;&#20540;&#26159;&#25104;&#21151;&#35835;&#21462;&#12289;&#20889;&#20986;&#30340; nmemb &#25968;&#12290;&#36825;&#19968;&#28857;&#26377;&#21161;&#20110;&#26597;&#38169;&#12290;</p>
<p><code>scanf</code> &#20250;&#36820;&#22238; scanf &#21040;&#30340;&#21464;&#37327;&#25968;&#30446;&#65307;<code>printf</code> &#20250;&#36820;&#22238; print &#20986;&#30340; char &#25968;&#30446;&#65288;&#19981;&#21253;&#25324;&#21738;&#20010; terminating null char <code>'\0'</code>&#65289;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/29861811/significance-of-two-arguments-in-fread">c - Significance of two arguments in fread? - Stack Overflow</a></li>
<li><a href="http://stackoverflow.com/questions/295994/what-is-the-rationale-for-fread-fwrite-taking-size-and-count-as-arguments/#296018">c - What is the rationale for fread/fwrite taking size and count as arguments? - Stack Overflow</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>What and where are the stack and heap? <code class="fold">@</code></dt>
<dd><p><strong>The stack is the memory set aside as scratch space for a thread of execution.</strong> When a function is called, a block is reserved on the top of the stack for local variables and some bookkeeping data. When that function returns, the block becomes unused and can be used the next time a function is called. The stack is always reserved <strong>in a LIFO (last in first out) order;</strong> the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack; freeing a block from the stack is nothing more than adjusting one pointer.</p>
<p><strong>The heap is memory set aside for dynamic allocation.</strong> Unlike the stack, there&#8217;s no enforced pattern to the allocation and deallocation of blocks from the heap; you can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time; there are many custom heap allocators available to tune heap performance for different usage patterns.</p>
<p>Each thread gets a stack, while there&#8217;s typically only one heap for the application (although it isn&#8217;t uncommon to have multiple heaps for different types of allocation).</p>
<p>To answer your questions directly:</p>
<dl>
<dt>To what extent are they controlled by the OS or language runtime?</dt>
<dd><p>The OS allocates the stack for each system-level thread when the thread is created. Typically the OS is called by the language runtime to allocate the heap for the application.</p>
</dd>
<dt>What is their scope?</dt>
<dd><p>The stack is attached to a thread, so when the thread exits the stack is reclaimed. The heap is typically allocated at application startup by the runtime, and is reclaimed when the application (technically process) exits.</p>
</dd>
<dt>What determines the size of each of them?</dt>
<dd><p>The size of the stack is set when a thread is created. The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system).</p>
</dd>
<dt>What makes one faster?</dt>
<dd><p>The stack is faster because the access pattern makes it trivial to allocate and deallocate memory from it (a pointer/integer is simply incremented or decremented), while the heap has much more complex bookkeeping involved in an allocation or deallocation. <strong>Also, each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor&#8217;s cache, making it very fast.</strong> Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe, i.e.&#160;each allocation and deallocation needs to be - typically - synchronized with &#8220;all&#8221; other heap accesses in the program.</p>
</dd>
<dt>A clear demonstration:</dt>
<dd><div class="figure">
<img src="http://i.stack.imgur.com/i6k0Z.png" />

</div>
</dd>
</dl>
<p>Stack:</p>
<ul>
<li>Stored in computer RAM just like the heap.</li>
<li>Variables created on the stack will <strong>go out of scope and automatically deallocate</strong>.</li>
<li>Much <strong>faster to allocate</strong> in comparison to variables on the heap.</li>
<li>Implemented with an actual stack data structure.</li>
<li>Stores local data, return addresses, used for parameter passing</li>
<li>Can have a stack overflow when too much of the stack is used. (mostly from infinite (or too much) recursion, very large allocations)</li>
<li>Data created on the stack can be used without pointers.</li>
<li><strong>You would use the stack if you know exactly how much data you need to allocate before compile time and it is not too big.</strong></li>
<li>Usually has a maximum size already determined when your program starts</li>
</ul>
<p>Heap:</p>
<ul>
<li>Stored in computer RAM just like the stack.</li>
<li><strong>In C, variables on the heap must be destroyed manually and never fall out of scope.</strong> The data is freed with <code>delete</code>, <code>delete[]</code>, or <code>free</code></li>
<li><strong>Slower to allocate</strong> in comparison to variables on the stack.</li>
<li>Used on demand to allocate a block of data for use by the program.</li>
<li>Can have fragmentation when there are a lot of allocations and deallocations</li>
<li>In C++ data created on the heap will be pointed to by pointers and allocated with new or malloc</li>
<li>Can have allocation failures if too big of a buffer is requested to be allocated.</li>
<li>You would use the heap if you don&#8217;t know exactly how much data you will need at runtime or if you need to allocate a lot of data.</li>
<li>Responsible for memory leaks</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> foo()
{
  <span class="dt">char</span> *pBuffer; <span class="co">//&lt;--nothing allocated yet (excluding the pointer itself, which is allocated here on the stack).</span>
  <span class="dt">bool</span> b = <span class="kw">true</span>; <span class="co">// Allocated on the stack.</span>
  <span class="kw">if</span>(b)
  {
    <span class="co">//Create 500 bytes on the stack</span>
    <span class="dt">char</span> buffer;

    <span class="co">//Create 500 bytes on the heap</span>
    pBuffer = <span class="kw">new</span> <span class="dt">char</span>;

   }<span class="co">//&lt;-- buffer is deallocated here, pBuffer is not</span>
}<span class="co">//&lt;--- oops there&#39;s a memory leak, I should have called delete[] pBuffer;</span></code></pre></div>
<p>&#36825;&#20010;&#21602;&#65311;<code>int buf[num]</code> &#26159;&#22312; heap &#36824;&#26159; stack&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main()
{
    <span class="dt">int</span> num;
    <span class="kw">while</span>( <span class="dv">1</span> == scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;num) ) {
        <span class="kw">if</span>( num &lt; <span class="dv">2</span> ) { <span class="kw">continue</span>; }
        <span class="dt">int</span> buf[num];
        buf[<span class="dv">0</span>] = <span class="dv">1</span>;
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt; num; ++i ) {
            buf[i] = buf[i<span class="dv">-1</span>] * <span class="dv">2</span>;
            printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, buf[i]);
        }
        printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
}</code></pre></div>
<p>seems on stack.</p>
<div class="figure">
<img src="http://whudoc.qiniudn.com/2016/20160706204948669.png" />

</div>
<p>&#31616;&#21333;&#30340;&#21487;&#20197;&#29702;&#35299;&#20026;&#65306;</p>
<ul>
<li>stack&#65306;&#26159;&#33258;&#21160;&#20998;&#37197;&#21464;&#37327;&#65292;&#20197;&#21450;&#20989;&#25968;&#35843;&#29992;&#30340;&#26102;&#20505;&#25152;&#20351;&#29992;&#30340;&#19968;&#20123;&#31354;&#38388;&#12290;<strong>&#22320;&#22336;&#26159;&#30001;&#39640;&#21521;&#20302;&#20943;&#23569;&#30340;&#12290;</strong></li>
<li>heap&#65306;&#26159;&#30001; malloc &#20043;&#31867;&#20989;&#25968;&#20998;&#37197;&#30340;&#31354;&#38388;&#25152;&#22312;&#22320;&#12290;<strong>&#22320;&#22336;&#26159;&#30001;&#20302;&#21521;&#39640;&#22686;&#38271;&#30340;&#12290;</strong></li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap#79936">memory management - What and where are the stack and heap? - Stack Overflow</a></li>
<li><a href="http://blog.csdn.net/changyourmind/article/details/51839395">&#22914;&#20309;&#21028;&#26029;&#26632;&#12289;&#22534;&#30340;&#22686;&#38271;&#26041;&#21521;&#65311; - changyourmind &#30340;&#19987;&#26639; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>pointer &#21644; reference &#30340;&#21306;&#21035;&#65311;What are the differences between a pointer variable and a reference variable in C++? <code class="fold">@</code></dt>
<dd><ul>
<li>A pointer can be re-assigned any number of times while a reference can not be re-seated after binding.</li>
<li>Pointers can point nowhere (NULL), whereas reference always refer to an object.</li>
<li>You can&#8217;t take the address of a reference like you can with pointers.</li>
<li>There&#8217;s no &#8220;reference arithmetics&#8221; (but you can take the address of an object pointed by a reference and do pointer arithmetics on it as in <code>&amp;obj + 5</code>).</li>
<li>References cannot be stuffed into an array, whereas pointers can be</li>
</ul>
<p>You can have pointers to pointers to pointers offering extra levels of indirection. Whereas references only offer one level of indirection.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> x = <span class="dv">0</span>;
<span class="dt">int</span> y = <span class="dv">0</span>;
<span class="dt">int</span> *p = &amp;x;
<span class="dt">int</span> *q = &amp;y;
<span class="dt">int</span> **pp = &amp;p;
pp = &amp;q;<span class="co">//*pp = q</span>
**pp = <span class="dv">4</span>;
assert(y == <span class="dv">4</span>);
assert(x == <span class="dv">0</span>);</code></pre></div>
<p>A pointer is a variable that holds a memory address. Regardless of how a reference is implemented, a reference has the same memory address as the item it references.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> i = <span class="dv">2</span>, *pi = &amp;i, &amp;ri = i;
printf( <span class="st">&quot;%p, %p, %p, %p</span><span class="ch">\n</span><span class="st">&quot;</span>, &amp;i, pi, &amp;ri, &amp;pi );
<span class="co">// 0x7fff039457c4, 0x7fff039457c4, 0x7fff039457c4, 0x7fff039457c8</span>

<span class="co">// &amp;&amp;ri --&gt; error: label &#8216;ri&#8217; used but not defined</span></code></pre></div>
<p>Const references can be bound to temporaries. Pointers cannot (not without some indirection):</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> &amp;x = <span class="dt">int</span>(<span class="dv">12</span>); <span class="co">//legal C++</span>
<span class="dt">int</span> *y = &amp;<span class="dt">int</span>(<span class="dv">12</span>); <span class="co">//illegal to dereference a temporary.</span></code></pre></div>
<p>This makes <code>const&amp;</code> safer for use in argument lists and so forth.</p>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in">What are the differences between a pointer variable and a reference variable in C++? - Stack Overflow</a></li>
<li><a href="http://yosefk.com/c++fqa/ref.html">C++ FQA Lite: References</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>What is the difference between <code>const int*</code>, <code>const int * const</code>, and <code>int const *</code>? <code class="fold">@</code></dt>
<dd><p>Read it backwards (as driven by <strong>Clockwise/Spiral Rule</strong>)&#8230;</p>
<ul>
<li><code>int*</code> - pointer to int</li>
<li><code>int const *</code> - pointer to const int</li>
<li><code>int * const</code> - const pointer to int</li>
<li><code>int const * const</code> - const pointer to const int</li>
</ul>
<p>Now the first const can be on either side of the type so:</p>
<ul>
<li><code>const int *</code> == <code>int const *</code></li>
<li><code>const int * const</code> == <code>int const * const</code></li>
</ul>
<p>If you want to go really crazy you can do things like this:</p>
<ul>
<li><code>int **</code> - pointer to pointer to int</li>
<li><code>int ** const</code> - a const pointer to a pointer to an int</li>
<li><code>int * const *</code> - a pointer to a const pointer to an int</li>
<li><strong><code>int const **</code></strong> - a pointer to a pointer to a const int &#65288;&#36825;&#20010;&#26377;&#28857;&#23481;&#26131;&#24324;&#38169;&#65289;</li>
<li><code>int * const * const</code> - a const pointer to a const pointer to an int &#8230;</li>
</ul>
<p>And to make sure we are clear on the meaning of const</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span>* foo;         <span class="co">// &#19981;&#33021;&#25913;&#21464;&#25351;&#21521;&#20301;&#32622;&#30340;&#20869;&#23481;</span>
<span class="dt">int</span> *<span class="dt">const</span> bar = &amp;i;    <span class="co">// &#21482;&#33021;&#25351;&#21521; i&#65292;&#19981;&#33021; re-assign &#20102;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// pc &#25351;&#21521;&#19968;&#20010; const char&#65292;&#25152;&#20197;&#19981;&#33021;&#20462;&#25913; buf</span>
<span class="dt">const</span> <span class="dt">char</span> *pc = buf;
<span class="co">// pc &#25351;&#21521; buf2&#65292;&#20381;&#26087;&#19981;&#33021;&#20462;&#25913;&#65292;&#22240;&#20026;&#19981;&#31649; pc &#25351;&#21521;&#21738;&#20799;&#65292;&#23427;&#37117;&#19981;&#33021;&#20462;&#25913;&#23427;&#25152;&#25351;&#30340;&#23545;&#35937;</span>
pc = buf2;</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/1143262/what-is-the-difference-between-const-int-const-int-const-and-int-const">c++ - What is the difference between <code>const int*</code>, <code>const int * const</code>, and <code>int const *</code>? - Stack Overflow</a></li>
<li><a href="http://c-faq.com/decl/spiral.anderson.html">Clockwise/Spiral Rule</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>What are rvalues, lvalues, xvalues, glvalues, and prvalues? <code class="fold">@</code></dt>
<dd><pre><code>            expression
             /    \
            /      \
           /        \
       glvalue     rvalue
       /    \      /    \
      /      \    /      \
     /        \  /        \
  lvalue     xvalue     prvalue

            ______ ______
           /      X      \
          /      / \      \
         |   l  | x |  pr  |
          \      \ /      /
           \______X______/
               gl    r
</code></pre>
<p>In C++03, an expression is either an rvalue or an lvalue.</p>
<p>In C++11, an expression can be an:</p>
<ul>
<li>rvalue = prvalue - xvalue</li>
<li>glvalue = lvalue + xvalue</li>
</ul>
<p>Two categories have become five categories. What are these new categories of expressions? How do these new categories relate to the existing rvalue and lvalue categories? Are the rvalue and lvalue categories in C++0x the same as they are in C++03? Why are these new categories needed? Are the WG21 gods just trying to confuse us mere mortals?</p>
<ul>
<li><p>An lvalue (so-called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function or an object.</p>
<p>Example: If E is an expression of pointer type, then *E is an lvalue expression referring to the object or function to which E points. As another example, <strong>the result of calling a function whose return type is an lvalue reference is an lvalue.</strong></p></li>
<li><p>An xvalue (<strong>an &#8220;eXpiring&#8221; value</strong>) also refers to an object, usually near the end of its lifetime (so that its resources may be moved, for example). An xvalue is the result of certain kinds of expressions involving rvalue references.</p>
<p>Example: The result of calling a function whose return type is an rvalue reference is an xvalue.</p></li>
<li><p>A glvalue (&#8220;generalized&#8221; lvalue) is an lvalue or an xvalue.</p></li>
<li><p>An rvalue (so-called, historically, because rvalues could appear on the right-hand side of an assignment expression) is an xvalue, a <strong>temporary object</strong> or subobject thereof&#65288;&#20854;&#20013;&#30340;&#65289;, or a value that is not associated with an object.</p></li>
<li><p>A prvalue (&#8220;pure&#8221; rvalue) is an rvalue that is not an xvalue.</p>
<p>Example: The result of calling a function whose return type is not a reference is a prvalue</p></li>
</ul>
<p>Examples with functions:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>   prvalue();
<span class="dt">int</span>&amp;  lvalue();
<span class="dt">int</span>&amp;&amp; xvalue();</code></pre></div>
<p>But also don&#8217;t forget that named rvalue references are lvalues:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> foo(<span class="dt">int</span>&amp;&amp; t) {
  <span class="co">// t is initialized with an rvalue expression</span>
  <span class="co">// but is actually an lvalue expression itself</span>
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues">c++ - What are rvalues, lvalues, xvalues, glvalues, and prvalues? - Stack Overflow</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf">n3055.pdf</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/value_category" class="heart">Value categories - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Iterator invalidation rules <code class="fold">@</code></dt>
<dd><p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/6438086/iterator-invalidation-rules">c++ - Iterator invalidation rules - Stack Overflow</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Split a string in C++? <code class="fold">@</code></dt>
<dd><p>What&#8217;s the most elegant way to split a string in C++? The string can be assumed to be composed of words separated by whitespace.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;sstream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main()
{
    string s(<span class="st">&quot;Somewhere down the road&quot;</span>);
    istringstream iss(s);

    <span class="kw">do</span> {
        string sub;
        iss &gt;&gt; sub;
        cout &lt;&lt; <span class="st">&quot;Substring: &quot;</span> &lt;&lt; sub &lt;&lt; endl;
    } <span class="kw">while</span> (iss);
}</code></pre></div>
<p>Dude&#8230; <strong>Elegance is just a fancy way to say &#8220;efficiency-that-looks-pretty&#8221;</strong> in my book. Don&#8217;t shy away from using C functions and quick methods to accomplish anything just because it is not contained within a template ;)</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;sstream&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>

<span class="dt">int</span> main() {
    <span class="kw">using</span> <span class="kw">namespace</span> std;
    string sentence = <span class="st">&quot;And I feel fine...&quot;</span>;

    {
        istringstream iss(sentence);
        copy( istream_iterator&lt;string&gt;(iss),    <span class="co">// istream_iterator</span>
              istream_iterator&lt;string&gt;(),       <span class="co">// &#26080;&#21442;&#25968;&#30340;&#26500;&#36896;&#65292;&#36820;&#22238;&#19968;&#20010;&#20195;&#34920; eof &#30340; iter</span>
              ostream_iterator&lt;string&gt;(cout, <span class="st">&quot; | &quot;</span>));
        cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    {
        istringstream iss(sentence);            <span class="co">// &#36825;&#35821;&#27861;&#20063;&#26159;&#31070;&#22855;</span>
        vector&lt;string&gt; tokens{istream_iterator&lt;string&gt;{iss},
                              istream_iterator&lt;string&gt;{}};
        <span class="kw">for</span>( <span class="dt">const</span> string &amp;s : tokens ) {
            cout &lt;&lt; <span class="st">&quot;(&quot;</span> &lt;&lt; s &lt;&lt; <span class="st">&quot;) &quot;</span>;
        }
        cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    {
        istringstream iss(sentence);
        vector&lt;string&gt; tokens;                  <span class="co">// &#29992; back_inserter &#30340;&#26102;&#20505;&#65292;&#19981;&#35201;&#20808;&#35843; size</span>
        copy( istream_iterator&lt;string&gt;(iss),
              istream_iterator&lt;string&gt;(),
              back_inserter(tokens) );          <span class="co">// &#29992; copy &#21040; iter &#30340;&#26102;&#20505;&#65292;&#35201;&#35843; size</span>
        <span class="kw">for</span>( <span class="dt">const</span> string &amp;s : tokens ) {
            cout &lt;&lt; <span class="st">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="st">&quot;] &quot;</span>;
        }
        cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
}</code></pre></div>
<p>output:</p>
<pre><code>And | I | feel | fine... |
(And) (I) (feel) (fine...)
[And] [I] [feel] [fine...]</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;sstream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">void</span> split(<span class="dt">const</span> string &amp;s, <span class="dt">char</span> delim, vector&lt;string&gt; &amp;elems) {
    stringstream ss(s);
    string item;
    <span class="kw">while</span> (getline(ss, item, delim)) {
        elems.push_back(item);
    }
}


vector&lt;string&gt; split(<span class="dt">const</span> string &amp;s, <span class="dt">char</span> delim) {
    vector&lt;string&gt; elems;
    split(s, delim, elems);
    <span class="kw">return</span> elems;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;boost/algorithm/string.hpp&gt;</span>
std::vector&lt;std::string&gt; strs;
boost::split(strs, <span class="st">&quot;string to split&quot;</span>, boost::is_any_of(<span class="st">&quot;</span><span class="ch">\t</span><span class="st"> &quot;</span>));</code></pre></div>
<dl>
<dt>strtok <code class="fold">@</code></dt>
<dd><pre><code>#include &lt;string.h&gt;
char *strtok(   char *str, const char *delim );
char *strtok_r( char *str, const char *delim, char **saveptr );</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
    <span class="dt">char</span> *str1, *str2, *token, *subtoken;
    <span class="dt">char</span> *saveptr1, *saveptr2;
    <span class="dt">int</span> j;

    <span class="kw">if</span> (argc != <span class="dv">4</span>) {
        fprintf(stderr, <span class="st">&quot;Usage: </span><span class="ch">%s</span><span class="st"> string delim subdelim</span><span class="ch">\n</span><span class="st">&quot;</span>,
                argv[<span class="dv">0</span>]);
        exit(EXIT_FAILURE);
    }

    <span class="kw">for</span> (j = <span class="dv">1</span>, str1 = argv[<span class="dv">1</span>]; ; j++, str1 = NULL) {
        token = strtok_r(str1, argv[<span class="dv">2</span>], &amp;saveptr1);
        <span class="kw">if</span> (token == NULL)
            <span class="kw">break</span>;
        printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">: </span><span class="ch">%s\n</span><span class="st">&quot;</span>, j, token);

        <span class="kw">for</span> (str2 = token; ; str2 = NULL) {
            subtoken = strtok_r(str2, argv[<span class="dv">3</span>], &amp;saveptr2);
            <span class="kw">if</span> (subtoken == NULL)
                <span class="kw">break</span>;
            printf(<span class="st">&quot; --&gt; </span><span class="ch">%s\n</span><span class="st">&quot;</span>, subtoken);
        }
    }

    exit(EXIT_SUCCESS);
}</code></pre></div>
<p>&#25928;&#26524;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">./a.out</span> <span class="st">&#39;a/bbb///cc;xxx:yyy:&#39;</span> <span class="st">&#39;:;&#39;</span> <span class="st">&#39;/&#39;</span>
       <span class="kw">1</span>: a/bbb///cc
                <span class="kw">--&gt;</span> a
                <span class="kw">--&gt;</span> bbb
                <span class="kw">--&gt;</span> cc
       <span class="kw">2</span>: xxx
                <span class="kw">--&gt;</span> xxx
       <span class="kw">3</span>: yyy
                <span class="kw">--&gt;</span> yyy</code></pre></div>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/236129/split-a-string-in-c">Split a string in C++? - Stack Overflow</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>What does the explicit keyword in C++ mean? &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#36825;&#20010;&#20851;&#38190;&#35789;&#25351;&#20986;&#20102; C++ &#30340;&#34507;&#30140;&#20043;&#22788;&#20043;&#19968;&#65288;&#35841;&#35753;&#20320;&#20860;&#23481; C &#30340; implicit conversion &#30340;&#65281;&#65311;&#65289;&#12290;</p>
<p>In C++, the compiler is allowed to make one implicit conversion to resolve the parameters to a function. What this means is that the compiler can use constructors callable with a single parameter to convert from one type to another in order to get the right type for a parameter. Here&#8217;s an example class with a constructor that can be used for implicit conversions:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Foo
{
<span class="kw">public</span>:
  <span class="co">// single parameter constructor, can be used as an implicit conversion</span>
  Foo (<span class="dt">int</span> foo) : m_foo (foo)
  {
  }

  <span class="dt">int</span> GetFoo () { <span class="kw">return</span> m_foo; }

<span class="kw">private</span>:
  <span class="dt">int</span> m_foo;
};</code></pre></div>
<p>Here&#8217;s a simple function that takes a Foo object:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> DoBar (Foo foo)
{
  <span class="dt">int</span> i = foo.GetFoo ();
}</code></pre></div>
<p>and here&#8217;s where the DoBar function is called.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main ()
{
  DoBar (<span class="dv">42</span>);
}</code></pre></div>
<p>The argument is not a Foo object, but an int. However, there exists a constructor for Foo that takes an int so this constructor can be used to convert the parameter to the correct type.</p>
<p>The compiler is allowed to do this once for each parameter.</p>
<p>Prefixing the explicit keyword to the constructor prevents the compiler from using that constructor for implicit conversions. Adding it to the above class will create a compiler error at the function call DoBar (42). It is now necessary to call for conversion explicitly with DoBar (Foo (42))</p>
<p>The reason you might want to do this is to avoid accidental construction that can hide bugs. Contrived example:</p>
<blockquote>
<p>You have a MyString(int size) class with a constructor that constructs a string of the given size. You have a function print(const MyString&amp;), and you call it with print(3). You expect it to print &#8220;3&#8221;, but it prints an empty string of length 3 instead.</p>
</blockquote>
<p>nice write up, you might want to mention multi-arg ctors with default params can also act as single arg ctor, e.g., <code>Object( const char* name=NULL, int otype=0)</code>.</p>
<p>I think it should also be mentioned that one should consider making single argument constructors explicit initially (more or less automatically), and removing the explicit keyword only when the implicit conversion is wanted by design. I think contructors should be explicit by default with an &#8216;implicit&#8217; keyword to enable them to work as implicit conversions. But that&#8217;s not how it is. &#8211; Michael Burr Aug 26 &#8217;09 at 17:47</p>
<p>Just an FYI that when calling &#8220;print(3)&#8221; in your example, the function needs to be &#8220;print(const MyString &amp;&#8221;). The &#8220;const&#8221; is mandatory here because 3 is converted to a temporary &#8220;MyString&#8221; object and you can&#8217;t bind a temporary to a reference unless it&#8217;s &#8220;const&#8221; (yet another in a long list of C++ gotchas)</p>
<hr />
<p>Suppose you have a class String:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> String {
<span class="kw">public</span>:
    String(<span class="dt">int</span> n); <span class="co">// allocate n bytes to the String object</span>
    String(<span class="dt">const</span> <span class="dt">char</span> *p); <span class="co">// initializes object with char *p</span>
};</code></pre></div>
<p>Now if you try</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">String mystring = <span class="st">&#39;x&#39;</span>;</code></pre></div>
<p>the char &#8216;x&#8217; will be implicitly converted to int and then will call the String(int) constructor. But this is not what the user might have intended. So to prevent such conditions, we shall define the constructor as explicit:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> String {
<span class="kw">public</span>:
    <span class="kw">explicit</span> String (<span class="dt">int</span> n); <span class="co">//allocate n bytes</span>
    String(<span class="dt">const</span> <span class="dt">char</span> *p); <span class="co">// initialize sobject with string p</span>
};</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-in-c-mean">constructor - What does the explicit keyword in C++ mean? - Stack Overflow</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>When should <code>static_cast</code>, <code>dynamic_cast</code>, <code>const_cast</code> and <code>reinterpret_cast</code> be used? <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>static_cast</dt>
<dd><p><code>static_cast</code> is the first cast you should attempt to use. It does things like implicit conversions between types (such as int to <code>float</code>, or pointer to <code>void*</code>), and it can also call explicit conversion functions (or implicit ones). In many cases, explicitly stating static_cast isn&#8217;t necessary, but it&#8217;s important to note that the <code>T(something)</code> syntax is equivalent to <code>(T)something</code> and should be avoided (more on that later). A <code>T(something, something_else)</code> is safe, however, and guaranteed to call the constructor.</p>
<p><code>static_cast</code> can also cast through inheritance hierarchies. It is unnecessary when casting upwards (towards a base class), but when casting downwards it can be used as long as it doesn&#8217;t cast through virtual inheritance. It does not do checking, however, and it is undefined behavior to <code>static_cast</code> down a hierarchy to a type that isn&#8217;t actually the type of the object.</p>
</dd>
</dl></li>
<li><dl>
<dt>const_cast</dt>
<dd><p><code>const_cast</code> can be used to remove or add const to a variable; no other C++ cast is capable of removing it (not even <code>reinterpret_cast</code>). It is important to note that modifying a formerly const value is only undefined if the original variable is const; if you use it to take the const off a reference to something that wasn&#8217;t declared with const, it is safe. This can be useful when overloading member functions based on const, for instance. It can also be used to add const to an object, such as to call a member function overload.</p>
<p><code>const_cast</code> also works similarly on volatile, though that&#8217;s less common.</p>
</dd>
</dl></li>
<li><dl>
<dt>dynamic_cast</dt>
<dd><p>dynamic_cast is almost exclusively used for handling polymorphism. You can cast a pointer or reference to any polymorphic type to any other class type (a polymorphic type has at least one virtual function, declared or inherited). You can use it for more than just casting downwards &#8211; you can cast sideways or even up another chain. The dynamic_cast will seek out the desired object and return it if possible. If it can&#8217;t, it will return nullptr in the case of a pointer, or throw std::bad_cast in the case of a reference.</p>
<p>dynamic_cast has some limitations, though. It doesn&#8217;t work if there are multiple objects of the same type in the inheritance hierarchy (the so-called &#8216;dreaded diamond&#8217;) and you aren&#8217;t using virtual inheritance. It also can only go through public inheritance - it will always fail to travel through protected or private inheritance. This is rarely an issue, however, as such forms of inheritance are rare.</p>
</dd>
</dl></li>
<li><dl>
<dt>reinterpert_cast</dt>
<dd><p>reinterpret_cast is the most dangerous cast, and <strong>should be used very sparingly</strong>. It turns one type directly into another - such as casting the value from one pointer to another, or storing a pointer in an int, or all sorts of other nasty things. Largely, the only guarantee you get with reinterpret_cast is that normally if you cast the result back to the original type, you will get the exact same value (but not if the intermediate type is smaller than the original type). There are a number of conversions that reinterpret_cast cannot do, too. It&#8217;s used primarily for particularly weird conversions and bit manipulations, like turning a raw data stream into actual data, or storing data in the low bits of an aligned pointer.</p>
</dd>
</dl></li>
<li><dl>
<dt>C casts</dt>
<dd><p>C casts are casts using (type)object or type(object). A C-style cast is defined as the first of the following which succeeds:</p>
<ul>
<li>const_cast</li>
<li>static_cast (though ignoring access restrictions)</li>
<li>static_cast (see above), then const_cast</li>
<li>reinterpret_cast</li>
<li>reinterpret_cast, then const_cast</li>
</ul>
<p>It can therefore be used as a replacement for other casts in some instances, but can be extremely dangerous because of the ability to devolve into a reinterpret_cast, and the latter should be preferred when explicit casting is needed, unless you are sure static_cast will succeed or reinterpret_cast will fail. Even then, consider the longer, more explicit option.</p>
<p>C-style casts also ignore access control when performing a static_cast, which means that they have the ability to perform an operation that no other cast can. This is mostly a kludge, though, and in my mind is just another reason to avoid C-style casts.</p>
</dd>
</dl></li>
</ul>
<p>so, the rules are:</p>
<ul>
<li>Use dynamic_cast for converting pointers/references within an inheritance hierarchy.</li>
<li>Use static_cast for ordinary type conversions.</li>
<li>Use reinterpret_cast for low-level reinterpreting of bit patterns. Use with extreme caution.</li>
<li>Use const_cast for casting away const/volatile. Avoid this unless you are stuck using a const-incorrect API.</li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used">c++ - When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used? - Stack Overflow</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Function overloading &amp; Operator overloading <code class="fold">@</code></dt>
<dd><p>&#25105;&#35760;&#24471; C++ &#37325;&#36733;&#20989;&#25968;&#30340;&#21305;&#37197;&#20998;&#22235;&#20010;&#20248;&#20808;&#32423;&#65306;</p>
<blockquote>
<p>&#30452;&#25509;&#21305;&#37197; &gt; &#31867;&#22411;&#25552;&#21319;&#36716;&#25442; (float-&gt;double &#36825;&#31181;) &gt; &#38544;&#24335;&#36716;&#25442; &gt; &#31867;&#31867;&#22411;&#36716;&#25442;&#12290;</p>
</blockquote>
<p>&#21333;&#20010;&#23454;&#21442;&#35843;&#29992;&#30340;&#38750; explicit &#26500;&#36896;&#20989;&#25968;&#65292;&#20915;&#23450;&#19968;&#20010;&#31867;&#31867;&#22411;&#36716;&#25442;&#12290;&#25351;&#38024;&#36716;&#25442;&#20026; bool &#26159;&#38544;&#24335;&#36716;&#25442;&#12290;</p>
<p>&#31616;&#21270;&#19968;&#19979;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> foo(<span class="dt">const</span> string&amp; name);
<span class="dt">void</span> foo(<span class="dt">bool</span> on); <span class="co">// &#20250;&#35843;&#29992;&#36825;&#20010;</span>

foo(<span class="st">&quot;C++&quot;</span>);  <span class="co">// &#35843;&#29992;&#21738;&#20010;&#65311;&#36825;&#20010;&#19981;&#38590;&#25512;&#26029;&#21543;&#65311;</span></code></pre></div>
<p>&#32780; nullptr &#30340;&#20986;&#29616;&#32972;&#26223;&#65292;&#20854;&#23454;&#26159;&#24456;&#31616;&#21333;&#30340;&#65292;C++ &#21746;&#23398;&#19978;&#26469;&#35828;&#23601;&#26159; C++ &#20043;&#29238;&#19968;&#30452;&#23545; null pointer &#27809;&#26377;&#19968;&#20010;&#27491;&#24335;&#30340;&#34920;&#31034;&#24863;&#21040;&#38750;&#24120;&#19981;&#28385;&#65292;&#32780;&#26356;&#24037;&#31243;&#30340;&#26469;&#35828;&#65292;&#23601;&#26159;&#20851;&#20110;&#37325;&#36733;&#36825;&#20010;&#38382;&#39064;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f(<span class="dt">void</span>*) { }
<span class="dt">void</span> f(<span class="dt">int</span>) { }

<span class="dt">int</span> main() {
    f(<span class="dv">0</span>);                   <span class="co">// what function will be called?.... WHAT THE FUCK...</span>
}</code></pre></div>
<p>&#32780;&#24341;&#20837;&#20102; nullptr&#65292;&#36825;&#20010;&#38382;&#39064;&#23601;&#24471;&#21040;&#20102;&#30495;&#27491;&#35299;&#20915;&#65292;&#20250;&#24456;&#39034;&#21033;&#30340;&#35843;&#21040; <code>void f(void*)</code> &#36825;&#20010;&#29256;&#26412;&#12290;</p>
<p>&#22909;&#20102;&#65292;&#30495;&#30340;&#20197;&#20026; nullptr &#23601;&#36825;&#26679;&#20102;&#20040;? &#25105;&#21069;&#38754;&#35828;&#36807;&#20102; nullptr &#26159;&#26377;&#31867;&#22411;&#30340;&#65292;&#21483;&#20570; nullptr_t&#65292;&#36825;&#32473;&#25105;&#20204;&#32534;&#35793;&#22120;&#23454;&#29616;&#24102;&#26469;&#20102;&#35832;&#22810;&#35201;&#32771;&#34385;&#30340;&#19996;&#35199;&#65292;&#19981;&#24184;&#30340;&#35805;&#35753;&#25105;&#20204;&#26469;&#20030;&#28857;&#20799;&#22855;&#33897;&#20363;&#23376;&#21543;&#65281;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">union</span> U {
    <span class="dt">long</span> i;
    nullptr_t t;
};

<span class="dt">int</span> main() {
    U u;
    u.i = <span class="dv">3</span>;
    printf(<span class="st">&quot;</span><span class="ch">%ld\n</span><span class="st">&quot;</span>,(<span class="dt">long</span>)u.t); <span class="co">// What it is? 0 or 3?</span>
}</code></pre></div>
<p>&#37027;&#20040;&#36825;&#26159;&#24212;&#35813;&#31526;&#21512; union &#35821;&#24847;&#36824;&#26159; nullptr &#30340;&#35821;&#24847;&#21602;&#65311;&#36825;&#22312;&#26631;&#20934;&#20013;&#26159;&#27809;&#26377;&#35828;&#30340;&#65292;&#25105;&#20204;&#20063;&#20026;&#27492;&#20105;&#35770;&#20102;&#38750;&#24120;&#20037;&#12290;&#24403;&#28982;&#22312;&#25105;&#20204;&#32534;&#35793;&#22120;&#30340;&#23454;&#29616;&#36824;&#26159;&#20445;&#25345;&#20102; nullptr &#30340;&#35821;&#24847;&#65292;&#32467;&#26524;&#26159; 0&#12290;</p>
<p>&#32780; nullptr &#26377;&#31867;&#22411;&#21518;&#65292;&#36824;&#33021;&#20570;&#20160;&#20040;&#21602;&#65311;&#37027;&#24403;&#28982;&#23601;&#26159;&#21487;&#20197;&#25429;&#33719;&#24322;&#24120;&#20102;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main() {
  <span class="kw">try</span> {
    <span class="kw">throw</span> <span class="kw">nullptr</span>;
  }
  <span class="kw">catch</span>(nullptr_t) {

  }
}</code></pre></div>
<p>&#20320;&#25172;&#19968;&#20010; NULL &#35797;&#35797;&#65311;&#30475;&#20182;&#24212;&#35813;&#29992;&#20160;&#20040;&#25910;&#65292;&#27491;&#26159;&#22240;&#20026;&#27809;&#26377;&#31867;&#22411;&#65292;&#25152;&#20197;&#23601;&#35201;&#29992;&#23427;&#30340;&#26412;&#36136;&#31867;&#22411;&#65292;&#27604;&#22914; long &#20160;&#20040;&#30340;&#26469;&#35828;&#12290;&#20320;&#25172;&#19968;&#20010; 0 &#35797;&#35797;&#65311;&#37027;&#23601;&#20063;&#19981;&#26159;&#25152;&#35859;&#30340;&#31354;&#25351;&#38024;&#31867;&#22411;&#20102;&#65292;&#23601;&#26159;&#35201;&#29992; int &#20160;&#20040;&#30340;&#26469;&#25910;&#20102;&#12290;</p>
<p>&#25152;&#20197;&#65292;&#25512;&#23815; nullptr &#26159;&#26377;&#36947;&#29702;&#30340;&#65292;&#25105;&#20204;&#22312;&#32534;&#35793;&#22120;&#23454;&#29616; nullptr &#30340;&#26102;&#20505;&#32771;&#34385;&#20102;&#38750;&#24120;&#38750;&#24120;&#22810;&#30340;&#32454;&#33410;&#65292;&#36824;&#26377;&#24456;&#22810;&#20320;&#20204;&#21487;&#33021;&#19968;&#30452;&#29992;&#19981;&#21040;&#30340;&#24773;&#20917;&#65292;&#25105;&#20204;&#37117;&#35201;&#29992;&#26469;&#27979;&#35797;&#65292;&#30446;&#30340;&#23601;&#26159;&#20445;&#38556;&#24320;&#21457;&#32773;&#30340;&#20351;&#29992;&#12290;&#20877;&#27425;&#37027;&#21477;&#35805;&#65292;&#22914;&#26524;&#20320;&#30340;&#32534;&#35793;&#22120;&#25903;&#25345; nullptr&#65292;&#35831;&#19968;&#23450;&#20351;&#29992; nullptr&#65281;</p>
<p>&#26368;&#21518;&#20877;&#25199;&#19968;&#28857;&#20799;&#65292;0 &#22312; C++ &#26159;&#24456;&#31070;&#22855;&#30340;&#19996;&#35199;&#12290;&#27604;&#22914;&#32431;&#34394;&#20989;&#25968;&#20026;&#20160;&#20040;&#26159;&#29992; =0 &#26469;&#35774;&#32622;&#30340;&#65292;&#19981;&#30693;&#36947;&#26377;&#27809;&#26377;&#21516;&#23398;&#21435;&#32771;&#34385;&#36807;&#36825;&#20010;&#38382;&#39064;&#27809;&#26377;&#12290;&#22914;&#26524;&#20320;&#28145;&#21051;&#29702;&#35299;&#20102; C++ &#21746;&#23398;&#65292;&#36825;&#24212;&#35813;&#23601;&#26159;&#38750;&#24120;&#31616;&#31572;&#30340;&#38382;&#39064;&#20102;&#12290;&#23398;&#35821;&#35328;&#22043;&#65292;&#19968;&#23450;&#35201;&#23398;&#21040;&#20854;&#21746;&#23398;&#65292;&#20320;&#25165;&#33021;&#30693;&#36947;&#20854;&#20043;&#32654;&#65292;&#20854;&#20043;&#23041;&#21147;&#65292;&#23588;&#20854;&#26159; C++&#12290;(TODO&#65306;&#26597;&#65306;&#20026;&#20160;&#20040;&#29992; =0&#65311;)</p>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Function_overloading">Function overloading - Wikipedia, the free encyclopedia</a></li>
<li><a href="http://stackoverflow.com/questions/4421706/operator-overloading">c++ - Operator overloading - Stack Overflow</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/overload_resolution">Overload resolution - cppreference.com</a></li>
<li><a href="http://stackoverflow.com/questions/72010/c-overload-resolution">function - C++ overload resolution - Stack Overflow</a></li>
<li><a href="http://zh.cppreference.com/w/cpp/language/overload_resolution">&#37325;&#36733;&#20915;&#35758; - cppreference.com</a></li>
<li><a href="http://blog.csdn.net/zhouguoqionghai/article/details/51703385">C++ &#37325;&#36733;&#20915;&#35758;overload resolution &#19982; SFINAE - zhouguoqionghai&#30340;&#21338;&#23458; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
<li><a href="https://www.zhihu.com/question/27932618">C++ &#38544;&#24335;&#31867;&#22411;&#36716;&#25442;&#37325;&#36733;&#20915;&#35758;&#30340;&#20855;&#20307;&#20248;&#20808;&#32423;&#26159;&#24590;&#26679;&#30340;&#65311; - &#30693;&#20046;</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#22914;&#20309;&#29702;&#35299; C &#35821;&#35328;&#20851;&#38190;&#23383; restrict&#65311; <code class="fold">@</code></dt>
<dd><dl>
<dt><a href="https://en.wikipedia.org/wiki/Pointer_aliasing">Pointer aliasing - Wikipedia, the free encyclopedia</a> <code class="foldable">@</code></dt>
<dd><p>In computer programming, aliasing refers to the situation where the <strong>same memory location can be accessed using different names</strong>.</p>
<p>In C99, the <code>restrict</code> keyword was added, which specifies that a pointer argument does not alias any other pointer argument.</p>
</dd>
</dl>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> foo(<span class="dt">int</span> *a, <span class="dt">int</span> *b)
{
    *a = <span class="dv">5</span>;
    *b = <span class="dv">6</span>;
    <span class="kw">return</span> *a + *b; <span class="co">// &#19981;&#19968;&#23450;&#26159; 11&#65281;</span>
}</code></pre></div>
<p>&#22914;&#26524; a &#21644; b &#37117;&#25351;&#21521;&#21516;&#19968;&#25968;&#25454;&#65292;<code>*b = 6</code> &#20250;&#23548;&#33268; <code>*a = 6</code>&#65292;&#36820;&#22238; 12&#12290;&#25152;&#20197;&#32534;&#35793;&#22120;&#22312;&#20570; <code>*a + *b</code> &#30340;&#26102;&#20505;&#65292;&#38656;&#35201;&#37325;&#26032;&#35835;&#21462; <code>*a</code> &#25351;&#21521;&#30340;&#25968;&#25454;</p>
<p>&#22914;&#26524;&#25105;&#20204;&#30830;&#20445;&#20004;&#20010;&#25351;&#38024;&#19981;&#25351;&#21521;&#21516;&#19968;&#25968;&#25454;&#65292;&#23601;&#21487;&#20197;&#29992; restrict &#20462;&#39280;&#25351;&#38024;&#31867;&#22411;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> rfoo(<span class="dt">int</span> *restrict a, <span class="dt">int</span> *restrict b)
{
    *a = <span class="dv">5</span>;
    *b = <span class="dv">6</span>;
    <span class="kw">return</span> *a + *b;
}</code></pre></div>
<p>&#20294;&#22914;&#26524;&#29992;&#20102; restrict &#21435;&#20462;&#39280;&#20004;&#20010;&#25351;&#38024;&#65292;&#32780;&#23427;&#20204;&#22312;&#20316;&#29992;&#22495;&#20869;&#21448;&#25351;&#21521;&#21516;&#19968;&#22320;&#22336;&#65292;&#37027;&#20040;&#26159;&#26410;&#23450;&#20041;&#34892;&#20026;&#12290;</p>
<p>&#24635;&#25324;&#32780;&#35328;&#65292;<strong>restrict &#26159;&#20026;&#20102;&#21578;&#35785;&#32534;&#35793;&#22120;&#39069;&#22806;&#20449;&#24687;&#65288;&#20004;&#20010;&#25351;&#38024;&#19981;&#25351;&#21521;&#21516;&#19968;&#25968;&#25454;&#65289;&#65292;&#20174;&#32780;&#29983;&#25104;&#26356;&#20248;&#21270;&#30340;&#26426;&#22120;&#30721;</strong>&#12290;&#27880;&#24847;&#65292;&#32534;&#35793;&#22120;&#26159;&#26080;&#27861;&#33258;&#34892;&#22312;&#32534;&#35793;&#26399;&#26816;&#27979;&#20004;&#20010;&#25351;&#38024;&#26159;&#21542; alias&#12290;&#22914;&#20351;&#29992; restrict&#65292;&#31243;&#24207;&#21592;&#20063;&#35201;&#36981;&#23432;&#22865;&#32422;&#25165;&#33021;&#24471;&#20986;&#27491;&#30830;&#30340;&#20195;&#30721;&#65288;&#25351;&#38024;&#19981;&#33021;&#25351;&#21521;&#30456;&#21516;&#25968;&#25454;&#65289;&#12290;</p>
<p>&#32534;&#35793;&#22120;&#23601;&#21487;&#20197;&#26681;&#25454;&#36825;&#20010;&#20449;&#24687;&#65292;&#20570;&#20986;&#20248;&#21270;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="https://www.zhihu.com/question/41653775">&#22914;&#20309;&#29702;&#35299; C &#35821;&#35328;&#20851;&#38190;&#23383; restrict&#65311; - &#30693;&#20046;</a></li>
<li><a href="http://en.cppreference.com/w/c/language/restrict">restrict type qualifier - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#24369;&#31867;&#22411;&#12289;&#24378;&#31867;&#22411;&#12289;&#21160;&#24577;&#31867;&#22411;&#12289;&#38745;&#24577;&#31867;&#22411;&#35821;&#35328;&#30340;&#21306;&#21035;&#26159;&#20160;&#20040;&#65311; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#20808;&#23450;&#20041;&#19968;&#20123;&#22522;&#30784;&#27010;&#24565;</p>
<p>Program Errors</p>
<ul>
<li>trapped errors&#12290;&#23548;&#33268;&#31243;&#24207;&#32456;&#27490;&#25191;&#34892;&#65292;&#22914;&#38500; 0&#65292;Java &#20013;&#25968;&#32452;&#36234;&#30028;&#35775;&#38382;</li>
<li>untrapped errors&#12290; &#20986;&#38169;&#21518;&#32487;&#32493;&#25191;&#34892;&#65292;&#20294;&#21487;&#33021;&#20986;&#29616;&#20219;&#24847;&#34892;&#20026;&#12290;&#22914; C &#37324;&#30340;&#32531;&#20914;&#21306;&#28322;&#20986;&#12289;Jump &#21040;&#38169;&#35823;&#22320;&#22336;</li>
</ul>
<p>Forbidden Behaviours</p>
<ul>
<li>&#35821;&#35328;&#35774;&#35745;&#26102;&#65292;&#21487;&#20197;&#23450;&#20041;&#19968;&#32452;forbidden behaviors. &#23427;&#24517;&#39035;&#21253;&#25324;&#25152;&#26377;untrapped errors, &#20294;&#21487;&#33021;&#21253;&#21547;trapped errors.</li>
</ul>
<p>Well behaved&#12289;ill behaved</p>
<ul>
<li>well behaved: &#22914;&#26524;&#31243;&#24207;&#25191;&#34892;&#19981;&#21487;&#33021;&#20986;&#29616;forbidden behaviors, &#21017;&#20026;well behaved&#12290;</li>
<li>ill behaved: &#21542;&#21017;&#20026;ill behaved&#8230;</li>
</ul>
<p>&#26377;&#20102;&#19978;&#38754;&#30340;&#27010;&#24565;&#65292;&#20877;&#35752;&#35770;&#24378;&#12289;&#24369;&#31867;&#22411;&#65292;&#38745;&#24577;&#12289;&#21160;&#24577;&#31867;&#22411;</p>
<p>&#24378;&#12289;&#24369;&#31867;&#22411;</p>
<ul>
<li>&#24378;&#31867;&#22411;strongly typed: &#22914;&#26524;&#19968;&#31181;&#35821;&#35328;&#30340;&#25152;&#26377;&#31243;&#24207;&#37117;&#26159;well behaved&#8212;&#8212;&#21363;&#19981;&#21487;&#33021;&#20986;&#29616;forbidden behaviors&#65292;&#21017;&#35813;&#35821;&#35328;&#20026;strongly typed&#12290;</li>
<li>&#24369;&#31867;&#22411;weakly typed: &#21542;&#21017;&#20026;weakly typed&#12290;&#27604;&#22914;C&#35821;&#35328;&#30340;&#32531;&#20914;&#21306;&#28322;&#20986;&#65292;&#23646;&#20110;trapped errors&#65292;&#21363;&#23646;&#20110;forbidden behaviors..&#25925;C&#26159;&#24369;&#31867;&#22411;</li>
</ul>
<p>&#21069;&#38754;&#30340;&#20154;&#20063;&#35828;&#20102;&#65292;&#24369;&#31867;&#22411;&#35821;&#35328;&#65292;&#31867;&#22411;&#26816;&#26597;&#26356;&#19981;&#20005;&#26684;&#65292;&#22914;&#20559;&#21521;&#20110;&#23481;&#24525;&#38544;&#24335;&#31867;&#22411;&#36716;&#25442;&#12290;&#35692;&#22914;&#35828;C &#35821;&#35328;&#30340;int&#21487;&#20197;&#21464;&#25104;double&#12290; &#36825;&#26679;&#30340;&#32467;&#26524;&#26159;&#65306;&#23481;&#26131;&#20135;&#29983;forbidden behaviours&#65292;&#25152;&#20197;&#26159;&#24369;&#31867;&#22411;&#30340;</p>
<p>&#21160;&#24577;&#12289;&#38745;&#24577;&#31867;&#22411;</p>
<ul>
<li>&#38745;&#24577;&#31867;&#22411; statically: &#22914;&#26524;&#22312;&#32534;&#35793;&#26102;&#25298;&#32477;ill behaved&#31243;&#24207;&#65292;&#21017;&#26159;statically typed;</li>
<li>&#21160;&#24577;&#31867;&#22411;dynamiclly: &#22914;&#26524;&#22312;&#36816;&#34892;&#26102;&#25298;&#32477;ill behaviors, &#21017;&#26159;dynamiclly typed&#12290;</li>
</ul>
<p>&#35823;&#21306;</p>
<ul>
<li>&#22823;&#23478;&#35273;&#24471;C&#35821;&#35328;&#35201;&#20889;int a, int b&#20043;&#31867;&#30340;&#65292;Python&#19981;&#29992;&#20889;(&#21487;&#20197;&#30452;&#25509;&#20889;a, b)&#65292;&#25152;&#20197;C&#26159;&#38745;&#24577;&#65292;Python&#26159;&#21160;&#24577;&#12290;&#36825;&#20040;&#29702;&#35299;&#26159;&#19981;&#22815;&#20934;&#30830;&#30340;&#12290;&#35692;&#22914;Ocaml&#26159;&#38745;&#24577;&#31867;&#22411;&#30340;&#65292;&#20294;&#26159;&#20063;&#21487;&#20197;&#19981;&#29992;&#26126;&#30830;&#22320;&#20889;&#20986;&#26469;&#12290;&#12290;Ocaml&#26159;&#38745;&#24577;&#38544;&#24335;&#31867;&#22411;</li>
</ul>
<p>&#38745;&#24577;&#31867;&#22411;&#21487;&#20197;&#20998;&#20026;&#20004;&#31181;&#65306;</p>
<ul>
<li>&#22914;&#26524;&#31867;&#22411;&#26159;&#35821;&#35328;&#35821;&#27861;&#30340;&#19968;&#37096;&#20998;&#65292;&#22312;&#26159;explicitly typed&#26174;&#24335;&#31867;&#22411;&#65307;</li>
<li>&#22914;&#26524;&#31867;&#22411;&#36890;&#36807;&#32534;&#35793;&#26102;&#25512;&#23548;&#65292;&#26159;implicity typed&#38544;&#24335;&#31867;&#22411;, &#27604;&#22914;ML&#21644;Haskell</li>
</ul>
<p>&#19979;&#38754;&#26159;&#20123;&#20363;&#23376;</p>
<ul>
<li>&#26080;&#31867;&#22411;&#65306; &#27719;&#32534;</li>
<li>&#24369;&#31867;&#22411;&#12289;&#38745;&#24577;&#31867;&#22411; &#65306; C/C++</li>
<li>&#24369;&#31867;&#22411;&#12289;&#21160;&#24577;&#31867;&#22411;&#26816;&#26597;&#65306; Perl/PHP</li>
<li>&#24378;&#31867;&#22411;&#12289;&#38745;&#24577;&#31867;&#22411;&#26816;&#26597; &#65306;Java/C#</li>
<li>&#24378;&#31867;&#22411;&#12289;&#21160;&#24577;&#31867;&#22411;&#26816;&#26597; &#65306;Python, Scheme</li>
<li>&#38745;&#24577;&#26174;&#24335;&#31867;&#22411; &#65306;Java/C</li>
<li>&#38745;&#24577;&#38544;&#24335;&#31867;&#22411; &#65306;Ocaml, Haskell</li>
</ul>
<dl>
<dt>by vczh</dt>
<dd><ul>
<li>&#24378;&#31867;&#22411;&#65306;&#20559;&#21521;&#20110;&#19981;&#23481;&#24525;&#38544;&#24335;&#31867;&#22411;&#36716;&#25442;&#12290;&#35692;&#22914;&#35828;haskell&#30340;int&#23601;&#19981;&#33021;&#21464;&#25104;double</li>
<li>&#24369;&#31867;&#22411;&#65306;&#20559;&#21521;&#20110;&#23481;&#24525;&#38544;&#24335;&#31867;&#22411;&#36716;&#25442;&#12290;&#35692;&#22914;&#35828;C&#35821;&#35328;&#30340;int&#21487;&#20197;&#21464;&#25104;double</li>
<li>&#38745;&#24577;&#31867;&#22411;&#65306;&#32534;&#35793;&#30340;&#26102;&#20505;&#23601;&#30693;&#36947;&#27599;&#19968;&#20010;&#21464;&#37327;&#30340;&#31867;&#22411;&#65292;&#22240;&#20026;&#31867;&#22411;&#38169;&#35823;&#32780;&#19981;&#33021;&#20570;&#30340;&#20107;&#24773;&#26159;&#35821;&#27861;&#38169;&#35823;&#12290;</li>
<li>&#21160;&#24577;&#31867;&#22411;&#65306;&#32534;&#35793;&#30340;&#26102;&#20505;&#19981;&#30693;&#36947;&#27599;&#19968;&#20010;&#21464;&#37327;&#30340;&#31867;&#22411;&#65292;&#22240;&#20026;&#31867;&#22411;&#38169;&#35823;&#32780;&#19981;&#33021;&#20570;&#30340;&#20107;&#24773;&#26159;&#36816;&#34892;&#26102;&#38169;&#35823;&#12290;&#35692;&#22914;&#35828;&#20320;&#19981;&#33021;&#23545;&#19968;&#20010;&#25968;&#23383;a&#20889;a&#24403;&#25968;&#32452;&#29992;&#12290;</li>
</ul>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="https://www.zhihu.com/question/19918532">&#24369;&#31867;&#22411;&#12289;&#24378;&#31867;&#22411;&#12289;&#21160;&#24577;&#31867;&#22411;&#12289;&#38745;&#24577;&#31867;&#22411;&#35821;&#35328;&#30340;&#21306;&#21035;&#26159;&#20160;&#20040;&#65311; - &#30693;&#20046;</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#20960;&#20010;&#30495;&#27491;&#30340;&#24555;&#38382;&#24555;&#31572; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>How can I provide input for my class <code>Fred</code>?</dt>
<dd><p>By adding a friend <code>friend std::istream&amp; operator&gt;&gt; (std::istream&amp; i, Fred&amp; fred);</code>&#65292;&#36825;&#20010;&#23454;&#29616;&#37324;&#65292;&#26368;&#22909;&#29992; <code>i &lt;&lt; fred.print()</code>&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>Should I end my output lines with <code>std::endl</code> or <code>\n</code>?</dt>
<dd><p>The former has the additional side-effect of flushing the output buffer. Therefore, the latter will probably work faster.</p>
<p>&#20004;&#32773;&#25171;&#21360;&#20986;&#26469;&#30340;&#25442;&#34892;&#31526;&#26159;&#19968;&#26679;&#30340;&#65292;&#31995;&#32479;&#30456;&#20851;&#30340;&#12290;endl &#20570;&#30340;&#20107;&#24773;&#35201;&#22810;&#19968;&#28857;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>How does that funky <code>while (std::cin &gt;&gt; foo)</code> syntax work? &#9829;&#65039;</dt>
<dd><p><code>istream</code> has overloaded <strong><code>operator void*</code></strong>. The compiler calls this operator in <strong>boolean contexts</strong> (when it expects a condition, for example), because <code>void*</code> can be converted to a boolean. The operator returns <code>NULL</code> when there&#8217;s nothing left to read, or when a format error occurred previously.</p>
<p>There&#8217;s nothing &#8220;funky&#8221; about it. It is ugly and boring. It&#8217;s also scary because many people think this is what programming is all about - using complicated syntax to do simple things without even getting them right (how do you tell end-of-file conditions from format errors?).</p>
<p>Why is it operator <code>void*</code>, and not operator <code>bool</code>? Apparently because the compiler implicitly converts booleans to numbers in &#8220;numeric contexts&#8221; (such as <code>file1+file2</code>), and we don&#8217;t want that to compile, do we?</p>
<p>But wait, there&#8217;s more! There&#8217;s an actual book out there, called <strong>&#8220;Imperfect C++&#8221;</strong>, arguing that operator <code>void*</code> is not the way to go, either. Because this way, <code>delete file</code> would compile. Surely we don&#8217;t want it to, do we? I mean, the fact that the statement is completely moronic&#65288;<code>[m&#596;'r&#596;nik, m&#601;-]</code> adj. &#20302;&#33021;&#30340;&#65307;&#36831;&#38045;&#30340;&#65289; shouldn&#8217;t matter. Morones have a right to get an equal opportunity in the exciting world of C++ programming; let&#8217;s catch of all their errors at compile time. Evil people spread rumors about the problem being undecidable, but we should keep trying.</p>
</dd>
</dl></li>
<li><dl>
<dt>Why should I use <code>&lt;iostream&gt;</code> instead of the traditional <code>&lt;cstdio&gt;</code>?</dt>
<dd><p>There are four reasons:</p>
<ul>
<li><strong>Increase type safety</strong>: with iostream, the compiler knows the types of the things you print. stdio only figures them out at run time from the format string.</li>
<li><strong>Reduce the number of errors</strong>: with stdio, the types of objects you pass must be consistent with the format string; iostream removes this redundancy - there is no format string, so you can&#8217;t make these errors.</li>
<li><strong>Printing objects of user-defined types</strong>: with iostream, you can overload the operators &lt;&lt; and &gt;&gt; to support new types, and the old code won&#8217;t break. stdio won&#8217;t let you extend the format string syntax, and there seems to be no way to support this kind of thing in a way avoiding conflicts between different extensions.</li>
<li><strong>Printing to streams of user-defined types</strong>: you can implement your own stream classes by deriving from the base classes provided by iostream. FILE* can not be extended because &#8220;it&#8217;s not a real class&#8221;.</li>
</ul>
<p>&#20854;&#23454;&#21069;&#20004;&#28857;&#26681;&#26412;&#27809;&#26377;&#35828;&#26381;&#21147;&#12290;&#21518;&#20004;&#28857;&#21602;&#8230;&#8230;&#34429;&#28982; printf &#19981;&#33021;&#33258;&#23450;&#20041;&#31867;&#22411;&#65288;&#26032;&#30340;&#35832;&#22914; &#8220;%d&#8221; &#20043;&#31867;&#30340;&#26631;&#31614;&#65289;&#65292;&#20294;&#26159;&#20320;&#21487;&#20197;&#33258;&#24049;&#20889;&#19968;&#20010;&#20989;&#25968;&#65292;&#25226;&#31867;&#22411;&#25171;&#21360;&#21040; string &#25110;&#32773; console&#12290;&#28982;&#21518;&#20877;&#29992; <code>std::cout</code> &#36755;&#20986;&#12290;</p>
</dd>
</dl></li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="http://yosefk.com/c++fqa/io.html#fqa-15.14">C++ FQA Lite: Input/output via <iostream> and <cstdio></a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>What is The Rule of Three? <code class="fold">@</code></dt>
<dd><p>&#20854;&#23454;&#23601;&#26159;&#19977;&#20010;&#25171;&#21253;&#22312;&#19968;&#36215;&#30340;&#20989;&#25968;&#65292;&#22914;&#26524;&#20320;&#19981;&#24819;&#34987; C++ &#40664;&#35748;&#30340; value semantics &#25171;&#36133;&#65292;&#20320;&#23601;&#25226;&#20182;&#20204;&#33258;&#24049;&#23454;&#29616;&#19968;&#19979;&#65292;&#32780;&#19981;&#26159;&#29992;&#32534;&#35793;&#22120;&#33258;&#21160;&#25552;&#20379;&#30340;&#12290;</p>
<p><strong>Introduction</strong></p>
<p>C++ treats variables of user-defined types with <strong>value semantics</strong>. This means that objects are implicitly copied in various contexts, and we should understand what &#8220;copying an object&#8221; actually means.</p>
<p>Let us consider a simple example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">person a(<span class="st">&quot;Bjarne Stroustrup&quot;</span>, <span class="dv">60</span>);
person b(a);   <span class="co">// What happens here?</span>
b = a;         <span class="co">// And here?</span></code></pre></div>
<p><strong>Special member functions</strong></p>
<ul>
<li><code>person b(a)</code> -&gt; &#12304;<strong>copy constructor</strong>&#12305;</li>
<li><code>b = a</code> -&gt; &#12304;<strong>copy assignment operator</strong>&#12305;</li>
</ul>
<p>&#22914;&#26524;&#27809;&#26377;&#36825;&#20004;&#20010;&#20989;&#25968;&#65292;&#32534;&#35793;&#22120;&#24110;&#20320;&#33258;&#21160;&#21152;&#19978;&#12290;&#20869;&#23481;&#26159; memberwise copy &#36807;&#21435;&#12290;&#26377;&#26102;&#20505;&#23601; bug &#20102;&#65292;&#27604;&#22914;&#20320;&#30340; name &#26159;&#19968;&#20010;&#25351;&#38024;&#65292;copy &#25351;&#38024;&#36824;&#19981;&#22815;&#65292;&#24212;&#35813;&#33258;&#24049;&#20998;&#37197;&#20869;&#23384;&#65292;&#28982;&#21518;&#28145;&#24230;&#22797;&#21046;&#65292;&#25152;&#20197;&#20320;&#23450;&#21046;&#20102;&#33258;&#24049;&#30340; copy constructor &#21644; copy assignment operator&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">person(<span class="dt">const</span> person&amp; that)
{
    name = <span class="kw">new</span> <span class="dt">char</span>[strlen(that.name) + <span class="dv">1</span>];
    strcpy(name, that.name);
    age = that.age;
}

person&amp; <span class="kw">operator</span>=(<span class="dt">const</span> person&amp; that)
{
    <span class="kw">if</span> (<span class="kw">this</span> != &amp;that)
    {
        <span class="kw">delete</span>[] name;
        <span class="co">// This is a dangerous point in the flow of execution!</span>
        <span class="co">// We have temporarily invalidated the class invariants,</span>
        <span class="co">// and the next statement might throw an exception,</span>
        <span class="co">// leaving the object in an invalid state :(</span>
        name = <span class="kw">new</span> <span class="dt">char</span>[strlen(that.name) + <span class="dv">1</span>];
        strcpy(name, that.name);
        age = that.age;
    }
    <span class="kw">return</span> *<span class="kw">this</span>;
}

<span class="co">//  &#21487;&#33021; rule of three &#37324;&#38500;&#20102;&#19978;&#38754;&#20004;&#20010;&#20989;&#25968;&#65292;&#36824;&#26377; dtor&#12290;</span></code></pre></div>
<p><strong>Noncopyable resources</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#37027;&#23601;&#25226;&#23427;&#20204;&#24324;&#25104; private &#21363;&#21487;&#65288;&#19981;&#38656;&#35201;&#23450;&#20041;&#65289;</span>
<span class="kw">private</span>:
    person(<span class="dt">const</span> person&amp; that);
    person&amp; <span class="kw">operator</span>=(<span class="dt">const</span> person&amp; that);

<span class="co">// &#25110;&#32773;&#65292;you can inherit from boost::noncopyable or declare them as deleted (C++0x):</span>
person(<span class="dt">const</span> person&amp; that) = <span class="kw">delete</span>;
person&amp; <span class="kw">operator</span>=(<span class="dt">const</span> person&amp; that) = <span class="kw">delete</span>;</code></pre></div>
<p>&#36825;&#26679;&#65292;&#20415;&#19981;&#33021;&#25335;&#36125;&#36825;&#20123;&#25335;&#36125;&#36215;&#26469;&#27809;&#26377;&#24847;&#20041;&#30340;&#23545;&#35937;&#20102;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#36825;&#20004;&#31181;&#38169;&#35823;&#65306;copy constructor</span>
person p2(p);
person p3 = p;

<span class="co">// &#36825;&#19968;&#31181;&#65306;copy assignment operator</span>
person p4;
p4 = p;</code></pre></div>
<p><strong>The rule of three</strong></p>
<p>Sometimes you need to implement a class that manages a resource. (Never manage multiple resources in a single class, this will only lead to pain.) In that case, remember the rule of three:</p>
<ul>
<li>If you need to explicitly declare either the <strong>destructor</strong>, <strong>copy constructor</strong> or <strong>copy assignment operator</strong> yourself, you probably need to explicitly declare all three of them.</li>
</ul>
<p>(Unfortunately, this &#8220;rule&#8221; is not enforced by the C++ standard or any compiler I am aware of.)</p>
<p><strong>Advice</strong></p>
<p>Most of the time, you do not need to manage a resource yourself, because an existing class such as <code>std::string</code> already does it for you. Just compare the simple code using a <code>std::string</code> member to the convoluted and error-prone alternative using a <code>char*</code> and you should be convinced. As long as you stay away from raw pointer members, the rule of three is unlikely to concern your own code.</p>
<p>&#19981;&#20316;&#27515;&#30340;&#35805;&#65292;&#26681;&#26412;&#29992;&#19981;&#30528; rule of three&#12290;</p>
<p>Wikipedia &#37324;&#30340;&#20363;&#23376;&#20063;&#19981;&#38169;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">class</span> Foo
{
<span class="kw">public</span>:
    <span class="co">/** </span>Default constructor */
    Foo() :
        data (<span class="kw">new</span> <span class="dt">char</span>)
    {
        std::strcpy(data, <span class="st">&quot;Hello, World!&quot;</span><span class="co">)</span>;
    }

    <span class="co">/** </span>Copy constructor */
    Foo (<span class="dt">const</span> Foo&amp; other) :
        data (<span class="kw">new</span> <span class="dt">char</span>[std::strlen (other.data) + <span class="dv">1</span>])
    {
        std::strcpy(data, other.data);
    }

    <span class="co">/** </span>Move constructor */
    Foo (Foo&amp;&amp; other) <span class="kw">noexcept</span> : <span class="co">/* noexcept needed to enable optimizations in containers */</span>
        data(other.data)
    {
        other.data = <span class="kw">nullptr</span>;
    }

    <span class="co">/** </span>Destructor */
    ~Foo() <span class="kw">noexcept</span> <span class="co">/* explicitly specified destructors should be annotated noexcept as best-practice */</span>
    {
        <span class="kw">delete</span>[] data;
    }

    <span class="co">/** </span>Copy assignment <span class="kw">operator</span> */
    Foo&amp; <span class="kw">operator</span>= (<span class="dt">const</span> Foo&amp; other)
    {
        Foo tmp(other);         <span class="co">// re-use copy-constructor</span>
        *<span class="kw">this</span> = std::move(tmp); <span class="co">// re-use move-assignment</span>
        <span class="kw">return</span> *<span class="kw">this</span>;
    }

    <span class="co">/** </span>Move assignment <span class="kw">operator</span> */
    Foo&amp; <span class="kw">operator</span>= (Foo&amp;&amp; other) <span class="kw">noexcept</span>
    {
        <span class="kw">delete</span>[] data;
        data = other.data;
        other.data = <span class="kw">nullptr</span>;
        <span class="kw">return</span> *<span class="kw">this</span>;
    }

<span class="kw">private</span>: <span class="co">// &#23545; friend &#32780;&#35328;&#65292;access control &#27809;&#26377;&#24847;&#20041;&#12290;</span>
    <span class="kw">friend</span> std::ostream&amp; <span class="kw">operator</span>&lt;&lt; (std::ostream&amp; os, <span class="dt">const</span> Foo&amp; foo)
    {
        os &lt;&lt; foo.data;
        <span class="kw">return</span> os;
    }

    <span class="dt">char</span>* data;
};

<span class="dt">int</span> main()
{
    <span class="dt">const</span> Foo foo;
    std::cout &lt;&lt; foo &lt;&lt; std::endl;

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/4172722/what-is-the-rule-of-three">c++ - What is The Rule of Three? - Stack Overflow</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming)">Rule of three (C++ programming) - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>What are the advantages of boost::noncopyable? <code class="fold">@</code></dt>
<dd><dl>
<dt>Rationale <code>[,r&#230;&#643;&#601;'n&#230;l]</code></dt>
<dd><p>Class noncopyable has protected constructor and destructor members to emphasize that it is to be used only as a base class. Dave Abrahams notes concern about the effect on compiler optimization of adding (even trivial inline) destructor declarations. He says:</p>
<p>&#8220;Probably this concern is misplaced, because noncopyable will be used mostly for classes which own resources and thus have non-trivial destruction semantics.&#8221;</p>
<p>With C++2011, using an optimized and trivial constructor and similar destructor can be enforced by declaring both and marking them default. This is done in the current implementation.</p>
</dd>
</dl>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> noncopyable
{
<span class="kw">protected</span>:
    noncopyable() {}
    ~noncopyable() {}
<span class="kw">private</span>:  <span class="co">// emphasize the following members are private</span>
    noncopyable( <span class="dt">const</span> noncopyable&amp; );
    <span class="dt">const</span> noncopyable&amp; <span class="kw">operator</span>=( <span class="dt">const</span> noncopyable&amp; );
};</code></pre></div>
<p>usage:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;boost/core/noncopyable.hpp&gt;</span>

<span class="kw">class</span> X: <span class="kw">private</span> boost::noncopyable
{
};</code></pre></div>
<p>To be fair, <code>boost::noncopyable</code> was available long before C++11 and compile support for <code>= delete</code>. I do agree with you that with C++11 near-compliant compilers, it is now obsolete.</p>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/7823990/what-are-the-advantages-of-boostnoncopyable">c++ - What are the advantages of boost::noncopyable - Stack Overflow</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>What is the copy-and-swap idiom? <code class="fold">@</code></dt>
<dd><p><strong>Why do we need the copy-and-swap idiom?</strong></p>
<p>rule of three &#22826;&#40635;&#28902;&#20102;&#65281;The copy-and-swap idiom is the solution, and elegantly assists the assignment operator in achieving two things: avoiding code duplication, and providing a strong exception guarantee.</p>
<p>The next version of C++, C++11, makes one very important change to how we manage resources: the Rule of Three is now <strong>The Rule of Four</strong> (and a half). Why? Because not only do we need to be able to copy-construct our resource, we need to move-construct it as well.</p>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom">c++ - What is the copy-and-swap idiom? - Stack Overflow</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>What are move semantics? <code class="fold">@</code></dt>
<dd><p>this guy gave two answers&#8230;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>

<span class="kw">class</span> string
{
    <span class="dt">char</span>* data;

<span class="kw">public</span>:
    string(<span class="dt">const</span> <span class="dt">char</span>* p) {
        size_t size = strlen(p) + <span class="dv">1</span>;
        data = <span class="kw">new</span> <span class="dt">char</span>[size];
        memcpy(data, p, size);
    }

    ~string() {
        <span class="kw">delete</span>[] data;
    }

    string(<span class="dt">const</span> string&amp; that) {
        size_t size = strlen(that.data) + <span class="dv">1</span>;
        data = <span class="kw">new</span> <span class="dt">char</span>[size];
        memcpy(data, that.data, size);
    }

    string(string&amp;&amp; that) {             <span class="co">// string&amp;&amp; is an rvalue reference to a string</span>
        data = that.data;
        that.data = <span class="kw">nullptr</span>;
    }

    string&amp; <span class="kw">operator</span>=(string that)
    {
        std::swap(data, that.data);
        <span class="kw">return</span> *<span class="kw">this</span>;
    }
};</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/3106110/what-are-move-semantics">c++ - What are move semantics? - Stack Overflow</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Do the parentheses after the type name make a difference with new? <code class="fold">@</code></dt>
<dd><p>This is one of the dusty corners of C++ that can drive you crazy. When constructing an object, sometimes you want/need the parens, sometimes you absolutely cannot have them, and sometimes it doesn&#8217;t matter.</p>
<p>&#24635;&#20043;&#21602;&#65292;&#36825;&#20010;&#22320;&#26041;&#19981;&#22909;&#35828;&#21834;&#12290;&#20294;&#21487;&#20197;&#30830;&#23450;&#30340;&#26159; <code>new int</code> &#26159;&#19981;&#21021;&#22987;&#21270;&#30340;&#65292; <code>new int()</code> &#21021;&#22987;&#21270;&#20026; 0&#12290;</p>
<p>&#36825;&#20010;&#20174;&#21160;&#26426;/&#35774;&#35745;&#24847;&#22270;&#35282;&#24230;&#32771;&#34385;&#30340;&#35299;&#37322;&#20498;&#26159;&#19981;&#38169;&#65306;</p>
<blockquote>
<p><code>new Thing();</code> is explicit that you want a constructor called whereas <code>new Thing;</code> is taken to imply you don&#8217;t mind if the constructor isn&#8217;t called.</p>
</blockquote>
<p>If used on a struct/class with a user-defined constructor, there is no difference. If called on a trivial struct/class (e.g. <code>struct Thing { int i; };</code>) then <code>new Thing;</code> is like <code>malloc(sizeof(Thing));</code> whereas <code>new Thing();</code> is like <code>calloc(sizeof(Thing));</code> - it gets zero initialized.</p>
<p>The gotcha (got you&#65292;&#8220;&#38590;&#21040;&#20320;&#20102;&#8221;) lies in-between:</p>
<p><code>cpp struct Thingy { ~Thingy(); // No-longer a trivial class virtual WaxOn(); int i; };</code></p>
<p>The behavior of <code>new Thingy;</code> vs <code>new Thingy();</code> in this case changed between C++98 and C++2003. See Michael Burr&#8217;s explanation for how and why.</p>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/620137/do-the-parentheses-after-the-type-name-make-a-difference-with-new">c++ - Do the parentheses after the type name make a difference with new? - Stack Overflow</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Splitting templated C++ classes into .hpp/.cpp files&#8211;is it possible? <code class="fold">@</code></dt>
<dd><p>&#19968;&#33324;&#32780;&#35328;&#65292;&#19981;&#35201;&#36825;&#26679;&#12290;&#20294;&#8230;&#8230;yeah, possible.</p>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/1724036/splitting-templated-c-classes-into-hpp-cpp-files-is-it-possible">class - Splitting templated C++ classes into .hpp/.cpp files&#8211;is it possible? - Stack Overflow</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>What is the difference between new/delete and malloc/free? &#9829;&#65039; <code class="fold">@</code></dt>
<dd><dl>
<dt><strong>new/delete</strong></dt>
<dd><p>Allocate/release memory</p>
<ul>
<li>Memory allocated from &#8216;Free Store&#8217;??? &#36825;&#20010;&#21861;&#24847;&#24605;&#65311;</li>
<li>Returns a fully <strong>typed</strong> pointer.</li>
<li><code>new</code> (standard version) <strong>never returns a NULL</strong> (will throw on failure)</li>
<li>Are called with Type-ID (compiler calculates the size)</li>
<li>Has a version explicitly to handle arrays.</li>
<li>Reallocating (to get more space) not handled intuitively (because of copy constructor).</li>
<li>Whether they call malloc/free is implementation defined.</li>
<li>Can add a new memory allocator to deal with low memory (set_new_handler)</li>
<li>operator new/delete can be overridden legally</li>
<li><strong>constructor/destructor used to initialize/destroy the object</strong></li>
</ul>
</dd>
<dt><strong>malloc/free</strong></dt>
<dd><p>Allocates/release memory</p>
<ul>
<li>Memory allocated from &#8216;Heap&#8217;</li>
<li>Returns a <code>void*</code></li>
<li>Returns NULL on failure</li>
<li>Must specify the size required <strong>in bytes</strong>.</li>
<li>Allocating array requires manual calculation of space.</li>
<li>Reallocating larger chunk of memory simple (No copy constructor to worry about)</li>
<li>They will NOT call new/delete</li>
<li>No way to splice user code into the allocation sequence to help with low memory.</li>
<li>malloc/free can NOT be overridden legally</li>
</ul>
</dd>
</dl>
<table>
<thead>
<tr class="header">
<th>Feature</th>
<th>new/delete</th>
<th>malloc/free</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Memory allocated from</td>
<td>&#8216;Free Store&#8217;</td>
<td>&#8216;Heap&#8217;</td>
</tr>
<tr class="even">
<td>Returns</td>
<td>Fully typed pointer</td>
<td>void*</td>
</tr>
<tr class="odd">
<td>On failure</td>
<td>Throws (never returns NULL)</td>
<td>Returns NULL</td>
</tr>
<tr class="even">
<td>Required size</td>
<td>Calculated by compiler</td>
<td>Must be specified in bytes</td>
</tr>
<tr class="odd">
<td>Handling arrays</td>
<td>Has an explicit version</td>
<td>Requires manual calculations</td>
</tr>
<tr class="even">
<td>Reallocating</td>
<td>Not handled intuitively</td>
<td>Simple (no copy constructor)</td>
</tr>
<tr class="odd">
<td>Call of reverse</td>
<td>Implementation defined</td>
<td>No</td>
</tr>
<tr class="even">
<td>Low memory cases</td>
<td>Can add a new memory allocator</td>
<td>Not handled by user code</td>
</tr>
<tr class="odd">
<td>Overridable</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr class="even">
<td>Use of (con-)/destructor</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
<p>Technically memory allocated by new comes from the &#8216;Free Store&#8217; while memory allocated by malloc comes from the &#8216;Heap&#8217;. Whether these two areas are the same is an implementation details, which is another reason that malloc and new can not be mixed.</p>
<p>This question doesn&#8217;t seem to ask any questions that I don&#8217;t answer in What are the differences between new and malloc?. But I&#8217;ll reiterate my previous points as raised here.</p>
<dl>
<dt>Can malloc/delete be used to allocate memory for objects? Will they call the constructor/destructor?</dt>
<dd><p>You cannot use malloc to allocate C++ objects and you cannot use free to deallocate C++ objects as they do not call the constructor or destructor. I can imagine someone making it work in a very hack-y and platform-specific manner, but it would be neither portable nor standards compliant. Nor could I imagine why you&#8217;d want to. Just use new and delete.</p>
<p>Moreover, you cannot manually call the constructor or destructor on an object instance.</p>
</dd>
<dt>What about realloc?</dt>
<dd><p>There is no equivalent to realloc for new and delete. Mostly because this doesn&#8217;t make sense. If you allocate a Foo object, what exactly would you reallocate? There is only one of them. You can use copy constructors to copy and move things around, but that isn&#8217;t addressing the same need as realloc.</p>
<p>&#23601;&#26159;&#37325;&#26032; malloc&#65292;&#23427;&#33258;&#21160;&#24110;&#20320; free &#21407;&#26469;&#30340;&#65292;malloc &#26032;&#30340;&#65292;&#25335;&#36125;&#12290;</p>
<p>C++ &#37324;&#27809;&#26377;&#23545;&#24212;&#29289;&#12290;</p>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/240212/what-is-the-difference-between-new-delete-and-malloc-free">c++ - What is the difference between new/delete and malloc/free? - Stack Overflow</a></li>
<li><a href="https://www.quora.com/What-are-the-differences-between-new-delete-and-malloc-free-when-allocating-memory-for-objects">What are the differences between new/delete and malloc/free when allocating memory for objects? - Quora</a></li>
<li><a href="http://www.cnblogs.com/daghlny/p/4874433.html">The differences between new(delete) and malloc(free) in c/c++ - daghlny - &#21338;&#23458;&#22253;</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Amortized complexity in layman&#8217;s terms? <code class="fold">@</code></dt>
<dd><p><strong>Amortized complexity</strong> <code>['&#230;m&#602;ta&#618;z]</code> is the total expense per operation, evaluated over a sequence of operations. The idea is to guarantee the total expense of the entire sequence, while permitting individual operations to be much more expensive than the average.</p>
<p>One simple example is the behavior of C++ <code>std::vector&lt;&gt;</code>. When <code>push_back()</code> increases the vector size above its pre-allocated value, it doubles the allocated length. This means that a single call of <code>push_back()</code> may take <strong>O(N) time to execute</strong> (as the contents of the array are copied to the new memory allocation). However, because the size of the allocation was doubled, the next N-1 calls to <code>push_back()</code> will each take O(1) time to execute. So, the total of N operations will still take O(N) time &#8211; giving <code>push_back()</code> an amortized cost of O(1) per operation.</p>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/15079327/amortized-complexity-in-laymans-terms">algorithm - Amortized complexity in layman&#8217;s terms? - Stack Overflow</a></li>
<li><a href="https://en.wikipedia.org/wiki/Amortized_analysis">Amortized analysis - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#34394;&#20989;&#25968;&#26159;&#20160;&#20040;&#65292;&#26377;&#20160;&#20040;&#20316;&#29992;&#65311;&#32431;&#34394;&#20989;&#25968;&#21602;&#65311; <code class="fold">@</code></dt>
<dd><p>&#34394;&#20989;&#25968;&#26159; C++ &#23454;&#29616;&#12304;&#21160;&#24577; dynamic&#12305;&#12304;&#21333;&#20998;&#27966; single-dispatch&#12305;&#12304;&#23376;&#31867;&#22411;&#22810;&#24577; subtype polymorphism&#12305;&#30340;&#26041;&#24335;&#12290;</p>
<ul>
<li>&#21160;&#24577;&#65306;&#22312;&#36816;&#34892;&#26102;&#20915;&#23450;&#30340;&#65288;&#30456;&#23545;&#30340;&#26159;&#38745;&#24577;&#65292;&#21363;&#22312;&#32534;&#35793;&#26399;&#20915;&#23450;&#65292;&#22914;&#20989;&#25968;&#37325;&#36733;&#12289;&#27169;&#26495;&#31867;&#30340;&#38750;&#34394;&#20989;&#25968;&#35843;&#29992;&#65289;</li>
<li>&#21333;&#20998;&#27966;&#65306;&#22522;&#20110;&#19968;&#20010;&#31867;&#22411;&#21435;&#36873;&#25321;&#35843;&#29992;&#21738;&#20010;&#20989;&#25968;&#65288;&#30456;&#23545;&#20110;&#22810;&#20998;&#27966;&#65292;&#21363;&#30001;&#22810;&#20010;&#31867;&#22411;&#21435;&#36873;&#25321;&#35843;&#29992;&#21738;&#20010;&#20989;&#25968;&#65289;</li>
<li>&#23376;&#31867;&#22411;&#22810;&#24577;&#65306;&#20197;&#23376;&#31867;&#22411;&#65293;&#36229;&#31867;&#22411;&#20851;&#31995;&#23454;&#29616;&#22810;&#24577;&#65288;&#30456;&#23545;&#20110;&#29992;&#21442;&#25968;&#24418;&#24335;&#65292;&#22914;&#20989;&#25968;&#37325;&#36733;&#12289;&#27169;&#29256;&#21442;&#25968;&#65289;</li>
</ul>
<p>&#26377;&#20960;&#20010;&#27010;&#24565;&#38656;&#35201;&#21400;&#28165;&#65306;</p>
<ul>
<li>&#23450;&#20041;&#19968;&#20010;&#20989;&#25968;&#20026;&#34394;&#20989;&#25968;&#65292;&#19981;&#20195;&#34920;&#20989;&#25968;&#20026;&#19981;&#34987;&#23454;&#29616;&#30340;&#20989;&#25968;&#12290;</li>
<li><strong>&#23450;&#20041;&#20182;&#20026;&#34394;&#20989;&#25968;&#26159;&#20026;&#20102;&#20801;&#35768;&#29992;&#22522;&#31867;&#30340;&#25351;&#38024;&#26469;&#35843;&#29992;&#23376;&#31867;&#30340;&#36825;&#20010;&#20989;&#25968;&#12290;</strong></li>
<li>&#23450;&#20041;&#19968;&#20010;&#20989;&#25968;&#20026;&#32431;&#34394;&#20989;&#25968;&#65292;&#25165;&#20195;&#34920;&#20989;&#25968;&#27809;&#26377;&#34987;&#23454;&#29616;&#12290;</li>
<li><strong>&#23450;&#20041;&#32431;&#34394;&#20989;&#25968;&#26159;&#20026;&#20102;&#23454;&#29616;&#19968;&#20010;&#25509;&#21475;&#65292;&#36215;&#21040;&#19968;&#20010;&#35268;&#33539;&#30340;&#20316;&#29992;</strong>&#65292;&#35268;&#33539;&#32487;&#25215;&#36825;&#20010;&#31867;&#30340;&#31243;&#24207;&#21592;&#24517;&#39035;&#23454;&#29616;&#36825;&#20010;&#20989;&#25968;&#12290;</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">class</span> A {
<span class="kw">public</span>:
    <span class="kw">virtual</span> <span class="dt">void</span> foo() { cout&lt;&lt;<span class="st">&quot;A::foo() is called&quot;</span>&lt;&lt;endl; }
};

<span class="kw">class</span> B : <span class="kw">public</span> A {
<span class="kw">public</span>:
    B() { cout &lt;&lt; <span class="st">&quot;B connstructed.</span><span class="ch">\n</span><span class="st">&quot;</span>; }
    <span class="kw">virtual</span> <span class="dt">void</span> foo() { cout&lt;&lt;<span class="st">&quot;B::foo() is called&quot;</span>&lt;&lt;endl; } <span class="co">// &#36825;&#20010; virtual &#21487;&#20197;&#30465;&#30053;</span>
};

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    A *a = <span class="kw">new</span> B;
    a-&gt;foo();

    B b;
    A &amp;x = <span class="kw">dynamic_cast</span>&lt;A&amp;&gt;(b);
    x.foo();
}</code></pre></div>
<p>&#32431;&#34394;&#20989;&#25968;&#26159;&#22312;&#22522;&#31867;&#20013;&#22768;&#26126;&#30340;&#34394;&#20989;&#25968;&#65292;&#23427;&#22312;&#22522;&#31867;&#20013;&#27809;&#26377;&#23450;&#20041;&#65292;&#20294;&#35201;&#27714;&#20219;&#20309;&#27966;&#29983;&#31867;&#37117;&#35201;&#23450;&#20041;&#33258;&#24049;&#30340;&#23454;&#29616;&#26041;&#27861;&#12290;&#22312;&#22522;&#31867;&#20013;&#23454;&#29616;&#32431;&#34394;&#20989;&#25968;&#30340;&#26041;&#27861;&#26159;&#22312;&#20989;&#25968;&#21407;&#22411;&#21518;&#21152; <code>=0</code></p>
<p><code>virtual void pureVirtualFunction()=0</code></p>
<p>&#24341;&#20837;&#21407;&#22240;&#65306;</p>
<ul>
<li>&#20026;&#20102;&#26041;&#20415;&#20351;&#29992;&#22810;&#24577;&#29305;&#24615;&#65292;&#25105;&#20204;&#24120;&#24120;&#38656;&#35201;&#22312;&#22522;&#31867;&#20013;&#23450;&#20041;&#34394;&#25311;&#20989;&#25968;&#12290;</li>
<li>&#22312;&#24456;&#22810;&#24773;&#20917;&#19979;&#65292;&#22522;&#31867;&#26412;&#36523;&#29983;&#25104;&#23545;&#35937;&#26159;&#19981;&#21512;&#24773;&#29702;&#30340;&#12290;&#20363;&#22914;&#65292;&#21160;&#29289;&#20316;&#20026;&#19968;&#20010;&#22522;&#31867;&#21487;&#20197;&#27966;&#29983;&#20986;&#32769;&#34382;&#12289;&#23380;&#38592;&#31561;&#23376;&#31867;&#65292;&#20294;&#21160;&#29289;&#26412;&#36523;&#29983;&#25104;&#23545;&#35937;&#26126;&#26174;&#19981;&#21512;&#24120;&#29702;&#12290;</li>
</ul>
<p>&#20026;&#20102;&#35299;&#20915;&#19978;&#36848;&#38382;&#39064;&#65292;&#24341;&#20837;&#20102;&#32431;&#34394;&#20989;&#25968;&#30340;&#27010;&#24565;&#65292;&#23558;&#20989;&#25968;&#23450;&#20041;&#20026;&#32431;&#34394;&#20989;&#25968;&#65288;&#26041;&#27861;&#65306; <code>virtual ReturnType Function()= 0;</code>&#65289;&#65292;&#21017;&#32534;&#35793;&#22120;&#35201;&#27714;&#22312;&#27966;&#29983;&#31867;&#20013;&#24517;&#39035;&#20104;&#20197;&#37325;&#20889;&#20197;&#23454;&#29616;&#22810;&#24577;&#24615;&#12290;&#21516;&#26102;&#21547;&#26377;&#32431;&#34394;&#25311;&#20989;&#25968;&#30340;&#31867;&#31216;&#20026;&#25277;&#35937;&#31867;&#65292;&#23427;&#19981;&#33021;&#29983;&#25104;&#23545;&#35937;&#12290;&#36825;&#26679;&#23601;&#24456;&#22909;&#22320;&#35299;&#20915;&#20102;&#19978;&#36848;&#20004;&#20010;&#38382;&#39064;&#12290;</p>
<p><strong>&#22768;&#26126;&#20102;&#32431;&#34394;&#20989;&#25968;&#30340;&#31867;&#26159;&#19968;&#20010;&#25277;&#35937;&#31867;&#12290;</strong>&#25152;&#20197;&#65292;&#29992;&#25143;&#19981;&#33021;&#21019;&#24314;&#31867;&#30340;&#23454;&#20363;&#65292;&#21482;&#33021;&#21019;&#24314;&#23427;&#30340;&#27966;&#29983;&#31867;&#30340;&#23454;&#20363;&#12290;</p>
<p>&#32431;&#34394;&#20989;&#25968;&#26368;&#26174;&#33879;&#30340;&#29305;&#24449;&#26159;&#65306;&#23427;&#20204;&#24517;&#39035;&#22312;&#32487;&#25215;&#31867;&#20013;&#37325;&#26032;&#22768;&#26126;&#20989;&#25968;&#65288;&#19981;&#35201;&#21518;&#38754;&#30340; <code>=0</code>&#65292;&#21542;&#21017;&#35813;&#27966;&#29983;&#31867;&#20063;&#19981;&#33021;&#23454;&#20363;&#21270;&#65289;&#65292;&#32780;&#19988;&#23427;&#20204;&#22312;&#25277;&#35937;&#31867;&#20013;&#24448;&#24448;&#27809;&#26377;&#23450;&#20041;&#12290;&#23450;&#20041;&#32431;&#34394;&#20989;&#25968;&#30340;&#30446;&#30340;&#22312;&#20110;&#65292;&#20351;&#27966;&#29983;&#31867;&#20165;&#20165;&#21482;&#26159;&#32487;&#25215;&#20989;&#25968;&#30340;&#25509;&#21475;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="https://www.zhihu.com/question/23971699">c++ &#34394;&#20989;&#25968;&#30340;&#20316;&#29992;&#26159;&#20160;&#20040;&#65311; - &#30693;&#20046;</a></li>
<li><a href="http://blog.csdn.net/hackbuteer1/article/details/7558868">&#34394;&#20989;&#25968;&#21644;&#32431;&#34394;&#20989;&#25968;&#30340;&#21306;&#21035; - Hackbuteer1&#30340;&#19987;&#26639; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>C &#35821;&#35328;&#20013;&#20026;&#20160;&#20040;&#19981;&#33021;&#29992; char &#31867;&#22411;&#26469;&#23384;&#20648; getchar() &#30340;&#36820;&#22238;&#20540;? <code class="fold">@</code></dt>
<dd><p>&#22312;&#38190;&#30424;&#25110;&#32773;&#23631;&#24149;&#19978;&#30340;&#23383;&#31526;&#37117;&#26159;&#29992; char &#31867;&#22411;&#23384;&#20648;&#30340;&#65292;&#24403;&#28982;&#20063;&#21487;&#20197;&#29992; int &#31867;&#22411;&#26469;&#23384;&#20648;&#12290;&#36825;&#20010;&#22320;&#26041;&#20351;&#29992; int &#26469;&#23384;&#20648;&#23383;&#31526;&#26377;&#19968;&#20010;&#24494;&#22937;&#20294;&#24456;&#37325;&#35201;&#30340;&#21407;&#22240;&#65306;&#20026;&#20102;&#25226;&#26377;&#25928;&#25968;&#25454;&#21644;&#36755;&#20837;&#30340;&#32467;&#26463; (EOF) &#21306;&#20998;&#24320;&#26469;&#12290;getchar() &#22312;&#27809;&#26377;&#26356;&#22810;&#36755;&#20837;&#25968;&#25454;&#26102;&#36820;&#22238;&#19968;&#20010;&#29305;&#27530;&#20540;&#65292;&#36825;&#20010;&#20540;&#19981;&#20250;&#36319;&#20219;&#20309;&#23454;&#38469;&#30340;&#23383;&#31526;&#28151;&#28102;&#12290;&#36825;&#20010;&#20540;&#31216;&#20026; EOF&#65288;end of file, &#25991;&#20214;&#32467;&#26463;&#65289;&#12290;&#25105;&#20204;&#24517;&#39035;&#25226; c &#21464;&#37327;&#22768;&#26126;&#25104;&#19968;&#20010;&#22823;&#21040;&#36275;&#22815;&#23384;&#20648;&#20219;&#20309; getchar() &#36820;&#22238;&#30340;&#20540;&#30340;&#31867;&#22411;&#12290;&#25105;&#20204;&#19981;&#33021;&#29992; char &#31867;&#22411;&#65292;&#22240;&#20026; c &#24517;&#39035;&#22823;&#21040;&#36275;&#22815;&#23481;&#32435;&#20219;&#24847;&#21487;&#33021;&#30340; char &#36824;&#26377; EOF&#12290;&#22240;&#27492;&#25105;&#20204;&#20351;&#29992; int &#31867;&#22411;&#12290;</p>
<p>Unlike some other languages you may have used, chars in C are integers. char is just another integer type, usually 8 bits and smaller than int, but still an integer type.</p>
<p>So, you don&#8217;t need ord() and chr() functions that exist in other languages you may have used. In C you can convert between char and other integer types using a cast, or just by assigning.</p>
<p>Unless EOF occurs, getchar() is defined to return &#8220;an unsigned char converted to an int&#8221; (same as fgetc), so if it helps you can imagine that it reads some char, c, then returns (int)(unsigned char)c.</p>
<p>You can convert this back to an unsigned char just by a cast or assignment, and if you&#8217;re willing to take a slight loss of theoretical portability, you can convert it to a char with a cast or by assigning it to a char.</p>
<p><code>int getchar ( void );</code></p>
<dl>
<dt><code>fgetc()</code></dt>
<dd>reads the next character from stream and returns it as an unsigned char cast to an int, or EOF on end of file or error.
</dd>
<dt><code>getc()</code></dt>
<dd>is equivalent to <code>fgetc()</code> except that it may be implemented as a macro which evaluates stream more than once.
</dd>
<dt><code>getchar()</code></dt>
<dd>is equivalent to <code>getc(stdin)</code>.
</dd>
<dt><code>gets()</code></dt>
<dd>reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with a null byte (&#8216;&#8217;). No check for buffer overrun is performed (see BUGS below).
</dd>
<dt><code>fgets()</code></dt>
<dd>reads in at most one less than size characters from stream and stores them into the buffer pointed to by s. Reading stops after an EOF or a newline. If a newline is read, it is stored into the buffer. A terminating null byte (&#8216;&#8217;) is stored after the last character in the buffer.
</dd>
<dt><code>ungetc()</code></dt>
<dd>pushes c back to stream, cast to unsigned char, where it is available for subsequent read operations. Pushed-back characters will be returned in reverse order; only one pushback is guaranteed.
</dd>
</dl>
<pre><code>+-------------------------------+      +--------------------------------------------+
|    int to char (truncate)     |      |       |         char to int (expand)       |
+-------------------------------+      +--------------------------------------------+
| hex     |  int        |  char |      |  char |unsigned char=&gt;int| signed char=&gt;int|
|---------|-------------|-------|      |-------|------------------|-----------------|
|  2      |00 00 00 02  |  02   |      |  02   |  00 00 00 02     |00 00 00 02      |
|  1      |00 00 00 01  |  01   |      |  01   |  00 00 00 01     |00 00 00 01      |
|  0      |00 00 00 00  |  00   |      |  00   |  00 00 00 00     |00 00 00 00      |
| EOF(-1) |FF FF FF FF  |  FF   |      |  FF   |  00 00 00 FF     |FF FF FF FF      |
|  -2     |FF FF FF FE  |  FE   |      |  FE   |  00 00 00 FE     |FF FF FF FE      |
+-------------------------------+      +--------------------------------------------+</code></pre>
<p>refs and see also</p>
<ul>
<li><a href="http://www.cnblogs.com/Jack47/archive/2013/01/15/zen-and-the-art-of-file-and-folder-organization-part1.html">&#31109;&#19982;&#25991;&#20214;&#21644;&#25991;&#20214;&#22841;&#32452;&#32455;&#30340;&#33402;&#26415; &#19978; - Jack47 - &#21338;&#23458;&#22253;</a></li>
<li><a href="http://www.cnblogs.com/Jack47/archive/2012/12/23/2819111.html">C &#35821;&#35328;&#20013;&#20026;&#20160;&#20040;&#19981;&#33021;&#29992; char &#31867;&#22411;&#26469;&#23384;&#20648; getchar() &#30340;&#36820;&#22238;&#20540; - Jack47 - &#21338;&#23458;&#22253;</a></li>
<li><a href="http://stackoverflow.com/questions/7119470/int-c-getchar">int c = getchar()? - Stack Overflow</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>When do you use float and when do you use double? <code class="fold">@</code></dt>
<dd><blockquote>
<p>When in double, use <code>double</code>.</p>
</blockquote>
<p>refs and see also</p>
<ul>
<li><a href="http://programmers.stackexchange.com/questions/188721/when-do-you-use-float-and-when-do-you-use-double">c++ - When do you use float and when do you use double - Programmers Stack Exchange</a> <code class="fold">@</code></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>TODO&#65292;&#25105;&#24050;&#32463;&#29702;&#35299;&#25110;&#32773;&#19979;&#25991;&#26377;&#20171;&#32461;&#30340;&#65292;&#19981;&#20877;&#36148;&#22312;&#36825;&#37324;&#65292;faqend &#9829;&#65039; <code class="fold">@</code></dt>
<dd><ul>
<li><a href="http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list">c++ faq - The Definitive C++ Book Guide and List - Stack Overflow</a></li>
<li><a href="http://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points">c++ - Undefined behavior and sequence points - Stack Overflow</a></li>
<li><a href="http://stackoverflow.com/questions/tagged/c%2b%2b-faq?sort=votes&amp;pageSize=100">Highest Voted &#8216;c++-faq&#8217; Questions - Stack Overflow</a></li>
<li><a href="https://github.com/ReadingLab/Discussion-for-Cpp/issues">Issues &#183; ReadingLab/Discussion-for-Cpp</a></li>
<li><a href="https://github.com/pezy/QtLab">pezy/QtLab: Qt Primer</a></li>
<li><a href="http://stackoverflow.com/questions/274626/what-is-object-slicing">c++ - What is object slicing? - Stack Overflow</a></li>
</ul>
<p>&#20316;&#32773;&#65306;&#38472;&#30805; &#9829;&#65039;</p>
<ul>
<li>&#26631;&#20934;&#24211;&#21508;&#23481;&#22120;&#30340;&#22522;&#26412;&#25805;&#20316;&#30340;&#22797;&#26434;&#24230;&#12290;&#26631;&#20934;&#24211;&#31639;&#27861;&#30340;&#22797;&#26434;&#24230;&#65292;&#20363;&#22914; std::sort() &#30340;&#24179;&#22343;&#22797;&#26434;&#24230;&#12289;&#26368;&#22351;&#22797;&#26434;&#24230;&#65288;&#31572; O(N^2) &#21644; O(N log N) &#37117;&#31639;&#23545;&#65289;&#65292;&#26368;&#22351;&#24773;&#20917;&#20160;&#20040;&#26102;&#20505;&#20986;&#29616;&#12290;</li>
<li>&#26631;&#20934;&#24211;&#21508;&#23481;&#22120;&#65288;deque &#38500;&#22806;&#65289;&#30340;&#25968;&#25454;&#32467;&#26500;&#65288;&#26631;&#20934;&#20826;&#21247;&#21943;&#65292;&#20027;&#27969; STL &#23454;&#29616;&#30340;&#25968;&#25454;&#32467;&#26500;&#37117;&#24046;&#19981;&#22810;&#65289;&#65292;&#20197;&#21450; vector &#30340;&#23481;&#37327;&#22686;&#38271;&#26041;&#24335;&#12290;&#22914;&#26524;&#22238;&#31572;&#24471;&#29305;&#21035;&#22909;&#65292;&#36824;&#21487;&#20197;&#34917;&#20805;&#38382;&#20026;&#20160;&#20040; vector::push_back() &#30340;&#22797;&#26434;&#24230;&#26159;&#20998;&#25674;&#20043;&#21518;&#30340; O(1)&#65292;&#20316;&#20026;&#21152;&#20998;&#12290;</li>
<li>&#20986;&#19968;&#36947;&#20351;&#29992; lower_bound / upper_bound &#33021;&#36731;&#26494;&#35299;&#20915;&#30340;&#31616;&#21333;&#31639;&#27861;&#39064;&#65307;&#25110;&#32773;&#23454;&#29616; set_intersection() &#25110; set_union() &#25110; merge()&#65307;&#25110;&#32773;&#23454;&#29616; word count&#65292;&#32479;&#35745;&#27599;&#20010;&#21333;&#35789;&#20986;&#29616;&#30340;&#27425;&#25968;&#65288;&#26368;&#22810;&#21313;&#20960;&#34892;&#20195;&#30721;&#65289;&#65292;&#22914;&#26524;&#26377;&#26102;&#38388;&#65292;&#36755;&#20986;&#26102;&#20877;&#25353;&#20986;&#29616;&#27425;&#25968;&#25490;&#24207;&#12290;</li>
<li>new &#23454;&#38469;&#19978;&#25191;&#34892;&#20102;&#20160;&#20040;&#25805;&#20316;&#65292;&#21487;&#33021;&#22312;&#20160;&#20040;&#27493;&#39588;&#20986;&#29616;&#24322;&#24120;</li>
</ul>
</dd>
</dl></li>
</ul>
<h2 id="&#20851;&#38190;&#27010;&#24565;-concepts">&#20851;&#38190;&#27010;&#24565; | Concepts</h2>
<ul>
<li><dl>
<dt><a href="https://en.wikipedia.org/wiki/Abstraction_layer">Abstraction layer - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/03/Computer_abstraction_layers.svg/200px-Computer_abstraction_layers.svg.png" alt="A typical vision of a computer architecture as a series of abstraction layers: hardware, firmware, assembler, kernel, operating system and applications (see also )." />
<p class="caption">A typical vision of a computer architecture as a series of abstraction layers: hardware, firmware, assembler, kernel, operating system and applications (see also ).</p>
</div>
<p>In computing, an abstraction layer or abstraction level is a way of <strong>hiding the implementation details</strong> of a particular set of functionality, allowing the separation of concerns to facilitate interoperability and platform independence. Software models that use layers of abstraction include the OSI 7-layer model for computer network protocols, the OpenGL graphics drawing library, and the byte stream input/output (I/O) model originated from Unix and adopted by MS-DOS, Linux, and most other modern operating systems.</p>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://en.wikipedia.org/wiki/Access_modifiers">Access modifiers - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p><strong>Access modifiers</strong> (or access specifiers) are keywords in object-oriented languages that set the accessibility of classes, methods, and other members. Access modifiers are a specific part of programming language syntax used to facilitate the encapsulation of components.</p>
<p>&#20174;&#21382;&#21490;&#21644;&#35774;&#35745;&#30340;&#35282;&#24230;&#25105;&#26469;&#25199;&#25199;&#28129;&#65306;</p>
<ul>
<li>&#26368;&#24320;&#22987;&#65292;&#20840;&#37096;&#26159; public &#30340;&#65292;&#22826;&#36879;&#26126;&#65292;&#23481;&#26131;&#34987;&#20854;&#20182;&#20154;&#20462;&#25913;&#65281;</li>
<li>&#28982;&#21518;&#24341;&#20837;&#20102; private&#65292;&#26377;&#20123;&#19996;&#35199;&#23601;&#20445;&#25252;&#36215;&#26469;&#20102;&#12290;</li>
<li>&#21518;&#26469;&#26377;&#20102;&#31867;&#30340;&#32487;&#25215;&#12290;&#24590;&#20040;&#30041;&#36951;&#20135;&#32473;&#20799;&#23376;&#65311;public &#30340;&#35805;&#25152;&#26377;&#20154;&#37117;&#33021;&#29992;&#65311; private &#30340;&#35805;&#26159;&#19981;&#26159;&#26292;&#38706;&#22826;&#22810;&#12290;&#25152;&#20197;&#21482;&#26377; public &#21644; private &#30340;&#36825;&#19968;&#22871;&#20307;&#31995;&#36824;&#19981;&#22815;&#12290;</li>
<li>&#20110;&#26159; protected &#20986;&#26469;&#20102;&#65292;&#33258;&#24049; protected &#30340;&#19996;&#35199;&#22312;&#20854;&#20182;&#20154;&#30475;&#26469;&#26159;&#8220;private&#8221; &#30340;&#12290;&#20256;&#32473;&#20799;&#23376;&#65292;&#36824;&#26159; protected&#65292;&#20182;&#20063;&#33021;&#29992;&#12290;&#20110;&#26159;<strong>&#19968;&#26465;&#36951;&#20256;&#32487;&#25215;&#30340;&#28192;&#36947;&#23601;&#26377;&#20102;</strong>&#12290;</li>
</ul>
<p>&#36825;&#20010;&#20363;&#23376;&#20063;&#26159;&#19981;&#38169;&#30340;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> std::cout;
<span class="kw">using</span> std::endl;

<span class="kw">struct</span> B { <span class="co">// default access modifier inside struct is public</span>
    <span class="dt">void</span> set_n(<span class="dt">int</span> v) { n = v; }
    <span class="dt">void</span> f()          { cout &lt;&lt; <span class="st">&quot;B::f&quot;</span> &lt;&lt; endl; }
  <span class="kw">protected</span>:
    <span class="dt">int</span> m, n; <span class="co">// B::m, B::n are protected</span>
  <span class="kw">private</span>:
    <span class="dt">int</span> x;
};

<span class="kw">struct</span> D : B {
    <span class="kw">using</span> B::m;               <span class="co">// D::m is public</span>
    <span class="dt">int</span> get_n() { <span class="kw">return</span> n; } <span class="co">// B::n is accessible here, but not outside</span>
<span class="co">//  int get_x() { return x; } // ERROR, B::x is inaccessible here</span>
 <span class="kw">private</span>:
    <span class="kw">using</span> B::f;               <span class="co">// D::f is private</span>
};

<span class="dt">int</span> main() {
    D d;

<span class="co">//  d.x = 2; // ERROR, private          &#65288;B &#30340; private&#65292;D &#26080;&#27861;&#35775;&#38382;&#65289;</span>
<span class="co">//  d.n = 2; // ERROR, protected        &#65288;B &#30340; protected&#65292;D &#21482;&#33021;&#20869;&#37096;&#35775;&#38382;&#65292;B &#30340; protected&#65292;&#33258;&#24049;&#20063;&#21482;&#33021;&#20869;&#37096;&#35775;&#38382;&#12290;&#65289;</span>
    d.m = <span class="dv">2</span>; <span class="co">// protected B::m is accessible as D::m</span>
             <span class="co">//                         &#65288;B &#30340; protected&#65292;&#20294;&#26159;&#25104;&#20102; D &#30340; public&#65289;</span>

    d.set_n(<span class="dv">2</span>); <span class="co">// calls B::set_n(int)  &#65288;&#20869;&#37096;&#35775;&#38382;&#65292;set &amp; get&#65289;</span>
    cout &lt;&lt; d.get_n() &lt;&lt; endl; <span class="co">// output: 2</span>

<span class="co">//  d.f();   // ERROR, B::f is inaccessible as D::f</span>
             <span class="co">//                         &#65288;private &#20989;&#25968;&#65292;&#38480;&#20869;&#37096;&#20351;&#29992;&#65289;</span>

    B&amp; b = d; <span class="co">// b references d and &quot;views&quot; it as being type B</span>

<span class="co">//  b.x = 3; // ERROR, private</span>
<span class="co">//  b.n = 3; // ERROR, protected</span>
<span class="co">//  b.m = 3; // ERROR, B::m is protected</span>

    b.set_n(<span class="dv">3</span>); <span class="co">// calls B::set_n(int)  &#65288;&#34429;&#28982;&#23454;&#38469;&#19978;&#26159; d&#65292;&#20294;&#26159;&#31867;&#22411;&#26159; B&#65292;&#25152;&#20197;&#29992;&#30340; B::set_n&#65289;</span>
<span class="co">//  cout &lt;&lt; b.get_n(); // ERROR, &#39;struct B&#39; has no member named &#39;get_n&#39;</span>

    b.f();   <span class="co">// calls B::f()</span>
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://en.wikipedia.org/wiki/Friend_function">Friend function - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p>1&#65289;friend &#25317;&#26377;&#26597;&#30475;&#20320;&#38544;&#31169;&#30340;&#29305;&#26435;&#12290;2&#65289;friend &#21487;&#33021;&#35828;&#26126;&#20102;&#35774;&#35745;&#19981;&#24403;&#65292;&#22240;&#20026;&#20320;&#21487;&#20197; control access&#65292;&#32780;&#19981;&#26159;&#20599;&#25042;&#22320; friend &#20854;&#23427;&#31867;&#21644;&#20989;&#25968;&#12290;3&#65289;friend &#26080;&#25152;&#35859; access specifier&#65292;&#22240;&#20026;&#23427;&#19981;&#26159;&#20320;&#30340;&#19968;&#37096;&#20998;&#12290;access control &#26159;&#25511;&#21046;&#33258;&#24049;&#30340;&#65288;&#34987;&#65289;&#35775;&#38382;&#12290;</p>
<p>In object-oriented programming, a friend function that is a &#8220;friend&#8221; of a given class is <strong>allowed access to private and protected data</strong> in that class that it would not normally be able to as if the data was public. Normally, a function that is defined outside of a class cannot access such information. Declaring a function a friend of a class allows this, in languages where the concept is supported.</p>
<p>A friend function is declared by the class that is granting access, explicitly stating what function from a class is allowed access. A similar concept is that of friend class.</p>
<p>Friends should be used with caution. Too many functions or external classes declared as friends of a class with protected or private (visibility modes) data may lessen the value of encapsulation of separate classes in object-oriented programming and may indicate a problem in the overall architecture design. Generally though, friend functions are a good thing for encapsulation, as you can <strong>keep data of a class private from all except those who you explicitly state need it</strong>, but this does mean your classes will become tightly coupled.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">class</span> Foo;
<span class="kw">class</span> Bar {
  <span class="kw">private</span>:
      <span class="dt">int</span> a;
  <span class="kw">public</span>:
      Bar(): a(<span class="dv">0</span>) {}
      <span class="co">//                                    &#21644; Foo &#19968;&#26679;&#65292;&#26377;&#36825;&#20010; friend</span>
      <span class="dt">void</span> show(Bar&amp; x, Foo&amp; y);        <span class="co">//  &#31169;&#26377;&#20989;&#25968;</span>
      <span class="kw">friend</span> <span class="dt">void</span> show(Bar&amp; x, Foo&amp; y); <span class="co">//  declaration of global friend&#65292;&#19968;&#20010;&#20840;&#23616;&#30340;&#26379;&#21451;</span>
};

<span class="kw">class</span> Foo {
  <span class="kw">private</span>:
      <span class="dt">int</span> b;
  <span class="kw">public</span>:
      Foo(): b(<span class="dv">6</span>) {}
      <span class="co">//                                    &#21644; Bar &#19968;&#26679;&#65292;&#26377;&#36825;&#20010; friend</span>
      <span class="kw">friend</span> <span class="dt">void</span> show(Bar&amp; x, Foo&amp; y); <span class="co">//  declaration of global friend</span>
      <span class="co">// &#36824;&#25226; Bar &#37324;&#38754;&#30340; show &#20989;&#25968;&#32473; friend &#30340;&#20102;&#12290;</span>
      <span class="kw">friend</span> <span class="dt">void</span> Bar::show(Bar&amp; x, Foo&amp; y); <span class="co">// declaration of friend from other class</span>
      <span class="co">//</span>
      <span class="co">//  &#22914;&#26524;&#19981; friend &#36825;&#20010;&#20989;&#25968;&#65292;Bar &#37027;&#20010;&#20989;&#25968;&#27809;&#27861;&#32534;&#35793;&#12290;&#20250;&#26377;&#22914;&#19979;&#38169;&#35823;&#65306;</span>
      <span class="co">//</span>
      <span class="co">//    main.cpp: In member function &#39;void Bar::show(Bar&amp;, Foo&amp;)&#39;:</span>
      <span class="co">//    main.cpp:17: error: &#39;int Foo::b&#39; is private</span>
      <span class="co">//    main.cpp:29: error: within this context</span>
};

<span class="co">// Definition of a member function of Bar; this member is a friend of Foo</span>
<span class="dt">void</span> Bar::show(Bar&amp; x, Foo&amp; y) {
<span class="co">// &#22240;&#20026;&#36825;&#20010;&#20989;&#25968;&#26159; Foo &#25351;&#23450; friend &#30340;&#65292;&#25152;&#20197; Bar &#21487;&#20197;&#35775;&#38382; y.b (Foo::b).</span>
  cout &lt;&lt; <span class="st">&quot;Show via function member of Bar&quot;</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="st">&quot;Bar::a = &quot;</span> &lt;&lt; x.a &lt;&lt; endl;
  cout &lt;&lt; <span class="st">&quot;Foo::b = &quot;</span> &lt;&lt; y.b &lt;&lt; endl;
}

<span class="co">// Friend for Bar and Foo, definition of global function</span>
<span class="dt">void</span> show(Bar&amp; x, Foo&amp; y) {
  cout &lt;&lt; <span class="st">&quot;Show via global function&quot;</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="st">&quot;Bar::a = &quot;</span> &lt;&lt; x.a &lt;&lt; endl;
  cout &lt;&lt; <span class="st">&quot;Foo::b = &quot;</span> &lt;&lt; y.b &lt;&lt; endl;
}

<span class="dt">int</span> main() {
   Bar a;
   Foo b;

   show(a,b);
   a.show(a,b); <span class="co">// Bar::show,</span>
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#26356;&#24120;&#29992;&#30340;&#21602;&#65292;&#26159; friend operator&lt;&lt;</span>
<span class="kw">class</span> Y {
    <span class="dt">int</span> data; <span class="co">// private member</span>
    <span class="co">// the non-member function operator&lt;&lt; will have access to Y&#39;s private members</span>
    <span class="kw">friend</span> std::ostream&amp; <span class="kw">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="dt">const</span> Y&amp; o);
    <span class="kw">friend</span> <span class="dt">char</span>* X::foo(<span class="dt">int</span>); <span class="co">// members of other classes can be friends too</span>

    <span class="co">// &#36824;&#21487;&#20197;&#36830;&#32493; friend &#20004;&#20010;&#20989;&#25968;&#12290;</span>
    <span class="kw">friend</span> X::X(<span class="dt">char</span>), X::~X(); <span class="co">// constructors and destructors can be friends</span>
};
<span class="co">// friend declaration does not declare a member function</span>
<span class="co">// this operator&lt;&lt; still needs to be defined, as a non-member</span>
std::ostream&amp; <span class="kw">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="dt">const</span> Y&amp; y)
{
    <span class="kw">return</span> out &lt;&lt; y.data; <span class="co">// can access private member Y::data</span>
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Y {};
<span class="kw">class</span> A {
    <span class="dt">int</span> data; <span class="co">// private data member</span>
    <span class="kw">class</span> B { }; <span class="co">// private nested type</span>
    <span class="kw">enum</span> { a = <span class="dv">100</span> }; <span class="co">// private enumerator</span>
    <span class="kw">friend</span> <span class="kw">class</span> X; <span class="co">// friend class forward declaration (elaborated class name)</span>
    <span class="kw">friend</span> Y; <span class="co">// friend class declaration (simple type specifier) (since c++11)</span>
};

<span class="kw">class</span> X : A::B <span class="co">// Error until C++11: the base-clause is not part of member declarations</span>
               <span class="co">// allowed in C++11</span>
{
    A::B mx; <span class="co">// OK: A::B accessible to member of friend</span>
    <span class="kw">class</span> Y : A::B { <span class="co">// OK: A::B accessible to base-clause of nested member of friend</span>
    };
    <span class="dt">int</span> v[A::a]; <span class="co">// OK: A::a accessible to member of friend</span>
};</code></pre></div>
<p>Notes</p>
<ul>
<li>Friendship is <strong>not transitive</strong> (a friend of your friend is not your friend)</li>
<li>Friendship is <strong>not inherited</strong> (your friend&#8217;s children are not your friends)</li>
<li>Prior to C++11, member declarations and definitions inside the nested class of the friend of class T cannot access the private and protected members of class T, but some compilers accept it even in pre-C++11 mode.</li>
<li>Storage class specifiers are not allowed in friend function declarations. A function that is defined in the friend declaration has external linkage, a function that was previously defined, keeps the linkage it was defined with.</li>
<li><strong>Access specifiers have no effect on the meaning of friend declarations</strong> (they can appear in <code>private:</code> or in <code>public:</code> sections, with no difference)</li>
<li>A friend class declaration cannot define a new class (<code>friend class X {};</code> is an error&#65292;<code>friend class X;</code> &#26159;&#21487;&#20197;&#30340;&#12290;)</li>
<li><p>When a local class declares an unqualified function or class as a friend, only functions and classes in the innermost non-class scope are looked up, not the global functions:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> F {};
<span class="dt">int</span> f();
<span class="dt">int</span> main()
{
    <span class="dt">extern</span> <span class="dt">int</span> g();
    <span class="kw">class</span> Local { <span class="co">// Local class in the main() function</span>
        <span class="kw">friend</span> <span class="dt">int</span> f(); <span class="co">// Error, no such function declared in main()</span>
        <span class="kw">friend</span> <span class="dt">int</span> g(); <span class="co">// OK, there is a declaration for g in main()</span>

        <span class="co">// &#21363;&#20351; F &#36824;&#27809;&#23450;&#20041;&#65292;&#20063;&#27809;&#22768;&#26126;&#65292;&#29616;&#22312;&#20063;&#21487;&#20197; friend</span>
        <span class="kw">friend</span> <span class="kw">class</span> F; <span class="co">// friends a local F (defined later)</span>
        <span class="co">// &#20840;&#21095;&#30340;&#37027;&#20010;&#65292;&#21487;&#20197;&#29992; ::F</span>
        <span class="kw">friend</span> <span class="kw">class</span> ::F; <span class="co">// friends the global F</span>
    };
    <span class="kw">class</span> F {}; <span class="co">// local F</span>
}</code></pre></div></li>
</ul>
<dl>
<dt>Template friends <code class="fold">@</code></dt>
<dd><p>tl;dr</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> A {
    <span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
    <span class="kw">friend</span> <span class="kw">class</span> B;                 <span class="co">// every B&lt;T&gt; is a friend of A</span>

    <span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
    <span class="kw">friend</span> <span class="dt">void</span> f(T) {}             <span class="co">// every f&lt;T&gt; is a friend of A</span>
};</code></pre></div>
<p>Friend declarations cannot refer to <strong>partial specializations</strong>, but can refer to full specializations:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; <span class="kw">class</span> A {};               <span class="co">// primary</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; <span class="kw">class</span> A&lt;T*&gt; {};           <span class="co">// partial</span>
<span class="kw">template</span>&lt;&gt; <span class="kw">class</span> A&lt;<span class="dt">int</span>&gt; {};                 <span class="co">// full</span>
<span class="kw">class</span> X {
    <span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; <span class="kw">friend</span> <span class="kw">class</span> A&lt;T*&gt;;   <span class="co">// error!</span>
    <span class="kw">friend</span> <span class="kw">class</span> A&lt;<span class="dt">int</span>&gt;;                    <span class="co">// OK</span>
};</code></pre></div>
<p>When a friend declaration refers to a full specialization of a function template, the keyword inline and default arguments cannot be used.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; <span class="dt">void</span> f(<span class="dt">int</span>);
<span class="kw">template</span>&lt;&gt; <span class="dt">void</span> f&lt;<span class="dt">int</span>&gt;(<span class="dt">int</span>);

<span class="kw">class</span> X {
    <span class="kw">friend</span> <span class="dt">void</span> f&lt;<span class="dt">int</span>&gt;(<span class="dt">int</span> x = <span class="dv">1</span>); <span class="co">// error: default args not allowed</span>
};</code></pre></div>
<p>&#8230;</p>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/language/friend">friend declaration - cppreference.com</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/465sdshe.aspx">friend (C++)</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://en.wikipedia.org/wiki/Template_%28C%2B%2B%29">Template (C++) - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p>Templates are a feature of the C++ programming language that allows functions and classes to operate with generic types. This allows a function or class to work on many different data types without being rewritten for each one.</p>
<p>Templates are of great utility to programmers in C++, especially when combined with multiple inheritance and operator overloading. The C++ Standard Library provides many useful functions within a framework of connected templates.</p>
<p>Major inspirations for C++ templates were the parameterized modules provided by CLU and the generics provided by Ada.</p>
<p>There are three kinds of templates: <strong>function templates</strong>, <strong>class templates</strong> and, since C++14, <strong>variable templates</strong>. Since C++11, templates may be either variadic or non-variadic; in earlier versions of C++ they are always non-variadic.</p>
<dl>
<dt>Function templates <code class="fold">@</code></dt>
<dd><p>A function template behaves like a function except that the template can <strong>have arguments of many different types</strong> (see example). In other words, a function template represents a family of functions. The format for declaring function templates with type parameters is</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#20004;&#32773;&#31561;&#20215;&#65292;&#20294;&#31532;&#19968;&#31181;&#21487;&#33021;&#26377;&#35823;&#23548;&#65288;&#19981;&#24517;&#39035;&#26159; class&#65289;</span>
<span class="kw">template</span> &lt;<span class="kw">class</span> identifier&gt; function_declaration;
<span class="kw">template</span> &lt;<span class="kw">typename</span> identifier&gt; function_declaration;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> Type&gt;
Type max(Type a, Type b) {
    <span class="kw">return</span> a &gt; b ? a : b;
}

<span class="ot">#include &lt;iostream&gt;</span>
<span class="dt">int</span> main()
{
    <span class="co">// call max&lt;int&gt; by implicit argument deduction.</span>
    std::cout &lt;&lt; max(<span class="dv">3</span>, <span class="dv">7</span>) &lt;&lt; std::endl;

    <span class="co">// max&lt;double&gt;</span>
    std::cout &lt;&lt; max(<span class="fl">3.0</span>, <span class="fl">7.0</span>) &lt;&lt; std::endl;

    <span class="co">// This depends on the compiler. Some compilers handle this by defining a template</span>
    <span class="co">// function like double max &lt;double&gt; ( double a, double b);, while in some compilers</span>
    <span class="co">// we need to explicitly cast it, like std::cout &lt;&lt; max&lt;double&gt;(3,7.0);</span>
    std::cout &lt;&lt; max(<span class="dv">3</span>, <span class="fl">7.0</span>) &lt;&lt; std::endl;
    std::cout &lt;&lt; max&lt;<span class="dt">double</span>&gt;(<span class="dv">3</span>, <span class="fl">7.0</span>) &lt;&lt; std::endl;
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>This function template can be <strong>instantiated</strong>&#65288;<code>[&#618;ns't&#230;n&#643;&#618;et]</code>&#65292;&#23454;&#20363;&#21270;&#65289; with any copy-constructible type for which the expression <code>y &gt; x</code> is valid. For user-defined types, this implies that the greater-than operator (&gt;) must be overloaded in the type.</p>
</dd>
<dt>Class templates <code class="fold">@</code></dt>
<dd><p>A class template <strong>provides a specification for generating classes based on parameters</strong>. Class templates are generally used to implement containers. A class template is instantiated by passing a given set of types to it as template arguments. The C++ Standard Library contains many class templates, in particular the containers adapted from the Standard Template Library, such as vector.</p>
</dd>
<dt>Variable templates</dt>
<dd><p>In C++14, templates can be also used for variables, as in the following example.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="kw">constexpr</span> T pi = T(<span class="fl">3.1415926535897932385</span>);

<span class="co">// Usual specialization rules apply:</span>
<span class="kw">template</span>&lt;&gt; <span class="kw">constexpr</span> <span class="dt">const</span> <span class="dt">char</span>* pi&lt;<span class="dt">const</span> <span class="dt">char</span>*&gt; = <span class="st">&quot;pi&quot;</span>;</code></pre></div>
<p>see more at <a href="https://en.wikipedia.org/wiki/C%2B%2B14#Variable_templates">C++14 - Wikipedia, the free encyclopedia</a>.</p>
</dd>
<dt>Template specialization <code class="fold">@</code></dt>
<dd><p>When a function or class is instantiated from a template, a specialization of that template is created by the compiler for the set of arguments used, and the specialization is referred to as being a generated specialization.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;&gt;
<span class="dt">bool</span> max&lt;<span class="dt">bool</span>&gt;(<span class="dt">bool</span> a, <span class="dt">bool</span> b) {
    <span class="kw">return</span> a || b;
}</code></pre></div>
</dd>
<dt>Variadic templates <code class="fold">@</code></dt>
<dd><p>C++11 introduced variadic templates, which can take a variable number of arguments in a manner somewhat similar to variadic functions such as <code class="sourceCode cpp">std::printf</code>. Both function templates and class templates can be variadic.</p>
<dl>
<dt><a href="https://en.wikipedia.org/wiki/Variadic_template">Variadic template - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p>In computer programming, variadic templates are templates that take a variable number of arguments. Variadic templates are supported by C++ (since the C++11 standard), and the D programming language.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span>... Values&gt; <span class="kw">class</span> tuple;

tuple&lt;<span class="dt">int</span>, std::vector&lt;<span class="dt">int</span>&gt;, std::map&lt;&lt;std::string&gt;, std::vector&lt;<span class="dt">int</span>&gt;&gt;&gt; some_instance_name;
tuple&lt;&gt; some_instance_name;     <span class="co">// no arguments</span>

<span class="kw">template</span>&lt;<span class="kw">typename</span> First, <span class="kw">typename</span>... Rest&gt; <span class="kw">class</span> tuple; <span class="co">// at least one argument</span></code></pre></div>
Variadic templates may also apply to functions, thus not only providing a type-safe add-on to variadic functions (such as printf)
<ul>
<li>but also allowing a printf-like function to process non-trivial objects.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span>... Params&gt; <span class="dt">void</span> printf(<span class="dt">const</span> std::string &amp;str_format, Params... parameters);</code></pre></div>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://en.wikipedia.org/wiki/Type_system" class="heart">Type system - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p>In programming languages, a type system is <strong>a collection of rules that assign a property called type</strong> to various constructs a computer program consists of, such as variables, expressions, functions or modules. The main purpose of a type system is to <strong>reduce possibilities for bugs</strong> in computer programs by defining interfaces between different parts of a computer program, and then checking that the parts have been connected in a consistent way. This checking can happen statically (at compile time), dynamically (at run time), or as a combination of static and dynamic checking. Type systems have other purposes as well, such as enabling certain compiler optimizations, allowing for multiple dispatch, providing a form of documentation, etc.</p>
<p>A type system associates a type with each computed value and, by examining the flow of these values, <strong>attempts to ensure or prove that no type errors can occur</strong>. The particular type system in question determines exactly what constitutes a type error, but in general the aim is to prevent operations expecting a certain kind of value from being used with values for which that operation does not make sense (<strong>logic errors</strong>); <strong>memory errors</strong> will also be prevented. Type systems are often specified as part of programming languages, and built into the interpreters and compilers for them; although the type system of a language can be extended by optional tools that perform additional kinds of checks using the language&#8217;s original type syntax and grammar.</p>
<dl>
<dt><a href="http://en.cppreference.com/w/cpp/language/types">Fundamental types - cppreference.com</a> <code class="fold">@</code></dt>
<dd><ul>
<li><p>Void type</p>
<p><code>void</code>&#65292;&#19981;&#33021;&#29992;&#26469;&#23454;&#20363;&#21270;&#23545;&#35937;&#65292;&#20294;&#21487;&#20197;&#29992;&#21040; pointer&#65292;&#36820;&#22238;&#20540;&#65292;&#36824;&#21487;&#20197;&#29992;&#26469;&#28040;&#38500; warning&#65288;&#27604;&#22914; <code>(void)argc; (void)argv;</code>&#65289;</p>
<p><code>std::nullptr_t</code> &#23450;&#20041;&#20026; <code>typedef decltype(nullptr) nullptr_t;</code>&#12290;nullptr &#21644; NULL &#31867;&#20284;&#12290;</p>
<p><code>std::nullptr_t</code> is the type of the null pointer literal, nullptr. It is a distinct type that is not itself a pointer type or a pointer to member type.</p></li>
<li><p>Boolean type</p>
<p><code>bool</code></p></li>
<li><p>Character types</p>
<p>unsigned char, siggned char, char&#65288;&#19981;&#26159; signed &#23601;&#26159; unsigned&#65289;, char16_t, char32_t, wchar_t&#12290;</p></li>
<li><p>Integer types</p>
<p>signed/unsigned short/long, int, long long</p>
<div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-09-202600_1366x768_scrot.png" />

</div></li>
<li><p>Floating point types</p>
<p>float, double, long double</p></li>
</ul>
<div class="figure">
<img src="2016-08-09-202912_1366x768_scrot.png" />

</div>
</dd>
</dl>
<p>General concepts</p>
<ul>
<li>Type safety</li>
</ul>
<p>Major categories</p>
<ul>
<li>Static vs.&#160;Dynamic</li>
<li>Manifest vs.&#160;Inferred</li>
<li>Nominal vs.&#160;Structural</li>
<li>Duck typing</li>
</ul>
<dl>
<dt>Static and dynamic type checking in practice</dt>
<dd><p>The choice between static and dynamic typing requires certain trade-offs.</p>
</dd>
<dt>&#8220;Strong&#8221; and &#8220;weak&#8221; type systems</dt>
<dd><p>TODO: <a href="https://en.wikipedia.org/wiki/Strong_and_weak_typing" class="uri">https://en.wikipedia.org/wiki/Strong_and_weak_typing</a></p>
</dd>
<dt>Type safety and memory safety</dt>
<dd><div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> x = <span class="dv">5</span>;
<span class="dt">char</span> y[] = <span class="st">&quot;37&quot;</span>;
<span class="dt">char</span>* z = x + y;</code></pre></div>
<p>As this example shows, C is neither a memory-safe nor a type-safe language.</p>
<p>In general, type-safety and memory-safety go hand in hand&#65288;&#25163;&#25289;&#25163;&#65292;&#19968;&#36215;&#36208;&#12290;&#65289;. For example, a language that supports pointer arithmetic and number-to-pointer conversions (like C) is neither memory-safe nor type-safe, because it <strong>allows arbitrary memory to be accessed</strong> as if it were valid memory of any type.</p>
<p>Variable levels of type checking</p>
<ul>
<li>The <code>use strict</code> directive in JavaScript and Perl applies stronger checking.</li>
<li>The <code>@</code> operator in PHP suppresses some error messages.</li>
<li>The <code>Option Strict On</code> in VB.NET allows the compiler to require a conversion between objects.</li>
</ul>
</dd>
<dt>Duck typing</dt>
<dd><p>In &#8220;duck typing&#8221;, a statement calling a method <code>m</code> on an object does not rely on the declared type of the object; only that the object, of whatever type, must supply an implementation of the method called, when called, at run-time.</p>
<p>Duck typing differs from <strong>structural typing</strong> in that, if the &#8220;part&#8221; (of the whole module structure) needed for a given local computation is present at runtime, the duck type system is satisfied in its type identity analysis. On the other hand, a structural type system would require the analysis of the whole module structure at compile time to determine type identity or type dependence.</p>
<p>Duck typing differs from a <strong>nominative type</strong> system in a number of aspects. The most prominent ones are that for duck typing, <strong>type information is determined at runtime</strong> (as contrasted to compile time), and the name of the type is irrelevant to determine type identity or type dependence; only partial structure information is required for that for a given point in the program execution.</p>
<p><code>['n&#593;m&#618;n&#601;t&#618;v]</code>, &#20027;&#26684;</p>
<p>Duck typing uses the <strong>premise</strong> (<code>['prem&#618;s]</code>, &#20551;&#23450;) that (referring to a value) &#8220;<strong>if it walks like a duck, and quacks like a duck, then it is a duck</strong>&#8221; (this is a reference to the duck test that is attributed to James Whitcomb Riley). The term may have been coined[citation needed] by Alex Martelli in a 2000 message to the comp.lang.python newsgroup (see Python).</p>
<p>While one controlled experiment showed an increase in developer productivity for duck typing in single developer projects, other controlled experiments on API usability show the opposite.</p>
<dl>
<dt><a href="https://en.wikipedia.org/wiki/Duck_typing">Duck typing - Wikipedia, the free encyclopedia</a></dt>
<dd><p>In computer programming, duck typing is an application of the duck test in type safety. It requires that <strong>type checking is deferred to runtime (&#25512;&#36831;&#21040;&#36816;&#34892;&#26102;)</strong>, and is implemented by means of dynamic typing or reflection.</p>
<p>Duck typing is concerned with establishing the suitability of an object for some purpose. With normal typing, suitability is assumed to be determined by an object&#8217;s type only. In duck typing, an object&#8217;s suitability is determined by the presence of certain methods and properties (with appropriate meaning), rather than the actual type of the object. The analogy to the duck test appeared in a Python Enhancement Proposal discussion in 2002.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">Resource Acquisition Is Initialization - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p>&#36825;&#31181;&#36164;&#28304;&#31649;&#29702;&#20854;&#23454;&#36319;&#8220;&#26632;&#8221;&#21644;&#8220;&#20316;&#29992;&#22495;&#8221;&#26377;&#20851;&#12290;smart pointer &#21644; mutex &#65288;&#26631;&#20934;&#24211;&#20013;&#30340; <code class="sourceCode cpp">std::lock_guard&lt;std::mutex&gt; lock(mutex)</code>&#65292;&#25110;&#32773; Qt &#20013;&#30340; <code>QMutexLocker locker( &amp;mutex )</code>&#65289; &#37117;&#36825;&#20040;&#29992;&#12290;</p>
<p>Resource Acquisition Is Initialization (RAII) is a programming idiom used in several object-oriented languages, most prominently C++, where it originated, but also D, Ada, Vala, and Rust. The technique was developed for exception-safe resource management in C++ during 1984&#8211;89, primarily by Bjarne Stroustrup and Andrew Koenig, and the term itself was coined by Stroustrup. RAII is generally pronounced as an initialism, sometimes pronounced as &#8220;R, A, double I&#8221;.</p>
<p>The following C++11 example demonstrates usage of RAII for file access and mutex locking:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;mutex&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;fstream&gt;</span>
<span class="ot">#include &lt;stdexcept&gt;</span>

<span class="dt">void</span> write_to_file (<span class="dt">const</span> std::string &amp; message) {
    <span class="co">// mutex to protect file access (shared across threads)</span>
    <span class="dt">static</span> std::mutex mutex;    <span class="co">// &#21482;&#33021;&#26159;&#38745;&#24577;&#30340;&#65292;&#22240;&#20026; static &#25165;&#33021; lock &#19968;&#20010;&#20989;&#25968;</span>

    <span class="co">// lock mutex before accessing file</span>
    std::lock_guard&lt;std::mutex&gt; lock(mutex);

    <span class="co">// try to open file</span>
    std::ofstream file(<span class="st">&quot;example.txt&quot;</span>);
    <span class="kw">if</span> (!file.is_open())
        <span class="kw">throw</span> std::runtime_error(<span class="st">&quot;unable to open file&quot;</span>);

    <span class="co">// write message to file</span>
    file &lt;&lt; message &lt;&lt; std::endl;

    <span class="co">// file will be closed 1st when leaving scope (regardless of exception)</span>
    <span class="co">// mutex will be unlocked 2nd (from lock destructor) when leaving</span>
    <span class="co">// scope (regardless of exception)</span>
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> LockGuard {
<span class="kw">public</span>:
    LockGuard(Lock&amp; lock) : lock_(lock){ lock_.acquire();}
    ~LockGuard() <span class="kw">noexcept</span> {lock_.release();}
<span class="kw">private</span>:
    LockGuard(<span class="dt">const</span> LockGuard&amp;)=<span class="kw">delete</span>;
    LockGuard&amp; <span class="kw">operator</span>=(<span class="dt">const</span> LockGuard&amp;)=<span class="kw">delete</span>;
<span class="kw">private</span>:
    Lock&amp; lock_;
};</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" class="heart">Polymorphism (computer science) - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p>&#25351;&#38024;&#21644; reference &#30340;&#23545;&#35937;&#33258;&#21160; down cast &#21040;&#32487;&#25215;&#31867;&#22411;&#65292;&#35843;&#29992;&#23545;&#24212;&#30340;&#25805;&#20316;&#12290;</p>
<p>In programming languages and type theory, polymorphism <code>[,p&#593;l&#618;'m&#596;rf&#618;zm]</code> (from Greek &#960;&#959;&#955;&#973;&#962;, polys, &#8220;many, much&#8221; and &#956;&#959;&#961;&#966;&#942;, morph&#275;, &#8220;form, shape&#8221;) is the provision of a single interface to entities of different types. A polymorphic type is one whose operations can also be applied to values of some other type, or types. There are several fundamentally different kinds of polymorphism:</p>
<ul>
<li><p>Ad hoc polymorphism</p>
<p>when a function denotes different and potentially heterogeneous implementations depending on a limited range of individually specified types and combinations. Ad hoc polymorphism is supported in many languages using function overloading.</p></li>
<li><p>Parametric polymorphism</p>
<p>when code is written without mention of any specific type and thus can be used transparently with any number of new types. In the object-oriented programming community, this is often known as generics or generic programming. In the functional programming community, this is often shortened to polymorphism.</p></li>
<li><p>Subtyping (also called subtype polymorphism or inclusion polymorphism)</p>
<p>when a name denotes instances of many different classes related by some common superclass. In the object-oriented programming community, this is often simply referred to as polymorphism.</p>
<p><strong>Object-oriented programming languages offer subtype polymorphism using subclassing (also known as inheritance).</strong> In typical implementations, each class contains what is called a <strong>virtual table</strong>&#8212;a table of functions that implement the polymorphic part of the class interface&#8212;and each object contains a pointer to the &#8220;vtable&#8221; of its class, which is then consulted whenever a polymorphic method is called. This mechanism is an example of:</p>
<ul>
<li><strong>late binding</strong>, because virtual function calls are not bound until the time of invocation;</li>
<li><strong>single dispatch (i.e.&#160;single-argument polymorphism)</strong>, because virtual function calls are bound simply by looking through the vtable provided by the first argument (the this object), so the runtime types of the other arguments are completely irrelevant.</li>
</ul></li>
</ul>
<p>The interaction between parametric polymorphism and subtyping leads to the concepts of variance and bounded quantification.</p>
<dl>
<dt>Static and dynamic polymorphism</dt>
<dd><p>Polymorphism can be distinguished by when the implementation is selected:</p>
<ul>
<li><strong>statically (at compile time)</strong> or</li>
<li><strong>dynamically (at run time, typically via a virtual function)</strong>.</li>
</ul>
<p>This is known respectively as <strong>static dispatch</strong> and <strong>dynamic dispatch</strong>, and the corresponding forms of polymorphism are accordingly called static polymorphism and dynamic polymorphism.</p>
<p>Static polymorphism executes faster, because there is <strong>no dynamic dispatch overhead</strong>, but requires additional compiler support. Further, static polymorphism allows greater static analysis, by compilers (notably for optimization), source code analysis tools, and human readers (programmers). Dynamic polymorphism is more flexible but slower &#8211;for example, dynamic polymorphism allows <strong>duck typing</strong>, and a dynamically linked library may operate on objects without knowing their full type.</p>
<p>Static polymorphism typically occurs in ad hoc polymorphism and parametric polymorphism, whereas dynamic polymorphism is usual for subtype polymorphism. However, it is possible to achieve static polymorphism with subtyping through more sophisticated use of template metaprogramming, namely <strong>the curiously recurring template pattern</strong>.</p>
</dd>
</dl>
<p>&#22312;&#31243;&#24207;&#35774;&#35745;&#39046;&#22495;&#65292;&#19968;&#20010;&#24191;&#27867;&#35748;&#21487;&#30340;&#23450;&#20041;&#26159;&#8220;&#19968;&#31181;&#23558;&#19981;&#21516;&#30340;&#38750;&#20961;&#34892;&#20026;&#21644;&#21333;&#20010;&#27867;&#21270;&#35760;&#21495;&#30456;&#20851;&#32852;&#30340;&#33021;&#21147;&#8221;&#12290;&#21644;&#32431;&#31929;&#30340;&#38754;&#21521;&#23545;&#35937;&#31243;&#24207;&#35774;&#35745;&#35821;&#35328;&#19981;&#21516;&#65292;C++ &#20013;&#30340;&#22810;&#24577;&#26377;&#30528;&#26356;&#24191;&#27867;&#30340;&#21547;&#20041;&#12290;&#38500;&#20102;&#24120;&#35265;&#30340;&#36890;&#36807;&#31867;&#32487;&#32493;&#21644;&#34394;&#20989;&#25968;&#26426;&#21046;&#29983;&#25928;&#20110;&#36816;&#34892;&#26399;&#30340;&#21160;&#24577;&#22810;&#24577;&#65288;dynamic polymorphism&#65289;&#22806;&#65292;&#27169;&#26495;&#20063;&#31572;&#24212;&#23558;&#19981;&#21516;&#30340;&#38750;&#20961;&#34892;&#20026;&#21644;&#21333;&#20010;&#27867;&#21270;&#35760;&#21495;&#30456;&#20851;&#32852;&#65292;&#30001;&#20110;&#36825;&#31181;&#20851;&#32852;&#22788;&#29702;&#20110;&#32534;&#35793;&#26399;&#32780;&#38750;&#36816;&#34892;&#26399;&#65292;&#22240;&#27492;&#34987;&#31216;&#20026;&#38745;&#24577;&#22810;&#24577;&#65288;static polymorphism&#65289;&#12290;</p>
<ul>
<li>&#20989;&#25968;&#22810;&#24577;&#65288;function polymorphism&#65289;&#65292;function overloading&#65292;&#36890;&#36807; name mangling &#23454;&#29616;</li>
<li>&#23439;&#22810;&#24577;&#65288;macro polymorphism&#65289;&#65292;&#27604;&#22914; <code>#define ADD(A, B) (A) + (B)</code> &#21487;&#20197;&#29992;&#20110; string&#65292;&#20063;&#21487;&#20197;&#29992;&#20110; int</li>
<li>&#21160;&#24577;&#22810;&#24577;&#65288;dynamic polymorphism&#65289;&#65292;&#26368;&#24120;&#35265;&#30340;&#65292;&#34394;&#20989;&#25968;+&#25351;&#38024;/&#24341;&#29992;</li>
<li>&#38745;&#24577;&#22810;&#24577;</li>
</ul>
<p>&#21160;&#24577;&#22810;&#24577;&#21482;&#38656;&#35201;&#19968;&#20010;&#22810;&#24577;&#20989;&#25968;&#65292;&#29983;&#25104;&#30340;&#21487;&#25191;&#34892;&#20195;&#30721;&#23610;&#23544;&#36739;&#23567;&#65292;&#38745;&#24577;&#22810;&#24577;&#24517;&#39035;&#38024;&#23545;&#19981;&#21516;&#30340;&#31867;&#22411;&#20135;&#29983;&#19981;&#21516;&#30340;&#27169;&#26495;&#23454;&#20307;&#65292;&#23610;&#23544;&#20250;&#22823;&#19968;&#20123;&#65292;&#20294;&#29983;&#25104;&#30340;&#20195;&#30721;&#20250;&#26356;&#24555;&#65292;&#22240;&#20026;&#26080;&#38656;&#36890;&#36807;&#25351;&#38024;&#36827;&#34892;&#38388;&#25509;&#25805;&#20316;&#12290;&#38745;&#24577;&#22810;&#24577;&#27604;&#21160;&#24577;&#22810;&#24577;&#26356;&#21152;&#31867;&#22411;&#23433;&#20840;&#65292;&#22240;&#20026;&#20840;&#37096;&#32465;&#23450;&#37117;&#34987;&#26816;&#26597;&#20110;&#32534;&#35793;&#26399;&#12290;&#27491;&#22914;&#21069;&#38754;&#20363;&#23376;&#25152;&#31034;&#65292;&#20320;&#19981;&#21487;&#23558;&#19968;&#20010;&#38169;&#35823;&#30340;&#31867;&#22411;&#30340;&#23545;&#35937;&#25554;&#20837;&#21040;&#20174;&#19968;&#20010;&#27169;&#26495;&#23454;&#20363;&#21270;&#32780;&#26469;&#30340;&#23481;&#22120;&#20043;&#20013;&#12290;&#27492;&#22806;&#65292;&#27491;&#22914;&#20320;&#24050;&#32463;&#30475;&#21040;&#30340;&#37027;&#26679;&#65292;&#21160;&#24577;&#22810;&#24577;&#21487;&#20197;&#20248;&#38597;&#22320;&#22788;&#29702;&#24322;&#36136;&#23545;&#35937;&#38598;&#21512;&#65292;&#32780;&#38745;&#24577;&#22810;&#24577;&#21487;&#20197;&#29992;&#26469;&#23454;&#29616;&#23433;&#20840;&#12289;&#39640;&#25928;&#30340;&#21516;&#36136;&#23545;&#35937;&#38598;&#21512;&#25805;&#20316;&#12290;</p>
<p>&#38745;&#24577;&#22810;&#24577;&#20026; C++ &#24102;&#26469;&#20102;&#27867;&#22411;&#32534;&#31243;&#65288;generic programming&#65289;&#30340;&#27010;&#24565;&#12290;&#27867;&#22411;&#32534;&#31243;&#21487;&#20197;&#35748;&#20026;&#26159;&#8220;&#32452;&#20214;&#21151;&#33021;&#22522;&#20110;&#26694;&#26550;&#25972;&#20307;&#32780;&#35774;&#35745;&#8221;&#30340;&#27169;&#26495;&#32534;&#31243;&#12290;STL &#23601;&#26159;&#27867;&#22411;&#32534;&#31243;&#30340;&#19968;&#20010;&#20856;&#33539;&#12290;STL &#26159;&#19968;&#20010;&#26694;&#26550;&#65292;&#23427;&#25552;&#20379;&#20102;&#22823;&#37327;&#30340;&#31639;&#27861;&#12289;&#23481;&#22120;&#21644;&#36845;&#20195;&#22120;&#65292;&#20840;&#37096;&#20197;&#27169;&#26495;&#25216;&#26415;&#23454;&#29616;&#12290;&#20174;&#29702;&#35770;&#19978;&#35762;&#65292;STL &#30340;&#21151;&#33021;&#24403;&#28982;&#21487;&#20197;&#20351;&#29992;&#21160;&#24577;&#22810;&#24577;&#26469;&#23454;&#29616;&#65292;&#19981;&#36807;&#36825;&#26679;&#19968;&#26469;&#20854;&#24615;&#33021;&#24517;&#23558;&#22823;&#25171;&#25240;&#25187;&#12290;</p>
<p>&#38745;&#24577;&#22810;&#24577;&#36824;&#20026; C++ &#31038;&#32676;&#24102;&#26469;&#20102;&#27867;&#22411;&#27169;&#24335;&#65288;generic patterns&#65289;&#30340;&#27010;&#24565;&#12290;&#29702;&#35770;&#19978;&#65292;&#27599;&#19968;&#20010;&#38656;&#35201;&#36890;&#36807;&#34394;&#20989;&#25968;&#21644;&#31867;&#32487;&#32493;&#32780;&#25903;&#25345;&#30340;&#35774;&#35745;&#27169;&#24335;&#37117;&#21487;&#20197;&#21033;&#29992;&#22522;&#20110;&#27169;&#26495;&#30340;&#38745;&#24577;&#22810;&#24577;&#25216;&#26415;&#65288;&#29978;&#33267;&#21487;&#20197;&#32467;&#21512;&#20351;&#29992;&#21160;&#24577;&#22810;&#24577;&#21644;&#38745;&#24577;&#22810;&#24577;&#20004;&#31181;&#25216;&#26415;&#65289;&#32780;&#23454;&#29616;&#12290;&#27491;&#22914;&#20320;&#30475;&#21040;&#30340;&#37027;&#26679;&#65292;Andrei Alexandrescu &#30340;&#22825;&#25165;&#20316;&#21697; Modern C++ Design: Generic Programming and Design Patterns Applied&#65288;Addison-Wesley&#65289;&#21644; Loki &#31243;&#24207;&#24211;&#24050;&#32463;&#36208;&#22312;&#20102;&#25105;&#20204;&#30340;&#21069;&#38754;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.cnblogs.com/hongzg1982/archive/2011/05/11/2042920.html">C++&#22810;&#24577; - &#19981;&#30693;&#36947; - &#21338;&#23458;&#22253;</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://en.wikipedia.org/wiki/Virtual_inheritance" class="heart">Virtual inheritance - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p>&#21482;&#26159;&#36991;&#20813;&#27495;&#20041;&#30340;&#19968;&#31181;&#26041;&#24335;&#12290;</p>
<p>Virtual inheritance is a technique used in C++, where a particular base class in an <strong>inheritance hierarchy</strong> is declared to share its member data instances with any other inclusions of that same base in further derived classes. For example, if class A is normally (non-virtually) derived from class X (assumed to contain data members), and if class B is also derived from class X, and class C inherits from both classes A and B, it will contain two sets of the data members associated with class X (accessible independently, often with suitable disambiguating qualifiers). But if class A is virtually derived from class X instead, then objects of class C will contain only one set of the data members from class X. &#36825;&#20010;&#20363;&#23376;&#20687;&#19981;&#20687;&#26159;&#36817;&#20146;&#32467;&#23130;&#65311;&#8230;&#8230;</p>
This feature is most useful for <strong>multiple inheritance</strong>, as it makes the virtual base a common subobject for the deriving class and all classes that are derived from it. This can be used to avoid the diamond problem by clarifying ambiguity over which ancestor class to use, as from the perspective of the deriving class (C in the example above) the virtual base
<ol start="24" style="list-style-type: upper-alpha">
<li>acts as though it were the direct base class of C, not a class derived indirectly through its base (A).</li>
</ol>
<p>It is used when inheritance represents restriction of a set rather than composition of parts. In C++, a base class intended to be common throughout the hierarchy is denoted as virtual with the <code>virtual</code> keyword.</p>
<p>Consider the following class hierarchy.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Animal {
 <span class="kw">public</span>:
  <span class="kw">virtual</span> <span class="dt">void</span> eat();
};

<span class="kw">class</span> Mammal : <span class="kw">public</span> Animal {
 <span class="kw">public</span>:
  <span class="kw">virtual</span> <span class="dt">void</span> breathe();
};

<span class="kw">class</span> WingedAnimal : <span class="kw">public</span> Animal {
 <span class="kw">public</span>:
  <span class="kw">virtual</span> <span class="dt">void</span> flap();
};

<span class="co">// A bat is a winged mammal</span>
<span class="kw">class</span> Bat : <span class="kw">public</span> Mammal, <span class="kw">public</span> WingedAnimal {
};

Bat bat;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Bat b;
Animal &amp;a = b; <span class="co">// error: which Animal subobject should a Bat cast into,</span>
               <span class="co">// a Mammal::Animal or a WingedAnimal::Animal?</span></code></pre></div>
<p>To disambiguate, one would have to explicitly convert bat to either base class subobject:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Bat b;
Animal &amp;mammal = <span class="kw">static_cast</span>&lt;Mammal&amp;&gt; (b);
Animal &amp;winged = <span class="kw">static_cast</span>&lt;WingedAnimal&amp;&gt; (b);

<span class="kw">static_cast</span>&lt;Mammal&amp;&gt;(bat).eat();
bat.Mammal::eat();</code></pre></div>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8e/Diamond_inheritance.svg/330px-Diamond_inheritance.svg.png" alt="the diamond problem" />
<p class="caption">the diamond problem</p>
</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Animal {
 <span class="kw">public</span>:
  <span class="kw">virtual</span> <span class="dt">void</span> eat();
};

<span class="co">// Two classes virtually inheriting Animal:</span>
<span class="kw">class</span> Mammal : <span class="kw">public</span> <span class="kw">virtual</span> Animal {
 <span class="kw">public</span>:
  <span class="kw">virtual</span> <span class="dt">void</span> breathe();
};

<span class="kw">class</span> WingedAnimal : <span class="kw">public</span> <span class="kw">virtual</span> Animal {
 <span class="kw">public</span>:
  <span class="kw">virtual</span> <span class="dt">void</span> flap();
};

<span class="co">// A bat is still a winged mammal</span>
<span class="kw">class</span> Bat : <span class="kw">public</span> Mammal, <span class="kw">public</span> WingedAnimal {
};</code></pre></div>
<p>The Animal portion of <code>Bat::WingedAnimal</code> is now the same <code>Animal</code> instance as the one used by <code>Bat::Mammal</code>, which is to say that a Bat has only one, shared, <code>Animal</code> instance in its representation and so a call to <code>Bat::eat()</code> is unambiguous. Additionally, a direct cast from Bat to Animal is also unambiguous, now that there exists only one Animal instance which Bat could be converted to.</p>
<p>The ability to share a single instance of the Animal parent between <code>Mammal</code> and <code>WingedAnimal</code> is enabled by recording the <strong>memory offset</strong> between the Mammal or WingedAnimal members and those of the base Animal within the derived class. However this offset can in the general case only be known at runtime, thus Bat must become (<code>vpointer</code>, Mammal, vpointer, WingedAnimal, Bat, Animal). There are two vtable pointers, one per inheritance hierarchy that virtually inherits Animal. In this example, one for Mammal and one for WingedAnimal. The object size has therefore increased by two pointers, but now there is only one Animal and no ambiguity. <strong>All objects of type Bat will use the same vpointers, but each Bat object will contain its own unique Animal object.</strong> If another class inherits from Mammal, such as Squirrel, then the vpointer in the Mammal part of Squirrel will generally be different to the vpointer in the Mammal part of Bat though they may happen to be the same should the Squirrel class be the same size as Bat.</p>
<dl>
<dt><a href="https://en.wikipedia.org/wiki/Vtable">Virtual method table - Wikipedia, the free encyclopedia</a></dt>
<dd><p>A virtual method table (VMT), virtual function table, virtual call table, dispatch table, vtable, or vftable is a mechanism used in a programming language to support dynamic dispatch (or run-time method binding).</p>
<p>Whenever a class defines a virtual function (or method), most compilers add a hidden member variable to the class which points to an array of pointers to (virtual) functions called the virtual method table (VMT or Vtable). These pointers are used at runtime to invoke the appropriate function implementations, because at compile time it may not yet be known if the base function is to be called or a derived one implemented by a class that inherits from the base class.</p>
<p>TODO.</p>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://en.wikipedia.org/wiki/Run-time_type_information">Run-time type information - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p>In computer programming, <strong>RTTI</strong> (Run-Time Type Information, or Run-Time Type Identification) refers to a C++ mechanism that exposes information about an object&#8217;s data type at runtime. Run-time type information can apply to simple data types, such as integers and characters, or to generic types. This is a C++ specialization of a more general concept called <strong>type introspection</strong>. Similar mechanisms are also known in other programming languages, such as Delphi (Object Pascal).</p>
<p>In the original C++ design, Bjarne Stroustrup did not include run-time type information, because he thought this mechanism was frequently misused.</p>
<p>Any function that gets class information explicitly at runtime:</p>
<ul>
<li><strong>typeid</strong></li>
<li><strong>dynamic_cast</strong></li>
</ul>
<p>Google style 3.26 discourages this, since if you really need it your design is probably flawed.</p>
<p>Also using typeid on variables means that extra meta data must be kept about those variables.</p>
<dl>
<dt>&#25191;&#34892;&#26399;&#31867;&#22411;&#35782;&#21035;&#65288;Runtime Type Identification RTTI&#65289; <code class="foldable">@</code></dt>
<dd><ol style="list-style-type: decimal">
<li>RTTI &#21482;&#25903;&#25345;&#22810;&#24577;&#31867;&#65292;&#20063;&#23601;&#26159;&#35828;&#27809;&#26377;&#23450;&#20041;&#34394;&#20989;&#25968;&#26159;&#30340;&#31867;&#26159;&#19981;&#33021;&#36827;&#34892; RTTI &#30340;&#12290;</li>
<li>&#23545;&#25351;&#38024;&#36827;&#34892; dynamic_cast &#22833;&#36133;&#20250;&#36820;&#22238; NULL , &#32780;&#23545;&#24341;&#29992;&#30340;&#35805;&#65292;&#35782;&#21035;&#20250;&#25243;&#20986; bad_cast exception&#12290;</li>
<li>typeid &#21487;&#20197;&#36820;&#22238; const type_info&amp;&#65292;&#29992;&#20197;&#33719;&#21462;&#31867;&#22411;&#20449;&#24687;&#12290;</li>
</ol>
<p>&#20851;&#20110; 1 &#26159;&#22240;&#20026; RTTI &#30340;&#23454;&#29616;&#26159;&#36890;&#36807; vptr &#26469;&#33719;&#21462;&#23384;&#20648;&#22312;&#34394;&#20989;&#25968;&#34920;&#20013;&#30340; type_info* &#65292;&#20107;&#23454;&#19978;&#20026;&#38750;&#22810; &#24577;&#31867;&#25552;&#20379; RTTI, &#20063;&#27809;&#26377;&#22810;&#22823;&#24847;&#20041;&#12290; 2 &#30340;&#21407;&#22240;&#22312;&#20110;&#25351;&#38024;&#21487;&#20197;&#34987;&#36171;&#20540;&#20026; 0&#65292;&#20197;&#34920;&#31034;no object&#65292;&#20294;&#26159; &#24341;&#29992;&#19981;&#34892;&#12290;&#20851;&#20110; 3&#65292;&#34429;&#28982;&#31532;&#19968;&#28857;&#25351;&#20986; RTTI &#21482;&#25903;&#25345;&#22810;&#24577;&#31867;&#65292;&#20294; typeid &#21644;type_info &#21516;&#26679;&#21487;&#29992;&#20110; &#20869;&#24314;&#31867;&#22411;&#21450;&#25152;&#26377;&#38750;&#22810;&#24577;&#31867;&#12290;&#19982;&#22810;&#24577;&#31867;&#30340;&#24046;&#21035;&#22312;&#20110;&#65292;&#38750;&#22810;&#24577;&#31867;&#30340;type_info &#23545;&#35937;&#26159;&#38745;&#24577;&#21462;&#24471; (&#25152; &#20197;&#19981;&#33021;&#21483;&#8220;&#25191;&#34892;&#26399;&#31867;&#22411;&#35782;&#21035;&#8221;)&#65292;&#32780;&#22810;&#24577;&#31867;&#30340;&#26159;&#22312;&#25191;&#34892;&#26399;&#33719;&#24471;&#12290;</p>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://en.wikipedia.org/wiki/Critical_section">Critical section - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p>In concurrent programming, a critical section or critical region is a part of a multi-threaded program that may not be concurrently executed by more than one of the program&#8217;s processes. In other words, it is <strong>a piece of a program that requires mutual exclusion of access</strong>. Typically, the critical section accesses a shared resource, such as a data structure, a peripheral device, or a network connection, that does not allow multiple concurrent accesses.</p>
<dl>
<dt><a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">Lock (computer science) - Wikipedia, the free encyclopedia</a></dt>
<dd><p>In computer science, a lock or mutex (from mutual exclusion) is a <strong>synchronization mechanism for enforcing limits on access</strong> to a resource in an environment where there are many threads of execution. A lock is designed to enforce a mutual exclusion concurrency control policy.</p>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://en.wikipedia.org/wiki/Opaque_pointer">Opaque pointer - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p><code>[o'pek]</code> &#19981;&#36879;&#26126;&#12290;</p>
<p>&#23601;&#26159; pimpl &#30340;&#23454;&#29616;&#12290;&#65288;pimpl &#21644; pimple&#65288;&#30168;&#30168;&#65289;&#21457;&#38899;&#31867;&#20284;&#65292;&#19981;&#36807;&#22909;&#20687; <code>i</code> &#24212;&#35813;&#27861;&#25104; <code>ai</code>&#65289;</p>
<p>&#20854;&#23454;&#21033;&#29992;&#20102;&#25351;&#38024;&#31867;&#22411;&#22312;&#22836;&#25991;&#20214;&#20013;&#12304;&#19981;&#38656;&#35201;&#23436;&#20840;&#23450;&#20041;&#12305;&#30340;&#29305;&#28857;&#12290;&#65288;&#26356;&#28145;&#21051;&#30340;&#21407;&#22240;&#65292;&#26159;&#65306;&#25351;&#38024;&#22823;&#23567;&#26159;&#19968;&#26679;&#30340;&#12290;&#26681;&#25454;&#22836;&#25991;&#20214;&#24050;&#32463;&#21487;&#20197;&#30830;&#23450;&#19968;&#20010; Class object &#30340;&#20869;&#23384;&#24067;&#23616;&#65289;</p>
<p>Opaque pointers are a way to <strong>hide the implementation details</strong> of an interface from ordinary clients, so that the implementation may be changed without the need to recompile the modules using it. This benefits the programmer as well since a simple interface can be created, and most details can be hidden in another file. This is important for providing binary code compatibility through different versions of a shared library, for example.</p>
<p>This technique is described in Design Patterns as the <strong>Bridge pattern</strong>. It is sometimes referred to as <strong>&#8220;handle classes&#8221;</strong>, the <strong>&#8220;Pimpl idiom&#8221;</strong> (for &#8220;pointer to implementation idiom&#8221;), <strong>&#8220;Compiler firewall idiom&#8221;</strong>, &#8220;d-pointer&#8221; or &#8220;Cheshire Cat&#8221;, especially among the C++ community.</p>
<ul>
<li><dl>
<dt>C example <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>obj.h <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> obj;

<span class="co">/*</span>
<span class="co"> * The compiler considers struct obj an incomplete type. Incomplete types</span>
<span class="co"> * can be used in declarations.</span>
<span class="co"> */</span>

size_t obj_size(<span class="dt">void</span>);

<span class="dt">void</span> obj_setid(<span class="kw">struct</span> obj *, <span class="dt">int</span>);

<span class="dt">int</span> obj_getid(<span class="kw">struct</span> obj *);</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>obj.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;obj.h&quot;</span>

<span class="kw">struct</span> obj {
    <span class="dt">int</span> id;
};

<span class="co">/*</span>
<span class="co"> * The caller will handle allocation.</span>
<span class="co"> * Provide the required information only</span>
<span class="co"> */</span>

size_t obj_size(<span class="dt">void</span>) {
    <span class="kw">return</span> <span class="kw">sizeof</span>(<span class="kw">struct</span> obj);
}

<span class="dt">void</span> obj_setid(<span class="kw">struct</span> obj *o, <span class="dt">int</span> i) {
    o-&gt;id = i;
}

<span class="dt">int</span> obj_getid(<span class="kw">struct</span> obj *o) {
    <span class="kw">return</span> o-&gt;id;
}</code></pre></div>
</dd>
</dl></li>
</ul>
<p>This example demonstrates a way to achieve the <strong>information hiding (encapsulation)</strong> aspect of object-oriented programming using the C language. If someone wanted to change the declaration of struct obj, it would be unnecessary to recompile any other modules in the program that use the obj.h header file unless the API was also changed.</p>
</dd>
</dl></li>
<li><dl>
<dt>C++ example <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>PublicClass.h <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> PublicClass {
<span class="kw">public</span>:
    PublicClass();                              <span class="co">// Constructor</span>
    PublicClass(<span class="dt">const</span> PublicClass&amp;);            <span class="co">// Copy constructor</span>
    PublicClass(PublicClass&amp;&amp;);                 <span class="co">// Move constructor</span>
    PublicClass&amp; <span class="kw">operator</span>=(<span class="dt">const</span> PublicClass&amp;); <span class="co">// Copy assignment operator</span>
    ~PublicClass();                             <span class="co">// Destructor</span>
    <span class="co">// Other operations...</span>

<span class="kw">private</span>:
    <span class="kw">struct</span> CheshireCat;                         <span class="co">// Not defined here</span>
    <span class="co">// &#36825;&#37324;&#20540;&#24471;&#27880;&#24847;&#30340;&#26159;&#27169;&#26495;&#37324;&#38754;&#31867;&#22411;&#26159; CheshireCat &#32780;&#19981;&#26159; CheshireCat *&#65292;</span>
    <span class="co">// &#32780;&#19988; unique_ptr&lt;CheshireCat&gt; &#26159;&#19968;&#31181;&#31867;&#22411;&#65292;&#36825;&#37324;&#19981;&#38656;&#35201; struct CheshireCat &#26377;</span>
    <span class="co">// &#23436;&#25972;&#30340;&#23450;&#20041;&#65292;&#22909;&#20687;&#26159;&#36825;&#26679; ==</span>
    unique_ptr&lt;CheshireCat&gt; d_ptr;              <span class="co">// opaque pointer</span>
};</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>PublicClass.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//CPP file:</span>
<span class="ot">#include &quot;PublicClass.h&quot;</span>

<span class="kw">struct</span> PublicClass::CheshireCat {
    <span class="dt">int</span> a;
    <span class="dt">int</span> b;
};

PublicClass::PublicClass()
    : d_ptr(<span class="kw">new</span> CheshireCat()) {
    <span class="co">// do nothing</span>
}

PublicClass::PublicClass(<span class="dt">const</span> PublicClass&amp; other)
    : d_ptr(<span class="kw">new</span> CheshireCat(*other.d_ptr)) {
    <span class="co">// do nothing</span>
}

PublicClass::PublicClass(PublicClass&amp;&amp; other) = <span class="kw">default</span>;

PublicClass&amp; PublicClass::<span class="kw">operator</span>=(<span class="dt">const</span> PublicClass &amp;other) {
    *d_ptr = *other.d_ptr;
    <span class="kw">return</span> *<span class="kw">this</span>;
}

PublicClass::~PublicClass() = <span class="kw">default</span>;</code></pre></div>
</dd>
</dl></li>
</ul>
<p>One type of opaque pointer commonly used in C++ class declarations is the d-pointer. The d-pointer is the only private data member of the class and points to an instance of a struct. Named by Arnt Gulbrandsen of Trolltech, this method allows class declarations to omit private data members, except for the d-pointer itself. The result: (a) more of the class implementation is hidden from view; (b) adding new data members to the private struct does not affect binary compatibility; (c) the header file containing the class declaration only needs to #include those other files needed for the class interface, rather than for its implementation. One side benefit is that compilations are faster because the header file changes less often. The d-pointer is heavily used in the Qt and KDE libraries.</p>
</dd>
</dl></li>
</ul>
<p>TODO: read the refs and see also.</p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=242">C++ Reference Guide | The Handle/Body Idiom | InformIT</a></li>
<li><a href="https://en.wikibooks.org/wiki/C%2B%2B_Programming/Idioms#Pointer_To_Implementation_.28pImpl.29">C++ Programming/Idioms - Wikibooks, open books for an open world</a></li>
<li><a href="http://www.thefullwiki.org/More_C%2B%2B_Idioms/Handle_Body">More C++ Idioms/Handle Body : Wikis (The Full Wiki)</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms">More C++ Idioms - Wikibooks, open books for an open world</a> <code class="fold">@</code></dt>
<dd><p>TODO</p>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://en.wikipedia.org/wiki/Placement_syntax">Placement syntax - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p><strong>Placement new allows you to construct an object on memory that&#8217;s already allocated.</strong></p>
<p>You may want to do this for optimizations (it is faster not to re-allocate all the time) but you need to re-construct an object multiple times. If you need to keep re-allocating it might be more efficient to allocate more than you need, even though you don&#8217;t want to use it yet.</p>
<p>Devex gives a good example:</p>
<blockquote>
<p>Standard C++ also supports placement new operator, which constructs an object on a pre-allocated buffer. This is useful when building a memory pool, a garbage collector or simply when performance and exception safety are paramount (there&#8217;s no danger of allocation failure since the memory has already been allocated, and constructing an object on a pre-allocated buffer takes less time):</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> *buf  = <span class="kw">new</span> <span class="dt">char</span>[<span class="kw">sizeof</span>(string)]; <span class="co">// pre-allocated buffer</span>
string *p = <span class="kw">new</span> (buf) string(<span class="st">&quot;hi&quot;</span>);    <span class="co">// placement new</span>
string *q = <span class="kw">new</span> string(<span class="st">&quot;hi&quot;</span>);          <span class="co">// ordinary heap allocation</span></code></pre></div>
<p>You may also want to be sure there can be no allocation failure at a certain part of critical code (maybe you work on a pacemaker for example). In that case you would want to use placement new.</p>
<p><strong>Deallocation in placement new</strong></p>
<p>You should not deallocate every object that is using the memory buffer. Instead you should <code>delete[]</code> only the original buffer. You would have to then call the destructors directly of your classes manually. For a good suggestion on this please see Stroustrup&#8217;s FAQ on: <a href="http://www.stroustrup.com/bs_faq2.html#placement-delete">Is there a &#8220;placement delete&#8221;?</a></p>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/222557/what-uses-are-there-for-placement-new">c++ - What uses are there for &#8220;placement new&#8221;? - Stack Overflow</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt><a href="http://en.cppreference.com/w/cpp/types/ptrdiff_t">std::ptrdiff_t - cppreference.com</a> <code class="fold">@</code></dt>
<dd>refs and see also
<ul>
<li><a href="https://en.wikipedia.org/wiki/C_data_types#Type_ptrdiff_t">C data types - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://en.wikipedia.org/wiki/Return_value_optimization">Return value optimization - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p>In the context of the C++ programming language, the return value optimization (RVO) is a compiler optimization that involves eliminating the temporary object created to hold a function&#8217;s return value. The RVO is particularly notable for being allowed to change the observable behaviour of the resulting program by the C++ standard.</p>
<p>&#22914;&#19979;&#30340;&#20195;&#30721;&#65292;&#26377;&#24471;&#32534;&#35793;&#22120;&#20250;&#36755;&#20986;&#19977;&#20010; &#8220;A copy was made.&#8221; &#26377;&#24471;&#29978;&#33267;&#21487;&#20197;&#19968;&#20010;&#37117;&#19981;&#36755;&#20986;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">struct</span> C {
  C() {}
  C(<span class="dt">const</span> C&amp;) { std::cout &lt;&lt; <span class="st">&quot;A copy was made.</span><span class="ch">\n</span><span class="st">&quot;</span>; }
};

C f() {
  <span class="kw">return</span> C();
}

<span class="dt">int</span> main() {
  std::cout &lt;&lt; <span class="st">&quot;Hello World!</span><span class="ch">\n</span><span class="st">&quot;</span>;
  C obj = f();
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>&#26377; ROV &#21518;&#30340;&#26679;&#23376;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#25105;&#20204;&#30340;&#25968;&#25454;</span>
<span class="kw">struct</span> Data {
  <span class="dt">char</span> bytes;
};

<span class="co">// &#21407;&#26469;&#22914;&#27492;</span>
Data f() {
  Data result = {};
  <span class="co">// generate result</span>
  <span class="kw">return</span> result;
}

<span class="dt">int</span> main() {
  Data d = f();
}

<span class="co">// &#36716;&#25104; C &#35821;&#35328;&#22823;&#27010;&#22914;&#27492;&#65292;&#25335;&#36125;&#20102;&#20004;&#27425;</span>
Data * f(Data * _hiddenAddress) {
  Data result = {};
  <span class="co">// copy result into hidden object</span>
  *_hiddenAddress = result;                         <span class="co">//  &#36825;&#37324;&#65292;&#25335;&#36125;</span>
  <span class="kw">return</span> _hiddenAddress;
}

<span class="dt">int</span> main() {
  Data _hidden; <span class="co">// create hidden object</span>
  Data d = *f(&amp;_hidden); <span class="co">// copy the result into d&#65292;&#21448;&#19968;&#27425;&#25335;&#36125;</span>
}

<span class="co">// ROV &#20248;&#21270;&#30340;&#24847;&#24605;&#22823;&#27010;&#22914;&#27492;</span>
<span class="dt">void</span> f(Data *p) {
  <span class="co">// generate result directly in *p</span>
}

<span class="dt">int</span> main() {
  Data d;
  f(&amp;d);
}</code></pre></div>
<p>&#26377;&#26102;&#20505; ROV &#26159;&#19981;&#33021;&#23454;&#29616;&#30340;&#65292;&#22240;&#20026;&#36825;&#20010;&#20989;&#25968;&#30340;&#36820;&#22238;&#26102;&#19981;&#30830;&#23450;&#30340;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;string&gt;</span>
std::string f(<span class="dt">bool</span> cond = <span class="kw">false</span>) {
    std::string first(<span class="st">&quot;first&quot;</span>);
    std::string second(<span class="st">&quot;second&quot;</span>);
    <span class="co">// the function may return one of two named objects</span>
    <span class="co">// depending on its argument. RVO might not be applied</span>
    <span class="kw">return</span> cond ? first : second;
}

<span class="dt">int</span> main() {
    std::string result = f();
}</code></pre></div>
<p>ROV &#31639;&#26159;&#19968;&#31181; Copy elision &#25226;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/language/copy_elision">Copy elision - cppreference.com</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/RVO_V_S_std_move?lang=en">RVO V.S. std::move (C/C++ Cafe)</a> <code class="fold">@</code></dt>
<dd><p>RVO&#12289;std::move&#65292;COW &#30340;&#36866;&#29992;&#26465;&#20214;</p>
<p>Return value optimization, simply RVO, is a compiler optimization technique that allows the compiler to construct the return value of a function at the call site. The technique is also named &#8220;elision&#8221;. C++98/03 standard doesn&#8217;t require the compiler to provide RVO optimization, but most popular C++ compilers contain this optimization technique, such as IBM XL C++ compiler, GCC and Clang . This optimization technique is included in the C++11 standard due to its prevalence. As defined in Section 12.8 in the C++11 standard, the name of the technique is &#8220;<strong>copy elision</strong>&#8221;.</p>
<div class="figure">
<img src="https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/resource/BLOGS_UPLOADED_IMAGES/%E5%9B%BE%E7%89%871.png" />

</div>
<div class="figure">
<img src="https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/resource/BLOGS_UPLOADED_IMAGES/%E5%9B%BE%E7%89%872.png" alt="&#26377; ROV &#21518;&#65292;&#23376;&#31243;&#24207;&#30452;&#25509;&#29992;&#22806;&#23618;&#30340;&#21464;&#37327;&#22320;&#22336;" />
<p class="caption">&#26377; ROV &#21518;&#65292;&#23376;&#31243;&#24207;&#30452;&#25509;&#29992;&#22806;&#23618;&#30340;&#21464;&#37327;&#22320;&#22336;</p>
</div>
<p>&#20877;&#30475;&#30475; std::move &#30340;&#23450;&#20041;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
<span class="kw">decltype</span>(<span class="kw">auto</span>) move(T&amp;&amp; param)
{
    <span class="co">// cast its argument to an rvalue, instructing the compiler that</span>
    <span class="co">// it is eligible to move the object</span>
    <span class="kw">using</span> ReturnType = remove_reference_t&lt;T&gt;&amp;&amp;;
    <span class="kw">return</span> <span class="kw">static_cast</span>&lt;ReturnType&gt;(param);
}</code></pre></div>
<p>So you can also call &#8220;std::move&#8221; as &#8220;std::rvalue_cast&#8221;, which seems to be more appropriate than &#8220;std::move&#8221;.</p>
<p>The price of moving is lower than coping but higher than RVO. Moving does the following two things:</p>
<ul>
<li>Steal all the data</li>
<li>Trick the object we steal into forgetting everything</li>
</ul>
<p>If we want to instruct the compiler to move, we can define move constructor and move assignment operator. I just define move constructor for convenience here. &#65288;&#26377;&#28857;&#30452;&#25509;&#8220;&#24039;&#22842;&#8221;&#23545;&#26041;&#19968;&#20999;&#30340;&#24863;&#35273;&#65289;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">BigObject(BigObject&amp;&amp;) {
    cout &lt;&lt; <span class="st">&quot;move constructor&quot;</span>&lt;&lt; endl;
}

BigObject foo(<span class="dt">int</span> n) {
    BigObject localObj, anotherLocalObj;
    <span class="kw">if</span> (n &gt; <span class="dv">2</span>) {
        <span class="kw">return</span> std::move(localObj);
    } <span class="kw">else</span> {
        <span class="kw">return</span> std::move(anotherLocalObj);
    }
}</code></pre></div>
<p>To summarize, RVO is a compiler optimization technique, while std::move is just an rvalue cast, which also instructs the compiler that it&#8217;s eligible to move the object. The price of moving is lower than copying but higher than RVO, so never apply std::move to local objects if they would otherwise be eligible for the RVO.</p>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://en.wikipedia.org/wiki/Smart_pointer">Smart pointer - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p>In computer science, a smart pointer is an abstract data type that <strong>simulates a pointer while providing added features, such as automatic memory management or bounds checking</strong>. Such features are intended to reduce bugs caused by the misuse of pointers, while retaining efficiency. Smart pointers typically keep track of the memory they point to, and may also be used to manage other resources, such as network connections and file handles. Smart pointers originated in the programming language C++.</p>
<p>&#20174;&#36739;&#27973;&#30340;&#23618;&#38754;&#30475;&#65292;&#26234;&#33021;&#25351;&#38024;&#26159;&#21033;&#29992;&#20102;&#19968;&#31181;&#21483;&#20570; RAII&#65288;&#36164;&#28304;&#33719;&#21462;&#21363;&#21021;&#22987;&#21270;&#65289;&#30340;&#25216;&#26415;&#23545;&#26222;&#36890;&#30340;&#25351;&#38024;&#36827;&#34892;&#23553;&#35013;&#65292;&#36825;&#20351;&#24471;&#26234;&#33021;&#25351;&#38024;&#23454;&#36136;&#26159;&#19968;&#20010;&#23545;&#35937;&#65292;&#34892;&#20026;&#34920;&#29616;&#30340;&#21364;&#20687;&#19968;&#20010;&#25351;&#38024;&#12290;&#20316;&#29992;&#24403;&#28982;&#24456;&#26126;&#26174;&#65292;<strong>&#38450;&#27490;&#24536;&#35760;&#35843;&#29992; delete</strong>&#65292;&#24403;&#28982;&#36824;&#26377;&#21478;&#19968;&#20010;&#20316;&#29992;&#65292; <span class="citation">@&#32993;&#26122;</span> &#20063;&#25351;&#20986;&#26469;&#20102;&#65292;&#23601;&#26159;<strong>&#24322;&#24120;&#23433;&#20840;</strong>&#12290;&#22312;&#19968;&#27573;&#36827;&#34892;&#20102;try/catch&#30340;&#20195;&#30721;&#27573;&#37324;&#38754;&#65292;&#21363;&#20351;&#20320;&#20889;&#20837;&#20102; delete&#65292;&#20063;&#26377;&#21487;&#33021;&#22240;&#20026;&#21457;&#29983;&#24322;&#24120;&#65292;&#31243;&#24207;&#36827;&#20837; catch &#22359;&#65292;&#20174;&#32780;&#24536;&#35760;&#37322;&#25918;&#20869;&#23384;&#65292;&#36825;&#20123;&#37117;&#21487;&#20197;&#36890;&#36807;&#26234;&#33021;&#25351;&#38024;&#35299;&#20915;&#12290;&#65288;&#36825;&#20854;&#23454;&#26159;1&#65289;RAII &#21644; 2&#65289;stack &#19978;&#21464;&#37327;&#22312;&#20986; stack &#30340;&#26102;&#20505;&#19968;&#23450;&#20250; destruct &#24102;&#26469;&#30340;&#22909;&#22788;&#12290;&#65289;</p>
<p>&#20294;&#26159;&#26234;&#33021;&#25351;&#38024;&#36824;&#26377;&#19968;&#37325;&#26356;&#21152;&#28145;&#21051;&#30340;&#21547;&#20041;&#65292;&#23601;&#26159;&#25226; <span class="citation">@&#38472;&#30805;&#25152;&#35828;&#30340;</span> <strong>value&#35821;&#20041;</strong>&#36716;&#21270;&#20026; <strong>reference&#35821;&#20041;</strong>&#12290;&#65288;&#22240;&#20026;&#20320;&#33258;&#24049;&#23454;&#29616;&#20102; copy constructor&#65292;dtor&#65292;copy assignment operator&#12290;&#65289;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::shared_ptr&lt;some_type&gt;
<span class="kw">auto</span> s = std::make_shared&lt;some_type&gt;(constructor, parameters, here);

std::unique_ptr&lt;some_type&gt;
<span class="kw">auto</span> u = std::make_unique&lt;some_type&gt;(constructor, parameters, here);</code></pre></div>
<dl>
<dt><code>unique_ptr</code> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::unique_ptr&lt;<span class="dt">int</span>&gt; p1(<span class="kw">new</span> <span class="dt">int</span>(<span class="dv">5</span>));

<span class="co">// Compile error.</span>
std::unique_ptr&lt;<span class="dt">int</span>&gt; p2 = p1;

<span class="co">// Transfers ownership. p3 now owns the memory and p1 is rendered invalid.</span>
std::unique_ptr&lt;<span class="dt">int</span>&gt; p3 = std::move(p1);

p3.reset(); <span class="co">// Deletes the memory.</span>
p1.reset(); <span class="co">// Does nothing.</span></code></pre></div>
</dd>
<dt><code>shared_ptr</code> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::shared_ptr&lt;<span class="dt">int</span>&gt; p1(<span class="kw">new</span> <span class="dt">int</span>(<span class="dv">5</span>));
std::shared_ptr&lt;<span class="dt">int</span>&gt; p2 = p1; <span class="co">// Both now own the memory.</span>

p1.reset(); <span class="co">// Memory still exists, due to p2.</span>
p2.reset(); <span class="co">// Deletes the memory, since no one else owns the memory.</span></code></pre></div>
<p><code>shared_ptr</code> &#20013;&#25152;&#23454;&#29616;&#30340;&#26412;&#36136;&#26159;<strong>&#24341;&#29992;&#35745;&#25968;(reference counting)</strong>&#65292;&#20063;&#23601;&#26159;&#35828; <code>shared_ptr</code> &#26159;&#25903;&#25345;&#22797;&#21046;&#30340;&#65292;&#22797;&#21046;&#19968;&#20010; <code>shared_ptr</code> &#30340;&#26412;&#36136;&#26159;&#23545;&#36825;&#20010;&#26234;&#33021;&#25351;&#38024;&#30340;&#24341;&#29992;&#27425;&#25968;&#21152; 1&#65292;&#32780;&#24403;&#36825;&#20010;&#26234;&#33021;&#25351;&#38024;&#30340;&#24341;&#29992;&#27425;&#25968;&#38477;&#20302;&#21040; 0 &#30340;&#26102;&#20505;&#65292;&#35813;&#23545;&#35937;&#33258;&#21160;&#34987;&#26512;&#26500;&#12290;</p>
<p>&#38656;&#35201;&#29305;&#21035;&#25351;&#20986;&#30340;&#26159;&#65292;&#22914;&#26524; <code>shared_ptr</code> &#25152;&#34920;&#24449;&#30340;&#24341;&#29992;&#20851;&#31995;&#20013;&#20986;&#29616;&#19968;&#20010;&#29615;(???&#20363;&#23376;&#65311;)&#65292;&#37027;&#20040;&#29615;&#19978;&#25152;&#36848;&#23545;&#35937;&#30340;&#24341;&#29992;&#27425;&#25968;&#37117;&#32943;&#23450;&#19981;&#21487;&#33021;&#20943;&#20026; 0 &#37027;&#20040;&#20063;&#23601;&#19981;&#20250;&#34987;&#21024;&#38500;&#65292;&#20026;&#20102;&#35299;&#20915;&#36825;&#20010;&#38382;&#39064;&#24341;&#20837;&#20102; weak_ptr&#12290;</p>
<dl>
<dt><a href="http://www.boost.org/doc/libs/1_61_0/libs/smart_ptr/shared_ptr.htm">shared_ptr - 1.61.0</a></dt>
<dd><p>TODO. Chenshuo &#25512;&#33616;&#38405;&#35835;&#12290;</p>
</dd>
</dl>
</dd>
<dt><code>weak_ptr</code> <code class="fold">@</code></dt>
<dd><p>&#23545; weak_ptr &#36215;&#30340;&#20316;&#29992;&#65292;&#24456;&#22810;&#20154;&#26377;&#33258;&#24049;&#19981;&#21516;&#30340;&#29702;&#35299;&#65292;&#25105;&#29702;&#35299;&#30340; weak_ptr &#21644; shared_ptr &#30340;&#26368;&#22823;&#21306;&#21035;&#22312;&#20110;weak_ptr&#22312;&#25351;&#21521;&#19968;&#20010;&#23545;&#35937;&#30340;&#26102;&#20505;&#19981;&#20250;&#22686;&#21152;&#20854;&#24341;&#29992;&#35745;&#25968;&#65292;&#22240;&#27492;&#20320;&#21487;&#20197;&#29992;weak_ptr&#21435;&#25351;&#21521;&#19968;&#20010;&#23545;&#35937;&#24182;&#19988;&#22312;weak_ptr&#20173;&#28982;&#25351;&#21521;&#36825;&#20010;&#23545;&#35937;&#30340;&#26102;&#20505;&#26512;&#26500;&#23427;&#65292;&#27492;&#26102;&#20320;&#20877;&#35775;&#38382;weak_ptr&#30340;&#26102;&#20505;&#65292;weak_ptr&#20854;&#23454;&#36820;&#22238;&#30340;&#20250;&#26159;&#19968;&#20010;&#31354;&#30340;shared_ptr&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::shared_ptr&lt;<span class="dt">int</span>&gt; p1(<span class="kw">new</span> <span class="dt">int</span>(<span class="dv">5</span>));
std::weak_ptr&lt;<span class="dt">int</span>&gt; wp1 = p1; <span class="co">//p1 owns the memory.</span>

{
    std::shared_ptr&lt;<span class="dt">int</span>&gt; p2 = wp1.lock(); <span class="co">// Now p1 and p2 own the memory.</span>
    <span class="kw">if</span>(p2) <span class="co">// As p2 is initialized from a weak pointer, you have to check if the memory still exists!</span>
    {
        <span class="co">//Do something with p2</span>
    }
} <span class="co">//p2 is destroyed. Memory is owned by p1.</span>

p1.reset(); <span class="co">// Memory is deleted.</span>

std::shared_ptr&lt;<span class="dt">int</span>&gt; p3 = wp1.lock(); <span class="co">//Memory is gone, so we get an empty shared_ptr.</span>
<span class="kw">if</span>(p3)
{
    <span class="co">//Will not execute this.</span>
}</code></pre></div>
<p>&#23454;&#38469;&#19978;&#65292;&#36890;&#24120;shared_ptr&#20869;&#37096;&#23454;&#29616;&#30340;&#26102;&#20505;&#32500;&#25252;&#30340;&#23601;&#19981;&#26159;&#19968;&#20010;&#24341;&#29992;&#35745;&#25968;&#65292;&#32780;&#26159;&#20004;&#20010;&#24341;&#29992;&#35745;&#25968;&#65292;&#19968;&#20010;&#34920;&#31034; <strong>strong reference</strong>&#65292;&#20063;&#23601;&#26159;&#29992; shared_ptr &#36827;&#34892;&#22797;&#21046;&#30340;&#26102;&#20505;&#36827;&#34892;&#30340;&#35745;&#25968;&#65292;&#19968;&#20010;&#26159; <strong>weak reference</strong>&#65292;&#20063;&#23601;&#26159;&#29992; weak_ptr &#36827;&#34892;&#22797;&#21046;&#30340;&#26102;&#20505;&#30340;&#35745;&#25968;&#12290;weak_ptr&#26412;&#36523;&#24182;&#19981;&#20250;&#22686;&#21152;strong reference&#30340;&#20540;&#65292;&#32780;strong reference&#38477;&#20302;&#21040;0&#65292;&#23545;&#35937;&#34987;&#33258;&#21160;&#26512;&#26500;&#12290;</p>
<p>&#20026;&#20160;&#20040;&#35201;&#37319;&#21462;weak_ptr&#26469;&#35299;&#20915;&#21018;&#25165;&#25152;&#36848;&#30340;&#29615;&#29366;&#24341;&#29992;&#30340;&#38382;&#39064;&#21602;&#65311;&#38656;&#35201;&#27880;&#24847;&#30340;&#26159;&#29615;&#29366;&#24341;&#29992;&#30340;&#26412;&#36136;&#30683;&#30462;&#26159;&#19981;&#33021;&#36890;&#36807;&#20219;&#20309;&#31243;&#24207;&#35774;&#35745;&#35821;&#35328;&#30340;&#26041;&#24335;&#26469;&#25171;&#30772;&#30340;&#65292;&#20026;&#20102;&#35299;&#20915;&#29615;&#29366;&#24341;&#29992;&#65292;&#31532;&#19968;&#27493;&#39318;&#20808;&#24471;&#25171;&#30772;&#29615;&#65292;&#20063;&#23601;&#26159;&#24471;<strong>&#21578;&#35785;C++&#65292;&#36825;&#20010;&#29615;&#19978;&#21738;&#19968;&#20010;&#24341;&#29992;&#26159;&#26368;&#24369;&#30340;&#65292;&#26159;&#21487;&#20197;&#34987;&#25171;&#30772;&#30340;&#65292;&#22240;&#27492;&#22312;&#19968;&#20010;&#29615;&#19978;&#21482;&#35201;&#25226;&#21407;&#26469;&#30340;&#26576;&#19968;&#20010; shared_ptr&#25913;&#25104;weak_ptr&#65292;&#23454;&#36136;&#19978;&#36825;&#20010;&#29615;&#23601;&#21487;&#20197;&#34987;&#25171;&#30772;&#20102;&#65292;&#21407;&#26377;&#30340;&#29615;&#29366;&#24341;&#29992;&#24102;&#26469;&#30340;&#26080;&#27861;&#26512;&#26500;&#30340;&#38382;&#39064;&#20063;&#23601;&#38543;&#20043;&#24471;&#21040;&#20102;&#35299;&#20915;</strong>&#12290;(???)</p>
</dd>
<dt><code>auto_ptr</code> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;memory&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv)
{
    <span class="dt">int</span> *i = <span class="kw">new</span> <span class="dt">int</span>;
    auto_ptr&lt;<span class="dt">int</span>&gt; x(i);
    auto_ptr&lt;<span class="dt">int</span>&gt; y;

    y = x;

    cout &lt;&lt; x.get() &lt;&lt; endl; <span class="co">// Print NULL</span>
    cout &lt;&lt; y.get() &lt;&lt; endl; <span class="co">// Print non-NULL address i</span>

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>output:</p>
<pre><code>0
0x1540010</code></pre>
<dl>
<dt><a href="http://openhome.cc/Gossip/CppGossip/">&#35486;&#35328;&#25216;&#34899;&#65306;C++ Gossip: <code>auto_ptr</code></a> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;memory&gt;</span></code></pre></div>
<p>auto_ptr &#21487;&#20197;&#25351;&#21521;&#19968;&#20491;&#20197; new &#24314;&#31435;&#30340;&#29289;&#20214;&#65292;&#30070; auto_ptr &#30340;&#29983;&#21629;&#36913;&#26399;&#32080;&#26463;&#24460;&#65292;&#25152;&#25351;&#21521;&#30340;&#29289;&#20214;&#20043;&#36039;&#28304;&#20063;&#26371;&#34987;&#37323;&#25918;&#65292;&#22312;&#24314;&#31435; auto_ptr &#26178;&#24517;&#38920;&#25351;&#23450;&#30446;&#27161;&#29289;&#20214;&#20043;&#22411;&#24907;&#12290;&#25805;&#20316; auto_ptr &#23601;&#20687;&#25805;&#20316;&#27794;&#26377;&#20351;&#29992; auto_ptr &#30340;&#25351;&#27161;&#19968;&#27171;&#12290;</p>
<pre><code>auto_ptr&lt;int&gt; iPtr (new int(100));
auto_ptr&lt;string&gt; sPtr (new string(&quot;caterpillar&quot;));

cout &lt;&lt; *iPtr &lt;&lt; endl; // &#39023;&#31034;100
if(sPtr-&gt;empty())
    cout &lt;&lt; &quot;&#23383;&#20018;&#28858;&#31354;&quot; &lt;&lt; endl;</code></pre>
<p>&#24744;&#20063;&#21487;&#20197;&#24314;&#31435;&#19968;&#20491;&#26410;&#25351;&#21521;&#20219;&#20309;&#29289;&#20214;&#30340; auto_ptr&#65292;&#20363;&#22914;&#65306;<code>auto_ptr&lt;int&gt; iPtr;</code></p>
<p>&#26410;&#25351;&#21521;&#20219;&#20309;&#29289;&#20214;&#30340; auto_ptr &#19981;&#21487;&#20197;&#21462;&#20540;&#65292;&#21542;&#21063;&#26371;&#30332;&#29983;&#19981;&#21487;&#38928;&#26399;&#20043;&#32080;&#26524;&#65292;&#26082;&#28982;&#19981;&#21487;&#21462;&#20540;&#65292;&#22914;&#20309;&#21028;&#26039;&#23427;&#26159;&#21542;&#26377;&#25351;&#21521;&#29289;&#20214;&#21602;&#65311;&#24744;&#21487;&#20197;&#20351;&#29992; get() &#20989;&#24335;&#65292;&#23427;&#26371;&#20659; &#22238;&#25152;&#25351;&#21521;&#29289;&#20214;&#30340;&#20301;&#22336;&#65292;&#22914;&#26524;&#20659;&#22238; 0&#65292;&#34920;&#31034;&#19981;&#25351;&#21521;&#20219;&#20309;&#29289;&#20214;&#65292;&#22914;&#26524;&#19981;&#25351;&#21521;&#20219;&#20309;&#29289;&#20214;&#65292;&#24744;&#21487;&#20197;&#20351;&#29992; reset() &#20358;&#35731;&#23427;&#25351;&#21521;&#19968;&#20491;&#29289;&#20214;&#65292;&#20363;&#22914;&#65306;</p>
<pre><code>if(iPtr.get() == 0) {
    iPtr.reset(new int(100));
}</code></pre>
<p>reset() &#21487;&#20197;&#25509;&#21463;&#19968;&#20491;&#25351;&#27161;&#25110;&#26159; 0 &#34920;&#31034;&#19981;&#25351;&#21521;&#20219;&#20309;&#29289;&#20214;&#65292;reset() &#26371;&#20808; delete &#30446;&#21069;&#25351;&#21521;&#30340;&#29289;&#20214;&#65292;&#28982;&#24460;&#37325;&#26032;&#25351;&#21521;&#26032;&#30340;&#29289;&#20214;&#65292;&#24744;&#20063;&#21487;&#20197;&#20351;&#29992; release() &#37323;&#25918; auto_ptr &#31649;&#29702;&#25152;&#25351;&#21521;&#29289;&#20214;&#30340;&#32887;&#36012;&#12290;</p>
<p>auto_ptr &#21487;&#20197;&#20351;&#29992;&#21478;&#19968;&#20491; auto_ptr &#20358;&#24314;&#31435;&#65292;&#36889;&#26371;&#36896;&#25104;&#25152;&#26377;&#27402;&#30340;&#36681;&#31227;&#65292;&#20363;&#22914;&#65306;</p>
<pre><code>auto_ptr&lt;SafeArray&gt; ptr1(new SafeArray(19));
auto_ptr&lt;SafeArray&gt; ptr2(ptr1);</code></pre>
<p>&#30070;&#20351;&#29992; ptr1 &#20358;&#24314;&#31435; ptr2 &#26178;&#65292;ptr1 &#19981;&#20877;&#23565;&#25152;&#25351;&#21521;&#29289;&#20214;&#30340;&#36039;&#28304;&#37323;&#25918;&#36000;&#36012;&#65292;&#32887;&#36012;&#20132;&#32102;&#20102; ptr2&#65292;&#22312;&#20351;&#29992;&#25351;&#23450;&#36939;&#31639;&#26178;&#65292;&#20063;&#26377;&#39006;&#20284;&#30340;&#34892;&#28858;&#65292;&#20363;&#22914;&#65306;</p>
<pre><code>auto_ptr&lt;SafeArray&gt; ptr1(new SafeArray(19));
auto_ptr&lt;SafeArray&gt; ptr2(new SafeArray(20));
ptr2 = ptr1;</code></pre>
<p>ptr2 &#25152;&#25351;&#21521;&#30340;&#29289;&#20214;&#26371;&#20808;&#34987; delete&#65292;&#28982;&#24460; ptr1 &#30340;&#23660;&#24615;&#26371;&#35079;&#35069;&#33267; ptr2&#65292;&#20063;&#23601;&#26159; ptr1 &#25152;&#25351;&#21521;&#30340;&#29289;&#20214;&#65292;&#29694;&#22312;&#30001; ptr2 &#25351;&#21521;&#23427;&#20102;&#65292;ptr1 &#19981;&#20877;&#36000;&#36012;&#25152;&#25351;&#21521;&#29289;&#20214;&#30340;&#36039;&#28304;&#37323;&#25918;&#12290;</p>
<p>auto_ptr &#30340;&#36039;&#28304;&#32173;&#35703;&#21205;&#20316;&#26159;&#20197; inline &#30340;&#26041;&#24335;&#20358;&#23436;&#25104;&#65292;&#20063;&#23601;&#26159;&#22312;&#32232;&#35695;&#26178;&#26371;&#34987;&#25844;&#23637;&#38283;&#20358;&#65292;&#25152;&#20197;&#20351;&#29992; auto_ptr &#20006;&#19981;&#26371;&#29351;&#29298;&#25928;&#29575;&#12290;</p>
<p>&#26368;&#24460;&#35201;&#27880;&#24847;&#30340;&#26159;&#65292;auto_ptr &#19981;&#33021;&#29992;&#20358;&#31649;&#29702;&#21205;&#24907;&#37197;&#32622;&#32780;&#20358;&#30340;&#38499;&#21015;&#65292;&#22914;&#26524;&#29992;&#23427;&#20358;&#31649;&#29702;&#21205;&#24907;&#37197;&#32622;&#32780;&#20358;&#30340;&#38499;&#21015;&#65292;&#32080;&#26524;&#26159;&#19981;&#21487;&#38928;&#26399;&#30340;&#12290;</p>
</dd>
</dl>
</dd>
<dt><code>scoped_ptr</code> <code class="fold">@</code></dt>
<dd><p>&#36825;&#26159;&#27604;&#36739;&#31616;&#21333;&#30340;&#19968;&#31181;&#26234;&#33021;&#25351;&#38024;&#65292;&#27491;&#22914;&#20854;&#21517;&#23383;&#25152;&#36848;&#65292;scoped_ptr &#25152;&#25351;&#21521;&#30340;&#23545;&#35937;&#22312;&#20316;&#29992;&#22495;&#20043;&#22806;&#20250;&#33258;&#21160;&#24471;&#21040;&#26512;&#26500;&#65292;&#19968;&#20010;&#20363;&#23376;&#26159;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;boost/scoped_ptr.hpp&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">struct</span> Shoe { ~Shoe() { std::cout &lt;&lt; <span class="st">&quot;Buckle my shoe</span><span class="ch">\n</span><span class="st">&quot;</span>; } };

<span class="kw">class</span> MyClass {
    boost::scoped_ptr&lt;<span class="dt">int</span>&gt; ptr;
  <span class="kw">public</span>:
    MyClass() : ptr(<span class="kw">new</span> <span class="dt">int</span>) { *ptr = <span class="dv">0</span>; }
    <span class="dt">int</span> add_one() { <span class="kw">return</span> ++*ptr; }
};

<span class="dt">int</span> main()
{
    boost::scoped_ptr&lt;Shoe&gt; x(<span class="kw">new</span> Shoe);
    MyClass my_instance;
    std::cout &lt;&lt; my_instance.add_one() &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
    std::cout &lt;&lt; my_instance.add_one() &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre></div>
<p>output:</p>
<pre><code>1
2
Buckle my shoe</code></pre>
<p>&#27492;&#22806;&#65292;scoped_ptr &#26159; non-copyable &#30340;&#65292;&#20063;&#23601;&#26159;&#35828;&#20320;&#19981;&#33021;&#21435;&#23581;&#35797;&#22797;&#21046;&#19968;&#20010; scoped_ptr &#30340;&#20869;&#23481;&#21040;&#21478;&#22806;&#19968;&#20010; scoped_ptr &#20013;&#65292;&#36825;&#20063;&#26159;&#20026;&#20102;&#38450;&#27490;&#38169;&#35823;&#30340;&#22810;&#27425;&#26512;&#26500;&#21516;&#19968;&#20010;&#25351;&#38024;&#25152;&#25351;&#21521;&#30340;&#23545;&#35937;&#12290;</p>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/3476938/example-to-use-shared-ptr">c++ - Example to use shared_ptr? - Stack Overflow</a></li>
<li><a href="http://www.boost.org/doc/libs/1_50_0/libs/smart_ptr/scoped_ptr.htm">scoped_ptr - 1.50.0</a></li>
<li><a href="http://www.boost.org/doc/libs/1_50_0/libs/smart_ptr/smart_ptr.htm">Smart Pointers - 1.50.0</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt><a href="http://en.cppreference.com/w/cpp/language/definition">Definitions and ODR - cppreference.com</a> <code class="fold">@</code></dt>
<dd><p>Definitions are declarations that <strong>fully define the entity</strong> introduced by the declaration. Every declaration is a definition, except for the following:</p>
<ul>
<li><p>A function declaration without a function body</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f(<span class="dt">int</span>); <span class="co">// declares, but doesn&#39;t define f</span></code></pre></div></li>
<li><p>Any declaration with an extern storage class specifier or with a language linkage specifier (such as extern &#8220;C&#8221;) without an initializer</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">extern</span> <span class="dt">const</span> <span class="dt">int</span> a; <span class="co">// declares, but doesn&#39;t define a</span>
<span class="dt">extern</span> <span class="dt">const</span> <span class="dt">int</span> b = <span class="dv">1</span>; <span class="co">// defines b</span></code></pre></div></li>
<li><p>Declaration of a non-inline (since C++17) static data member inside a class definition</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S {
    <span class="dt">int</span> n;               <span class="co">// defines S::n</span>
    <span class="dt">static</span> <span class="dt">int</span> i;        <span class="co">// declares, but doesn&#39;t define S::i</span>
    <span class="kw">inline</span> <span class="dt">static</span> <span class="dt">int</span> x; <span class="co">// defines S::x</span>
};                       <span class="co">// defines S</span>
<span class="dt">int</span> S::i;                <span class="co">// defines S::i</span></code></pre></div></li>
<li><p>(deprecated) Namespace scope declaration of a static data member that was defined within the class with the constexpr specifier</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S {
    <span class="dt">static</span> <span class="kw">constexpr</span> <span class="dt">int</span> x = <span class="dv">42</span>; <span class="co">// implicitly inline, defines S::x</span>
};
<span class="kw">constexpr</span> <span class="dt">int</span> S::x; <span class="co">// declares S::x, not a redefinition</span></code></pre></div></li>
<li><p>(since C++17) Declaration of a class name (by forward declaration or by the use of the elaborated type specifier in another declaration)</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S; <span class="co">// declares, but doesn&#39;t define S</span>
<span class="kw">class</span> Y f(<span class="kw">class</span> T p); <span class="co">// declares, but doesn&#39;t define Y and T (and also f and p)</span></code></pre></div></li>
<li><p>An opaque declaration of an enumeration (since C++11)</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">enum</span> Color : <span class="dt">int</span>; <span class="co">// declares, but doesn&#39;t define Color</span></code></pre></div></li>
<li><p>Declaration of a template parameter</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="co">// declares, but doesn&#39;t define T</span></code></pre></div></li>
<li><p>A parameter declaration in a function declaration that isn&#8217;t a definition</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f(<span class="dt">int</span> x); <span class="co">// declares, but doesn&#39;t define f and x</span>
<span class="dt">int</span> f(<span class="dt">int</span> x) { <span class="co">// defines f and x</span>
     <span class="kw">return</span> x+a;
}</code></pre></div></li>
<li><p>A typedef declaration</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> S S2; <span class="co">// declares, but doesn&#39;t define S2 (S may be incomplete)</span></code></pre></div></li>
<li><p>An alias-declaration (since C++11)</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> S2 = S; <span class="co">// declares, but doesn&#39;t define S2 (S may be incomplete)</span></code></pre></div></li>
<li><p>A using-declaration</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> N::d; <span class="co">// declares, but doesn&#39;t define d</span></code></pre></div></li>
</ul>
<dl>
<dt>One Definition Rule</dt>
<dd><p>Only one definition of any variable, function, class type, enumeration type, or template is allowed in any one translation unit (some of these may have multiple declarations, but only one definition is allowed).</p>
<p>One and only one definition of every non-inline function or variable that is odr-used (see below) is required to appear in the entire program (including any standard and user-defined libraries). The compiler is not required to diagnose this violation, but the behavior of the program that violates it is undefined.</p>
<p>For an inline function or inline variable (since C++17), a definition is required in every translation unit where it is odr-used.</p>
<dl>
<dt>ODR-use</dt>
<dd><p>Informally, an object is odr-used if its address is taken, or a reference is bound to it, and a function is odr-used if a function call to it is made or its address is taken. If an object or a function is odr-used, its definition must exist somewhere in the program; a violation of that is a link-time error.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S {
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> x = <span class="dv">0</span>; <span class="co">// static data member</span>
    <span class="co">// a definition outside of class is required if it is odr-used</span>
};
<span class="dt">const</span> <span class="dt">int</span>&amp; f(<span class="dt">const</span> <span class="dt">int</span>&amp; r);

<span class="dt">int</span> n = b ? (<span class="dv">1</span>, S::x) <span class="co">// S::x is not odr-used here</span>
          : f(S::x);  <span class="co">// S::x is odr-used here: a definition is required</span></code></pre></div>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl></li>
</ul>
<h2 id="&#22909;&#20070;&#21338;&#20849;&#20139;-selected-booksposts">&#22909;&#20070;/&#21338;&#20849;&#20139; | Selected Books/Posts</h2>
<ul>
<li><dl>
<dt>&#12298;&#28145;&#20837;&#25506;&#32034; C++ &#23545;&#35937;&#27169;&#22411;&#12299; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>vczh</p>
<blockquote>
<p>&#24403;&#28982;&#21487;&#20197;&#12290;&#20320;&#39318;&#20808;&#21435;&#30475;&#12298;Inside C++ Object Model&#12299;&#65292;&#28982;&#21518;&#30475;&#30475;&#20154;&#23478;&#26159;&#24590;&#20040;&#23454;&#29616;&#32487;&#25215;&#30340;&#65292;&#20174;&#27492;&#20197;&#21518;&#20320;&#23601;<strong>&#20195;&#26367; C++ &#32534;&#35793;&#22120;&#20570;&#20154;&#32905;&#20195;&#30721;&#23637;&#24320;</strong>&#23601;&#21487;&#20197;&#20102;&#12290;</p>
</blockquote>
<p>&#20505;&#25463;&#35828; 1&#12289;3&#12289;4 &#26159;&#26368;&#20540;&#24471;&#19968;&#35835;&#30340;&#12290;&#25105;&#26631;&#35760;&#20102;&#8220;&#9829;&#65039;&#8221;&#12290;</p>
<dl>
<dt>&#31532; 1 &#31456; &#20851;&#20110;&#23545;&#35937; (Object Lessons) &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>C &#35821;&#35328;&#20013;&#25968;&#25454;&#21644;&#25805;&#20316;&#20998;&#24320;&#65292;&#35821;&#35328;&#26412;&#36523;&#27809;&#26377;&#25552;&#20379;&#20043;&#38388;&#30340;&#20851;&#32852;&#24615;&#12290;&#36825;&#31181;&#31243;&#24207;&#26041;&#27861;&#34987;&#31216;&#20026; Procedural&#65292;&#23427;&#20197;&#19968;&#20123;&#20989;&#25968;&#20026;&#23548;&#21521;&#65292;&#22788;&#29702;&#20849;&#21516;&#30340;&#22806;&#37096;&#25968;&#25454;&#12290;</p>
<ul>
<li><dl>
<dt>&#31354;&#38388;&#24067;&#23616;&#21644;&#23384;&#21462;&#26102;&#38388;&#30340;&#39069;&#22806;&#25104;&#26412; <code class="fold">@</code></dt>
<dd><p>&#36825;&#20123;&#39069;&#22806;&#25104;&#26412;&#20027;&#35201;&#30001; virtual &#24341;&#36215;&#65292;&#21253;&#25324;&#65306;</p>
<ul>
<li>virtual function &#26426;&#21046;&#65292;&#29992;&#26469;&#25903;&#25345;&#8220;&#25191;&#34892;&#26399;&#32465;&#23450;&#8221;&#65288;runtime binding&#65289;&#12290;</li>
<li>virtual base class &#8212;&#8212;&#34394;&#22522;&#31867;&#26426;&#21046;&#65292;&#20197;&#23454;&#29616;&#20849;&#20139;&#34394;&#22522;&#31867;&#30340; subobject&#12290;</li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#31616;&#21333;&#23545;&#35937;&#27169;&#22411;&#12289;&#34920;&#26684;&#39537;&#21160;&#23545;&#35937;&#27169;&#22411;&#20197;&#21450; C++ &#23545;&#35937;&#27169;&#22411; <code class="fold">@</code></dt>
<dd><p>C++ &#20013;&#26377;&#20004;&#31181; class data members&#65306;static &#21644; nonstatic&#65292;&#20197;&#21450;&#19977;&#31181; class member functions&#65306;static&#12289;nonstatic&#12289;virtual&#12290;</p>
<p>&#65288;&#25105;&#20204;&#21487;&#20197;&#31616;&#35760;&#20026; static + nonstatic ++ virtual&#65289;</p>
<ul>
<li><p>&#31616;&#21333;&#23545;&#35937;&#27169;&#22411;</p>
<div class="figure">
<img src="http://www.roading.org/images/2011-11/image_thumb10.png" />

</div>
<p>&#20840;&#37096;&#37117;&#26159;&#25351;&#38024;&#65292;&#20840;&#37096;&#23384;&#36215;&#26469;&#12290;&#27599;&#19968;&#20010;&#23454;&#20363;&#37117;&#35201;&#23384;&#20989;&#25968;&#25351;&#38024;&#65292;&#25152;&#20197;&#31354;&#38388;&#25104;&#26412;&#39640;&#65292;&#25191;&#34892;&#25928;&#29575;&#20302;&#12290;</p>
<p>C++ &#24182;&#27809;&#26377;&#37319;&#29992;&#36825;&#26679;&#19968;&#31181;&#23545;&#35937;&#27169;&#22411;&#65292;&#20294;&#26159;&#34987;&#29992;&#21040;&#20102; C++ &#20013;&#8220;&#25351;&#21521;&#25104;&#21592;&#30340;&#25351;&#38024;&#8221;&#65288;pointer-to-member&#65289;&#30340;&#27010;&#24565;&#24403;&#20013;&#12290;</p></li>
<li><p>&#34920;&#26684;&#39537;&#21160;&#23545;&#35937;&#27169;&#22411;</p>
<div class="figure">
<img src="http://www.roading.org/images/2011-11/image11_thumb1.png" />

</div>
<p>&#23558;&#25152;&#26377;&#30340;&#25968;&#25454;&#25104;&#21592;&#25277;&#31163;&#20986;&#26469;&#24314;&#25104;<strong>&#25968;&#25454;&#25104;&#21592;&#34920;</strong>&#65292;&#23558;&#25152;&#26377;&#30340;&#20989;&#25968;&#25277;&#21462;&#20986;&#26469;&#24314;&#25104;&#19968;&#24352;<strong>&#20989;&#25968;&#25104;&#21592;&#34920;</strong>&#65292;&#32780;&#23545;&#35937;&#26412;&#36523;&#21482;&#20445;&#25345;&#19968;&#20010;&#25351;&#21521;&#25968;&#25454;&#25104;&#21592;&#34920;&#30340;&#25351;&#38024;&#12290;</p>
<p>C++ &#20063;&#27809;&#26377;&#37319;&#29992;&#36825;&#19968;&#31181;&#23545;&#35937;&#27169;&#22411;&#65292;&#20294; C++ &#21364;&#20197;&#27492;&#27169;&#22411;&#20316;&#20026;&#25903;&#25345;&#34394;&#20989;&#25968;&#30340;&#26041;&#26696;&#12290;</p></li>
<li><p>C++ &#23545;&#35937;&#27169;&#22411;</p>
<p>&#25152;&#26377;&#30340;&#38750;&#38745;&#24577;&#25968;&#25454;&#25104;&#21592;&#23384;&#20648;&#22312;&#23545;&#35937;&#26412;&#36523;&#20013;&#12290;&#25152;&#26377;&#30340;&#38745;&#24577;&#25968;&#25454;&#25104;&#21592;&#12289;&#25104;&#21592;&#20989;&#25968;&#65288;&#21253;&#25324;&#38745;&#24577;&#19982;&#38750;&#38745;&#24577;&#65289;&#37117;&#32622;&#20110;&#23545;&#35937;&#20043;&#22806;&#12290;&#21478;&#22806;&#65292;&#29992;&#19968;&#24352;&#34394;&#20989;&#25968;&#34920;&#65288;virtual table) &#23384;&#20648;&#25152;&#26377;&#25351;&#21521;&#34394;&#20989;&#25968;&#30340;&#25351;&#38024;&#65292;&#24182;&#22312;&#34920;&#22836;&#38468;&#21152;&#19978;&#19968;&#20010;&#35813;&#31867;&#30340; type_info &#23545;&#35937;&#65292;&#22312;&#23545;&#35937;&#20013;&#21017;&#20445;&#23384;&#19968;&#20010;&#25351;&#21521;&#34394;&#20989;&#25968;&#34920;&#30340;&#25351;&#38024;&#12290;&#22914;&#19979;&#22270;&#65306;</p>
<div class="figure">
<img src="http://www.roading.org/images/2011-11/image17_thumb1.png" />

</div>
<p>Virtual functions &#21017;&#20197;&#19978;&#20010;&#27493;&#39588;&#25903;&#25345;&#20043;&#65306;</p>
<ul>
<li>&#27599;&#19968;&#20010; class &#20135;&#29983;&#19968;&#22534;&#24535;&#21521; virtual functions &#30340;&#25351;&#38024;&#65292;&#25918;&#22312;&#34920;&#26684;&#20043;&#20013;&#12290;&#36825;&#20010;&#34920;&#26684;&#34987;&#31216;&#20026; <strong>virtual table&#65288;vtbl&#65289;</strong>&#12290;</li>
<li>&#27599;&#20010; class object &#34987;&#28155;&#21152;&#19968;&#20010;&#25351;&#38024;&#65292;&#25351;&#21521;&#30456;&#20851;&#30340; virtual table&#12290;&#36890;&#24120;&#36825;&#20010;&#25351;&#38024;&#34987;&#31216;&#20026; <strong>vptr</strong>&#12290;&#20854; setting &#21644; resetting &#37117;&#30001;&#27599;&#20010; class &#30340; constructor &#21644; destructor &#21644; copy assignment &#36816;&#31639;&#31526;&#33258;&#21160;&#23436;&#25104;&#12290;&#27599;&#20010; class &#25152;&#20851;&#32852;&#30340; <code>type_info object</code>&#65288;&#29992;&#20197;&#25903;&#25345; RTTI&#65292;runtime type identification&#65289;&#20063;&#32463;&#30001; virtual table &#34987;&#25351;&#20986;&#26469;&#65292;&#36890;&#24120;&#26159;&#25918;&#22312;&#34920;&#26684;&#30340;&#31532;&#19968;&#20010; slot &#22788;&#12290;</li>
</ul>
<p>&#36825;&#26679;&#19968;&#26469;&#65292;&#19968;&#20010; class X &#25104;&#21592; x &#30340;&#20869;&#23384;&#20013;&#65292;&#26377; nonstatic &#25968;&#25454;&#12289;align &#30340;&#23383;&#33410;&#65292;&#20197;&#21450; vptr&#65292;&#36825;&#20010; vptr &#25351;&#21521;&#19968;&#20010; virtual table&#65292;&#36825;&#20010; virtual table &#30340;&#31532;&#19968;&#20010;&#22320;&#22336;&#65288;<code>px-&gt;_vtbl</code>&#65289;&#25351;&#21521; type_info for X&#65292;&#20854;&#23427;&#25351;&#21521; X &#20013;&#30340;&#21508;&#20010; virtual function&#12290;</p>
<p>&#26377;&#20960;&#20010;&#28857;&#20877;&#24378;&#35843;&#19968;&#19979;&#65306;</p>
<ul>
<li>class object &#37324;&#23384;&#30340;&#26377; non static &#25104;&#21592;&#23545;&#35937;&#65292;&#26377; alignment</li>
<li>&#22914;&#26524;&#26377;&#34394;&#20989;&#25968;&#65292;&#23384;&#30340;&#36824;&#26377; vptr&#65288;&#21487;&#33021;&#19981;&#27490;&#19968;&#20010;&#65292;&#22240;&#20026;&#21487;&#33021;&#32487;&#25215;&#22810;&#20010;&#26377;&#34394;&#20989;&#25968;&#30340;&#31867;&#65289;&#65292;&#25351;&#21521;&#20989;&#25968;&#34920;&#65288;&#22312; GCC &#37324;&#25918;&#22312;&#23545;&#35937;&#26368;&#24320;&#22987;&#30340;&#20301;&#32622;&#65289;</li>
<li>&#32431;&#34394;&#20989;&#25968;&#19981;&#33021;&#23454;&#20363;&#21270;</li>
</ul></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#19977;&#31181;&#32534;&#31243;&#20856;&#33539; <code class="foldable">@</code></dt>
<dd><ul>
<li>&#31243;&#24207;&#27169;&#22411;</li>
<li>ADT &#27169;&#22411;</li>
<li>&#38754;&#21521;&#23545;&#35937;&#27169;&#22411;</li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#19968;&#20010;&#31867;&#30340;&#23545;&#35937;&#65288;class object&#65289;&#30340;&#20869;&#23384;&#22823;&#23567;&#21253;&#25324;&#65306; <code class="fold">@</code></dt>
<dd><ul>
<li>&#25152;&#26377;&#38750;&#38745;&#24577;&#25968;&#25454;&#25104;&#21592;&#30340;&#22823;&#23567;&#12290;</li>
<li>&#30001;&#20869;&#23384;&#23545;&#40784;&#65288;alignment&#65289;&#32780;&#22635;&#34917;&#65288;padding&#65289;&#30340;&#20869;&#23384;&#22823;&#23567;&#12290;</li>
<li>&#20026;&#20102;&#25903;&#25345; virtual &#26377;&#20869;&#37096;&#20135;&#29983;&#30340;&#39069;&#22806;&#36127;&#25285;&#65288;&#19968;&#20010;&#25110;&#22810;&#20010; vptr &#25351;&#38024;&#65292;&#27599;&#20010; 4 &#23383;&#33410;&#25110;&#32773; 8 &#23383;&#33410;&#65292;&#20197;&#21450; vbptr&#65289;</li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#20851;&#20110;&#38754;&#21521;&#23545;&#35937;&#21644;&#22810;&#24577;&#30340;&#26356;&#22810;&#24605;&#32771; <code class="fold">@</code></dt>
<dd><p>&#25351;&#38024;&#30340;&#31867;&#22411;&#65292;&#24433;&#21709;&#30340;&#26159;&#8220;<strong>&#34987;&#25351;&#20986;&#20043;&#20869;&#23384;&#30340;&#22823;&#23567;&#21644;&#20854;&#20869;&#23481;&#30340;&#35299;&#37322;&#26041;&#24335;</strong>&#8221;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Bear b;
ZooAnimal *pz = &amp;b;         <span class="co">// pz &#20043;&#21253;&#25324;&#20854;&#20013; ZooAnimal &#30340; subject</span>
Bear *pb = &amp;b;              <span class="co">// pb &#25351;&#21521;&#25972;&#20010; Bear object</span>

pb-&gt;cell_block; <span class="co">// okay</span>
pz-&gt;cell_block; <span class="co">// bad</span>

<span class="co">// &#19981;&#36807;&#25105;&#20204;&#21487;&#20197; cast</span>
((Bear *)pz)-&gt;cell_block;
<span class="kw">if</span>( Bear *pb2 = <span class="kw">dynamic_cast</span>&lt;Bear *&gt;(pz) ) {
    pb2-&gt;cell_block;
}</code></pre></div>
<p>pz &#30340;&#31867;&#22411;&#23558;&#22312;&#32534;&#35793;&#26102;&#26399;&#20915;&#23450;&#20197;&#19979;&#20004;&#28857;&#65306;</p>
<ul>
<li>&#22266;&#23450;&#30340;&#21487;&#29992;&#25509;&#21475;&#65288;ZooAnimal &#30340; public &#20989;&#25968;&#25509;&#21475;&#65289;</li>
<li>&#35813;&#25509;&#21475;&#30340; access level</li>
</ul>
<pre><code>Bear b;
ZooAnimal zb = b;           // &#35793;&#27880;&#65306;&#36825;&#20250;&#24341;&#36215; sliced&#65292;&#19979;&#38754;&#26377;&#20855;&#20307;&#35770;&#36848;
zb.rotate();                // &#20250;&#35843;&#29992; ZooAnimal::rotate()</code></pre>
<p>&#20026;&#20160;&#20040;&#25335;&#36125;&#36807;&#21435;&#21518;&#65292;vptr &#19981;&#26159;&#25351;&#21521; <code>Bear::rotate</code>&#65311;&#22240;&#20026;&#32534;&#35793;&#22120;&#22312; 1&#65289;&#21021;&#22987;&#21270;&#65288;constructor&#65289;&#21644; 2&#65289;copy assignment operator &#30340;&#26102;&#20505;&#20316;&#20102;&#20210;&#35009;&#12290;&#32534;&#35793;&#22120;&#24517;&#39035;&#30830;&#20445;&#22914;&#26524;&#26576;&#20010; object &#21547;&#26377;&#19968;&#20010;&#25110;&#19968;&#20010;&#20197;&#19978;&#30340; vptrs&#65292;&#37027;&#20123; vptrs &#30340;&#20869;&#23481;&#19981;&#20250;&#34987; base class object &#21021;&#22987;&#21270;&#25110;&#25913;&#21464;&#12290;&#65288;&#36825;&#20010;&#24067;&#23616;&#32943;&#23450;&#26159;&#32534;&#35793;&#22120;&#30830;&#23450;&#20102;&#30340;&#65292;&#32780;&#19988;&#22312;&#25335;&#36125;&#26500;&#36896;&#31561;&#26102;&#20505;&#19981;&#33021;&#21482;&#26159; memcpy&#65292;&#36824;&#35201;&#27491;&#30830;&#22320;&#38142;&#25509;&#37027;&#20123; vptr&#12290;&#65289;</p>
<p>&#21021;&#22987;&#21270;&#25110;&#32773; assignment &#30340;&#26102;&#20505;&#65292;&#22914; <code>Derived d; Base b = d;</code>&#65292; derived class object &#20250;&#34987;sliced&#65292;&#28982;&#21518;&#25335;&#36125;&#22622;&#20837;&#26356;&#23567;&#30340;&#31354;&#38388;&#12290;&#22810;&#24577;&#27809;&#26377;&#20986;&#29616;&#12290;&#22914;&#26524;&#26159;&#24341;&#29992;&#25110;&#32773;&#25351;&#38024;&#65292;&#22914; <code>Base *b = &amp;d;</code> &#25110;&#32773; <code>Base &amp;b = d;</code> &#22810;&#24577;&#21017;&#20986;&#29616;&#20102;&#12290;</p>
<blockquote>
<p><strong>C++ &#36890;&#36807; class &#30340; pointer &#21644; references &#26469;&#25903;&#25345;&#22810;&#24577;&#65292;&#36825;&#31181;&#31243;&#24207;&#35774;&#35745;&#39118;&#26684;&#23601;&#31216;&#20026;&#8220;&#38754;&#21521;&#23545;&#35937;&#8221;&#12290;</strong></p>
</blockquote>
<dl>
<dt>&#20851;&#20110;&#36825;&#20250;&#24341;&#36215; sliced&#65292;&#25105;&#20570;&#20102;&#19968;&#20010;&#23567;&#27979;&#35797;&#12290; <code class="fold">@</code></dt>
<dd><p>&#19978;&#38754;&#37027;&#20010; ZooAnimal zb = b&#65292;&#19981;&#20165;&#20165;&#26159; slice &#20102; b &#28982;&#21518;&#25226;&#19968;&#37096;&#20998;&#25335;&#36125;&#36827; zb &#37324;&#38754;&#12290;&#22312;&#26500;&#36896;&#30340;&#36807;&#31243;&#20013;&#65292;&#23427;&#36824;&#25226;&#30456;&#24212;&#30340; vptr &#36716;&#21270;&#25104;&#20102; ZooAnimal &#30340;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string.h&gt; </span><span class="co">// memcpy</span>
<span class="ot">#include &lt;stdlib.h&gt; </span><span class="co">// malloc</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">class</span> B {
<span class="kw">public</span>:
    <span class="kw">explicit</span> B( <span class="dt">int</span> id ) : id(id) { }
    <span class="kw">virtual</span> <span class="dt">void</span> say() { cout &lt;&lt; <span class="st">&quot;SOS, I&#39;m #&quot;</span> &lt;&lt; id &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>; }
<span class="kw">protected</span>:
    <span class="dt">int</span> id;
};

<span class="kw">class</span> D : <span class="kw">public</span> B {
<span class="kw">public</span>:
    <span class="kw">explicit</span> D( <span class="dt">int</span> id ) : B(id) { }
    <span class="kw">virtual</span> <span class="dt">void</span> say() { cout &lt;&lt; <span class="st">&quot;---...---, I&#39;m #0x&quot;</span> &lt;&lt; hex &lt;&lt; id &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>; }
};

<span class="dt">int</span> main()
{
    cout &lt;&lt; <span class="st">&quot; B b(2); b.say(); ---&gt; &quot;</span>;
    B b(<span class="dv">2</span>); b.say();
    cout &lt;&lt; <span class="st">&quot; D d(5); d.say(); ---&gt; &quot;</span>;
    D d(<span class="dv">5</span>); d.say();
    cout &lt;&lt; <span class="st">&quot; B b2 = d; b2.say(); --&gt; &quot;</span>;
    B b2 = d; b2.say();

    cout &lt;&lt; <span class="st">&quot; B *pd = &amp;d; pb-&gt;say(); ---&gt; &quot;</span>;
    B *pb = &amp;d; pb-&gt;say();

    cout &lt;&lt; <span class="st">&quot; memcpy D-&gt;B, b-&gt;say(); ---&gt; &quot;</span>;
    B *pb2 = (B *)malloc( <span class="kw">sizeof</span>(B) );
    memcpy( pb2, &amp;d, <span class="kw">sizeof</span>(B) );
    pb2-&gt;say();

    cout &lt;&lt; <span class="st">&quot; memcpy B-&gt;D, d-&gt;say(); ---&gt; &quot;</span>;
    D *pd2 = (D *)malloc( <span class="kw">sizeof</span>(D) );
    memcpy( pd2, &amp;b, <span class="kw">sizeof</span>(B) );
    pd2-&gt;say();

    cout &lt;&lt; <span class="st">&quot; so we can achive polymorphism within an object (not pointer, not reference)</span><span class="ch">\n</span><span class="st">:&quot;</span>;
    B b3(<span class="dv">9</span>);
    memcpy( &amp;b3, &amp;d, <span class="kw">sizeof</span>(B) );
    b3.say();
}</code></pre></div>
<p>&#27880;&#37322;&#20102;&#30340;&#36755;&#20986;&#65306;</p>
<pre><code>// &#36825;&#19977;&#20010;&#26159;&#27627;&#26080;&#24748;&#24565;&#30340;&#65288;&#22810;&#24577;&#21482;&#26377; reference &#21644; pointer &#30340;&#26102;&#20505;&#25165;&#23637;&#29616;&#65289;
B b(2); b.say(); ---&gt; SOS, I&#39;m #2
D d(5); d.say(); ---&gt; ---...---, I&#39;m #0x5
B b2 = d; b2.say(); --&gt; SOS, I&#39;m #5

// &#22810;&#24577;&#65292;base object &#25351;&#38024;&#34920;&#29616;&#20986; derived objet &#30340;&#20989;&#25968;
B *pd = &amp;d; pb-&gt;say(); ---&gt; ---...---, I&#39;m #0x5

// &#20043;&#38388;&#25805;&#20316;&#20869;&#23384;&#65292;&#21487;&#35265;&#25226; vptr &#20063;&#25335;&#36125;&#20102;&#65292;&#25152;&#20197;&#23436;&#20840;&#35748;&#19981;&#28165;&#33258;&#24049;&#65292;orz
memcpy D-&gt;B, b-&gt;say(); ---&gt; ---...---, I&#39;m #0x5     // b &#34920;&#29616;&#24471;&#20687; d&#65292;&#24681;&#65292;&#19968;&#33324;&#33324;
memcpy B-&gt;D, d-&gt;say(); ---&gt; SOS, I&#39;m #2             // d &#34920;&#29616;&#24471;&#20687; b&#65292;&#29275;&#36924;&#38378;&#38378;

// &#39069;&#8230;&#8230;&#20026;&#20160;&#20040;&#26159;&#36825;&#26679;&#65311;&#65281;&#25105;&#24819;&#19981;&#36890;&#20102;&#12290;&#35841;&#24110;&#25105;&#20998;&#26512;&#20998;&#26512;&#12290;
so we can achive polymorphism within an object (not pointer, not reference)
:SOS, I&#39;m #5</code></pre>
</dd>
</dl>
</dd>
</dl></li>
</ul>
</dd>
<dt>&#31532; 2 &#31456; &#26500;&#36896;&#20989;&#25968;&#35821;&#24847;&#23398; (The Semantics of constructors) &#9829;&#65039; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#28145;&#20837; C++ &#26500;&#36896;&#20989;&#25968; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#21253;&#21547;&#26377;&#24102;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#30340;&#23545;&#35937;&#25104;&#21592;&#30340;&#31867;</dt>
<dd><p>&#33509;&#19968;&#20010;&#31867; X &#27809;&#26377;&#23450;&#20041;&#20219;&#20309;&#26500;&#36896;&#20989;&#25968;&#65292;&#20294;&#21364;&#21253;&#21547;&#19968;&#20010;&#25110;&#20197;&#19978;&#23450;&#20041;&#26377;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#30340; &#23545;&#35937;&#25104;&#21592;&#65292;&#27492;&#26102;&#32534;&#35793;&#22120;&#20250;&#20026; X &#21512;&#25104;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#65292;&#35813;&#40664;&#35748;&#20989;&#25968;&#20250;&#35843;&#29992;&#23545;&#35937;&#25104;&#21592;&#30340; &#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#20026;&#20043;&#21021;&#22987;&#21270;&#12290;&#22914;&#26524;&#23545;&#35937;&#30340;&#25104;&#21592;&#27809;&#26377;&#23450;&#20041;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#65292;&#37027;&#20040;&#32534;&#35793;&#22120; &#21512;&#25104;&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#23558;&#19981;&#20250;&#20026;&#20043;&#25552;&#20379;&#21021;&#22987;&#21270;&#12290;&#20363;&#22914;&#31867; A &#21253;&#21547;&#20004;&#20010;&#25968;&#25454;&#25104;&#21592;&#23545;&#35937;&#65292; &#20998;&#21035;&#20026;&#65306;<code>string str</code> &#21644; <code>char *Cstr</code>&#65292;&#37027;&#20040;&#32534;&#35793;&#22120;&#29983;&#25104;&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#23558;&#21482;&#25552; &#20379;&#23545; <code>string</code> &#31867;&#22411;&#25104;&#21592;&#30340;&#21021;&#22987;&#21270;&#65292;&#32780;&#19981;&#20250;&#25552;&#20379;&#23545; <code>char *</code> &#31867;&#22411;&#30340;&#21021;&#22987;&#21270;&#12290;</p>
<p>&#20551;&#22914;&#31867; X &#30340;&#35774;&#35745;&#32773;&#20026; X &#23450;&#20041;&#20102;&#40664;&#35748;&#30340;&#26500;&#36896;&#20989;&#25968;&#26469;&#23436;&#25104;&#23545; str &#30340;&#21021;&#22987;&#21270;&#65292;&#24418;&#22914;&#65306; <code>A::A(){Cstr=&#8221;hello&#8221;};</code> &#22240;&#20026;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#24050;&#32463;&#23450;&#20041;&#65292;&#32534;&#35793;&#22120;&#23558;&#19981;&#33021;&#20877;&#29983;&#25104;&#19968;&#20010;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#12290;&#20294;&#26159;&#32534;&#35793;&#22120;&#23558;&#20250;&#25193;&#20805;&#31243;&#24207;&#21592;&#23450;&#20041;&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#8212;&#8212;&#22312;&#26368;&#21069;&#38754;&#25554;&#20837;&#23545;&#21021;&#22987;&#21270; str &#30340;&#20195;&#30721;&#12290;&#33509;&#26377;&#22810;&#20010;&#23450;&#20041;&#26377;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#30340;&#25104;&#21592;&#23545;&#35937;&#65292;&#37027;&#20040;&#36825;&#20123;&#25104;&#21592; &#23545;&#35937;&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#30340;&#35843;&#29992;&#23558;&#20381;&#25454;&#22768;&#26126;&#39034;&#24207;&#25490;&#21015;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#32487;&#25215;&#33258;&#24102;&#26377;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#30340;&#22522;&#31867;&#30340;&#31867;</dt>
<dd><p>&#22914;&#26524;&#19968;&#20010;&#27809;&#26377;&#23450;&#20041;&#20219;&#20309;&#26500;&#36896;&#20989;&#25968;&#30340;&#31867;&#27966;&#29983;&#33258;&#24102;&#26377;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#30340;&#22522;&#31867;&#65292;&#37027;&#20040;&#32534;&#35793; &#22120;&#20026;&#23427;&#23450;&#20041;&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#65292;&#23558;&#25353;&#29031;&#22768;&#26126;&#39034;&#24207;&#20026;&#20043;&#20381;&#27425;&#35843;&#29992;&#20854;&#22522;&#31867;&#30340;&#40664;&#35748;&#26500;&#36896;&#20989; &#25968;&#12290;&#33509;&#35813;&#31867;&#27809;&#26377;&#23450;&#20041;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#32780;&#23450;&#20041;&#20102;&#22810;&#20010;&#20854;&#20182;&#26500;&#36896;&#20989;&#25968;&#65292;&#37027;&#20040;&#32534;&#35793;&#22120;&#25193;&#20805; &#23427;&#30340;&#25152;&#26377;&#26500;&#36896;&#20989;&#25968;&#8212;&#8212;&#21152;&#20837;&#24517;&#35201;&#30340;&#22522;&#31867;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#12290;&#21478;&#22806;&#65292;&#32534;&#35793;&#22120;&#20250;&#23558;&#22522;&#31867;&#30340;&#40664; &#35748;&#26500;&#36896;&#20989;&#25968;&#20195;&#30721;&#21152;&#22312;&#23545;&#35937;&#25104;&#21592;&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#20195;&#30721;&#20043;&#21069;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#24102;&#26377;&#34394;&#20989;&#25968;&#30340;&#31867; &#9829;&#65039;</dt>
<dd><p>&#24102;&#26377;&#34394;&#20989;&#25968;&#30340;&#31867;&#65292;&#19982;&#20854;&#23427;&#31867;&#19981;&#22826;&#19968;&#26679;&#65292;&#22240;&#20026;&#23427;&#22810;&#20102;&#19968;&#20010; vptr&#65292;<strong>&#32780; vptr &#30340;&#35774;&#32622;&#26159;&#30001;&#32534;&#35793;&#22120;&#23436;&#25104;&#30340;</strong>&#65292;&#22240;&#27492;&#32534;&#35793;&#22120;&#20250;&#20026;&#31867;&#30340;&#27599;&#20010;&#26500;&#36896;&#20989;&#25968;&#28155;&#21152;&#20195;&#30721;&#26469;&#23436;&#25104;&#23545; vptr &#30340;&#21021;&#22987;&#21270;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#24102;&#26377;&#19968;&#20010;&#34394;&#22522;&#31867;&#30340;&#31867; <code class="fold">@</code></dt>
<dd><p>&#22312;&#36825;&#31181;&#24773;&#20917;&#19979;&#65292;&#32534;&#35793;&#22120;&#35201;&#23558;&#34394;&#22522;&#31867;&#22312;&#31867;&#20013;&#30340;&#20301;&#32622;&#20934;&#22791;&#22949;&#24403;&#65292;&#25552;&#20379;&#25903;&#25345;&#34394;&#22522;&#31867;&#30340;&#26426; &#21046;&#12290;&#20063;&#23601;&#26159;&#35828;&#35201;&#22312;&#25152;&#26377;&#26500;&#36896;&#20989;&#25968;&#20013;&#21152;&#20837;&#23454;&#29616;&#21069;&#36848;&#21151;&#33021;&#30340;&#30340;&#20195;&#30721;&#12290;&#27809;&#26377;&#26500;&#36896;&#20989;&#25968;&#23558; &#21512;&#25104;&#20197;&#23436;&#25104;&#19978;&#36848;&#24037;&#20316;&#12290;</p>
</dd>
</dl></li>
</ul>
<p>&#24635;&#32467;&#65306;<strong>&#31616;&#21333;&#26469;&#35762;&#32534;&#35793;&#22120;&#20250;&#20026;&#26500;&#36896;&#20989;&#25968;&#20570;&#30340;&#19968;&#28857;&#20107;&#23601;&#26159;&#35843;&#29992;&#20854;&#22522;&#31867;&#25110;&#25104;&#21592;&#23545;&#35937;&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#65292;&#20197;&#21450;&#21021;&#22987;&#21270; vprt &#20197;&#21450;&#20934;&#22791;&#34394;&#22522;&#31867;&#30340;&#20301;&#32622;&#12290;</strong></p>
<p>&#24635;&#30340;&#26469;&#35828;&#65292;&#32534;&#35793;&#22120;&#23558;&#23545;&#26500;&#36896;&#20989;&#25968;&#21160;&#36825;&#20123;&#25163;&#33050;&#65306;</p>
<ul>
<li>&#22914;&#26524;&#31867;&#34394;&#32487;&#25215;&#33258;&#22522;&#31867;&#65292;&#32534;&#35793;&#22120;&#23558;&#22312;&#25152;&#26377;&#26500;&#36896;&#20989;&#25968;&#20013;&#25554;&#20837;&#20934;&#22791;&#34394;&#22522;&#31867;&#20301;&#32622;&#30340;&#20195;&#30721;&#21644;&#25552;&#20379;&#25903;&#25345;&#34394;&#22522;&#31867;&#26426;&#21046;&#30340;&#20195;&#30721;&#12290;</li>
<li>&#22914;&#26524;&#31867;&#22768;&#26126;&#26377;&#34394;&#20989;&#25968;&#65292;&#37027;&#20040;&#32534;&#35793;&#22120;&#23558;&#20026;&#20043;&#29983;&#25104;&#34394;&#20989;&#25968;&#34920;&#20197;&#23384;&#20648;&#34394;&#20989;&#25968;&#22320;&#22336;&#65292;&#24182;&#23558;&#34394;&#20989;&#25968;&#25351;&#38024;&#65288;vptr&#65289;&#30340;&#21021;&#22987;&#21270;&#20195;&#30721;&#25554;&#20837;&#21040;&#31867;&#30340;&#25152;&#26377;&#26500;&#36896;&#20989;&#25968;&#20013;&#12290;</li>
<li>&#22914;&#26524;&#31867;&#30340;&#29238;&#31867;&#26377;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#65292;&#32534;&#35793;&#23558;&#20250;&#23545;&#25152;&#26377;&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#25554;&#20837;&#35843;&#29992;&#20854;&#29238;&#31867;&#24517;&#35201;&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#12290;&#24517;&#35201;&#26159;&#25351;&#35774;&#35745;&#32773;&#27809;&#26377;&#26174;&#31034;&#21021;&#22987;&#21270;&#20854;&#29238;&#31867;&#65292;&#35843;&#29992;&#39034;&#24207;&#65292;&#20381;&#29031;&#20854;&#32487;&#25215;&#26102;&#22768;&#26126;&#39034;&#24207;&#12290;</li>
<li>&#22914;&#26524;&#31867;&#21253;&#21547;&#24102;&#26377;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#30340;&#23545;&#35937;&#25104;&#21592;&#65292;&#37027;&#20040;&#32534;&#35793;&#22120;&#23558;&#20250;&#20026;&#25152;&#26377;&#30340;&#26500;&#36896;&#20989;&#25968;&#25554;&#20837;&#23545;&#36825;&#20123;&#23545;&#35937;&#25104;&#21592;&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#36827;&#34892;&#24517;&#35201;&#30340;&#35843;&#29992;&#20195;&#30721;&#65292;&#25152;&#35859;&#24517;&#35201;&#26159;&#25351;&#31867;&#35774;&#35745;&#32773;&#35774;&#35745;&#30340;&#26500;&#36896;&#20989;&#25968;&#27809;&#26377;&#23545;&#23545;&#35937;&#25104;&#21592;&#36827;&#34892;&#26174;&#24335;&#21021;&#22987;&#21270;&#12290;&#25104;&#21592;&#23545;&#35937;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#30340;&#35843;&#29992;&#39034;&#24207;&#65292;&#20381;&#29031;&#20854;&#22768;&#26126;&#39034;&#24207;&#12290;</li>
<li>&#33509;&#31867;&#27809;&#26377;&#23450;&#20041;&#20219;&#20309;&#26500;&#36896;&#20989;&#25968;&#65292;&#32534;&#35793;&#22120;&#20250;&#20026;&#20854;&#21512;&#25104;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#65292;&#20877;&#25191;&#34892;&#19978;&#36848;&#22235;&#28857;&#12290;</li>
</ul>
</dd>
<dt>&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#65288;copy constructor&#65289; <code class="fold">@</code></dt>
<dd><p>&#36890;&#24120; C++ &#21021;&#32423;&#31243;&#24207;&#21592;&#20250;&#35748;&#20026;&#24403;&#19968;&#20010;&#31867;&#20026;&#27809;&#26377;&#23450;&#20041;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#30340;&#26102;&#20505;&#65292;&#32534;&#35793;&#22120;&#20250;&#20026;&#20854;&#21512;&#25104;&#19968;&#20010;&#65292;&#31572;&#26696;&#26159;&#21542;&#23450;&#30340;&#12290;&#32534;&#35793;&#22120;&#21482;&#26377;&#22312;&#24517;&#35201;&#30340;&#26102;&#20505;&#22312;&#21512;&#25104;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#12290;&#37027;&#20040;&#32534;&#35793;&#22120;&#20160;&#20040;&#26102;&#20505;&#21512;&#25104;&#65292;&#20160;&#20040;&#26102;&#20505;&#19981;&#21512;&#25104;&#65292;&#21512;&#25104;&#30340;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#22312;&#19981;&#21516;&#24773;&#20917;&#19979;&#20998;&#21035;&#22914;&#20309;&#24037;&#20316;&#21602;&#65311;&#36825;&#26159;&#26412;&#25991;&#30340;&#37325;&#28857;&#12290;</p>
<dl>
<dt>&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#30340;&#23450;&#20041;</dt>
<dd><p>&#26377;&#19968;&#20010;&#21442;&#25968;&#30340;&#31867;&#22411;&#26159;&#20854;&#31867;&#31867;&#22411;&#30340;&#26500;&#36896;&#20989;&#25968;&#26159;&#20026;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#12290;&#22914;&#19979;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">X::X( <span class="dt">const</span> X&amp; x);
Y::Y( <span class="dt">const</span> Y&amp; y, <span class="dt">int</span> =<span class="dv">0</span> );
<span class="co">//&#21487;&#20197;&#26159;&#22810;&#21442;&#25968;&#24418;&#24335;&#65292;&#20294;&#20854;&#31532;&#20108;&#20010;&#21363;&#21518;&#32487;&#21442;&#25968;&#37117;&#26377;&#19968;&#20010;&#40664;&#35748;&#20540;</span></code></pre></div>
</dd>
<dt>&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#30340;&#24212;&#29992;</dt>
<dd><p>&#24403;&#19968;&#20010;&#31867;&#23545;&#35937;&#20197;&#21478;&#19968;&#20010;&#21516;&#31867;&#23454;&#20307;&#20316;&#20026;&#21021;&#20540;&#26102;&#65292;&#22823;&#37096;&#20998;&#24773;&#20917;&#19979;&#20250;&#35843;&#29992;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#12290; &#19968;&#33324;&#26159;&#36825;&#19977;&#31181;&#20855;&#20307;&#24773;&#20917;&#65306;</p>
<ul>
<li>&#26174;&#24335;&#22320;&#20197;&#19968;&#20010;&#31867;&#23545;&#35937;&#20316;&#20026;&#21478;&#19968;&#20010;&#31867;&#23545;&#35937;&#30340;&#21021;&#20540;&#65292;&#24418;&#22914;X xx=x;</li>
<li>&#24403;&#31867;&#23545;&#35937;&#34987;&#20316;&#20026;&#21442;&#25968;&#20132;&#32473;&#20989;&#25968;&#26102;&#12290;</li>
<li>&#24403;&#20989;&#25968;&#36820;&#22238;&#19968;&#20010;&#31867;&#23545;&#35937;&#26102;&#12290;</li>
</ul>
</dd>
<dt>&#32534;&#35793;&#22120;&#20309;&#26102;&#21512;&#25104;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;</dt>
<dd><p>&#24182;&#19981;&#26159;&#25152;&#26377;&#26410;&#23450;&#20041;&#26377;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#30340;&#31867;&#32534;&#35793;&#22120;&#37117;&#20250;&#20026;&#20854;&#21512;&#25104;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#65292;&#32534;&#35793;&#22120;&#21482;&#26377;&#22312;&#24517;&#35201;&#30340;&#26102;&#20505;&#25165;&#20250;&#20026;&#20854;&#21512;&#25104;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#12290;&#25152;&#35859;&#24517;&#35201;&#30340;&#26102;&#21051;&#26159;&#25351;&#32534;&#35793;&#22120;&#22312;&#26222;&#36890;&#25163;&#27573;&#26080;&#27861;&#23436;&#25104;&#35299;&#20915;&#8220;&#24403;&#19968;&#20010;&#31867;&#23545;&#35937;&#20197;&#21478;&#19968;&#20010;&#21516;&#31867;&#23454;&#20307;&#20316;&#20026;&#21021;&#20540;&#8221;&#26102;&#65292;&#25165;&#20250;&#21512;&#25104;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#12290;&#20063;&#23601;&#26159;&#35828;&#65292;&#24403;&#24120;&#35268;&#27494;&#22120;&#33021;&#35299;&#20915;&#38382;&#39064;&#30340;&#26102;&#20505;&#65292;&#23601;&#27809;&#24517;&#35201;&#21160;&#29992;&#38750;&#24120;&#35268;&#27494;&#22120;&#12290;</p>
<p>&#22914;&#26524;&#19968;&#20010;&#31867;&#27809;&#26377;&#23450;&#20041;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#65292;&#36890;&#24120;&#25353;&#29031;&#8220;&#25104;&#21592;&#36880;&#19968;&#21021;&#22987;&#21270; (Default Memberwise Initialization)&#8221;&#30340;&#25163;&#27861;&#26469;&#35299;&#20915;&#8220;&#19968;&#20010;&#31867;&#23545;&#35937;&#20197;&#21478;&#19968;&#20010;&#21516;&#31867;&#23454;&#20307;&#20316;&#20026;&#21021;&#20540;&#8221;&#8212;&#8212;&#20063;&#23601;&#26159;&#35828;&#25226;&#20869;&#24314;&#25110;&#27966;&#29983;&#30340;&#25968;&#25454;&#25104;&#21592;&#20174;&#26576;&#19968;&#20010;&#23545;&#35937;&#25335;&#36125;&#21040;&#21478;&#19968;&#20010;&#23545;&#35937;&#36523;&#19978;&#65292;&#22914;&#26524;&#25968;&#25454;&#25104;&#21592;&#26159;&#19968;&#20010;&#23545;&#35937;&#65292;&#21017;&#36882;&#24402;&#20351;&#29992;&#8220;&#25104;&#21592;&#36880;&#19968;&#21021;&#22987;&#21270; (Default Memberwise Initialization)&#8221;&#30340;&#25163;&#27861;&#12290;</p>
<p><strong>&#25104;&#21592;&#36880;&#19968;&#21021;&#22987;&#21270; (Default Memberwise Initialization)</strong> &#20855;&#20307;&#30340;&#23454;&#29616;&#26041;&#24335;&#21017;&#26159;<strong>&#20301;&#36880;&#27425;&#25335;&#36125;&#65288;Bitwise copy semantics&#65289;</strong>1&#12290;&#20063;&#23601;&#26159;&#35828;&#22312;&#33021;&#20351;&#29992;&#36825;&#31181;&#24120;&#35268;&#26041;&#24335; &#26469;&#35299;&#20915;&#8220;&#19968;&#20010;&#31867;&#23545;&#35937;&#20197;&#21478;&#19968;&#20010;&#21516;&#31867;&#23454;&#20307;&#20316;&#20026;&#21021;&#20540;&#8221;&#30340;&#26102;&#20505;&#65292;&#32534;&#35793;&#22120;&#26159;&#19981;&#38656;&#35201;&#21512;&#25104;&#25335; &#36125;&#26500;&#36896;&#20989;&#25968;&#30340;&#12290;&#20294;&#26377;&#20123;&#26102;&#20505;&#24120;&#35268;&#27494;&#22120;&#19981;&#37027;&#20040;&#31649;&#29992;&#65292;&#25105;&#20204;&#23601;&#24471;&#31085;&#20986;&#38750;&#24120;&#35268;&#27494;&#22120;&#20102; &#8212;&#8212;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#12290;&#26377;&#20197;&#19979;&#20960;&#31181;&#24773;&#20917;&#20043;&#19968;&#65292;&#20301;&#36880;&#27425;&#25335;&#36125;&#23558;&#19981;&#33021;&#32988;&#20219;&#25110;&#32773;&#19981;&#36866;&#21512;&#26469;&#23436; &#25104;&#8220;&#19968;&#20010;&#31867;&#23545;&#35937;&#20197;&#21478;&#19968;&#20010;&#21516;&#31867;&#23454;&#20307;&#20316;&#20026;&#21021;&#20540;&#8221;&#30340;&#24037;&#20316;&#12290;&#27492;&#26102;&#65292;&#22914;&#26524;&#31867;&#27809;&#26377;&#23450;&#20041;&#25335;&#36125; &#26500;&#36896;&#20989;&#25968;&#65292;&#37027;&#20040;&#32534;&#35793;&#22120;&#23558;&#24517;&#39035;&#20026;&#31867;&#21512;&#25104;&#19968;&#20010;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#12290;</p>
<ul>
<li>&#24403;&#31867;&#20869;&#21547;&#19968;&#20010;&#25104;&#21592;&#23545;&#35937;&#65292;&#32780;&#21518;&#32773;&#30340;&#31867;&#22768;&#26126;&#26377;&#19968;&#20010;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#26102;&#65288;&#19981;&#35770;&#26159;&#35774; &#35745;&#32773;&#23450;&#20041;&#30340;&#36824;&#26159;&#32534;&#35793;&#22120;&#21512;&#25104;&#30340;&#65289;&#12290;</li>
<li>&#24403;&#31867;&#32487;&#25215;&#33258;&#19968;&#20010;&#22768;&#26126;&#26377;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#30340;&#31867;&#26102;&#65288;&#21516;&#26679;&#65292;&#19981;&#35770;&#36825;&#20010;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968; &#26159;&#34987;&#26174;&#31034;&#22768;&#26126;&#36824;&#26159;&#30001;&#32534;&#35793;&#22120;&#21512;&#25104;&#30340;&#65289;&#12290;</li>
<li>&#31867;&#20013;&#22768;&#26126;&#26377;&#34394;&#20989;&#25968;&#12290;</li>
<li>&#24403;&#31867;&#30340;&#27966;&#29983;&#20018;&#38142;&#20013;&#21253;&#21547;&#26377;&#19968;&#20010;&#25110;&#22810;&#20010;&#34394;&#22522;&#31867;&#12290;</li>
</ul>
<p>&#23545;&#20110;&#21069;&#20004;&#31181;&#24773;&#20917;&#65292;&#19981;&#35770;&#26159;&#22522;&#31867;&#36824;&#26159;&#23545;&#35937;&#25104;&#21592;&#65292;&#26082;&#28982;&#21518;&#32773;&#22768;&#26126;&#26377;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#26102;&#65292; &#23601;&#34920;&#26126;&#20854;&#31867;&#30340;&#35774;&#35745;&#32773;&#25110;&#32773;&#32534;&#35793;&#22120;&#24076;&#26395;&#20197;&#20854;&#22768;&#26126;&#30340;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#26469;&#23436;&#25104;&#8220; &#19968;&#20010;&#31867;&#23545;&#35937; &#20197;&#21478;&#19968;&#20010;&#21516;&#31867;&#23454;&#20307;&#20316;&#20026;&#21021;&#20540;&#8221;&#30340;&#24037;&#20316;&#65292;&#32780;&#35774;&#35745;&#32773;&#25110;&#32534;&#35793;&#22120;&#36825;&#26679;&#20570;&#8212; &#8212;&#22768;&#26126;&#25335;&#36125;&#26500;&#36896;&#20989; &#25968;&#65292;&#24635;&#26377;&#23427;&#20204;&#30340;&#29702;&#30001;&#65292;&#32780;&#36890;&#24120;&#26368;&#30452;&#25509;&#30340;&#21407;&#22240;&#33707;&#36807;&#20110;&#22240;&#20026;&#20182;&#20204;&#24819;&#35201;&#20570;&#19968;&#20123;&#39069;&#22806;&#30340;&#24037; &#20316;&#25110;&#8220;&#20301;&#36880;&#27425;&#25335;&#36125;&#8221;&#26080;&#27861;&#32988;&#20219;&#12290;</p>
<p>&#23545;&#20110;&#26377;&#34394;&#20989;&#25968;&#30340;&#31867;&#65292;&#22914;&#26524;&#20004;&#20010;&#23545;&#35937;&#30340;&#31867;&#22411;&#30456;&#21516;&#37027;&#20040;&#20301;&#36880;&#27425;&#25335;&#36125;&#20854;&#23454;&#26159;&#21487;&#20197;&#32988;&#20219;&#30340;&#12290; &#20294;&#38382;&#39064;&#23558;&#20986;&#29616;&#22312;&#65292;&#22914;&#26524;&#22522;&#31867;&#30001;&#20854;&#32487;&#25215;&#31867;&#36827;&#34892;&#21021;&#22987;&#21270;&#26102;&#65292;&#27492;&#26102;&#33509;&#25353;&#29031;&#20301;&#36880;&#27425;&#25335;&#36125;&#26469; &#23436;&#25104;&#36825;&#20010;&#24037;&#20316;&#65292;&#37027;&#20040;&#22522;&#31867;&#30340; vptr &#23558;&#25351;&#21521;&#20854;&#32487;&#25215;&#31867;&#30340;&#34394;&#20989;&#25968;&#34920;&#65292;&#36825;&#23558;&#23548;&#33268;&#26080;&#27861;&#39044;&#26009; &#30340;&#21518;&#26524;&#8212;&#8212;&#35843;&#29992;&#19968;&#20010;&#38169;&#35823;&#30340;&#34394;&#20989;&#25968;&#23454;&#20307;&#26159;&#26080;&#27861;&#36991;&#20813;&#30340;&#65292;&#36731;&#21017;&#24102;&#26469;&#31243;&#24207;&#23849;&#28291;&#65292;&#26356;&#31967;&#31957; &#30340;&#38382;&#39064;&#21487;&#33021;&#26159;&#36825;&#20010;&#38169;&#35823;&#34987;&#38544;&#34255;&#20102;&#12290;&#25152;&#20197;&#23545;&#20110;&#26377;&#34394;&#20989;&#25968;&#30340;&#31867;&#32534;&#35793;&#22120;&#23558;&#20250;&#26126;&#30830;&#30340;&#20351;&#34987; &#21021;&#22987;&#21270;&#30340;&#23545;&#35937;&#30340; vptr &#25351;&#21521;&#27491;&#30830;&#30340;&#34394;&#20989;&#25968;&#34920;&#12290;&#22240;&#27492;&#26377;&#34394;&#20989;&#25968;&#30340;&#31867;&#27809;&#26377;&#22768;&#26126;&#25335;&#36125;&#26500;&#36896; &#20989;&#25968;&#65292;&#32534;&#35793;&#23558;&#20026;&#20043;&#21512;&#25104;&#19968;&#20010;&#65292;&#26469;&#23436;&#25104;&#19978;&#36848;&#24037;&#20316;&#65292;&#20197;&#21450;&#21021;&#22987;&#21270;&#21508;&#25968;&#25454;&#25104;&#21592;&#65292;&#22768;&#26126;&#26377; &#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#30340;&#35805;&#20063;&#20250;&#34987;&#25554;&#20837;&#23436;&#25104;&#19978;&#36848;&#24037;&#20316;&#30340;&#20195;&#30721;&#12290;</p>
<p>&#23545;&#20110;&#32487;&#25215;&#20018;&#38142;&#20013;&#26377;&#34394;&#22522;&#31867;&#30340;&#24773;&#20917;&#65292;&#38382;&#39064;&#21516;&#26679;&#20986;&#29616;&#22312;&#32487;&#25215;&#31867;&#21521;&#22522;&#31867;&#25552;&#20379;&#21021;&#20540;&#30340;&#24773;&#20917;&#65292; &#27492;&#26102;&#20301;&#36880;&#27425;&#25335;&#36125;&#26377;&#21487;&#33021;&#30772;&#22351;&#23545;&#35937;&#20013;&#34394;&#22522;&#31867;&#23376;&#23545;&#35937;&#30340;&#20301;&#32622;&#12290;</p>
</dd>
</dl>
</dd>
<dt>&#21629;&#21517;&#36820;&#22238;&#20540;&#20248;&#21270;&#21644;&#25104;&#21592;&#21021;&#22987;&#21270;&#38431;&#21015; <code class="fold">@</code></dt>
<dd><p>&#23545;&#20110;&#19968;&#20010;&#22914; foo() &#36825;&#26679;&#30340;&#20989;&#25968;&#65292;&#23427;&#30340;&#27599;&#19968;&#20010;&#36820;&#22238;&#20998;&#25903;&#37117;&#36820;&#22238;&#30456;&#21516;&#30340;&#23545;&#35937;&#65292;&#32534;&#35793;&#22120;&#26377;&#21487;&#33021;&#23545;&#20854;&#20570; <strong>Named return Value &#20248;&#21270;&#65288;NRV &#20248;&#21270;&#65289;</strong>&#65292;&#26041;&#27861;&#26159;&#20197;&#19968;&#20010;&#21442;&#25968; result &#21462;&#20195;&#36820;&#22238;&#23545;&#35937;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">X foo()                            <span class="dt">void</span>  foo(X &amp;result)
{                                  {
    X xx;                              result.X::X();
    <span class="kw">if</span>(...)                            <span class="kw">if</span>(...)
        <span class="kw">return</span> xx;                     {
    <span class="kw">else</span>                                   <span class="co">//&#30452;&#25509;&#22788;&#29702;result</span>
        <span class="kw">return</span> xx;                         <span class="kw">return</span>;
}                                      }
                                       <span class="kw">else</span>
                                       {
                                           <span class="co">//&#30452;&#25509;&#22788;&#29702;result</span>
                                           <span class="kw">return</span>;
                                       }
                                   }</code></pre></div>
<p>&#23545;&#27604;&#20248;&#21270;&#21069;&#19982;&#20248;&#21270;&#21518;&#30340;&#20195;&#30721;&#21487;&#20197;&#30475;&#20986;&#65292;&#23545;&#20110;&#19968;&#21477;&#31867;&#20284;&#20110; <code>X a = foo()</code> &#36825;&#26679;&#30340;&#20195; &#30721;&#65292; NRV &#20248;&#21270;&#21518;&#30340;&#20195;&#30721;&#30456;&#36739;&#20110;&#21407;&#20195;&#30721;&#33410;&#30465;&#20102;&#19968;&#20010;&#20020;&#26102;&#23545;&#35937;&#30340;&#31354;&#38388;&#65288;&#30465;&#30053;&#20102; xx&#65289;, &#21516;&#26102;&#20943;&#23569;&#20102;&#20004;&#27425;&#20989;&#25968;&#35843;&#29992;&#65288;&#20943;&#23569; xx &#23545;&#35937;&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#21644;&#26512;&#26500;&#20989;&#25968;&#65292;&#20197;&#21450;&#19968;&#27425;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#30340;&#35843;&#29992;&#65292;&#22686;&#21152;&#20102;&#19968;&#27425;&#23545; a &#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#30340;&#35843;&#29992;&#65289;&#12290;</p>
</dd>
<dt>&#25104;&#21592;&#21021;&#22987;&#21270;&#38431;&#21015;&#65288;Member Initialization List&#65289; <code class="fold">@</code></dt>
<dd><p>&#23545;&#20110;&#21021;&#22987;&#21270;&#38431;&#21015;&#65292;&#25105;&#30456;&#20449;&#21400;&#28165;&#19968;&#20010;&#27010;&#24565;&#26159;&#38750;&#24120;&#37325;&#35201;&#30340;&#65306;&#22312;&#26500;&#36896;&#20989;&#25968;&#20013;&#23545;&#20110;&#23545;&#35937; &#25104;&#21592;&#30340;&#21021;&#22987;&#21270;&#21457;&#29983;&#22312;&#21021;&#22987;&#21270;&#38431;&#21015;&#20013;&#8212;&#8212;&#25110;&#32773;&#25105;&#20204;&#21487;&#20197;&#25226;&#21021;&#22987;&#21270;&#38431;&#21015;&#30452;&#25509;&#30475;&#20570;&#26159;&#23545; &#25104;&#21592;&#30340;&#23450;&#20041;&#65292;&#32780;&#26500;&#36896;&#20989;&#25968;&#20307;&#20013;&#36827;&#34892;&#30340;&#21017;&#26159;&#36171;&#20540;&#25805;&#20316;&#12290;&#25152;&#20197;&#19981;&#38590;&#29702;&#35299;&#26377;&#22235;&#31181;&#24773;&#20917; &#24517;&#39035;&#29992;&#21040;&#21021;&#22987;&#21270;&#21015;&#34920;&#65306;</p>
<ul>
<li>&#26377; const &#25104;&#21592;</li>
<li>&#26377;&#24341;&#29992;&#31867;&#22411;&#25104;&#21592;</li>
<li>&#25104;&#21592;&#23545;&#35937;&#27809;&#26377;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;</li>
<li>&#22522;&#31867;&#23545;&#35937;&#27809;&#26377;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;</li>
</ul>
</dd>
</dl>
<p>&#21069;&#20004;&#32773;&#22240;&#20026;&#35201;&#27714;&#23450;&#20041;&#26102;&#21021;&#22987;&#21270;&#65292;&#25152;&#20197;&#24517;&#39035;&#26126;&#30830;&#30340;&#22312;&#21021;&#22987;&#21270;&#38431;&#21015;&#20013;&#32473;&#23427;&#20204;&#25552;&#20379;&#21021; &#20540;&#12290;&#21518;&#20004;&#32773;&#22240;&#20026;&#19981;&#25552;&#20379;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#65292;&#25152;&#26377;&#24517;&#39035;&#26174;&#31034;&#30340;&#35843;&#29992;&#23427;&#20204;&#30340;&#24102;&#21442;&#26500;&#36896;&#20989; &#25968;&#26469;&#23450;&#20041;&#21363;&#21021;&#22987;&#21270;&#23427;&#20204;&#12290;</p>
<p>&#26174;&#32780;&#26131;&#35265;&#30340;&#26159;&#24403;&#31867;&#20013;&#21547;&#26377;&#23545;&#35937;&#25104;&#21592;&#25110;&#32773;&#32487;&#25215;&#33258;&#22522;&#31867;&#30340;&#26102;&#20505;&#65292;&#22312;&#21021;&#22987;&#21270;&#38431;&#21015;&#20013;&#21021; &#22987;&#21270;&#25104;&#21592;&#23545;&#35937;&#21644;&#22522;&#31867;&#23376;&#23545;&#35937;&#20250;&#22312;&#25928;&#29575;&#19978;&#24471;&#21040;&#25552;&#21319;&#8212;&#8212;&#30465;&#21435;&#20102;&#19968;&#20123;&#36171;&#20540;&#25805;&#20316;&#22043;&#12290;</p>
<p>&#26368;&#21518;&#65292;&#19968;&#20010;&#20851;&#20110;&#21021;&#22987;&#21270;&#38431;&#21015;&#20247;&#25152;&#21608;&#30693;&#30340;&#38519;&#38449;&#65292;&#21021;&#22987;&#21270;&#38431;&#21015;&#30340;&#39034;&#24207;&#65292;&#35831;&#21442;&#32771;&#12298; C++ primer&#12299;&#25110;&#32773;&#12298;&#28145;&#24230;&#25506;&#32034; C++ &#23545;&#35937;&#27169;&#22411;&#12299;&#12290;</p>
</dd>
<dt>&#31532; 3 &#31456; Data&#35821;&#24847;&#23398;&#65288;The Semantics of Data&#65289; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><dl>
<dt>C++ &#31867;&#23545;&#35937;&#30340;&#22823;&#23567; <code class="fold">@</code></dt>
<dd><p>&#20107;&#23454;&#19978;&#65292;&#23545;&#20110;&#20687; X &#36825;&#26679;&#30340;&#19968;&#20010;&#30340;&#31354;&#31867;&#65292;&#32534;&#35793;&#22120;&#20250;&#23545;&#20854;&#21160;&#28857;&#25163;&#33050;&#8212;&#8212;&#38544;&#26214;&#30340;&#25554;&#20837;&#19968;&#20010;&#23383;&#33410;&#12290;&#20026;&#20160;&#20040;&#35201;&#36825;&#26679;&#20570;&#21602;&#65311;&#25554;&#20837;&#20102;&#36825;&#19968;&#20010;&#23383;&#33410;&#65292;&#37027;&#20040; X &#30340;&#27599;&#19968;&#20010;&#23545;&#35937;&#37117;&#23558;&#26377;&#19968;&#20010;&#29420;&#19968;&#26080;&#20108;&#30340;&#22320;&#22336;&#12290;&#22914;&#26524;&#19981;&#25554;&#20837;&#36825;&#19968;&#20010;&#23383;&#33410;&#21602;&#65311;&#21756;&#21756;&#65292;&#37027;&#23545; X &#30340;&#23545;&#35937;&#21462;&#22320;&#22336;&#30340;&#32467;&#26524;&#26159;&#20160;&#20040;&#65311;&#20004;&#20010;&#19981;&#21516;&#30340; X &#23545;&#35937;&#38388;&#22320;&#22336;&#30340;&#27604;&#36739;&#24590;&#20040;&#21150;&#65311;</p>
<p>&#23545;&#20110;&#37027;&#20301; Lippman &#30340;&#27861;&#22269;&#35835;&#32773;&#26469;&#35828;&#65292;A &#30340; &#22823;&#23567;&#26159;&#20849;&#20139;&#30340; X &#23454;&#20307; 1 &#23383;&#33410;&#65292;X &#21644; Y &#30340;&#22823;&#23567;&#20998;&#21035;&#20943;&#21435;&#34394;&#22522;&#31867;&#24102;&#26469;&#30340;&#20869;&#23384;&#31354;&#38388;&#65292;&#37117;&#26159; 4&#12290;A &#30340;&#24635;&#35745;&#22823;&#23567;&#20026; 9&#65292;alignment &#20197;&#21518;&#23601;&#26159; 12 &#20102;&#12290;&#32780;&#23545;&#20110; vs2010 &#26469;&#35828;&#65292;&#37027;&#20010;&#19968;&#23383;&#33410;&#34987;&#20248;&#21270;&#21518;&#65292;A &#30340;&#22823;&#23567;&#20026; 8&#65292;&#20063;&#19981;&#38656;&#20877;&#36827;&#34892; alignment &#25805;&#20316;&#12290;</p>
<p>&#24433;&#21709; C++ &#31867;&#30340;&#22823;&#23567;&#30340;&#19977;&#20010;&#22240;&#32032;&#65306;</p>
<ul>
<li>&#25903;&#25345;&#29305;&#27530;&#21151;&#33021;&#25152;&#24102;&#26469;&#30340;&#39069;&#22806;&#36127;&#25285;&#65288;&#23545;&#21508;&#31181; virtual &#30340;&#25903;&#25345;&#65289;&#12290;</li>
<li>&#32534;&#35793;&#22120;&#23545;&#29305;&#27530;&#24773;&#20917;&#30340;&#20248;&#21270;&#22788;&#29702;&#12290;</li>
<li>alignment &#25805;&#20316;&#65292;&#21363;&#20869;&#23384;&#23545;&#40784;&#12290;</li>
</ul>
<p>C++ &#23545;&#35937;&#27169;&#22411;&#23613;&#37327;&#20197;&#12304;&#31354;&#38388;&#20248;&#21270;&#12305;&#21644;&#12304;&#23384;&#21462;&#36895;&#24230;&#20248;&#21270;&#12305;&#32771;&#34385;&#26469;&#34920;&#29616; nonstatic data members&#65292;&#24182;&#19988;&#20445;&#25345;&#21644; C &#35821;&#35328; struct &#25968;&#25454;&#37197;&#32622;&#30340;&#20860;&#23481;&#24615;&#12290;</p>
<dl>
<dt><strong>member scope resolution rules</strong></dt>
<dd><p>&#36825;&#26679;&#30340;&#22909;&#22788;&#26159;&#65292;&#20320;&#19981;&#24517;&#25226;&#25152;&#26377;&#30340; data members &#25918;&#22312;&#19968;&#24320;&#22987;&#23601;&#22768;&#26126;&#12290;&#21807;&#19968;&#30340;&#29305;&#20363;&#26159;&#31867;&#20013;&#30340;&#23376;&#31867;&#22411;&#65288;nested type&#65289;&#65292;&#38656;&#35201;&#25918;&#22312;&#21069;&#38754;&#12290;</p>
</dd>
</dl>
</dd>
<dt>VC &#20869;&#23384;&#23545;&#40784;&#20934;&#21017;&#65288;Memory alignment&#65289; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// sizeof(T) == 1+(3) + 4 + 8 = 16</span>
<span class="kw">class</span> T {
    <span class="dt">char</span> c;
    <span class="dt">int</span> i;
    <span class="dt">double</span>  d;
};

<span class="co">// sizeof(T) == 1+(7) + 8 + 4+(4) = 24</span>
<span class="kw">class</span> T {
    <span class="dt">char</span> c;
    <span class="dt">double</span>  d;
    <span class="dt">int</span> i;
};</code></pre></div>
<p>Vptr &#24433;&#21709;&#23545;&#40784;&#32780; VbcPoint(Virtual base class pointer) &#19981;&#24433;&#21709;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> X{ <span class="dt">char</span> a; };
<span class="kw">class</span> Y : <span class="kw">virtual</span> <span class="kw">public</span> X{};</code></pre></div>
</dd>
<dt>C++ &#23545;&#35937;&#30340;&#25968;&#25454;&#25104;&#21592; <code class="fold">@</code></dt>
<dd><p>C++ &#26631;&#20934;&#30340;&#35268;&#23450;</p>
<ul>
<li>&#22312;&#21516;&#19968;&#20010; Access Section&#65288;&#20063;&#23601;&#26159; private,public,protected &#29255;&#27573;&#65289;&#20013;&#65292; &#35201;&#27714;&#36739;&#26202;&#20986;&#29616;&#30340;&#25968;&#25454;&#25104;&#21592;&#22788;&#22312;&#36739;&#22823;&#30340;&#20869;&#23384;&#20013;&#12290;&#36825;&#24847;&#21619;&#30528;&#21516;&#19968;&#20010;&#29255;&#27573;&#20013;&#30340;&#25968;&#25454;&#25104;&#21592;&#24182;&#19981;&#38656;&#35201;&#32039;&#23494;&#30456;&#36830;&#65292;&#32534;&#35793;&#22120;&#25152;&#20570;&#30340;&#25104;&#21592;&#23545;&#40784;&#23601;&#26159;&#19968;&#20010;&#20363;&#23376;&#12290;</li>
<li>&#20801;&#35768;&#32534;&#35793;&#22120;&#23558;&#22810;&#20010; Acess Section &#30340;&#39034;&#24207;&#33258;&#30001;&#25490;&#21015;&#65292;&#32780;&#19981;&#24517;&#22312;&#20046;&#23427;&#20204;&#30340;&#22768;&#26126; &#27425;&#24207;&#12290;&#20294;&#20284;&#20046;&#27809;&#26377;&#32534;&#35793;&#22120;&#36825;&#26679;&#20570;&#12290;</li>
<li><strong>&#23545;&#20110;&#32487;&#25215;&#31867;&#65292;C++ &#26631;&#20934;&#24182;&#26410;&#25351;&#23450;&#26159;&#20854;&#22522;&#31867;&#25104;&#21592;&#22312;&#21069;&#36824;&#26159;&#33258;&#24049;&#30340;&#25104;&#21592;&#22312;&#21069;&#12290;</strong> &#65288;&#36825;&#19968;&#28857;&#26377;&#28857;&#21453;&#30452;&#35273;&#65289;</li>
<li>&#23545;&#20110;&#34394;&#22522;&#31867;&#25104;&#21592;&#20063;&#26159;&#21516;&#26679;&#30340;&#26410;&#20104;&#35268;&#23450;&#12290;</li>
</ul>
<p>&#19968;&#33324;&#30340;&#32534;&#35793;&#22120;&#24590;&#20040;&#20570;&#65311;</p>
<ul>
<li>&#21516;&#19968;&#20010; Access Section &#20013;&#30340;&#25968;&#25454;&#25104;&#21592;&#25353;&#26399;&#22768;&#26126;&#39034;&#24207;&#65292;&#20381;&#27425;&#25490;&#21015;&#12290; &#20294;&#25104;&#21592;&#19982;&#25104;&#21592;&#20043;&#38388;&#22240;&#20026;&#20869;&#23384;&#23545;&#40784;&#30340;&#21407;&#22240;&#21487;&#33021;&#23384;&#22312;&#31354;&#24403;&#12290;</li>
<li>&#22810;&#20010; Access Section &#25353;&#20854;&#22768;&#26126;&#39034;&#24207;&#25490;&#25918;&#12290;</li>
<li><strong>&#22522;&#31867;&#30340;&#25968;&#25454;&#25104;&#21592;&#24635;&#25918;&#22312;&#33258;&#24049;&#30340;&#25968;&#25454;&#25104;&#21592;&#20043;&#21069;&#65292;&#20294;&#34394;&#22522;&#31867;&#38500;&#22806;&#12290;</strong>&#65288;&#34394;&#22522;&#31867;&#27809;&#26377; instance&#65292;&#25104;&#21592;&#20989;&#25968;&#30452;&#25509;&#36827;&#33258;&#24049;&#30340;&#25104;&#21592;&#20013;&#12290;&#65289;</li>
</ul>
<p><strong>&#20026;&#20102;&#23454;&#29616;&#34394;&#20989;&#25968;&#21644;&#34394;&#25311;&#32487;&#25215;&#20004;&#20010;&#21151;&#33021;&#65292;&#32534;&#35793;&#22120;&#19968;&#33324;&#20250;&#21512;&#25104; Vptr &#21644; Vbptr &#20004;&#20010;&#25351;&#38024;&#12290;</strong>&#37027;&#20040;&#36825;&#20004;&#20010;&#25351;&#38024;&#24212;&#35813;&#25918;&#22312;&#20160;&#20040;&#20301;&#32622;&#65311;C++ &#26631;&#20934;&#32943;&#23450;&#26159;&#19981;&#26366;&#35268;&#23450;&#30340;&#65292;&#22240;&#20026;&#23427;&#29978;&#33267;&#24182;&#27809;&#26377;&#35268;&#23450;&#22914;&#20309;&#26469;&#23454;&#29616;&#36825;&#20004;&#20010;&#21151;&#33021;&#65292;&#22240;&#27492;&#23601;&#35821;&#35328;&#23618;&#38754;&#26469;&#30475;&#26159;&#19981;&#23384;&#22312;&#36825;&#20004;&#20010;&#25351;&#38024;&#30340;&#12290;</p>
<p>&#23545;&#20110; Vptr &#26469;&#35828;&#26377;&#30340;&#32534;&#35793;&#22120;&#23558;&#23427;&#25918;&#22312;&#26411;&#23614;&#65292;&#22914; Lippman &#39046;&#23548;&#24320;&#21457;&#30340; Cfront&#12290;&#26377;&#30340;&#21017;&#23558;&#20854;&#25918;&#22312;&#26368;&#21069;&#38754;&#65292;&#22914; MS &#30340; VC&#65292;&#20294;&#20284;&#20046;&#27809;&#20154;&#23558;&#23427;&#25918;&#22312;&#20013;&#38388;&#12290;&#20026;&#20160;&#20040;&#19981;&#25918;&#22312;&#20013;&#38388;&#65311;&#27809;&#26377;&#29702;&#30001;&#21487;&#20197;&#35753;&#20154;&#36825;&#20040;&#20570;&#65292;&#25918;&#22312;&#26411;&#23614;&#65292;&#21487;&#20197;&#20445;&#25345; C++ &#31867;&#23545; C &#30340; struct &#30340;&#33391;&#22909;&#20860;&#23481;&#24615;&#65292;&#25918;&#22312;&#26368;&#21069;&#21487;&#20197;&#32473;&#22810;&#37325;&#32487;&#25215;&#19979;&#30340;&#25351;&#38024;&#25110;&#24341;&#29992;&#35843;&#29992;&#34394;&#20989;&#25968;&#24102;&#26469;&#22909;&#22788;&#12290;</p>
<p>&#65288;By the way&#65292;&#19968;&#20010; class &#37324;&#26377;&#24456;&#22810; virtual function&#65292;vptr &#36824;&#26159;&#19968;&#20010;&#12290;&#21482;&#26377;&#23427;&#32487;&#25215;&#20102;&#22909;&#20960;&#20010;&#26377; vptr &#24471; class &#30340;&#26102;&#20505;&#65292;&#23427;&#25165;&#26377;&#24456;&#22810; vptr&#12290;&#65289;</p>
<p>&#30475;&#19968;&#23567;&#27573;&#20195;&#30721;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;stddef.h&gt;</span>

<span class="kw">class</span> X {
<span class="kw">public</span>:
    <span class="dt">int</span> a;
    <span class="kw">virtual</span> <span class="dt">void</span> vfc() { }
};

<span class="dt">int</span> main()
{
    X x;
    std::cout &lt;&lt; &amp;x.a&lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; &amp;x &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="st">&quot;offset: &quot;</span> &lt;&lt; offsetof( X, a ) &lt;&lt; std::endl;
}</code></pre></div>
<p>&#22312; VS2010 &#21644; VC6.0 &#20013;&#36816;&#34892;&#30340;&#32467;&#26524;&#37117;&#26159;&#22320;&#22336;&#20540; <code>&amp;x.a</code> &#27604; <code>&amp;x</code> &#22823; 4&#65292;&#21487;&#35265;&#35828; vc &#30340; vptr &#25918;&#22312;&#23545;&#35937;&#30340;&#26368;&#21069;&#38754;&#27492;&#35328;&#38750;&#34394;&#12290;&#65288;&#22312; GCC 4.8 x64 &#20013;&#26159;&#22823; 8&#65292;&#32467;&#35770;&#19968;&#26679;&#12290;&#65289;</p>
<p>&#23545;&#20110; Vbptr &#26469;&#35828;&#65292;&#26377;&#22909;&#20960;&#31181;&#26041;&#27861;&#65292;&#22312;&#36825;&#20799;&#25105;&#20204;&#21482;&#30475;&#30475; VC &#30340;&#23454;&#29616;&#21407;&#29702;&#65306;???</p>
<blockquote>
<p>&#23545;&#20110;&#30001;&#34394;&#25311;&#32487;&#25215;&#32780;&#24471;&#30340;&#31867;&#65292;VC &#20250;&#22312;&#20854;&#27599;&#19968;&#20010;&#23545;&#35937;&#20013;&#25554;&#20837;&#19968;&#20010; Vbptr&#65292;&#36825;&#20010; Vbptr &#25351;&#21521; vitual base class table&#65288;&#34394;&#22522;&#31867;&#34920;&#65289;&#12290;&#34394;&#22522;&#31867;&#34920;&#20013;&#21017;&#23384;&#25918;&#26377;&#20854;&#34394;&#22522;&#31867;&#23376;&#23545;&#35937;&#30456;&#23545;&#20110;&#34394;&#22522;&#31867;&#25351;&#38024;&#30340;&#20559;&#31227;&#37327;&#12290;&#20363;&#22914;&#22768;&#26126;&#22914; <code>class Y:virtual public X</code> &#30340;&#31867;&#30340; virtual base class table &#30340;&#34394;&#22522;&#31867;&#34920;&#20013;&#24403;&#23384;&#20648;&#26377; X &#23545;&#35937;&#30456;&#23545;&#20110;Vbptr&#30340;&#20559;&#31227;&#37327;&#12290;</p>
</blockquote>
<p>&#23545;&#35937;&#25104;&#21592;&#25110;&#22522;&#31867;&#23545;&#35937;&#25104;&#21592;&#21518;&#38754;&#30340;&#22635;&#20805;&#31354;&#30333;&#19981;&#33021;&#20026;&#20854;&#23427;&#25104;&#21592;&#25152;&#29992;&#65292;&#36825;&#26679;&#25165;&#33021;&#20445;&#35777;&#20108;&#36827;&#21046;&#30340;&#20860;&#23481;&#24615;&#12290;</p>
<p>shit.</p>
<pre><code>X x;
X2 x2;

x2 = x;     // &#22914;&#26524; padding &#21487;&#20197;&#20026; drived &#31867;&#20351;&#29992;&#65292;&#20250;&#21457;&#29983;&#35206;&#30422;
x  = x2;    // &#20250;&#21457;&#29983;&#25130;&#26029;&#65292;&#21482;&#20250; copy sizeof(x) &#22823;&#23567;&#30340;&#20869;&#23384;&#12290;</code></pre>
<p><strong>Vptr &#19982; Vbptr &#9829;&#65039;</strong></p>
<ul>
<li>&#22312;&#22810;&#32487;&#25215;&#24773;&#20917;&#19979;&#65292;&#21363;&#20351;&#26159;&#22810;&#34394;&#25311;&#32487;&#25215;&#65292;&#32487;&#25215;&#32780;&#24471;&#30340;&#31867;&#21482;&#38656;&#32500;&#25252;&#19968;&#20010; Vbptr&#65307; &#32780;&#22810;&#32487;&#25215;&#24773;&#20917;&#19979; Vptr &#21017;&#21487;&#33021;&#26377;&#35201;&#32500;&#25252;&#22810;&#20010; Vptr&#65292;&#35270;&#20854;&#22522;&#31867;&#26377;&#20960;&#20010;&#26377;&#34394;&#20989;&#25968;&#12290;</li>
<li>&#19968;&#26465;&#32487;&#25215;&#32447;&#36335;&#21482;&#26377;&#19968;&#20010; Vptr&#65292;&#20294;&#21487;&#33021;&#26377;&#22810;&#20010; Vbptr&#65292;&#35270;&#26377;&#20960;&#27425;&#34394;&#25311;&#32487;&#25215;&#32780;&#23450;&#12290;&#25442;&#35328;&#20043;&#65292;&#23545;&#20110;&#19968;&#20010;&#32487;&#25215;&#31867;&#23545;&#35937;&#26469;&#35828;&#65292;&#19981;&#38656;&#35201;&#26032;&#21512;&#25104; vptr&#65292;&#32780;&#26159;&#20351;&#29992;&#20854;&#22522;&#31867;&#23376;&#23545;&#35937;&#30340; vptr&#12290;&#32780;&#23545;&#20110;&#19968;&#20010;&#34394;&#25311;&#32487;&#25215;&#31867;&#26469;&#35828;&#65292;&#24517;&#39035;&#26032;&#21512;&#25104;&#19968;&#20010;&#33258;&#24049;&#30340; Vbptr&#12290;</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;stddef.h&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="kw">class</span> X {
    <span class="kw">virtual</span> <span class="dt">void</span> vf(){}
    <span class="kw">private</span>: <span class="dt">double</span> d;
};

<span class="kw">class</span> X2: <span class="kw">virtual</span> <span class="kw">public</span> X {
    <span class="kw">virtual</span> <span class="dt">void</span> vf(){}
    <span class="kw">private</span>: <span class="dt">double</span> d;
};

<span class="kw">class</span> X3: <span class="kw">virtual</span> <span class="kw">public</span> X2 {
    <span class="kw">virtual</span> <span class="dt">void</span> vf(){}
    <span class="kw">private</span>: <span class="dt">double</span> d;
};

<span class="dt">int</span> main()
{
    X x;
    X2 x2;
    X3 x3;
    printf( <span class="st">&quot;sizeof X, X2, X3: </span><span class="ch">%lu</span><span class="st">, </span><span class="ch">%lu</span><span class="st">, </span><span class="ch">%lu</span><span class="st">.</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(x), <span class="kw">sizeof</span>(x2), <span class="kw">sizeof</span>(x3) );
    <span class="co">// sizeof X, X2, X3: 16, 32, 48.</span>
}</code></pre></div>
<p><strong>X3 &#23558;&#21253;&#21547;&#26377;&#19968;&#20010; Vptr&#65292;&#20004;&#20010; Vbptr&#12290;&#30830;&#20999;&#30340;&#35828;&#36825;&#20004;&#20010; Vbptr &#19968;&#20010;&#23646;&#20110; X3&#65292;&#19968;&#20010;&#23646;&#20110; X3 &#30340;&#23376;&#23545;&#35937; X2&#65292;X3 &#36890;&#36807;&#20854; Vbptr &#25214;&#21040;&#23376;&#23545;&#35937; X2&#65292;&#32780; X2 &#36890;&#36807;&#20854; Vbptr &#25214;&#21040; X&#12290;</strong></p>
<p>&#20854;&#20013;&#24046;&#21035;&#22312;&#20110; vptr &#36890;&#36807;&#19968;&#20010;&#34394;&#20989;&#25968;&#34920;&#21487;&#20197;&#30830;&#20999;&#22320;&#30693;&#36947;&#35201;&#35843;&#29992;&#30340;&#20989;&#25968;&#65292;&#32780; Vbptr &#36890;&#36807;&#34394;&#22522;&#31867;&#34920;&#21482;&#33021;&#22815;&#30693;&#36947;&#20854;&#34394;&#22522;&#31867;&#23376;&#23545;&#35937;&#30340;&#20559;&#31227;&#37327;&#12290;&#36825;&#20004;&#26465;&#35268;&#21017;&#26159;&#30001;&#34394;&#20989;&#25968;&#19982;&#34394;&#25311;&#32487;&#25215;&#30340;&#23454;&#29616;&#26041;&#24335;&#65292;&#20197;&#21450;&#21463;&#23427;&#20204;&#30340;&#23384;&#21462;&#26041;&#24335;&#21644;&#22797;&#21046;&#25511;&#21046;&#30340;&#35201;&#27714;&#20915;&#23450;&#30340;&#12290;</p>
</dd>
<dt>&#25968;&#25454;&#25104;&#21592;&#30340;&#23384;&#21462; <code class="fold">@</code></dt>
<dd><p>&#38745;&#24577;&#25968;&#25454;&#25104;&#21592;&#30456;&#24403;&#20110;&#19968;&#20010;&#20165;&#23545;&#35813;&#31867;&#21487;&#35265;&#30340;&#20840;&#23616;&#21464;&#37327;&#65292;&#22240;&#20026;&#31243;&#24207;&#20013;&#21482;&#23384;&#22312;&#19968;&#20010;&#38745;&#24577;&#25968;&#25454;&#25104;&#21592;&#30340;&#23454;&#20363;&#65292;&#25152;&#20197;&#20854;&#22320;&#22336;&#22312;&#32534;&#35793;&#26102;&#23601;&#24050;&#32463;&#34987;&#20915;&#23450;&#12290;&#19981;&#35770;&#22914;&#20309;&#38745;&#24577;&#25968;&#25454;&#25104;&#21592;&#30340;&#23384;&#21462;&#19981;&#20250;&#24102;&#26469;&#20219;&#20309;&#39069;&#22806;&#36127;&#25285;&#12290;</p>
<p>&#38750;&#38745;&#24577;&#25968;&#25454;&#25104;&#21592;&#30340;&#23384;&#21462;&#65292;&#30456;&#24403;&#20110;&#23545;&#35937;&#36215;&#22987;&#22320;&#22336;&#21152;&#19978;&#20559;&#31227;&#37327;&#12290;&#25928;&#29575;&#19978;&#19982; C struct &#25104;&#21592;&#30340;&#25928;&#29575;&#31561;&#21516;&#12290;&#22240;&#20026;&#23427;&#30340;&#20559;&#31227;&#37327;&#22312;&#32534;&#35793;&#38454;&#27573;&#24050;&#32463;&#30830;&#23450;&#12290;<strong>&#20294;&#26377;&#19968;&#31181;&#24773;&#20917;&#20363;&#22806;&#65306;<code>pt-&gt;x=0.0</code>&#12290;&#24403;&#36890;&#36807;&#25351;&#38024;&#25110;&#24341;&#29992;&#26469;&#23384;&#21462;&#8212;&#8212;x &#32780; x &#21448;&#26159;&#34394;&#22522;&#31867;&#30340;&#25104;&#21592;&#30340;&#26102;&#20505;&#12290;&#22240;&#20026;&#24517;&#39035;&#35201;&#31561;&#21040;&#25191;&#34892;&#26399;&#25165;&#33021;&#30693;&#36947; pt &#25351;&#21521;&#30340;&#30830;&#20999;&#31867;&#22411;&#65292;&#25152;&#20197;&#24517;&#39035;&#36890;&#36807;&#19968;&#20010;&#38388;&#25509;&#23548;&#24341;&#25165;&#33021;&#23436;&#25104;&#12290;</strong></p>
</dd>
<dt>VC &#24067;&#23616; <code class="fold">@</code></dt>
<dd><p>&#22312; VC &#20013;&#25968;&#25454;&#25104;&#21592;&#30340;&#24067;&#23616;&#39034;&#24207;&#20026;&#65306;</p>
<ul>
<li>vptr &#37096;&#20998;&#65288;&#22914;&#26524;&#22522;&#31867;&#26377;&#65292;&#21017;&#32487;&#25215;&#22522;&#31867;&#30340;&#65289;</li>
<li>vbptr &#65288;&#22914;&#26524;&#38656;&#35201;&#65289;</li>
<li>&#22522;&#31867;&#25104;&#21592;&#65288;&#25353;&#22768;&#26126;&#39034;&#24207;&#65289;</li>
<li>&#33258;&#36523;&#25968;&#25454;&#25104;&#21592;</li>
<li>&#34394;&#22522;&#31867;&#25968;&#25454;&#25104;&#21592;&#65288;&#25353;&#22768;&#26126;&#39034;&#24207;</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Point3d : <span class="kw">public</span> Point2d {
<span class="kw">public</span>:
    Point3d( <span class="dt">float</span> x = <span class="fl">0.0f</span>, <span class="dt">float</span> y = <span class="fl">0.0f</span>, <span class="dt">float</span> z = <span class="fl">0.0f</span> )
      : Point2d( x, y )
      , _z( z ) { }

    <span class="dt">void</span> <span class="kw">operator</span>+=( <span class="dt">const</span> Point2d &amp;rhs ) {
        Point2d::<span class="kw">operator</span>+=( rhs );
        _z += rsh.z();
    }

    ...

<span class="kw">protected</span>:
    <span class="dt">float</span> _z;
};</code></pre></div>
</dd>
</dl>
</dd>
<dt>&#31532; 4 &#31456; Function &#35821;&#24847;&#23398;&#65288;The Semantics of Function&#65289; <code class="fold">@</code></dt>
<dd><dl>
<dt>C++ &#20043;&#25104;&#21592;&#20989;&#25968;&#35843;&#29992; <code class="fold">@</code></dt>
<dd><p>c++ &#25903;&#25345;&#19977;&#31181;&#31867;&#22411;&#30340;&#25104;&#21592;&#20989;&#25968;&#65292;&#20998;&#21035;&#20026; static, nostatic, virtual&#12290;&#27599;&#19968;&#31181;&#35843;&#29992;&#26041;&#24335;&#37117;&#19981;&#23613;&#30456;&#21516;&#12290;</p>
<dl>
<dt>&#38750;&#38745;&#24577;&#25104;&#21592;&#20989;&#25968;&#65288;Nonstatic Member Functions&#65289; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1. &#23558;&#25104;&#21592;&#20989;&#25968;&#20889;&#25104;&#19968;&#20010;&#22806;&#37096;&#20989;&#25968;&#65306;</span>

    <span class="co">// &#25104;&#21592;&#20989;&#25968;</span>
    <span class="dt">float</span> Point::X();
    <span class="co">// &#22806;&#37096;&#20989;&#25968;</span>
    <span class="dt">float</span> Point::X( Point *<span class="dt">const</span> <span class="kw">this</span> );

    <span class="co">// &#25110;&#32773;&#20989;&#25968;&#26159; const &#30340;&#65292;this &#25351;&#38024;&#20063;&#35201;&#21152;&#19978; const</span>
    <span class="dt">float</span> Point::X() <span class="dt">const</span>;
    <span class="dt">float</span> Point::X( <span class="dt">const</span> Point *<span class="dt">const</span> <span class="kw">this</span> );

<span class="co">// 2. &#23545;&#20989;&#25968;&#21517;&#36827;&#34892;&#8220;mangling&#8221;&#22788;&#29702;&#65292;&#20351;&#20043;&#25104;&#20026;&#29420;&#19968;&#26080;&#20108;&#30340;&#21517;&#31216;&#65288;&#30053;&#65289;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Point3d obj;</span>
obj.normalize();</code></pre></div>
<p>&#36825;&#37324;&#19981;&#38656;&#35201;&#20351;&#29992; <code>(*p-&gt;vptr)()</code>&#65292;&#22240;&#20026;&#32534;&#35793;&#26399;&#38388;&#23601;&#21487;&#20197;&#22788;&#29702;&#22909;&#65292;&#29992; mangled &#20989;&#25968;&#21517;&#30452;&#25509;&#35843;&#29992;&#21363;&#21487;&#65306;<code>normalize__7Point3dFv( &amp;obj );</code>&#12290;</p>
<p>&#23545;&#20110;&#38745;&#24577;&#20989;&#25968;&#65292;<code>&amp;Point3d::object_count();</code> &#20250;&#24471;&#21040;&#19968;&#20010;&#25968;&#20540;&#65292;&#31867;&#22411;&#26159; <code>unsigned int (*)();</code>&#65288;&#20989;&#25968;&#25351;&#38024;&#65289;&#65292;&#32780;&#19981;&#26159; <code>unsigned int (Point3d::*)();</code>&#65288;&#20989;&#25968;&#25351;&#38024;&#65292;&#20294;&#26159;&#26159;&#30456;&#23545;&#30340;&#20415;&#23452;&#37327;&#65289;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// method 1</span>
<span class="dt">float</span> *ax = &amp;pA.x;
cout &lt;&lt; *ax;

<span class="co">// method 2</span>
<span class="dt">float</span> Point3d::*ax = &amp;Point3d::x;
cout &lt;&lt; pA.*ax;</code></pre></div>
</dd>
<dt>&#34394;&#25311;&#25104;&#21592;&#20989;&#25968; (Virtual Member Functions) <code class="fold">@</code></dt>
<dd><p>&#22914;&#26524; function() &#26159;&#19968;&#20010;&#34394;&#25311;&#20989;&#25968;&#65292;&#37027;&#20040;&#29992;&#25351;&#38024;&#25110;&#24341;&#29992;&#36827;&#34892;&#30340;&#35843;&#29992;&#23558;&#21457;&#29983;&#19968;&#28857;&#29305;&#21035;&#30340;&#36716;&#25442;&#8212;&#8212;&#19968;&#20010;&#20013;&#38388;&#23618;&#34987;&#24341;&#20837;&#36827;&#26469;&#12290;&#20363;&#22914;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// p-&gt;function()</span>
<span class="co">// &#23558;&#36716;&#21270;&#20026;</span>
(*p-&gt;vptr[<span class="dv">1</span>])(p);</code></pre></div>
<ul>
<li>&#20854;&#20013; vptr &#20026;&#25351;&#21521;&#34394;&#20989;&#25968;&#34920;&#30340;&#25351;&#38024;&#65292;&#23427;&#30001;&#32534;&#35793;&#22120;&#20135;&#29983;&#12290; <strong>vptr &#20063;&#35201;&#36827;&#34892;&#21517;&#23383;&#22788;&#29702;&#65292;&#22240;&#20026;&#19968;&#20010;&#32487;&#25215;&#20307;&#31995;&#21487;&#33021;&#26377;&#22810;&#20010; vptr&#12290;</strong></li>
<li><code>1</code> &#26159;&#34394;&#20989;&#25968;&#22312;&#34394;&#20989;&#25968;&#34920;&#20013;&#30340;&#32034;&#24341;&#65292;&#36890;&#36807;&#23427;&#20851;&#32852;&#21040;&#34394;&#20989;&#25968; <code>function()</code>.</li>
</ul>
<blockquote>
<p>&#22312; C++ &#20013;&#65292;&#22810;&#24577;&#65288;polymorphism&#65289;&#34920;&#31034;&#8220;&#20197;&#19968;&#20010; public base class &#30340;&#25351;&#38024;&#65288;&#25110; reference&#65289;&#65292;&#23547;&#22336;&#20986;&#19968;&#20010; derived class object&#8221;&#30340;&#24847;&#24605;&#12290;</p>
</blockquote>
</dd>
<dt>&#38745;&#24577;&#25104;&#21592;&#20989;&#25968; (Static Member Functions) <code class="fold">@</code></dt>
<dd><p>&#38745;&#24577;&#25104;&#21592;&#20989;&#25968;&#30340;&#19968;&#20123;&#29305;&#24615;&#65306;</p>
<ul>
<li>&#19981;&#33021;&#22815;&#30452;&#25509;&#23384;&#21462;&#20854;&#31867;&#20013;&#30340;&#38750;&#38745;&#24577;&#25104;&#21592;&#65288;nostatic members&#65289;&#65292;&#21253;&#25324;&#19981;&#33021;&#35843;&#29992;&#38750;&#38745;&#24577;&#25104;&#21592;&#20989;&#25968; (Nonstatic Member Functions)&#12290;</li>
<li>&#19981;&#33021;&#22815;&#22768;&#26126;&#20026; const&#12289;voliatile &#25110; virtual&#12290;</li>
<li>&#23427;&#19981;&#38656;&#32463;&#30001;&#23545;&#35937;&#35843;&#29992;&#65292;&#24403;&#28982;&#65292;&#36890;&#36807;&#23545;&#35937;&#35843;&#29992;&#20063;&#34987;&#20801;&#35768;&#12290;</li>
</ul>
</dd>
</dl>
</dd>
<dt>C++ &#20043;&#34394;&#20989;&#25968;(Virtual Member Functions) <code class="fold">@</code></dt>
<dd><p><strong>&#12298;&#28145;&#24230;&#25506;&#32034;C++&#23545;&#35937;&#27169;&#22411;&#12299;&#26159;&#36825;&#26679;&#26469;&#35828;&#22810;&#24577;&#30340;:</strong></p>
<blockquote>
<p>&#22312; C++ &#20013;,&#22810;&#24577;&#34920;&#31034;&#8220;&#20197;&#19968;&#20010;public base class &#30340;&#25351;&#38024;&#65288;&#25110;&#24341;&#29992;&#65289;&#65292;&#23547;&#22336;&#20986;&#19968;&#20010; derived class object&#8221;&#30340;&#24847;&#24605;&#12290;</p>
</blockquote>
<dl>
<dt>&#28040;&#26497;&#22810;&#24577;&#19982;&#31215;&#26497;&#22810;&#24577; <code class="fold">@</code></dt>
<dd><p>&#29992;&#22522;&#31867;&#25351;&#38024;&#26469;&#23547;&#22336;&#32487;&#25215;&#31867;&#30340;&#23545;&#35937;&#65292;&#25105;&#20204;&#21487;&#20197;&#36825;&#26679;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Point *ptr = <span class="kw">new</span> Point3d;               <span class="co">//Point3d&#32487;&#25215;&#33258;Point</span>

<span class="co">// passive polymorphism&#65292;&#28040;&#26497;&#22810;&#24577;</span>
ptr-&gt;x();</code></pre></div>
<p>&#22312;&#36825;&#31181;&#24773;&#20917;&#19979;&#65292;&#22810;&#24577;&#21487;&#20197;<strong>&#22312;&#32534;&#35793;&#26399;&#23436;&#25104;&#65288;&#34394;&#22522;&#31867;&#24773;&#20917;&#38500;&#22806;&#65289;&#65292;&#22240;&#27492;&#34987;&#31216;&#20316;&#28040;&#26497;&#22810;&#24577;&#65288;&#27809;&#26377;&#36827;&#34892;&#34394;&#20989;&#25968;&#30340;&#35843;&#29992;&#65289;</strong>&#12290;&#30456;&#23545;&#20110;&#28040;&#26497;&#22810;&#24577;&#65292;&#21017;&#26377;&#31215;&#26497;&#22810;&#24577;&#8212;&#8212;&#25351;&#21521;&#30340;&#23545;&#35937;&#31867;&#22411;&#38656;&#35201;&#22312;&#25191;&#34892;&#26399;&#22312;&#33021;&#20915;&#23450;&#12290;<strong>&#31215;&#26497;&#22810;&#24577;&#30340;&#20363;&#23376;&#22914;&#34394;&#20989;&#25968;&#21644; RTTI</strong>&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp featured"><code class="sourceCode cpp"><span class="co">// active polymorphism&#65292;&#31215;&#26497;&#22810;&#24577;&#65292;&#35843;&#29992;&#20102;&#34394;&#20989;&#25968;</span>
ptr-&gt;z();

<span class="co">// active polymorphism, RTTI &#30340;&#24212;&#29992;</span>
<span class="kw">if</span>( Point3d *p =<span class="kw">dynamic_cast</span>&lt;Point3d*&gt;(ptr) ) {
<span class="kw">return</span> p-&gt;z();
}</code></pre></div>
<p>&#35782;&#21035;&#19968;&#20010; class &#26159;&#21542;&#25903;&#25345;&#22810;&#24577;&#65292;&#23601;&#26159;&#30475;&#20182;&#26377;&#27809;&#26377;&#20219;&#20309; virtual function&#12290;&#25105;&#20204;&#20026;&#27599;&#20010;&#22810;&#24577;&#30340; class object &#22686;&#21152;&#20004;&#20010; members&#65306;</p>
<ul>
<li>&#19968;&#20010;&#23383;&#31526;&#20018;&#25110;&#25968;&#23383;&#65292;&#34920;&#31034; class &#30340;&#31867;&#22411;&#65307;</li>
<li>&#19968;&#20010;&#25351;&#38024;&#65292;&#25351;&#21521;&#26576;&#34920;&#26684;&#65292;&#34920;&#26684;&#20013;&#24102;&#26377;&#31243;&#24207;&#30340; virtual functions &#30340;&#25191;&#34892;&#26399;&#22320;&#22336;&#12290;</li>
</ul>
</dd>
<dt>&#21333;&#32487;&#25215;&#19979;&#30340;&#34394;&#20989;&#25968; <code class="fold">@</code></dt>
<dd><p>&#34394;&#20989;&#25968;&#30340;&#23454;&#29616;&#65306;</p>
<ul>
<li>&#20026;&#27599;&#20010;&#26377;&#34394;&#20989;&#25968;&#30340;&#31867;&#37197;&#19968;&#24352;&#34394;&#20989;&#25968;&#34920;&#65292;&#23427;&#23384;&#20648;&#35813;&#31867;&#31867;&#22411;&#20449;&#24687;&#21644;&#25152;&#26377;&#34394;&#20989;&#25968;&#25191;&#34892;&#26399;&#30340;&#22320;&#22336;&#12290;</li>
<li>&#20026;&#27599;&#20010;&#26377;&#34394;&#20989;&#25968;&#30340;&#31867;&#25554;&#20837;&#19968;&#20010;&#25351;&#38024;&#65288;vptr&#65289;,&#36825;&#20010;&#25351;&#38024;&#25351;&#21521;&#35813;&#31867;&#30340;&#34394;&#20989;&#25968;&#34920;&#12290;</li>
<li>&#32473;&#27599;&#19968;&#20010;&#34394;&#20989;&#25968;&#25351;&#27966;&#19968;&#20010;&#22312;&#34920;&#20013;&#30340;&#32034;&#24341;&#12290;</li>
</ul>
<p>&#29992;&#36825;&#31181;&#27169;&#22411;&#26469;&#23454;&#29616;&#34394;&#20989;&#25968;&#24471;&#30410;&#20110;&#22312; C++ &#20013;&#65292;&#34394;&#20989;&#25968;&#30340;&#22320;&#22336;&#22312;&#32534;&#35793;&#26399;&#26159;&#21487;&#30693;&#30340;&#65292;&#32780;&#19988;&#36825;&#19968;&#22320;&#22336;&#26159;&#22266;&#23450;&#19981;&#21464;&#30340;&#12290;&#32780;&#19988;&#34920;&#30340;&#22823;&#23567;&#19981;&#20250;&#22312;&#25191;&#34892;&#26399;&#22686;&#22823;&#25110;&#20943;&#23567;&#12290;</p>
<p>&#19968;&#20010;&#31867;&#30340;&#34394;&#20989;&#25968;&#34920;&#20013;&#23384;&#20648;&#26377;&#31867;&#22411;&#20449;&#24687;&#65288;&#23384;&#20648;&#22312;&#32034;&#24341;&#20026; 0 &#30340;&#20301;&#32622;&#65289;&#21644;&#25152;&#26377;&#34394;&#20989;&#25968;&#22320;&#22336;&#65292;&#36825;&#20123;&#34394;&#20989;&#25968;&#22320;&#22336;&#21253;&#25324;&#19977;&#31181;&#65306;</p>
<ul>
<li>&#36825;&#20010;&#31867;&#23450;&#20041;&#30340;&#34394;&#20989;&#25968;&#65292;&#20250;&#25913;&#20889;&#65288;overriding&#65289;&#19968;&#20010;&#21487;&#33021;&#23384;&#22312;&#30340;&#22522;&#31867;&#30340;&#34394;&#20989;&#25968;&#23454;&#20307;&#8212;&#8212;&#20551;&#22914;&#22522;&#31867;&#20063;&#23450;&#20041;&#26377;&#36825;&#20010;&#34394;&#20989;&#25968;&#12290;</li>
<li>&#32487;&#25215;&#33258;&#22522;&#31867;&#30340;&#34394;&#20989;&#25968;&#23454;&#20307;&#65292;&#8212;&#8212;&#22522;&#31867;&#23450;&#20041;&#26377;&#65292;&#32780;&#36825;&#20010;&#31867;&#21364;&#27809;&#26377;&#23450;&#20041;&#12290;&#30452;&#25509;&#32487;&#25215;&#20043;&#12290;</li>
<li>&#19968;&#20010;&#32431;&#34394;&#20989;&#25968;&#23454;&#20307;&#12290;&#29992;&#26469;&#22312;&#34394;&#20989;&#25968;&#34920;&#20013;&#21344;&#24231;&#65292;&#26377;&#26102;&#20505;&#20063;&#21487;&#20197;&#24403;&#20570;&#25191;&#34892;&#26399;&#24322;&#24120;&#22788;&#29702;&#20989;&#25968;&#12290;</li>
</ul>
<p>&#27599;&#19968;&#20010;&#34394;&#20989;&#25968;&#37117;&#34987;&#25351;&#27966;&#19968;&#20010;&#22266;&#23450;&#30340;&#32034;&#24341;&#20540;&#65292;&#36825;&#20010;&#32034;&#24341;&#20540;&#22312;&#25972;&#20010;&#32487;&#25215;&#20307;&#31995;&#20013;&#20445;&#25345;&#21069;&#21518;&#20851;&#32852;&#65292;&#20363;&#22914;&#65292;&#20551;&#22914; z() &#22312; Point &#34394;&#20989;&#25968;&#34920;&#20013;&#30340;&#32034;&#24341;&#20540;&#20026; 2&#65292;&#37027;&#20040;&#22312; Point3d &#34394;&#20989;&#25968;&#34920;&#20013;&#30340;&#32034;&#24341;&#20540;&#20063;&#20026; 2&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#22522;&#31867; Point</span>
<span class="kw">class</span> Point {
<span class="kw">public</span>:
    <span class="kw">virtual</span> ~Point();
    <span class="kw">virtual</span> Point&amp; mult( <span class="dt">float</span> ) = <span class="dv">0</span>;       <span class="co">// pure virtual function&#65292;&#32431;&#34394;&#20989;&#25968;</span>
                                            <span class="co">// &#22312; vtbl &#37324;&#27809;&#26377; slot&#65292;&#23545;&#24212;&#30340;&#26159; pure_virtual_called()</span>
    <span class="dt">float</span> x() <span class="dt">const</span> { <span class="kw">return</span> _x; }          <span class="co">// &#19981;&#26159;&#34394;&#20989;&#25968;&#65292;&#19981;&#38656;&#35201;&#22312; vtbl &#37324;&#21152;&#20837; slot</span>
    <span class="kw">virtual</span> <span class="dt">float</span> y() <span class="dt">const</span> { <span class="kw">return</span> <span class="dv">0</span>; }   <span class="co">// vtbl &#20013;&#26377; slot &#25351;&#21521;&#23454;&#29616;</span>
    <span class="kw">virtual</span> <span class="dt">float</span> z() <span class="dt">const</span> { <span class="kw">return</span> <span class="dv">0</span>; }
<span class="kw">protected</span>:
    Point( <span class="dt">float</span> x = <span class="fl">0.0</span> );
    <span class="dt">float</span> _x;
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Derived Class Point2d</span>
<span class="kw">class</span> Point2d : <span class="kw">public</span> Point {
<span class="kw">public</span>:
    Point2d( <span class="dt">float</span> x = <span class="fl">0.0f</span>, <span class="dt">float</span> y = <span class="fl">0.0f</span> )
      : Point( x ), _y( y ) { }
    ~Point2d();

    <span class="co">// &#25913;&#20889; base class virtual functions</span>
    Point2d&amp; mult( <span class="dt">float</span> );
    <span class="dt">float</span> y() <span class="dt">const</span> { <span class="kw">return</span> _y; }
    ...
<span class="kw">protected</span>:
    <span class="dt">float</span> _y;
};</code></pre></div>
<p>&#19968;&#20849;&#26377;&#19977;&#31181;&#21487;&#33021;&#65306;</p>
<ol style="list-style-type: decimal">
<li>&#23427;&#21487;&#20197;&#32487;&#25215; base class &#25152;&#22768;&#26126;&#30340; virtual function&#65288;&#20854;&#23454;&#23601;&#26159; vtbl &#19979;&#30456;&#24212; slot&#65288;&#19979;&#30340;&#20989;&#25968;&#25351;&#38024;&#65289;&#25335;&#36125;&#36807;&#21435;&#65289;&#65307;</li>
<li>&#20351;&#29992;&#33258;&#24049;&#30340;&#20989;&#25968;&#23454;&#20307;&#65292;&#24212;&#35813;&#25918;&#21040;&#30456;&#24212;&#30340;&#20301;&#32622; slot&#65292;&#35206;&#30422;&#21407;&#26469;&#30340;&#20989;&#25968;&#25351;&#38024;&#65307;</li>
<li>&#28155;&#21152;&#26032;&#30340; virtual function&#65292;&#36825;&#26102;&#20505; virtual table &#20250;&#21464;&#22823;&#65292;&#26032;&#30340; slot &#20250;&#34987; append &#21040;&#21518;&#26041;&#12290;</li>
</ol>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Point3d : <span class="kw">public</span> Point2d {
<span class="kw">public</span>:
    Point3d( <span class="dt">float</span> x = <span class="fl">0.0f</span>, <span class="dt">float</span> y = <span class="fl">0.0f</span>, <span class="dt">float</span> z = <span class="fl">0.0f</span> )
      : Point2d( x, y ), _z( z ) { }
    ~Point3d();

    <span class="co">// &#25913;&#20889; base class &#30340; virtual functions</span>
    Point3d&amp; mult( <span class="dt">float</span> );
    <span class="dt">float</span> z() <span class="dt">const</span> { <span class="kw">return</span> _z; }
    ...
<span class="kw">protected</span>:
    <span class="dt">float</span> _z;
};</code></pre></div>
<p><code>ptr-&gt;z()</code> &#22914;&#20309;&#22312;&#32534;&#35793;&#26102;&#26399;&#35774;&#23450; virtual function &#30340;&#35843;&#29992;&#21602;&#65311;</p>
<ol style="list-style-type: decimal">
<li>&#25105;&#20204;&#19981;&#30693;&#36947; ptr &#25152;&#25351;&#30340;&#31867;&#22411;&#65292;&#20294;&#25105;&#20204;&#21487;&#20197;&#25343;&#21040;&#35813;&#23545;&#35937;&#30340; vtbl&#65307;</li>
<li>&#25105;&#20204;&#19981;&#30693;&#36947;&#21738;&#20010; z() &#35201;&#34987;&#35843;&#29992;&#65292;&#20294; z() &#23545;&#24212;&#30340; slot &#37117;&#26159;&#19968;&#20010;&#20301;&#32622;&#65288;&#27604;&#22914; slot4&#65289;</li>
</ol>
<p>&#20110;&#26159;&#32534;&#35793;&#22120;&#23601;&#21487;&#20197;&#25226; <code>ptr-&gt;z()</code> &#36716;&#21270;&#20026; <code>(*ptr-&gt;vptr)( ptr )</code>&#12290;&#36825;&#37324; vptr &#21644; 4 &#37117;&#26159;&#22312;&#32534;&#35793;&#26399;&#38388;&#23601;&#30693;&#36947;&#30340;&#65292;&#21482;&#26377; ptr &#30340;&#22320;&#22336;&#21644;&#20855;&#20307;&#35843;&#29992;&#21738;&#20010; z() &#26159;&#36816;&#34892;&#26399;&#38388;&#25165;&#30693;&#36947;&#30340;&#12290;</p>
<dl>
<dt>pure virtual functions&#65311;</dt>
<dd><p>???</p>
</dd>
</dl>
</dd>
<dt>&#22810;&#37325;&#32487;&#25215;&#19979;&#30340;&#34394;&#20989;&#25968; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Base2 *ptr = <span class="kw">new</span> Derived;

<span class="co">// &#38656;&#35201;&#34987;&#36716;&#25442;&#20026;&#65292;&#36825;&#20010;&#36716;&#25442;&#22312;&#32534;&#35793;&#26399;&#23436;&#25104;</span>
Derived *temp = <span class="kw">new</span> Derived;
Base2 *ptr = temp ? temp + <span class="kw">sizeof</span>(base1) : <span class="dv">0</span> ; <span class="co">// &#20559;&#31227;&#8220;&#25481;&#8221; Base1 &#30340;&#37027;&#37096;&#20998;</span></code></pre></div>
<p>&#24403;&#35201;delete ptr&#26102;&#21448;&#38754;&#20020;&#20102;&#19968;&#27425;&#36716;&#25442;&#65292;&#22240;&#20026;&#22312;delete ptr&#30340;&#26102;&#20505;&#65292;&#38656;&#35201;&#23545;&#25972;&#20010;&#23545;&#35937;&#32780;&#19981;&#26159;&#20854;&#23376;&#23545;&#35937;&#26045;&#34892;delete&#36816;&#31639;&#31526;&#65292;&#36825;&#26399;&#38388;&#38656;&#35201;&#35843;&#25972;ptr&#25351;&#21521;&#23436;&#25972;&#30340;&#23545;&#35937;&#36215;&#28857;&#65292;&#22240;&#20026;&#19981;&#35770;&#26159;&#35843;&#29992;&#27491;&#30830;&#30340;&#26512;&#26500;&#20989;&#25968;&#36824;&#26159;delete&#36816;&#31639;&#31526;&#37117;&#38656;&#35201;&#19968;&#20010;&#25351;&#21521;&#23545;&#35937;&#36215;&#28857;&#30340;&#25351;&#38024;&#65292;&#24819;&#19968;&#24819;&#32473;&#20104;&#19968;&#20010;derived&#31867;&#30340;&#25104;&#21592;&#20989;&#25968;&#25351;&#21521;base2 subobjuect &#30340;this&#25351;&#38024;&#20250;&#21457;&#29983;&#20160;&#20040;&#21543;&#12290;&#22240;&#20026;ptr&#30340;&#20855;&#20307;&#31867;&#22411;&#24182;&#19981;&#30693;&#36947;&#65292;&#25152;&#20197;&#24517;&#39035;&#35201;&#31561;&#21040;&#25191;&#34892;&#26399;&#26469;&#23436;&#25104;&#12290;</p>
<p>Bjame &#30340;&#35299;&#20915;&#26041;&#27861;&#26159;&#23558;&#27599;&#19968;&#20010;&#34394;&#20989;&#25968;&#34920;&#30340; slot &#25193;&#23637;&#65292;&#20197;&#20351;&#20043;&#23384;&#25918;&#19968;&#20010;&#39069;&#22806;&#30340;&#20559;&#31227;&#37327;&#12290;&#20110;&#26159;&#34394;&#20989;&#25968;&#30340;&#35843;&#29992;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">(*ptr-&gt;vptr)(ptr);
<span class="co">//&#23558;&#21464;&#25104;&#65306;</span>
(*ptr-&gt;vptr.addr)(ptr+*ptr-&gt;vptr.offset);</code></pre></div>
<p>&#20854;&#20013;&#20351;&#29992; <code>ptr-&gt;vptr.addr</code> &#29992;&#20197;&#33719;&#21462;&#27491;&#30830;&#30340;&#34394;&#20989;&#25968;&#22320;&#22336;&#65292;&#32780; <code>ptr+*ptr-&gt;vptr.offset</code> &#26469;&#33719;&#24471;&#25351;&#21521;&#23545;&#35937;&#23436;&#25972;&#30340;&#36215;&#28857;&#12290;&#36825;&#31181;&#26041;&#27861;&#30340;&#32570;&#28857;&#26174;&#32780;&#26131;&#35265;&#65292;&#20195;&#20215;&#36807;&#22823;&#20102;&#19968;&#28857;&#65292;&#25152;&#26377;&#30340;&#24773;&#20917;&#37117;&#34987;&#36825;&#19968;&#31181;&#21344;&#27604;&#36739;&#23567;&#30340;&#24773;&#20917;&#25302;&#32047;&#12290;</p>
<p>&#36824;&#26377;&#19968;&#31181;&#21483;&#20570; thunk &#30340;&#26041;&#27861;&#65292;thunk &#30340;&#20316;&#29992;&#22312;&#20110;:</p>
<ul>
<li>&#20197;&#36866;&#24403;&#30340; offset &#20540;&#26469; this &#35843;&#25972;&#25351;&#38024;.</li>
<li>&#36339;&#21040;&#34394;&#20989;&#25968;&#20013;&#21435;&#12290;</li>
</ul>
<p>&#22810;&#32487;&#25215;&#19979;&#30340;&#34394;&#20989;&#25968;&#65292;&#24433;&#21709;&#21040;&#34394;&#20989;&#25968;&#30340;&#35843;&#29992;&#30340;&#23454;&#38469;&#36136;&#19978;&#20026; this &#30340;&#35843;&#25972;&#12290;&#32780; this &#35843;&#25972;&#19968;&#33324;&#20026;&#20004;&#31181;&#65306;</p>
<ul>
<li>&#35843;&#25972;&#25351;&#38024;&#25351;&#21521;&#23545;&#24212;&#30340; subobject&#65292;&#19968;&#33324;&#21457;&#29983;&#22312;&#32487;&#25215;&#31867;&#31867;&#22411;&#25351;&#38024;&#21521;&#22522;&#31867;&#31867;&#22411;&#25351;&#38024;&#36171;&#20540;&#30340;&#24773;&#20917;&#19979;&#12290;</li>
<li>&#23558;&#25351;&#21521; subobject &#30340;&#25351;&#38024;&#35843;&#25972;&#22238;&#32487;&#25215;&#31867;&#23545;&#35937;&#30340;&#36215;&#22987;&#28857;&#65292;&#19968;&#33324;&#21457;&#29983;&#22312;&#22522;&#31867;&#25351;&#38024;&#23545;&#32487;&#25215;&#31867;&#34394;&#20989;&#25968;&#36827;&#34892;&#35843;&#29992;&#30340;&#26102;&#20505;&#12290;</li>
</ul>
<p>&#36824;&#26377;&#21035;&#24536;&#20102;&#65292;vptr &#20063;&#21487;&#20197;&#30475;&#20570;&#19968;&#20010;&#25968;&#25454;&#25104;&#21592;&#65292;&#35201;&#25214;&#21040;&#34394;&#20989;&#25968;&#65292;&#21069;&#25552;&#26159;&#33719;&#21462;&#27491;&#30830;&#30340; vptr &#20559;&#31227;&#37327;&#12290;</p>
</dd>
<dt>&#34394;&#25311;&#32487;&#25215;&#19979;&#30340;&#34394;&#20989;&#25968; <code class="fold">@</code></dt>
<dd><p>Lippman &#35828;&#65292;&#22914;&#26524;&#19968;&#20010;&#34394;&#22522;&#31867;&#27966;&#29983;&#33258;&#21478;&#19968;&#34394;&#22522;&#31867;&#65292;&#32780;&#19988;&#23427;&#20204;&#37117;&#25903;&#25345;&#34394;&#20989;&#25968;&#21644;&#38750;&#38745;&#24577;&#25968;&#25454;&#25104;&#21592;&#30340;&#26102;&#20505;&#65292;&#32534;&#35793;&#22120;&#23545;&#34394;&#22522;&#31867;&#30340;&#25903;&#25345;&#23601;&#20687;&#36855;&#23467;&#19968;&#26679;&#22797;&#26434;&#12290;&#20854;&#23454;&#25105;&#21407;&#24819;&#21578;&#35785;&#20182;&#65292;&#25105;&#26159;&#24576;&#30528;&#19968;&#39063;&#21191;&#22763;&#20043;&#24515;&#32780;&#26469;&#30340; : &#20320;&#35828;&#21602;:&#65311;&#12290;</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>&#31532; 5 &#31456; &#26500;&#36896;&#12289;&#35299;&#26500;&#12289;&#25335;&#36125; &#35821;&#24847;&#23398;&#65288;Semantics of Construction&#65292;Destruction&#65292;and Copy&#65289; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#20960;&#28857;&#31867;&#35774;&#35745;&#21407;&#21017; <code class="fold">@</code></dt>
<dd><p>&#19968;&#20123;&#24314;&#35758;&#12290;</p>
</dd>
<dt>&#26500;&#36896;&#12289;&#22797;&#21046;&#12289;&#26512;&#26500;&#35821;&#24847;&#23398;</dt>
<dd><p>TODO</p>
</dd>
</dl>
</dd>
</dl>
<p>&#31532; 6 &#31456; &#25191;&#34892;&#26399;&#35821;&#24847;&#23398;&#65288;Runtime Semantics&#65289;</p>
<p>&#31532; 7 &#31456; &#31449;&#22312;&#23545;&#35937;&#27169;&#22411;&#30340;&#31867;&#31471;&#65288;On the Cusp of the Object Model&#65289;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.roading.org/develop/cpp/%e3%80%8a%e6%b7%b1%e5%ba%a6%e6%8e%a2%e7%b4%a2c%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b%e3%80%8b%e7%ac%94%e8%ae%b0%e6%b1%87%e6%80%bb.html">&#12298;&#28145;&#24230;&#25506;&#32034; C++ &#23545;&#35937;&#27169;&#22411;&#12299;&#31508;&#35760;&#27719;&#24635;</a></li>
<li><a href="http://www.roading.org/develop/cpp/c%E4%B9%8B%E8%99%9A%E5%87%BD%E6%95%B0virtual-member-functions.html">C++ &#20043;&#34394;&#20989;&#25968; (Virtual Member Functions)</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://github.com/chenshuo/documents/" class="heart">chenshuo/documents</a> <code class="fold">@</code></dt>
<dd><dl>
<dt>1&#65289;&#24910;&#29992;&#21311;&#21517; namespace <code class="fold">@</code></dt>
<dd><p>C &#35821;&#35328;&#30340; static &#20851;&#38190;&#23383;&#26377;&#20004;&#31181;&#29992;&#36884;:</p>
<ul>
<li><ol style="list-style-type: decimal">
<li>&#29992;&#20110;&#20989;&#25968;&#20869;&#37096;&#20462;&#39280;&#21464;&#37327;,&#21363;<strong>&#20989;&#25968;&#20869;&#30340;&#38745;&#24577;&#21464;&#37327;</strong>&#12290;&#36825;&#31181;&#21464;&#37327;&#30340;&#29983;&#23384;&#26399;&#38271;&#20110;&#35813;&#20989;&#25968;,&#20351;&#24471;&#20989;&#25968;&#20855;&#26377;&#19968;&#23450;&#30340;&#8220;&#29366;&#24577;&#8221;&#12290;&#20351;&#29992;&#38745;&#24577;&#21464;&#37327;&#30340;&#20989;&#25968;&#19968;&#33324;&#26159;&#19981;&#21487;&#37325;&#20837;&#30340;,&#20063;&#19981;&#26159;&#32447;&#31243;&#23433;&#20840;&#30340;</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>&#29992;&#22312;&#25991;&#20214;&#32423;&#21035;(&#20989;&#25968;&#20307;&#20043;&#22806;)&#65292;&#20462;&#39280;&#21464;&#37327;&#25110;&#20989;&#25968;,&#34920;&#31034;&#35813;&#21464;&#37327;&#25110;&#20989;&#25968;&#21482;&#22312;&#26412;&#25991;&#20214;&#21487;&#35265;,&#20854;&#20182;&#25991;&#20214;&#30475;&#19981;&#21040;&#20063;&#35775;&#38382;&#19981;&#21040;&#35813;&#21464;&#37327;&#25110;&#20989;&#25968;&#12290;&#19987;&#19994;&#30340;&#35828;&#27861;&#21483;&#8220;<strong>&#20855;&#26377; internal linkage</strong>&#8221;(&#31616;&#35328;&#20043;:&#19981;&#26292;&#38706;&#32473;&#21035;&#30340; translation unit)&#12290;</li>
</ol></li>
</ul>
<p>C++?</p>
<ul>
<li><ol start="3" style="list-style-type: decimal">
<li>&#29992;&#20110;<strong>&#20462;&#39280; class &#30340;&#25968;&#25454;&#25104;&#21592;,&#21363;&#25152;&#35859;&#8220;&#38745;&#24577;&#25104;&#21592;&#8221;</strong>&#12290;class varible vs instance variable</li>
</ol></li>
<li><ol start="4" style="list-style-type: decimal">
<li>&#29992;&#20110;<strong>&#20462;&#39280; class &#30340;&#25104;&#21592;&#20989;&#25968;&#65292;&#21363;&#25152;&#35859;&#8220;&#38745;&#24577;&#25104;&#21592;&#20989;&#25968;&#8221;</strong>&#12290;&#36825;&#31181;&#25104;&#21592;&#20989;&#25968;&#21482;&#33021;&#35775;&#38382; class variable &#21644;&#20854;&#20182;&#38745;&#24577;&#31243;&#24207;&#20989;&#25968;&#65292;&#19981;&#33021;&#35775;&#38382; instance variable &#25110; instance method&#12290;</li>
</ol></li>
</ul>
<p>&#22312; C++ &#37324;&#19981;&#24517;&#20351;&#29992;&#25991;&#20214;&#32423;&#30340; static &#20851;&#38190;&#23383;,&#25105;&#20204;&#21487;&#20197;&#29992;&#21311;&#21517; namespace &#36798;&#21040;&#30456;&#21516;&#30340;&#25928;&#26524;&#12290;</p>
<p>&#20294;&#21311;&#21517; namespace &#30340;&#19981;&#22909;&#22312;&#20110;&#19981;&#21033;&#20110; debug&#65292;&#22240;&#20026; namespace &#21517;&#23383;&#27599;&#27425;&#37117;&#35201;&#21464;&#65292;&#21464;&#37327;&#21517;&#23601;&#21464;&#20102;&#12290;</p>
</dd>
<dt>2&#65289;&#19981;&#35201;&#37325;&#36733;&#20840;&#23616; <code>::operator new()</code> <code class="fold">@</code></dt>
<dd><p>&#22914;&#26524;&#21482;&#32771;&#34385;&#20998;&#37197;&#21644;&#37322;&#25918;&#65292;&#20869;&#23384;&#31649;&#29702;&#22522;&#26412;&#35201;&#27714;&#26159;&#8220;&#19981;&#37325;&#19981;&#28431;&#8221;:&#26082;&#19981;&#37325;&#22797; delete&#65292;&#20063;&#19981;&#28431;&#25481; delete&#12290;&#20063;&#23601;&#35828;&#25105;&#20204;&#24120;&#35828;&#30340; new/delete &#35201;&#37197;&#23545;&#65292;&#8220;&#37197;&#23545;&#8221;&#19981;&#20165;&#26159;&#20010;&#25968;&#30456;&#31561;&#65292;&#36824;&#38544;&#21547;&#20102; new &#21644; delete &#30340;&#35843;&#29992;&#26412;&#36523;&#35201;&#21305;&#37197;&#65292;&#19981;&#35201;&#8220;&#19996;&#23478;&#20511;&#30340;&#19996;&#35199;&#35199;&#23478;&#36824;&#8221;</p>
<ul>
<li>malloc -&gt; free</li>
<li>new -&gt; delete</li>
<li>new[] -&gt; delete[]</li>
<li>::operator new() -&gt; ::operator delete()</li>
</ul>
<p>&#36825;&#21487;&#20197;&#24402;&#32467;&#20026;&#26368;&#23567;&#24778;&#35766;&#21407;&#21017;:&#22914;&#26524;&#25105;&#22312;&#20195;&#30721;&#37324;&#35835;&#21040; <code>Node* p = new Node</code>&#65292;&#25105;&#20250;&#35748;&#20026;&#23427;&#22312; heap &#19978;&#20998;&#37197;&#20102;&#20869;&#23384;&#65292;&#22914;&#26524; Node class &#37325;&#36733;&#20102; member <code>::operator new()</code>&#65292;&#37027;&#20040;&#25105;&#35201;&#20107;&#20808;&#20180;&#32454;&#38405;&#35835; node.h &#25165;&#33021;&#21457;&#29616;&#20854;&#23454;&#36825;&#34892;&#20195;&#30721;&#20351;&#29992;&#20102;&#31169;&#26377;&#30340;&#20869;&#23384;&#27744;&#12290;&#20026;&#20160;&#20040;&#19981;&#20889;&#24471;&#26126;&#30830;&#19968;&#28857;&#21602;?&#20889;&#25104; <strong><code class="sourceCode cpp">Node* p = NodeFactory::createNode()</code></strong>&#65292;&#37027;&#20040;&#25105;&#33021;&#29468;&#21040; NodeFactory::createNode() &#32943;&#23450;&#20570;&#20102;&#20160;&#20040;&#19982; new Node &#19981;&#19968;&#26679;&#30340;&#20107;&#24773;&#65292;&#20813;&#24471;&#23558;&#26469;&#22823;&#21507;&#19968;&#24778;&#12290;</p>
<p>The Zen of Python &#35828; <strong>explicit is better than implicit</strong>&#65292;&#25105;&#28145;&#20449;&#19981;&#30097;&#12290;</p>
</dd>
<dt>11&#65289;iostream &#30340;&#29992;&#36884;&#19982;&#23616;&#38480; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#19968;&#20010; 300 &#34892;&#30340; memory buffer output stream <code class="fold">@</code></dt>
<dd><p><a href="https://github.com/chenshuo/recipes/blob/master/logging" class="uri">https://github.com/chenshuo/recipes/blob/master/logging</a></p>
<p><a href="http://www.serpentine.com/blog/2011/06/29/here-be-dragons-advances-in-problems-you-didnt-even-know-you-had/">Here be dragons: advances in problems you didn&#8217;t even know you had | teideal glic deisbh&#233;alach</a></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Fmt : boost::noncopyable
{
    <span class="kw">public</span>:
        <span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
        Fmt(<span class="dt">const</span> <span class="dt">char</span>* fmt, T val)
        {
            BOOST_STATIC_ASSERT(boost::is_arithmetic&lt;T&gt;::value == <span class="kw">true</span>);
            length_ = snprintf(buf_, <span class="kw">sizeof</span> buf_, fmt, val);
        }
        <span class="dt">const</span> <span class="dt">char</span>* data() <span class="dt">const</span> { <span class="kw">return</span> buf_; }
        <span class="dt">int</span> length() <span class="dt">const</span> { <span class="kw">return</span> length_; }
    <span class="kw">private</span>:
        <span class="dt">char</span> buf_;
        <span class="dt">int</span> length_;
};

<span class="kw">inline</span> LogStream&amp; <span class="kw">operator</span>&lt;&lt;(LogStream&amp; os, <span class="dt">const</span> Fmt&amp; fmt)
{
    os.append(fmt.data(), fmt.length());
    <span class="kw">return</span> s;
}

LogStream os;
<span class="dt">double</span> x = <span class="fl">19.82</span>;
<span class="dt">int</span> y = <span class="dv">43</span>;
os &lt;&lt; Fmt(&#8221;%<span class="fl">8.3f</span>&#8221;, x) &lt;&lt; Fmt(&#8221;%<span class="er">4d</span>&#8221;, y);</code></pre></div>
</dd>
</dl>
</dd>
<dt>12&#65289;&#20540;&#35821;&#20041;&#19982;&#25968;&#25454;&#25277;&#35937; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#20160;&#20040;&#26159;&#20540;&#35821;&#20041;<code class="fold">@</code></dt>
<dd><p><strong>&#20540;&#35821;&#20041; (value semantics)</strong> &#25351;&#30340;&#26159;&#23545;&#35937;&#30340;&#25335;&#36125;&#19982;&#21407;&#23545;&#35937;&#26080;&#20851;&#65292;&#23601;&#20687;&#25335;&#36125; int &#19968;&#26679;&#12290;C++ &#30340;&#20869;&#32622;&#31867;&#22411; (bool/int/double/char) &#37117;&#26159;&#20540;&#35821;&#20041;&#65292;&#26631;&#20934;&#24211;&#37324;&#30340; complex&lt;&gt; &#12289;pair&lt;&gt;&#12289;vector&lt;&gt;&#12289;map&lt;&gt;&#12289; string &#31561;&#31561;&#31867;&#22411;&#20063;&#37117;&#26159;&#20540;&#35821;&#24847;,<strong>&#25335;&#36125;&#20043;&#21518;&#23601;&#19982;&#21407;&#23545;&#35937;&#33073;&#31163;&#20851;&#31995;</strong>&#12290;</p>
<p><a href="https://en.m.wikipedia.org/wiki/Value_semantics">&#32500;&#22522;</a> &#19978;&#36825;&#20040;&#20171;&#32461;&#30340;&#65306;</p>
<blockquote>
<p>In computer science, having <strong>value semantics</strong> (also <strong>value-type semantics</strong> or <strong>copy-by-value semantics</strong>) means for an object that only its value counts, not its identity. If the concept is fully applied, value semantics implies immutability of the object.</p>
<p>The concepts that are used to explain this concept are extensionality, definiteness, substitutivity of identity, unfoldability, and referential transparency.</p>
</blockquote>
<p>&#19982;&#20540;&#35821;&#20041;&#23545;&#24212;&#30340;&#26159;&#8220;<strong>&#23545;&#35937;&#35821;&#20041; /object semantics</strong>&#8221;&#65292;&#25110;&#32773;&#21483;&#20570;&#24341;&#29992;&#35821;&#20041;(reference semantics)&#65292;&#30001;&#20110;&#8220;&#24341;&#29992;&#8221;&#19968;&#35789;&#22312; C++ &#37324;&#26377;&#29305;&#27530;&#21547;&#20041;&#65292;&#25152;&#20197;&#25105;&#22312;&#26412;&#25991;&#20013;&#20351;&#29992;&#8220;&#23545;&#35937;&#35821;&#20041;&#8221;&#36825;&#20010;&#26415;&#35821;&#12290;&#23545;&#35937;&#35821;&#20041;&#25351;&#30340;&#26159;&#38754;&#21521;&#23545;&#35937;&#24847;&#20041;&#19979;&#30340;&#23545;&#35937;,&#12304;&#23545;&#35937;&#25335;&#36125;&#26159;&#31105;&#27490;&#30340;&#12305;&#12290;&#20363;&#22914; muduo &#37324;&#30340; Thread &#26159;&#23545;&#35937;&#35821;&#20041;&#65292;&#25335;&#36125;Thread &#26159;&#26080;&#24847;&#20041;&#30340;&#65292;&#20063;&#26159;&#34987;&#31105;&#27490;&#30340;: &#22240;&#20026; Thread &#20195;&#34920;&#32447;&#31243;&#65292;&#25335;&#36125;&#19968;&#20010;Thread &#23545;&#35937;&#24182;&#19981;&#33021;&#35753;&#31995;&#32479;&#22686;&#21152;&#19968;&#20010;&#19968;&#27169;&#19968;&#26679;&#30340;&#32447;&#31243;&#12290;</p>
<p>&#19968;&#20123;&#36776;&#26512;&#65306;</p>
<ul>
<li><p>&#20540;&#35821;&#20041;&#19982; immutable &#26080;&#20851;&#12290;C++ &#20013;&#30340;&#20540;&#35821;&#20041;&#23545;&#35937;&#20063;&#21487;&#20197;&#26159; mutable&#65292;&#27604;&#22914; complex&lt;&gt;&#12289;pair&lt;&gt;&#12289;vector&lt;&gt;&#12289;map&lt;&gt;&#12289;string &#37117;&#26159;&#21487;&#20197;&#20462;&#25913;&#30340;&#12290;</p></li>
<li><p>&#20540;&#35821;&#20041;&#30340;&#23545;&#35937;&#19981;&#19968;&#23450;&#26159; POD&#65292;&#20363;&#22914; string &#23601;&#19981;&#26159; POD&#65292;&#20294;&#23427;&#26159;&#20540;&#35821;&#20041;&#30340;&#12290;</p></li>
<li><p>&#20540;&#35821;&#20041;&#30340;&#23545;&#35937;&#19981;&#19968;&#23450;&#23567;&#65292;&#20363;&#22914; vector<int> &#30340;&#20803;&#32032;&#21487;&#22810;&#21487;&#23569;&#65292;&#20294;&#23427;&#22987;&#32456;&#26159;&#20540;&#35821;&#20041;&#30340;&#12290;&#24403;&#28982;&#65292;&#24456;&#22810;&#20540;&#35821;&#20041;&#30340;&#23545;&#35937;&#37117;&#26159;&#23567;&#30340;&#65292;&#20363;&#22914; complex&lt;&gt;&#12289; muduo::Date&#12289;muduo:: Timestamp&#12290;</p></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#20540;&#35821;&#20041;&#19982;&#29983;&#21629;&#26399; <code class="fold">@</code></dt>
<dd><p>&#20540;&#35821;&#20041;&#30340;&#19968;&#20010;&#24040;&#22823;&#22909;&#22788;&#26159;&#29983;&#21629;&#26399;&#31649;&#29702;&#24456;&#31616;&#21333;&#65292;&#23601;&#36319; int &#19968;&#26679;&#8212;&#8212;&#20320;&#19981;&#38656;&#35201;&#25805;&#24515; int &#30340;&#29983;&#21629;&#26399;&#12290;&#20540;&#35821;&#20041;&#30340;&#23545;&#35937;&#35201;&#20040;&#26159; <strong>stack object</strong>&#65292;&#25110;&#32773;<strong>&#12304;&#30452;&#25509;&#12305;&#20316;&#20026;&#20854;&#20182; object &#30340;&#25104;&#21592;</strong>&#65292;&#22240;&#27492;&#25105;&#20204;&#19981;&#29992;&#25285;&#24515;&#23427;&#30340;&#29983;&#21629;&#26399; (&#19968;&#20010;&#20989;&#25968;&#20351;&#29992;&#33258;&#24049; stack &#19978;&#30340;&#23545;&#35937;&#65292;&#19968;&#20010;&#25104;&#21592;&#20989;&#25968;&#20351;&#29992;&#33258;&#24049;&#30340;&#25968;&#25454;&#25104;&#21592;&#23545;&#35937;)&#12290;&#30456;&#21453;,<strong>&#23545;&#35937;&#35821;&#20041;&#30340; object &#30001;&#20110;&#19981;&#33021;&#25335;&#36125;&#65292;&#25105;&#20204;&#21482;&#33021;&#36890;&#36807;&#25351;&#38024;&#25110;&#24341;&#29992;&#26469;&#20351;&#29992;&#23427;&#12290;</strong></p>
<p>&#19968;&#26086;&#20351;&#29992;&#25351;&#38024;&#21644;&#24341;&#29992;&#26469;&#25805;&#20316;&#23545;&#35937;&#65292;<strong>&#37027;&#20040;&#23601;&#35201;&#25285;&#24515;&#25152;&#25351;&#30340;&#23545;&#35937;&#26159;&#21542;&#24050;&#34987;&#37322;&#25918;</strong>&#65292;&#36825;&#19968;&#24230;&#26159; C++ &#31243;&#24207; bug &#30340;&#19968;&#22823;&#26469;&#28304;&#12290;&#27492;&#22806;&#65292;&#30001;&#20110; C++ &#21482;&#33021;&#36890;&#36807;&#25351;&#38024;&#25110;&#24341;&#29992;&#26469;&#33719;&#24471;&#22810;&#24577;&#24615;&#65292;&#37027;&#20040;&#22312; C++ &#37324;&#20174;&#20107;&#22522;&#20110;&#32487;&#25215;&#21644;&#22810;&#24577;&#30340;&#38754;&#21521;&#23545;&#35937;&#32534;&#31243;&#26377;&#20854;&#26412;&#36136;&#30340;&#22256;&#38590;&#8212;&#8212;<strong>&#12304;&#23545;&#35937;&#29983;&#21629;&#26399;&#31649;&#29702; (&#36164;&#28304;&#31649;&#29702;)&#12305;</strong>&#12290;</p>
<p>&#25105;&#20204;&#21487;&#20197;&#20511;&#21161; smart pointer &#25226;&#23545;&#35937;&#35821;&#20041;&#36716;&#25442;&#20026;&#20540;&#35821;&#20041;&#65292;&#20174;&#32780;&#36731;&#26494;&#35299;&#20915;&#23545;&#35937;&#29983;&#21629;&#26399;: &#35753; Parent &#25345;&#26377; Child &#30340; smart pointer&#65292;&#21516;&#26102;&#35753; Child &#25345;&#26377; Parent &#30340; smart pointer&#65292;&#36825;&#26679;&#22987;&#32456;&#24341;&#29992;&#23545;&#26041;&#30340;&#26102;&#20505;&#23601;&#19981;&#29992;&#25285;&#24515;&#20986;&#29616;&#31354;&#24748;&#25351;&#38024;&#12290;&#24403;&#28982;&#65292;&#20854;&#20013;&#19968;&#20010;smart pointer &#24212;&#35813;&#26159; weak reference&#65292;&#21542;&#21017;&#20250;&#20986;&#29616;&#24490;&#29615;&#24341;&#29992;,&#23548;&#33268;&#20869;&#23384;&#27844;&#28431;&#12290;&#21040;&#24213;&#21738;&#19968;&#20010;&#26159; weak reference&#65292;&#21017;&#21462;&#20915;&#20110;&#20855;&#20307;&#24212;&#29992;&#22330;&#26223;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#20540;&#35821;&#20041;&#19982;&#26631;&#20934;&#24211; <code class="fold">@</code></dt>
<dd><p>&#22312;&#29616;&#20195; C++ &#20013;&#65292;&#19968;&#33324;&#19981;&#38656;&#35201;&#33258;&#24049;&#32534;&#20889; copy constructor &#25110; copy assignment operator&#65292;&#22240;&#20026;&#21482;&#35201;&#27599;&#20010;&#25968;&#25454;&#25104;&#21592;&#37117;&#20855;&#26377;&#20540;&#35821;&#20041;&#30340;&#35805;&#65292;&#32534;&#35793;&#22120;&#33258;&#21160;&#29983;&#25104;&#30340; member-wise copying&amp;assigning &#23601;&#33021;&#27491;&#24120;&#24037;&#20316;; &#22914;&#26524;&#20197;<code>smart_ptr</code> &#20026;&#25104;&#21592;&#26469;&#25345;&#26377;&#20854;&#20182;&#23545;&#35937;&#65292;&#37027;&#20040;&#23601;&#33021;&#33258;&#21160;&#21551;&#29992;&#25110;&#31105;&#29992; copying&amp;assigning&#12290;</p>
<p>&#25110;&#32773;&#20320;&#33258;&#24049;&#20889;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#20540;&#35821;&#20041;&#19982; C++ &#35821;&#35328; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p><strong>C++ &#30340; class &#26412;&#36136;&#19978;&#26159;&#20540;&#35821;&#20041;&#30340;,&#36825;&#25165;&#20250;&#20986;&#29616; object slicing &#36825;&#31181;&#35821;&#35328;&#29420;&#26377;&#30340;&#38382;&#39064;,&#20063;&#25165;&#20250;&#38656;&#35201;&#31243;&#24207;&#21592;&#27880;&#24847; pass-by-value &#21644; pass-by-const-reference &#30340;&#21462;&#33293;&#12290;</strong>&#22312;&#20854;&#20182;&#38754;&#21521;&#23545;&#35937;&#32534;&#31243;&#35821;&#35328;&#20013;,&#36825;&#37117;&#19981;&#38656;&#35201;&#36153;&#33041;&#31563;&#12290;</p>
<p>&#20540;&#35821;&#20041;&#26159; C++ &#35821;&#35328;&#30340;&#19977;&#22823;&#32422;&#26463;&#20043;&#19968;&#65292;C++ &#30340;&#35774;&#35745;&#21021;&#34935;&#26159;&#35753;&#29992;&#25143;&#23450;&#20041;&#30340;&#31867;&#22411;(class) &#33021;&#20687;&#20869;&#32622;&#31867;&#22411; (int) &#19968;&#26679;&#24037;&#20316;&#65292;&#20855;&#26377;&#21516;&#31561;&#30340;&#22320;&#20301;&#12290;&#20026;&#27492; C++ &#20570;&#20102;&#20197;&#19979;&#35774;&#35745;(&#22949;&#21327;):</p>
<ul>
<li><p>class &#30340; layout &#19982; C struct &#19968;&#26679;,&#27809;&#26377;&#39069;&#22806;&#30340;&#24320;&#38144;&#12290;&#23450;&#20041;&#19968;&#20010;&#8220;&#21482;&#21253;&#21547;&#19968;&#20010; int &#25104;&#21592;&#30340; class&#8221;&#30340;&#23545;&#35937;&#24320;&#38144;&#21644;&#23450;&#20041;&#19968;&#20010; int &#19968;&#26679;&#12290;</p></li>
<li><p>&#29978;&#33267; <strong>class data member &#37117;&#40664;&#35748;&#26159; uninitialized</strong>,&#22240;&#20026;&#20989;&#25968;&#23616;&#37096;&#30340; int &#26159; uninitialized&#12290;&#65288;&#36825;&#19968;&#28857;&#20854;&#23454;&#24456;&#21453;&#30452;&#35273;&#65292;&#33267;&#23569;&#23545;&#25105;&#32780;&#35328;&#12290;&#65289;</p></li>
<li><p>class &#21487; &#20197; &#22312; stack &#19978; &#21019; &#24314;,&#20063; &#21487; &#20197; &#22312; heap &#19978;&#21019; &#24314;&#12290;&#22240; &#20026; int &#21487; &#20197; &#26159; stack variable&#12290;</p></li>
<li><p>class &#30340;&#25968;&#32452;&#23601;&#26159;&#19968;&#20010;&#20010; class &#23545;&#35937;&#25384;&#30528;&#65292;&#27809;&#26377;&#39069;&#22806;&#30340; indirection&#12290;&#22240;&#20026; int &#25968;&#32452;&#23601;&#26159;&#36825;&#26679;&#12290;</p></li>
<li><p>&#32534;&#35793;&#22120;&#20250;&#20026; class &#40664;&#35748;&#29983;&#25104; copy constructor &#21644; assignment operator&#12290;&#20854;&#20182;&#35821;&#35328;&#27809;&#26377; copy constructor &#19968;&#35828;&#65292;&#20063;&#19981;&#20801;&#35768;&#37325;&#36733; assignment operator&#12290;C++ &#30340;&#23545;&#35937;&#40664;&#35748;&#26159;&#21487;&#20197;&#25335;&#36125;&#30340;&#65292;&#36825;&#26159;&#19968;&#20010;&#23604;&#23596;&#30340;&#29305;&#24615;&#12290;</p></li>
<li><p>&#24403; class type &#20256;&#20837;&#20989;&#25968;&#26102;&#65292;&#40664;&#35748;&#26159; make a copy (&#38500;&#38750;&#21442;&#25968;&#22768;&#26126;&#20026; reference)&#12290;</p>
<p>&#22240;&#20026;&#25226; int &#20256;&#20837;&#20989;&#25968;&#26102;&#26159; make a copy&#12290;C++ &#30340;&#8220;&#20989;&#25968;&#35843;&#29992;&#8221;&#27604;&#20854;&#20182;&#35821;&#35328;&#22797;&#26434;&#20043;&#22788;&#22312;&#20110;&#21442;&#25968;&#20256;&#36882;&#21644;&#36820;&#22238;&#20540;&#20256;&#36882;&#12290;C&#12289; Java &#31561;&#35821;&#35328;&#37117;&#26159;&#20256;&#20540;&#65292;&#31616;&#21333;&#22320;&#22797;&#21046;&#20960;&#20010;&#23383;&#33410;&#30340;&#20869;&#23384;&#23601;&#34892;&#20102;&#12290;&#20294;&#26159; C++ &#23545;&#35937;&#26159;&#20540;&#35821;&#20041;&#65292;&#22914;&#26524;&#20197; pass-by-value &#26041;&#24335;&#25226;&#23545;&#35937;&#20256;&#20837;&#20989;&#25968;&#65292;&#20250;&#28041;&#21450;&#25335;&#36125;&#26500;&#36896;&#12290;&#20195;&#30721;&#37324;&#30475;&#21040;&#19968;&#21477;&#31616;&#21333;&#30340;&#20989;&#25968;&#35843;&#29992;&#65292;&#23454;&#38469;&#32972;&#21518;&#21457;&#29983;&#30340;&#21487;&#33021;&#26159;&#19968;&#38271;&#20018;&#23545;&#35937;&#26500;&#36896;&#25805;&#20316;&#65292;&#22240;&#27492;&#20943;&#23569;&#26080;&#35859;&#30340;&#20020;&#26102;&#23545;&#35937;&#26159; C++ &#20195;&#30721;&#20248;&#21270;&#30340;&#20851;&#38190;&#20043;&#19968;&#12290;</p></li>
<li><p>&#24403;&#20989;&#25968;&#36820;&#22238;&#19968;&#20010; class type &#26102;,&#21482;&#33021;&#36890;&#36807; make a copy(C++ &#19981;&#24471;&#19981;&#23450;&#20041; RVO&#26469;&#35299;&#20915;&#24615;&#33021;&#38382;&#39064;)&#12290;</p>
<p>&#22240;&#20026;&#20989;&#25968;&#36820;&#22238; int &#26102;&#26159; make a copy&#12290;</p></li>
<li><p>&#20197; class type &#20026; &#25104; &#21592; &#26102;,&#25968; &#25454; &#25104; &#21592; &#26159; &#23884; &#20837; &#30340;&#12290;&#20363; &#22914; pair<complex<double>, size_t&gt; &#30340; layout &#23601;&#26159; complex<double> &#25384;&#30528; size_t&#12290;</p></li>
</ul>
<p><strong>&#36825;&#20123;&#35774;&#35745;&#24102;&#26469;&#20102;&#24615;&#33021;&#19978;&#30340;&#22909;&#22788;&#65292;&#21407;&#22240;&#26159; memory locality&#12290;</strong></p>
<dl>
<dt>&#27979;&#35797;&#20102;&#19968;&#20010;&#35753;&#25105;&#36855;&#24785;&#24471;&#22320;&#26041; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>

<span class="dt">int</span> main()
{
    <span class="dt">char</span> bufbuf[<span class="dv">50</span>];
    printf( <span class="st">&quot;address of bufbuf[50]: %p</span><span class="ch">\n</span><span class="st">&quot;</span>,bufbuf );
    <span class="dt">int</span> n;
    <span class="kw">while</span>( scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span> &amp;&amp; n &gt; <span class="dv">0</span> ) {
        <span class="dt">char</span> buf[n];
        printf( <span class="st">&quot;address of buf[</span><span class="ch">%3d</span><span class="st">]: %p</span><span class="ch">\n</span><span class="st">&quot;</span>, n, buf );
        <span class="dt">char</span> *buf2 = (<span class="dt">char</span> *)malloc( n * <span class="kw">sizeof</span>(<span class="dt">char</span>) );
        printf( <span class="st">&quot;address of *buf2   : %p</span><span class="ch">\n</span><span class="st">&quot;</span>, buf2 );
        free( buf2 );
    }
}</code></pre></div>
<p>&#21487;&#20197;&#30475;&#21040; stack &#21644; heap &#26159;&#30001;&#21306;&#21035;&#24471;&#12290;stack &#19978;&#38754;&#20063;&#26159;&#21487;&#20197;&#20998;&#37197;&#21160;&#24577;&#24471;&#25968;&#25454;&#12290;</p>
<pre><code>address of bufbuf[50]: 0x7ffdc88e9520
5
address of buf[  5]: 0x7ffdc88e94f0
address of *buf2   : 0x1c32010
9
address of buf[  9]: 0x7ffdc88e94f0
address of *buf2   : 0x1c32010
7
address of buf[  7]: 0x7ffdc88e94f0
address of *buf2   : 0x1c32010
3
address of buf[  3]: 0x7ffdc88e94f0
address of *buf2   : 0x1c32010
100
address of buf[100]: 0x7ffdc88e9490
address of *buf2   : 0x1c32030
7
address of buf[  7]: 0x7ffdc88e94f0
address of *buf2   : 0x1c32010</code></pre>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>&#20160;&#20040;&#26159;&#25968;&#25454;&#25277;&#35937; <code class="fold">@</code></dt>
<dd><p><strong>C++ &#30340;&#24378;&#22823;&#20043;&#22788;&#22312;&#20110;&#8220;&#25277;&#35937;&#8221;&#19981;&#20197;&#24615;&#33021;&#25439;&#22833;&#20026;&#20195;&#20215;&#12290;</strong></p>
<p>&#25968;&#25454;&#25277;&#35937; (data abstraction) &#26159;&#19982;&#38754;&#21521;&#23545;&#35937; (object-oriented) &#24182;&#21015;&#30340;&#19968;&#31181;&#32534;&#31243;&#33539;&#24335;(programming paradigm)&#12290;&#35828;&#8220;&#25968;&#25454;&#25277;&#35937;&#8221;&#25110;&#35768;&#26174;&#24471;&#38476;&#29983;,&#23427;&#30340;&#21478;&#22806;&#19968;&#20010;&#21517;&#23383;&#8220;&#25277;&#35937;&#25968;&#25454;&#31867;&#22411;/abstract data type/ADT&#8221;&#24819;&#24517;&#22914;&#38647;&#36143;&#32819;&#12290;</p>
<p>&#19977;&#20010;&#24120;&#35265;&#32534;&#31243;&#31684;&#24335;&#26159;&#65306;</p>
<ul>
<li>(procedural&#65292;&#31243;&#24207;&#27169;&#22411;)</li>
<li>ADT &#27169;&#22411;&#65292;data abstraction</li>
<li>object-based</li>
<li>object-oriented&#65292;&#38754;&#21521;&#23545;&#35937;&#27169;&#22411;</li>
</ul>
<p>C++ is a general-purpose programming language with a bias towards systems programming that</p>
<ul>
<li>is a better C,</li>
<li>supports data abstraction&#65292;&#65288;&#25903;&#25345; ADT&#65289;</li>
<li>supports object-oriented programming&#65288;&#25903;&#25345;&#23553;&#35013;&#12289;&#32487;&#25215;&#12289;&#22810;&#24577;&#65289;&#65292;and</li>
<li>supports generic programming.</li>
</ul>
<dl>
<dt>&#37027;&#20040;&#21040;&#24213;&#20160;&#20040;&#26159;&#25968;&#25454;&#25277;&#35937;?</dt>
<dd><p>&#31616;&#21333;&#30340;&#35828;&#65292;&#25968;&#25454;&#25277;&#35937;&#26159;&#29992;&#26469;&#25551;&#36848; (&#25277;&#35937;) &#25968;&#25454;&#32467;&#26500;&#30340;&#12290;</p>
<p>&#25968;&#25454;&#25277;&#35937;&#23601;&#26159; ADT&#12290;&#19968;&#20010; ADT &#20027;&#35201;&#34920;&#29616;&#20026;&#23427;<strong>&#25903;&#25345;&#30340;&#19968;&#20123;&#25805;&#20316; </strong>&#65292;&#27604;&#26041;&#35828; stack.push&#12289;stack.pop&#65292;&#36825;&#20123;&#25805;&#20316;&#24212;&#35813;&#20855;&#26377;&#26126;&#30830;&#30340;&#26102;&#38388;&#21644;&#31354;&#38388;&#22797;&#26434;&#24230;&#12290;&#21478;&#22806;&#65292;&#19968;&#20010; ADT &#21487;&#20197;<strong>&#38544;&#34255;&#20854;&#23454;&#29616;&#32454;&#33410;</strong>, &#27604;&#26041;&#35828; stack &#26082;&#21487;&#20197;&#29992;&#21160;&#24577;&#25968;&#32452;&#23454;&#29616;&#65292;&#21448;&#21487;&#20197;&#29992;&#38142;&#34920;&#23454;&#29616;&#12290;</p>
</dd>
</dl>
<p>&#25353;&#29031;&#36825;&#20010;&#23450;&#20041;&#65292;&#25968;&#25454;&#25277;&#35937;&#21644;&#22522;&#20110;&#23545;&#35937; (object-based) &#24456;&#20687;&#65292;&#37027;&#20040;&#23427;&#20204;&#30340;&#21306;&#21035;&#22312;&#21738;&#37324;? &#35821;&#20041;&#19981;&#21516;&#12290;<strong>ADT &#36890;&#24120;&#26159;&#20540;&#35821;&#20041;&#65292;&#32780; object-based &#26159;&#23545;&#35937;&#35821;&#20041;&#12290;</strong>(&#36825;&#20004;&#31181;&#35821;&#20041;&#30340;&#23450;&#20041;&#35265;&#21069;&#19968;&#33410;&#12298;&#20160;&#20040;&#26159;&#20540;&#35821;&#20041;&#12299;12.1)&#12290;ADT class &#26159;&#21487;&#20197;&#25335;&#36125;&#30340;&#65292;&#25335;&#36125;&#20043;&#21518;&#30340; instance &#19982;&#21407; instance &#33073;&#31163;&#20851;&#31995;&#12290;&#27604;&#26041;&#35828;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">stack&lt;<span class="dt">int</span>&gt; a;
a.push(<span class="dv">10</span>);
stack&lt;<span class="dt">int</span>&gt; b = a;
b.pop();</code></pre></div>
<p>&#36825;&#26102;&#20505; a &#37324;&#20173;&#28982;&#26377;&#20803;&#32032; 10&#12290;</p>
<p>&#26412;&#25991;&#25226; data abstraction&#12289;object-based&#12289;object-oriented &#35270;&#20026;&#19977;&#20010;&#32534;&#31243;&#33539;&#24335;&#12290;&#36825;&#31181;&#32454;&#33268;&#30340;&#20998;&#31867;&#25110;&#35768;&#26377;&#21161;&#20110;&#29702;&#35299;&#21306;&#20998;&#23427;&#20204;&#20043;&#38388;&#30340;&#24046;&#21035;&#12290;&#24248;&#20439;&#22320;&#35762;&#65292;&#38754;&#21521;&#23545;&#35937; (object-oriented) &#26377;&#19977;&#22823;&#29305;&#24449;: &#23553;&#35013;&#12289;&#32487;&#25215;&#12289;&#22810;&#24577;&#12290;<strong>&#32780;&#22522;&#20110;&#23545;&#35937; (object-based) &#21017;&#21482;&#26377;&#23553;&#35013;&#65292;&#27809;&#26377;&#32487;&#25215;&#21644;&#22810;&#24577;&#65292;&#21363;&#21482;&#26377;&#20855;&#20307;&#31867;&#65292;&#27809;&#26377;&#25277;&#35937;&#25509;&#21475;&#12290;</strong>&#23427;&#20204;&#20004;&#20010;&#37117;&#26159;&#23545;&#35937;&#35821;&#20041;&#12290;</p>
<p>&#38754;&#21521;&#23545;&#35937;&#30495;&#27491;&#26680;&#24515;&#30340;&#24605;&#24819;&#26159;&#28040;&#24687;&#20256;&#36882; (messaging)&#65292;&#8220;&#23553;&#35013;&#32487;&#25215;&#22810;&#24577;&#8221;&#21482;&#26159;&#34920;&#35937;&#12290;&#36825;&#19968;&#28857;&#23391;&#23721; 63 &#21644;&#29579;&#30410; 64 &#37117;&#26377;&#31934;&#24425;&#30340;&#35770;&#36848;&#65292;&#38472;&#30805;&#19981;&#20877;&#36184;&#35328;&#12290;</p>
<dl>
<dt><a href="https://cxwangyi.wordpress.com/2011/06/19/%E6%9D%82%E8%B0%88%E7%8E%B0%E4%BB%A3%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">&#26434;&#35848;&#29616;&#20195;&#39640;&#32423;&#32534;&#31243;&#35821;&#35328; | Yi Wang&#8217;s Tech Notes</a> <code class="fold">@</code></dt>
<dd><p>OO &#20043;&#29238; Alan Kay &#23601;&#26366;&#32463;&#22312;&#19968;&#31687;&#37038;&#20214;&#20013;&#35828;&#65292;&#20182;&#24456;&#21518;&#24724;&#21457;&#26126;&#20102; &#8220;object&#8221;&#36825;&#20010;&#35789;&#65292;&#20174;&#32780;&#35823;&#23548;&#22823;&#23478;&#65292;&#25226;&#27880;&#24847;&#21147;&#37117;&#38598;&#20013;&#21040;&#8220;&#23553;&#35013;&#8221;&#65292;&#32780;&#24573;&#35270;&#20102; OO &#30340;&#26412;&#36136;&#8212;&#8212;&#12304;messaging&#65288;&#28040;&#24687;&#20256;&#36882;&#65289;&#12305;&#12290;Alan Kay &#30340;&#21407;&#35805;&#26159;&#65306;</p>
<blockquote>
<p>The big idea is &#8220;messaging&#8221; &#8230; . The key in making great and growable systems is much more to design <strong>how its modules communicate</strong> rather than what their internal properties and behaviors should be.</p>
</blockquote>
<p>&#26377;&#24847;&#24605;&#30340;&#26159;&#65292;&#20026;&#20102;&#25903;&#25345; messaging&#65292;Qt &#23545; C++ &#35821;&#35328;&#20570;&#20102;&#25193;&#23637;&#65292;&#32780; Objective-C &#23545; C &#35821;&#35328;&#20570;&#20102;&#25193;&#23637;&#12290;&#36825;&#20004;&#22871;&#25193;&#23637;&#37117;&#21033;&#29992;&#20102;&#36215;&#28304;&#20110; C &#35821;&#35328;&#30340;&#8220;&#23439;&#8221;&#26426;&#21046;&#65288;macro&#65289;&#12290;&#31867;&#20284;&#30340;&#20570;&#27861;&#20063;&#21487;&#20197;&#29992;&#20110; Java&#65292;&#21069;&#25552;&#26159;&#25105;&#20204;&#22312;&#35843;&#29992; Java &#32534;&#35793;&#22120;&#20043;&#21069;&#65292;&#20808;&#35843;&#29992;&#19968;&#19979; cpp &#23439;&#23637;&#24320;&#31243;&#24207;&#26469;&#39044;&#22788;&#29702;&#19968;&#19979;&#25105;&#20204;&#30340; Java &#31243;&#24207;&#12290;&#36825;&#20107;&#20799;&#21487;&#20197;&#30041;&#24453; Java &#29233;&#22909;&#32773;&#20204;&#26469;&#25630;&#65311;</p>
<p>&#35828;&#21040;&#36825;&#37324;&#65292;&#25105;&#35273;&#24471;&#24046;&#19981;&#22810;&#21487;&#20197;&#21453;&#36807;&#26469;&#29702;&#35299; Robert Harper &#25945;&#25480;&#23545; OO &#30340;&#35780;&#20215;&#20102;&#8212;&#8212;&#20854;&#23454; Robert &#19981;&#26159;&#22312;&#34256;&#35270; OO&#65292;&#32780;&#26159;&#22312;&#25351;&#36131;&#24456;&#22810; imperative OO languages&#65288;&#25105;&#29702;&#35299;&#21253;&#25324; Java &#21644;&#26410;&#32463; Qt &#25193;&#23637;&#30340; C++&#65307;&#35814;&#35265;&#21518;&#36848;&#65289;&#65292;&#35748;&#20026;&#36825;&#20123;&#35821;&#35328;&#27809;&#26377;&#23436;&#25104;&#23454;&#29616; OO &#20013; object messaging &#30340;&#26680;&#24515;&#24605;&#24819;&#65292;&#20174;&#32780;&#19981;&#31639;&#23454;&#29616;&#20102;&#8220;&#27169;&#22359;&#21270; &#8220;&#65288;modulization&#65289;&#30340;&#24605;&#24819;&#12290;</p>
</dd>
<dt><a href="http://blog.csdn.net/myan/article/details/5928531">function/bind&#30340;&#25937;&#36174;&#65288;&#19978;&#65289; - &#23391;&#23721; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a> <code class="fold">@</code></dt>
<dd><p>Function/bind &#21487;&#20197;&#26159;&#19968;&#20010;&#24456;&#31616;&#21333;&#30340;&#35805;&#39064;&#65292;&#22240;&#20026;&#23427;&#20854;&#23454;&#19981;&#36807;&#23601;&#26159;&#19968;&#20010;&#27867;&#22411;&#30340;&#20989;&#25968;&#25351;&#38024;&#12290;&#20294;&#26159;&#22914;&#26524;&#37027;&#20040;&#26469;&#35848;&#65292;&#23601;&#27809;&#24847;&#24605;&#20102;&#65292;&#20063;&#29359;&#19981;&#19978;&#20889;&#36825;&#31687;&#19996;&#35199;&#12290;&#22312;&#25105;&#30475;&#26469;&#65292;&#36825;&#20010;&#20107;&#24773;&#35201;&#35762;&#30340;&#35805;&#65292;&#23601;&#24212;&#35813;&#35762;&#36879;&#65292;&#35762;&#21040;&#22238;&#35843;&#65288;callback&#65289;&#12289;&#20195;&#29702;&#65288;delegate&#65289;&#12289;&#20449;&#21495;&#65288;signal&#65289;&#21644;&#28040;&#24687;&#20256;&#36882;&#65288;messaging&#65289;&#30340;&#23618;&#38754;&#65292;&#22240;&#20026;&#23427;&#30830;&#23454;&#26159;&#22826;&#37325;&#35201;&#20102;&#12290;</p>
<p>&#23545;&#35937;&#33539;&#24335;&#19982;&#36807;&#31243;&#33539;&#24335;&#30456;&#27604;&#65292;&#26377;&#19977;&#20010;&#31361;&#20986;&#30340;&#20248;&#21183;&#65292;&#31532;&#19968;&#65292;&#30001;&#20110;&#23454;&#29616;&#20102;&#36923;&#36753;&#19978;&#30340;&#20998;&#24037;&#65292;&#38477;&#20302;&#20102;&#22823;&#35268;&#27169;&#31243;&#24207;&#30340;&#24320;&#21457;&#38590;&#24230;&#12290;&#31532;&#20108;&#65292;&#28789;&#27963;&#24615;&#26356;&#22909;&#8212;&#8212;&#33509;&#24178;&#23545;&#35937;&#22312;&#19968;&#36215;&#65292;&#21487;&#20197;&#28789;&#27963;&#32452;&#21512;&#65292;&#21487;&#20197;&#20197;&#19981;&#21516;&#30340;&#26041;&#24335;&#21327;&#20316;&#65292;&#23436;&#25104;&#19981;&#21516;&#30340;&#20219;&#21153;&#65292;&#20063;&#21487;&#20197;&#28789;&#27963;&#30340;&#26367;&#25442;&#21644;&#21319;&#32423;&#12290;&#31532;&#19977;&#65292;&#23545;&#35937;&#33539;&#24335;&#26356;&#21152;&#36866;&#24212;&#22270;&#24418;&#21270;&#12289;&#32593;&#32476;&#21270;&#12289;&#28040;&#24687;&#39537;&#21160;&#30340;&#29616;&#20195;&#35745;&#31639;&#29615;&#22659;&#12290;</p>
<p>&#37325;&#22797;&#19968;&#36941;&#23545;&#35937;&#33539;&#24335;&#30340;&#20004;&#20010;&#22522;&#26412;&#35266;&#24565;&#65306;</p>
<ul>
<li>&#31243;&#24207;&#26159;&#30001;&#23545;&#35937;&#32452;&#25104;&#30340;&#65307;</li>
<li>&#23545;&#35937;&#20043;&#38388;&#20114;&#30456;&#21457;&#36865;&#28040;&#24687;&#65292;&#21327;&#20316;&#23436;&#25104;&#20219;&#21153;&#65307;</li>
</ul>
<p>&#32780;&#22914;&#26524;&#20320;&#35201;&#35753;&#25152;&#26377;&#30340;&#31383;&#21475;&#31867;&#37117;&#33021;&#22788;&#29702;&#25152;&#26377;&#21487;&#33021;&#30340;&#28040;&#24687;&#65292;&#19988;&#19981;&#35770;&#36825;&#26679;&#22312;&#36923;&#36753;&#19978;&#23601;&#34892;&#19981;&#36890;&#65288;&#29992;&#25143;&#23450;&#20041;&#30340;&#28040;&#24687;&#24590;&#20040;&#22788;&#29702;&#65311;&#65289;&#65292;&#21333;&#22312;&#23454;&#29616;&#19978;&#23601;&#19981;&#21487;&#25509;&#21463;&#8212;&#8212;&#20026;&#19968;&#20010;&#23567;&#23567;&#30340;&#19981;&#21516;&#23601;&#24471;&#21019;&#36896;&#19968;&#20010;&#26032;&#30340;&#31383;&#21475;&#31867;&#65292;&#27599;&#19968;&#20010;&#23567;&#23567;&#30340;&#31383;&#21475;&#31867;&#37117;&#35201;&#32972;&#19978;&#19968;&#20010;&#22810;&#36798;&#25968;&#30334;&#39033;&#30340; v-table&#65292;&#32780;&#20854;&#20013;&#21487;&#33021; 99% &#30340;&#39033;&#37117;&#26159;&#28010;&#36153;&#65292;&#19981;&#35201;&#35828;&#22312;&#24403;&#26102;&#65292;&#23601;&#26159;&#22312;&#20170;&#22825;&#65292;&#20869;&#23384;&#25968;&#37327;&#38750;&#24120;&#20016;&#23500;&#30340;&#26102;&#20505;&#65292;&#22914;&#26524;&#27599;&#19968;&#20010; GUI &#31243;&#24207;&#37117;&#36825;&#20040;&#25630;&#65292;&#29992;&#25143;&#20063;&#21507;&#19981;&#28040;&#12290;</p>
<p>&#20320;&#30475;&#21040; MFC &#30340;&#31867;&#32487;&#25215;&#26641;&#65292;&#35273;&#24471;&#35774;&#35745;&#32773;&#22826;&#29275;&#20102;&#65292;&#33021;&#25226;&#36825;&#20123;&#23618;&#27425;&#27010;&#24565;&#37117;&#24819;&#28165;&#26970;&#65292;&#33258;&#24049;&#30340;&#27700;&#24179;&#36824;&#19981;&#22815;&#65292;&#36824;&#24471;&#20462;&#28860;&#12290;&#23454;&#38469;&#19978;&#21602;&#65292;&#36825;&#20010;&#35774;&#35745;&#26159;&#32463;&#36807;&#25968;&#19981;&#28165;&#30340;&#22833;&#36133;&#21644;&#38065;&#30952;&#20986;&#26469;&#12289;&#30776;&#20986;&#26469;&#30340;&#65292;MFC &#30340;&#21069;&#36523; Afx &#19981;&#26159;&#23601;&#22833;&#36133;&#20102;&#21527;&#65311;</p>
<p>&#33267;&#20110; .NET&#65292;&#25105;&#21548;&#38472;&#27029;&#20171;&#32461;&#36807;&#65292;&#22312;&#35774;&#35745;.NET &#30340;&#26102;&#20505;&#65292;&#24494;&#36719;&#20869;&#37096;&#23545;&#20110;&#26159;&#21542;&#20801;&#35768;&#32487;&#25215;&#29190;&#21457;&#20102;&#38750;&#24120;&#28608;&#28872;&#30340;&#20105;&#35770;&#12290;&#24456;&#22810;&#36164;&#28145;&#39640;&#20154;&#37117;&#24378;&#28872;&#21453;&#23545;&#32487;&#25215;&#12290;&#33267;&#20110;&#26368;&#21518;&#24341;&#20837;&#32487;&#25215;&#65292;&#24456;&#22823;&#31243;&#24230;&#19978;&#26159;&#33829;&#38144;&#38656;&#35201;&#21387;&#20498;&#20102;&#25216;&#26415;&#29702;&#24615;&#12290;&#23613;&#31649;&#22914;&#27492;&#65292;&#30001;&#20110;&#26377; COM &#30340;&#22522;&#30784;&#65292;&#21448;&#23454;&#29616;&#20102;&#38750;&#24120;&#24443;&#24213;&#30340; delegate&#65292;&#25152;&#20197; .NET &#30340;&#35774;&#35745;&#27700;&#24179;&#36824;&#26159;&#24456;&#39640;&#30340;&#12290;&#23427;&#30340;&#20027;&#35201;&#38382;&#39064;&#19981;&#22312;&#36825;&#65292;&#22312;&#20110;&#22826;&#24613;&#20110;&#27714;&#32988;&#65292;&#26356;&#26032;&#36895;&#24230;&#22826;&#24555;&#65292;&#22522;&#30784;&#19981;&#29282;&#12290;&#24403;&#28982;&#65292;&#26681;&#26412;&#38382;&#39064;&#36824;&#26159;&#24494;&#36719;&#27809;&#26377;&#33021;&#22815;&#22312; Web &#21644; Mobile &#39046;&#22495;&#37324;&#21344;&#21040;&#22810;&#22823;&#30340;&#20248;&#21183;&#65292;&#20063;&#23601;&#20351;&#24471;.NET &#27809;&#26377;&#29992;&#27494;&#20043;&#22320;&#12290;</p>
<p>C++ &#26159;&#26377;&#19968;&#20010;&#34917;&#25937;&#26426;&#20250;&#30340;&#65292;&#37027;&#23601;&#26159;&#23454;&#29616;&#23545;&#35937;&#32423;&#21035;&#30340; delegate &#26426;&#21046;&#12290;&#23398;&#36807;.NET &#30340;&#20154;&#65292;&#19968;&#21548; delegate &#36825;&#20010;&#35789;&#23601;&#30693;&#36947;&#26159;&#20160;&#20040;&#24847;&#24605;&#65292;&#20294; Java &#37324;&#27809;&#26377;&#23545;&#24212;&#26426;&#21046;&#12290;&#22312; C++ &#30340;&#26415;&#35821;&#20307;&#31995;&#37324;&#65292;&#25152;&#35859;&#23545;&#35937;&#32423;&#21035; delegate&#65292;&#23601;&#26159;&#19968;&#20010;&#23545;&#35937;&#22238;&#35843;&#26426;&#21046;&#12290;&#36890;&#36807; delegate&#65292;&#19968;&#20010;&#23545;&#35937; A &#21487;&#20197;&#25226;&#19968;&#20010;&#29305;&#23450;&#24037;&#20316;&#65292;&#27604;&#22914;&#22788;&#29702;&#29992;&#25143;&#30340;&#40736;&#26631;&#20107;&#20214;&#65292;&#22996;&#25176;&#32473;&#21478;&#19968;&#20010;&#23545;&#35937; B &#30340;&#19968;&#20010;&#26041;&#27861;&#26469;&#23436;&#25104;&#12290;A &#19981;&#24517;&#30693;&#36947; B &#30340;&#21517;&#23383;&#65292;&#20063;&#19981;&#29992;&#30693;&#36947;&#23427;&#30340;&#31867;&#22411;&#65292;&#29978;&#33267;&#37117;&#19981;&#38656;&#35201;&#30693;&#36947; B &#30340;&#23384;&#22312;&#65292;&#21482;&#35201;&#27714; B &#23545;&#35937;&#20855;&#26377;&#19968;&#20010;&#31614;&#21517;&#27491;&#30830;&#30340;&#26041;&#27861;&#65292;&#23601;&#21487;&#20197;&#36890;&#36807; delegate &#25226;&#24037;&#20316;&#20132;&#32473; B &#30340;&#36825;&#20010;&#26041;&#27861;&#26469;&#25191;&#34892;&#12290;&#22312; C &#35821;&#35328;&#37324;&#65292;&#36825;&#20010;&#26426;&#21046;&#26159;&#36890;&#36807;&#20989;&#25968;&#25351;&#38024;&#23454;&#29616;&#30340;&#65292;&#25152;&#20197;&#24456;&#33258;&#28982;&#30340;&#65292;&#22312; C++ &#37324;&#65292;&#25105;&#20204;&#24076;&#26395;&#36890;&#36807;&#25351;&#21521;&#25104;&#21592;&#20989;&#25968;&#30340;&#25351;&#38024;&#26469;&#35299;&#20915;&#31867;&#20284;&#38382;&#39064;&#12290;</p>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>&#25968;&#25454;&#25277;&#35937;&#25152;&#38656;&#30340;&#35821;&#35328;&#35774;&#26045; <code class="fold">@</code></dt>
<dd><p>&#19981;&#26159;&#27599;&#20010;&#35821;&#35328;&#37117;&#25903;&#25345;&#25968;&#25454;&#25277;&#35937;,&#19979;&#38754;&#31616;&#35201;&#21015;&#20986;&#8220;&#25968;&#25454;&#25277;&#35937;&#8221;&#25152;&#38656;&#30340;&#35821;&#35328;&#35774;&#26045;&#12290;</p>
<ul>
<li><p><strong>&#25903;&#25345;&#25968;&#25454;&#32858;&#21512;</strong></p>
<p>&#25968; &#25454; &#32858; &#21512; data aggregation&#65292;&#25110; &#32773; value aggregates&#12290; &#21363; &#23450; &#20041; C- style struct&#65292;&#25226;&#26377;&#20851;&#25968;&#25454;&#25918;&#21040;&#21516;&#19968;&#20010; struct &#37324;&#12290;</p></li>
<li><p><strong>&#20840;&#23616;&#20989;&#25968;&#19982;&#37325;&#36733;</strong></p>
<p>C &#35821;&#35328;&#21487;&#20197;&#23450;&#20041;&#20840;&#23616;&#20989;&#25968;&#65292;&#20294;&#26159;&#19981;&#33021;&#19982;&#24050;&#26377;&#30340;&#20989;&#25968;&#37325;&#21517;&#65292;&#20063;&#23601;&#27809;&#26377;&#37325;&#36733;&#12290;Java &#27809;&#26377;&#20840;&#23616;&#20989;&#25968;&#65292;&#32780;&#19988; Math class &#26159;&#23553;&#38381;&#30340;&#65292;&#24182;&#19981;&#33021;&#24448;&#20854;&#20013;&#28155;&#21152; sin(Complex)&#12290;</p></li>
<li><p><strong>&#25104;&#21592;&#20989;&#25968;&#19982; private &#25968;&#25454;</strong></p></li>
<li><p><strong>&#25335;&#36125;&#25511;&#21046; (copy control)</strong></p>
<p>copy control &#26159;&#25335;&#36125; <code>stack a; stack b = a;</code> &#21644;&#36171;&#20540; <code>stack b; b = a;</code> &#30340;&#21512;&#31216;&#12290;</p>
<p>&#30001;&#20110; C++ class &#26159;&#20540;&#35821;&#20041;&#65292;copy control &#26159;&#23454;&#29616;&#28145;&#25335;&#36125;&#30340;&#24517;&#35201;&#25163;&#27573;&#12290;&#32780;&#19988; ADT &#29992;&#21040;&#30340;&#36164;&#28304;&#21482;&#28041;&#21450;&#21160;&#24577;&#20998;&#37197;&#30340;&#20869;&#23384;&#65292;&#25152;&#20197;&#28145;&#25335;&#36125;&#26159;&#21487;&#34892;&#30340;&#12290;&#30456;&#21453;&#65292;object-based &#32534;&#31243;&#39118;&#26684;&#20013;&#30340; class &#24448;&#24448;&#20195;&#34920;&#26576;&#26679;&#30495;&#23454;&#30340;&#20107;&#29289; (Employee&#12289;Account&#12289;File &#31561;&#31561;)&#65292;&#28145;&#25335;&#36125;&#26080;&#24847;&#20041;&#12290;</p>
<p>C &#35821;&#35328;&#27809;&#26377; copy control&#65292;&#20063;&#27809;&#26377;&#21150;&#27861;&#38450;&#27490;&#25335;&#36125;&#65292;&#19968;&#20999;&#35201;&#38752;&#31243;&#24207;&#21592;&#33258;&#24049;&#23567;&#24515;&#22312;&#24847;&#12290;<code>FILE *</code> &#21487;&#20197;&#38543;&#24847;&#25335;&#36125;&#65292;&#20294;&#26159;&#21482;&#35201;&#20851;&#38381;&#20854;&#20013;&#19968;&#20010; copy&#65292;&#20854;&#20182; copies &#20063;&#37117;&#22833;&#25928;&#20102;&#65292;&#36319;&#31354;&#24748;&#25351;&#38024;&#19968;&#33324;&#12290;&#25972;&#20010; C &#35821;&#35328;&#23545;&#24453;&#36164;&#28304; (malloc &#24471;&#21040;&#30340;&#20869;&#23384;&#65292;open() &#25171;&#24320;&#30340;&#25991;&#20214;&#65292;socket() &#25171;&#24320;&#30340;&#36830;&#25509;) &#37117;&#26159;&#36825;&#26679;&#65292;&#29992;&#25972;&#25968;&#25110;&#25351;&#38024;&#26469;&#20195;&#34920; (&#21363;&#8220;&#21477;&#26564;&#8221;)&#12290;&#32780;&#25972;&#25968;&#21644;&#25351;&#38024;&#31867;&#22411;&#30340;&#8220;&#21477;&#26564;&#8221;&#26159;&#21487;&#20197;&#38543;&#24847;&#25335;&#36125;&#30340;&#65292;&#24456;&#23481;&#26131;&#23601;&#36896;&#25104;&#37325;&#22797;&#37322;&#25918;&#12289;&#36951;&#28431;&#37322;&#25918;&#12289;&#20351;&#29992;&#24050;&#32463;&#37322;&#25918;&#30340;&#36164;&#28304;&#31561;&#31561;&#24120;&#35265;&#38169;&#35823;&#12290;&#36825;&#26041;&#38754; C++ &#26159;&#19968;&#20010;&#26174;&#33879;&#30340;&#36827;&#27493;&#65292;boost::noncopyable &#26159; boost &#37324;&#26368;&#20540;&#24471;&#25512;&#24191;&#30340;&#24211;&#12290;</p></li>
<li><p>&#25805;&#20316;&#31526;&#37325;&#36733;</p>
<p>&#22914;&#26524;&#35201;&#20889;&#21160;&#24577;&#25968;&#32452;&#65292;&#25105;&#20204;&#24076;&#26395;&#33021;&#20687;&#20351;&#29992;&#20869;&#32622;&#25968;&#32452;&#19968;&#26679;&#20351;&#29992;&#23427;&#65292;&#27604;&#22914;&#25903;&#25345;&#19979;&#26631;&#25805;&#20316;&#12290;C++ &#21487;&#20197;&#37325;&#36733; operator[] &#26469;&#20570;&#21040;&#36825;&#19968;&#28857;&#12290;</p></li>
<li><p>&#25928;&#29575;&#26080;&#25439;</p></li>
<li><p>&#27169;&#26495;&#19982;&#27867;&#22411;</p></li>
<li><p>&#27169;&#26495;&#19982;&#27867;&#22411;</p></li>
</ul>
</dd>
</dl></li>
</ul>
<blockquote>
<p>&#25968;&#25454;&#25277;&#35937;&#26159; C++ &#30340;&#37325;&#35201;&#25277;&#35937;&#25163;&#27573;&#65292;&#36866;&#21512;&#23553;&#35013;&#8220;&#25968;&#25454;&#8221;&#65292;&#23427;&#30340;&#35821;&#20041;&#31616;&#21333;&#65292;&#23481;&#26131;&#20351;&#29992;&#12290;&#25968;&#25454;&#25277;&#35937;&#33021;&#31616;&#21270;&#20195;&#30721;&#20070;&#20889;&#65292;&#20943;&#23569;&#20598;&#28982;&#38169;&#35823;&#12290;</p>
</blockquote>
</dd>
<dt>13&#65289;&#20877;&#25506; std::string <code class="fold">@</code></dt>
<dd><p>std::string &#26377;&#22810;&#31181;&#23454;&#29616;&#26041;&#24335;&#65292;&#24402;&#32435;&#36215;&#26469;&#26377;&#19977;&#31867;&#65306;</p>
<ul>
<li><p>&#26080;&#29305;&#27530;&#22788;&#29702; (eager copy) <code class="foldable">@</code></p>
<p>&#23454;&#29616;&#19978;&#65292;&#36890;&#24120;&#26159;&#65306;</p>
<ul>
<li>&#19977;&#20010;&#25351;&#38024;&#65306;start&#65292;finish&#65292;end_of_storage</li>
<li><p>&#19968;&#20010;&#25351;&#38024;&#65292;&#20004;&#20010;&#22823;&#23567;&#65306;start&#65292;size&#65292;capacity</p>
<p>&#22914;&#26524; size &#29992; int &#34920;&#31034;&#65292;&#37027;&#20040;&#23383;&#31526;&#20018;&#23481;&#37327;&#22312; 2<sup><sup>32</sup></sup>-1 bytes = 2<sup><sup>32-10-10-10</sup></sup> giga bytes&#12290;&#36890;&#24120;&#29992;&#19981;&#30528;&#65292;&#25152;&#20197;&#25226;&#20182;&#25442;&#25104; short &#21487;&#20197;&#33410;&#32422;&#31354;&#38388;&#12290;</p></li>
</ul></li>
<li><p>Copy-on-Write (COW)&#65292;gcc <code class="foldable">@</code></p>
<p>COW &#23545;&#22810;&#32447;&#31243;&#19981;&#21451;&#22909;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> cow_string <span class="co">// libstdc++-v3</span>
{
    <span class="kw">struct</span> Rep
    {
        size_t size;
        size_t capacity;
        size_t refcount;
        <span class="dt">char</span>* data; <span class="co">// variable length</span>
    };
    <span class="dt">char</span>* start;
};</code></pre></div>
<p>&#36825;&#31181;&#25968;&#25454;&#32467;&#26500;&#27809;&#21861;&#22909;&#35828;&#30340;&#65292;&#22312; 64-bit &#20013;&#20284;&#20046;&#20063;&#27809;&#26377;&#20248;&#21270;&#31354;&#38388;&#12290;&#21478;&#22806; COW &#30340;&#25805;&#20316;&#22797;&#26434;&#24230;&#19981;&#19968;&#23450;&#31526;&#21512;&#30452;&#35273;&#65292;&#23427;&#25335;&#36125;&#23383;&#31526;&#20018;&#26159; O(1) &#26102;&#38388;&#65292;&#20294;&#26159;&#25335;&#36125;&#20043;&#21518;&#30340;&#31532;&#19968;&#27425; operator[] &#26377;&#21487;&#33021;&#26159; O(N) &#26102;&#38388;&#12290;</p>
<p>refs and see also</p>
<ul>
<li>http://coolshell.cn/articles/1443.html</li>
</ul></li>
<li><dl>
<dt>&#30701;&#23383;&#31526;&#20018;&#20248;&#21270; (SSO)&#65292;&#21033;&#29992; string &#23545;&#35937;&#26412;&#36523;&#30340;&#31354;&#38388;&#26469;&#23384;&#20648;&#30701;&#23383;&#31526;&#20018;&#65292;vc++ <code class="foldable">@</code></dt>
<dd><p>&#36825;&#20010;&#35774;&#35745;&#23601;&#27604;&#36739;&#22855;&#33897;&#20102;&#12290;</p>
</dd>
</dl></li>
</ul>
<p>C++03/98 &#26631;&#20934;&#27809;&#26377;&#35268;&#23450; string &#20013;&#30340;&#23383;&#31526;&#26159;&#36830;&#32493;&#23384;&#20648;&#30340;&#65292;&#20294;&#26159;&#12298;Generic Programming and the STL&#12299; &#30340; &#20316; &#32773; Matthew Austern &#25351; &#20986; 78 : &#29616;&#22312;&#25152;&#26377;&#30340; std::string &#23454;&#29616;&#37117;&#26159;&#36830;&#32493;&#23384;&#20648;&#30340;&#65292;&#22240;&#27492;&#24314;&#35758;&#22312;&#26032;&#26631;&#20934;&#20013;&#26126;&#30830;&#35268;&#23450;&#19979;&#26469;&#12290;</p>
</dd>
<dt>14&#65289;&#29992; STL algorithm &#31186;&#26432;&#20960;&#36947;&#31639;&#27861;&#38754;&#35797;&#39064; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#29983;&#25104; N &#20010;&#19981;&#21516;&#20803;&#32032;&#20840;&#25490;&#21015; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="dt">int</span> main()
{
  <span class="co">// &#36825;&#37324;&#30340;&#39034;&#24207;&#39035;&#26159;&#23383;&#20856;&#39034;&#24207;</span>
  <span class="dt">int</span> elements[] = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span> };
  <span class="dt">const</span> size_t N = <span class="kw">sizeof</span>(elements)/<span class="kw">sizeof</span>(elements);
  std::vector&lt;<span class="dt">int</span>&gt; vec(elements, elements + N);

  <span class="dt">int</span> count = <span class="dv">0</span>;
  <span class="kw">do</span>
  {
    std::cout &lt;&lt; ++count &lt;&lt; <span class="st">&quot;: &quot;</span>;
    std::copy(vec.begin(), vec.end(),
              std::ostream_iterator&lt;<span class="dt">int</span>&gt;(std::cout, <span class="st">&quot;, &quot;</span>));
    std::cout &lt;&lt; std::endl;
  } <span class="kw">while</span> (next_permutation(vec.begin(), vec.end())); <span class="co">// &#36825;&#20010; permutation &#36824;&#20250;&#32467;&#26463;&#8230;&#8230;orz</span>
}</code></pre></div>
<p>output: (4! = 24)</p>
<pre><code>1: 1, 2, 3, 4,
2: 1, 2, 4, 3,
3: 1, 3, 2, 4,
4: 1, 3, 4, 2,
5: 1, 4, 2, 3,
6: 1, 4, 3, 2,
7: 2, 1, 3, 4,
8: 2, 1, 4, 3,
9: 2, 3, 1, 4,
10: 2, 3, 4, 1,
11: 2, 4, 1, 3,
12: 2, 4, 3, 1,
13: 3, 1, 2, 4,
14: 3, 1, 4, 2,
15: 3, 2, 1, 4,
16: 3, 2, 4, 1,
17: 3, 4, 1, 2,
18: 3, 4, 2, 1,
19: 4, 1, 2, 3,
20: 4, 1, 3, 2,
21: 4, 2, 1, 3,
22: 4, 2, 3, 1,
23: 4, 3, 1, 2,
24: 4, 3, 2, 1,</code></pre>
</dd>
<dt>&#29983;&#25104;&#20174; N &#20010;&#20803;&#32032;&#20013;&#21462;&#20986; M &#20010;&#30340;&#25152;&#26377;&#32452;&#21512; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;assert.h&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="dt">int</span> main()
{
  <span class="dt">int</span> values[] = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span> };
  <span class="co">// 1, 1, 1 &#36825;&#20010;&#25490;&#21015;&#21069;&#24471;&#29366;&#24577;&#26159;&#20160;&#20040;&#65311;&#36825;&#20160;&#20040;&#21407;&#29702;&#65311;</span>
  <span class="dt">int</span> elements[] = { <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> };
  <span class="dt">const</span> size_t N = <span class="kw">sizeof</span>(elements)/<span class="kw">sizeof</span>(elements);
  assert(N == <span class="kw">sizeof</span>(values)/<span class="kw">sizeof</span>(values));
  std::vector&lt;<span class="dt">int</span>&gt; selectors(elements, elements + N);

  <span class="dt">int</span> count = <span class="dv">0</span>;
  <span class="kw">do</span>
  {
    std::cout &lt;&lt; ++count &lt;&lt; <span class="st">&quot;: &quot;</span>;
    <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; selectors.size(); ++i)
    {
      <span class="kw">if</span> (selectors[i])
      {
        std::cout &lt;&lt; values[i] &lt;&lt; <span class="st">&quot;, &quot;</span>;
      }
    }
    std::cout &lt;&lt; std::endl;
  } <span class="kw">while</span> (prev_permutation(selectors.begin(), selectors.end()));
}</code></pre></div>
<p>output: (7C3 = 7<em>6</em>5/3<em>2</em>1 = 35)</p>
<pre><code>1: 1, 2, 3,
2: 1, 2, 4,
3: 1, 2, 5,
4: 1, 2, 6,
5: 1, 2, 7,
6: 1, 3, 4,
7: 1, 3, 5,
8: 1, 3, 6,
9: 1, 3, 7,
10: 1, 4, 5,
11: 1, 4, 6,
12: 1, 4, 7,
13: 1, 5, 6,
14: 1, 5, 7,
15: 1, 6, 7,
16: 2, 3, 4,
17: 2, 3, 5,
18: 2, 3, 6,
19: 2, 3, 7,
20: 2, 4, 5,
21: 2, 4, 6,
22: 2, 4, 7,
23: 2, 5, 6,
24: 2, 5, 7,
25: 2, 6, 7,
26: 3, 4, 5,
27: 3, 4, 6,
28: 3, 4, 7,
29: 3, 5, 6,
30: 3, 5, 7,
31: 3, 6, 7,
32: 4, 5, 6,
33: 4, 5, 7,
34: 4, 6, 7,
35: 5, 6, 7,</code></pre>
</dd>
<dt>&#29992; <code>{make,push,pop}_heap()</code> &#23454;&#29616;&#22810;&#36335;&#24402;&#24182; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#12304;&#19981;&#26126;&#35273;&#21385;&#65281;&#65281;&#12305;</p>
<p>&#29992;&#19968;&#21488; 4G &#20869;&#23384;&#30340;&#26426;&#22120;&#23545;&#30913;&#30424;&#19978;&#30340;&#21333;&#20010; 100G &#25991;&#20214;&#25490;&#24207;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">typedef</span> <span class="dt">int</span> Record;
<span class="kw">typedef</span> std::vector&lt;Record&gt; File;

<span class="kw">struct</span> Input
{
  Record value;
  size_t index;
  <span class="dt">const</span> File* file;

  <span class="kw">explicit</span> Input(<span class="dt">const</span> File* f)
    : value(<span class="dv">-1</span>),
      index(<span class="dv">0</span>),
      file(f)
  { }

  <span class="dt">bool</span> next()
  {
    <span class="kw">if</span> (index &lt; file-&gt;size())
    { value = (*file)[index];
      ++index;
      <span class="kw">return</span> <span class="kw">true</span>;
    } <span class="kw">else</span> {
      <span class="kw">return</span> <span class="kw">false</span>;
    }
  }

  <span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="dt">const</span> Input&amp; rhs) <span class="dt">const</span>
  {
    <span class="co">// make_heap to build min-heap, for merging</span>
    <span class="kw">return</span> value &gt; rhs.value;
  }
};

File mergeN(<span class="dt">const</span> std::vector&lt;File&gt;&amp; files)
{
  File output;
  std::vector&lt;Input&gt; inputs;

  <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; files.size(); ++i) {
    Input input(&amp;files[i]);
    <span class="kw">if</span> (input.next()) {
      inputs.push_back(input);
    }
  }

  std::make_heap(inputs.begin(), inputs.end());
  <span class="kw">while</span> (!inputs.empty()) {
    std::pop_heap(inputs.begin(), inputs.end());
    output.push_back(inputs.back().value);

    <span class="kw">if</span> (inputs.back().next()) {
      std::push_heap(inputs.begin(), inputs.end());
    } <span class="kw">else</span> {
      inputs.pop_back();
    }
  }

  <span class="kw">return</span> output;
}

<span class="dt">int</span> main()
{
  <span class="dt">const</span> <span class="dt">int</span> kFiles = <span class="dv">32</span>;
  std::vector&lt;File&gt; files(kFiles);
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; kFiles; ++i) {
    File file(rand() % <span class="dv">1000</span>);
    std::generate(file.begin(), file.end(), &amp;rand);
    std::sort(file.begin(), file.end());
    files[i].swap(file);
  }

  File output = mergeN(files);

  std::copy(output.begin(), output.end(),
            std::ostream_iterator&lt;Record&gt;(std::cout, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>));
}</code></pre></div>
<p>&#31867;&#20284;&#30340;&#39064;&#30446;: &#26377; a&#12289;b &#20004;&#20010;&#25991;&#20214;&#65292;&#22823;&#23567;&#21508;&#26159; 100G &#24038;&#21491;&#65292;&#27599;&#34892;&#38271;&#24230;&#19981;&#36229;&#36807; 1k&#65292;&#36825;&#20004;&#20010;&#25991;&#20214;&#26377;&#23569;&#37327; (&#20960;&#30334;&#20010;) &#37325;&#22797;&#30340;&#34892;&#65292;&#35201;&#27714;&#29992;&#19968;&#21488; 4G &#20869;&#23384;&#30340;&#26426;&#22120;&#25214;&#20986;&#36825;&#20123;&#37325;&#22797;&#34892;&#12290;&#35299;&#36825;&#36947;&#39064;&#30446;&#26377;&#20004;&#20010;&#26041;&#21521;&#65292;&#19968;&#26159; hash&#65292;&#25226; a&#12289;b &#20004;&#20010;&#25991;&#20214;&#25353;&#34892;&#30340; hash &#21462;&#27169;&#20998;&#25104;&#20960;&#30334;&#20010;&#23567;&#25991;&#20214;&#65292;&#27599;&#20010;&#23567;&#25991;&#20214;&#37117;&#22312; 1G &#20197;&#20869;, &#28982;&#21518;&#23545; a1&#12289;b1 &#27714;&#20132;&#38598; c1&#65292;&#23545; a2&#12289;b2 &#27714;&#20132;&#38598; c2&#65292;&#36825;&#26679;&#23601;&#33021;&#22312;&#20869;&#23384;&#37324;&#35299;&#20915;&#20102;&#12290;</p>
<p>&#31532;&#20108;&#20010;&#24605;&#36335;&#26159;&#22806;&#37096;&#25490;&#24207;&#65292;&#20294;&#26159;&#36319;&#21069;&#38754;&#23436;&#25972;&#30340;&#22806;&#37096;&#25490;&#24207;&#19981;&#21516;&#65292;&#25105;&#20204;&#24182;&#19981;&#38656;&#35201;&#24471;&#21040; a&#8217;&#12289;b&#8217; &#20004;&#20010;&#24050;&#25490;&#24207;&#30340;&#25991;&#20214;&#20877;&#27714;&#20132;&#38598;&#65292;&#21482;&#38656;&#35201;&#25226; a &#20998;&#22359;&#25490;&#24207;&#25104; 100 &#20010;&#23567;&#25991;&#20214;&#65292;&#20877;&#25226; b &#20998;&#22359;&#25490;&#24207;&#25104; 100 &#20010;&#23567;&#25991;&#20214;&#65292;&#21097;&#19979;&#30340;&#24037;&#20316;&#23601;&#26159;&#19968;&#36793;&#35835;&#36825;&#20123;&#23567;&#25991;&#20214;&#65292;&#19968;&#36793;&#22312;&#20869;&#23384;&#20013;&#21516;&#26102;&#24402;&#24182;&#20986; a&#8217; &#21644; b&#8217;&#65292;&#19968;&#36793;&#27714;&#20986;&#20132;&#38598;&#12290;&#20869;&#23384;&#20013;&#30340;&#20004;&#20010;&#22810;&#36335;&#24402;&#24182;&#38656;&#35201;&#20004;&#20010; heap&#65292;&#20998;&#21035;&#23545;&#24212; a &#21644; b &#30340;&#23567;&#25991;&#20214; s&#12290;</p>
</dd>
<dt>&#29992; unique() &#21435;&#38500;&#36830;&#32493;&#37325;&#22797;&#31354;&#30333; <code class="fold">@</code></dt>
<dd><p>Prefer algorithm calls to hand-written loops.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> AreBothSpaces
{
  <span class="dt">bool</span> <span class="kw">operator</span>()(<span class="dt">char</span> x, <span class="dt">char</span> y) <span class="dt">const</span>
  {
    <span class="kw">return</span> x == <span class="st">&#39; &#39;</span> &amp;&amp; y == <span class="st">&#39; &#39;</span>;
    <span class="co">// std::isspace(x) &amp;&amp; std::isspace(y) &amp;&amp; x == y;</span>
  }
};

<span class="dt">void</span> removeContinuousSpaces(std::string&amp; str)
{
  std::string::iterator last
    = std::unique(str.begin(), str.end(), AreBothSpaces());
  str.erase(last, str.end());
}</code></pre></div>
</dd>
<dt>&#29992; partition() &#23454;&#29616;&#8220;&#35843;&#25972;&#25968;&#32452;&#39034;&#24207;&#20351;&#24471;&#22855;&#25968;&#20301;&#20110;&#20598;&#25968;&#21069;&#38754;&#8221; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>

<span class="dt">bool</span> isOdd(<span class="dt">int</span> x)
{
  <span class="kw">return</span> x % <span class="dv">2</span> != <span class="dv">0</span>;  <span class="co">// x % 2 == 1 is WRONG</span>
}

<span class="dt">void</span> moveOddsBeforeEvens()
{
  <span class="dt">int</span> oddeven[] = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span> };
  std::partition(oddeven, oddeven<span class="dv">+6</span>, &amp;isOdd);
  std::copy(oddeven, oddeven<span class="dv">+6</span>, std::ostream_iterator&lt;<span class="dt">int</span>&gt;(std::cout, <span class="st">&quot;, &quot;</span>));
  std::cout &lt;&lt; std::endl;
}

<span class="dt">int</span> main()
{
  moveOddsBeforeEvens();

  <span class="dt">int</span> oddeven[] = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span> };
  std::partition(oddeven, oddeven<span class="dv">+6</span>, &amp;isOdd);
  std::copy(oddeven, oddeven<span class="dv">+6</span>, std::ostream_iterator&lt;<span class="dt">int</span>&gt;(std::cout, <span class="st">&quot;, &quot;</span>));
  std::cout &lt;&lt; std::endl;
}</code></pre></div>
<p>&#22797;&#26434;&#24230;&#26159; O(N) &#26102;&#38388; O(1) &#31354;&#38388;&#12290;</p>
<p>&#22914;&#26524;&#35201;&#39034;&#24207;&#20445;&#25345;&#19981;&#21464;&#65292;&#21487;&#20197;&#29992; <code>stable_partition()</code>&#65292;&#22797;&#26434;&#24230;&#26159; O(N) &#26102;&#38388;&#21644; O(N) &#31354;&#38388;&#12290;</p>
</dd>
<dt>&#29992; lower_bound() &#26597;&#25214; IP &#22320;&#22336;&#25152;&#23646;&#30340;&#22478;&#24066; <code class="fold">@</code></dt>
<dd><blockquote>
<p>&#24050;&#30693; N &#20010; IP &#22320;&#22336;&#21306;&#38388;&#21644;&#23427;&#20204;&#23545;&#24212;&#30340;&#22478;&#24066;&#21517;&#31216;&#65292;&#20889;&#19968;&#20010;&#31243;&#24207;&#65292;&#33021;&#20174; IP &#22320;&#22336;&#25214;&#21040;&#23427;&#25152;&#22312;&#30340;&#22478;&#24066;&#12290;&#27880;&#24847;&#36825;&#20123; IP &#22320;&#22336;&#21306;&#38388;&#20114;&#19981;&#37325;&#21472;&#12290;</p>
</blockquote>
<p>&#36825;&#36947;&#39064;&#30446;&#30340; na&#239;ve &#35299;&#27861;&#26159; O(N)&#65292;&#20511;&#21161; std::lower_bound() &#21487;&#20197;&#36731;&#26131;&#20570;&#21040; O(logN) &#26597;&#25214;&#65292;&#20195;&#20215;&#26159;&#20107;&#20808;&#20570;&#19968;&#36941; O(N logN) &#30340;&#25490;&#24207;&#65292;&#22914;&#26524;&#21306;&#38388;&#30456;&#23545;&#22266;&#23450;&#32780;&#26597;&#25214;&#24456;&#39057;&#32321;&#65292;&#36825;&#20040;&#20570;&#26159;&#20540;&#24471;&#30340;&#12290;</p>
<p>TODO.</p>
</dd>
<dt>&#23567;&#32467; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#21478;&#22806;&#65292;&#38754;&#35797;&#39064;&#30340;&#30446;&#30340;&#21487;&#33021;&#23601;&#26159;&#35753;&#20320;&#21160;&#25163;&#23454;&#29616;&#19968;&#20123; STL &#31639;&#27861;&#65292;&#20363;&#22914;&#27714;&#20004;&#20010;&#26377;&#24207;&#38598;&#21512;&#30340;&#20132;&#38598; (set_intersection)&#12289;&#27927;&#29260; (random_shuffle) &#31561;&#31561;</p>
<p>TODO!!!</p>
<p>&#25105;&#20010;&#20154;&#25226; STL algorithm &#20998;&#20026;&#19977;&#31867;&#65292;&#38754;&#35797;&#26102;&#35201;&#27714;&#25163;&#20889;&#30340;&#24448;&#24448;&#26159;&#31532;&#20108;&#31867;&#31639;&#27861;&#12290;</p>
<ul>
<li>&#23481;&#26131;&#65292;&#21363;&#38381;&#30528;&#30524;&#30555;&#19968;&#24819;&#23601;&#30693;&#36947;&#26159;&#22914;&#20309;&#23454;&#29616;&#30340;&#65292;&#33258;&#24049;&#25163;&#20889;&#19968;&#36941;&#30340;&#38590;&#24230;&#36319; <code>strlen()</code> &#21644; <code>strcpy()</code> &#24046;&#19981;&#22810;&#12290;&#36825;&#31867;&#31639;&#27861;&#22522;&#26412;&#19978;&#23601;&#26159;&#36941;&#21382;&#19968;&#36941;&#36755;&#20837;&#21306;&#38388;&#65292;&#23545;&#27599;&#20010;&#20803;&#32032;&#20570;&#20123;&#21028;&#26029;&#25110;&#25805;&#20316;&#65292;&#19968;&#20010; for &#24490;&#29615;&#23601;&#35299;&#20915;&#25112;&#26007;&#12290;&#19968;&#21322;&#24038;&#21491;&#30340; STL algorithm &#23646;&#20110;&#27492;&#31867;&#65292;&#20363;&#22914; <code>for_each()</code>&#12289;<code>transform()</code>&#12289; <code>accumulate()</code> &#31561;&#31561;&#12290;</li>
<li>&#36739;&#38590;&#65292;&#30693;&#36947;&#24605;&#36335;&#65292;&#20294;&#26159;&#35201;&#20889;&#20986;&#27491;&#30830;&#30340;&#23454;&#29616;&#35201;&#32771;&#34385;&#28165;&#26970;&#21508;&#31181;<strong>&#36793;&#30028;&#26465;&#20214;</strong>&#12290;&#20363;&#22914; merge()&#12289;unique()&#12289;remove()&#12289;random_shuffle()&#12289; partition()&#12289;lower_bound() &#31561;&#31561;&#65292;&#19977;&#25104;&#24038;&#21491;&#30340; STL algorithm &#23646;&#20110;&#27492;&#31867;&#12290;</li>
<li>&#38590;&#65292;&#35201;&#22312;&#19968;&#20010;&#23567;&#26102;&#20869;&#20889;&#20986;&#27491;&#30830;&#30340;&#20581;&#22766;&#30340;&#23454;&#29616;&#22522;&#26412;&#19981;&#29616;&#23454;&#65292;&#20363;&#22914; sort()&#12289; nth_element()&#12289;next_permutation()&#12289;inplace_merge() &#31561;&#31561;&#65292;&#32422;&#26377;&#20004;&#25104; STL algorithm &#23646;&#20110;&#27492;&#31867;&#12290;</li>
</ul>
</dd>
</dl>
</dd>
<dt>15&#65289;C++ &#32534;&#35793;&#38142;&#25509;&#27169;&#22411;&#31934;&#35201; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><blockquote>
<p><strong>C++ &#35821;&#35328;&#30340;&#19977;&#22823;&#32422;&#26463;&#26159;:&#19982; C &#20860;&#23481;&#12289;&#38646;&#24320;&#38144; (zero overhead) &#21407;&#21017;&#12289;&#20540;&#35821;&#20041;&#12290;</strong></p>
</blockquote>
<p>&#19982; C &#20860;&#23481;&#20070;&#35828;&#30340;&#19981;&#26159;&#35821;&#27861;&#65292;&#32780;&#26159;&#21644;&#32534;&#35793;&#31995;&#32479;&#24211;&#30340; C &#35821;&#35328;&#32534;&#35793;&#22120;&#20445;&#25345;&#19968;&#33268;&#12290;</p>
<dl>
<dt>&#26597;&#30475;&#23439;&#23637;&#24320;&#65306;<code>gcc -E code.cpp</code> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cat</span> bind.cpp
<span class="co">#define BIND(a, b) a##b</span>
<span class="kw">BIND</span>(foo, bar)

$ <span class="kw">gcc</span> -E tmp.cpp
<span class="co"># 1 &quot;bind.cpp&quot;</span>
<span class="co"># 1 &quot;&lt;built-in&gt;&quot;</span>
<span class="co"># 1 &quot;&lt;command-line&gt;&quot;</span>
<span class="co"># 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4</span>
<span class="co"># 1 &quot;&lt;command-line&gt;&quot; 2</span>
<span class="co"># 1 &quot;bind.cpp&quot;</span>

<span class="kw">foobar</span></code></pre></div>
</dd>
</dl>
<p>&#20540;&#24471;&#19968;&#25552;&#30340;&#26159;&#65292;&#20026;&#20102;&#20860;&#23481; C &#35821;&#35328;,C++ &#20184;&#20986;&#20102;&#24456;&#22823;&#30340;&#20195;&#20215;&#12290;&#20363;&#22914;&#35201;<strong>&#20860;&#23481; C &#35821;&#35328;&#30340;&#38544;&#24335;&#31867;&#22411;&#36716;&#25442;&#35268;&#21017; (&#20363;&#22914;&#25972;&#25968;&#31867;&#22411;&#25552;&#21319;)</strong>&#65292;&#22312;&#35753; C++ &#30340;&#20989;&#25968;&#37325;&#36733;&#20915;&#35758; (overload resolution) &#35268;&#21017;&#26080;&#27604;&#22797;&#26434;&#12290;&#21478;&#22806; class &#23450;&#20041;&#24335;&#21518;&#38754;&#37027;&#20010;&#20998;&#21495;&#20063;&#19981;&#26195;&#24471;&#35851;&#26432;&#20102;&#22810;&#23569;&#21021;&#23398;&#32773;&#30340;&#26102;&#38388;&#12290;Bjarne Stroustrup &#33258;&#24049;&#20063;&#35828;&#8220;<strong>&#25105;&#21448;&#19981;&#26159;&#19981;&#25026;&#22914;&#20309;&#35774;&#35745;&#20986;&#27604; C++ &#26356;&#28418;&#20142;&#30340;&#35821;&#35328;&#12290;</strong>&#8221;(&#30001;&#20110; C &#35821;&#35328;&#27809;&#20989;&#25968;&#37325;&#36733;&#65292;&#20063;&#23601;&#19981;&#23384;&#22312;&#37325;&#36733;&#20915;&#35758;&#65292;&#25152;&#20197;&#38544;&#24335;&#31867;&#22411;&#36716;&#25442;&#30340;&#21361;&#23475;&#27809;&#26377;&#20307;&#29616;&#22312;&#36825;&#19968;&#26041;&#38754;&#12290;)</p>
<p><strong>C++ &#20063;&#32487;&#25215;&#20102;&#21333;&#36941;&#32534;&#35793;&#12290;</strong>&#22312;&#21333;&#36941;&#32534;&#35793;&#26102;&#65292;&#32534;&#35793;&#22120;&#21482;&#33021;&#26681;&#25454;&#30446;&#21069;&#30475;&#21040;&#30340;&#20195;&#30721;&#20570;&#20986;&#20915;&#31574;&#65292;&#35835;&#21040;&#21518;&#38754;&#30340;&#20195;&#30721;&#20063;&#19981;&#20250;&#24433;&#21709;&#21069;&#38754;&#20570;&#20986;&#30340;&#20915;&#23450;&#12290;&#36825;&#29305;&#21035;&#24433;&#21709;&#20102;&#21517;&#23383;&#26597;&#25214; (name lookup) &#21644;&#20989;&#25968;&#37325;&#36733;&#20915;&#35758;&#12290;C++ &#32534;&#35793;&#22120;&#24517;&#39035;&#22312;&#20869;&#23384;&#20013;&#20445;&#23384;&#20989;&#25968;&#32423;&#30340;&#35821;&#27861;&#26641;&#65292;&#25165;&#33021;&#27491;&#30830;&#23454;&#26045;&#36820;&#22238;&#20540;&#20248;&#21270; (RVO) 134 &#65292;&#21542;&#21017;&#36935;&#21040; return &#35821;&#21477;&#30340;&#26102;&#20505;&#32534;&#35793;&#22120;&#26080;&#27861;&#21028;&#26029;&#34987;&#36820;&#22238;&#30340;&#36825;&#20010;&#23545;&#35937;&#26159;&#19981;&#26159;&#37027;&#20010;&#21487;&#20197;&#34987;&#20248;&#21270;&#30340; named object 135&#12290;&#20854;&#23454;&#30001;&#20110; C++ &#26032;&#22686;&#20102;&#19981;&#23569;&#35821;&#35328;&#29305;&#24615;,C++ &#32534;&#35793;&#22120;&#24182;&#19981;&#33021;&#30495;&#27491;&#20570;&#21040;&#20687; C &#37027;&#26679;&#36807;&#30524;&#21363;&#24536;&#30340;&#21333;&#36941;&#32534;&#35793;&#12290;&#20294;&#26159; C++ &#24517;&#39035;&#20860;&#23481; C &#30340;&#35821;&#24847;&#65292;&#22240;&#27492;&#32534;&#35793;&#22120;&#19981;&#24471;&#19981;&#35013;&#24471;&#22909;&#20687;&#26159;&#21333;&#36941;&#32534;&#35793; (&#20934;&#30830;&#35828;&#26159;&#21333;&#36941; parse) &#19968;&#26679;&#65292;&#21738;&#24597;&#23427;&#20869;&#37096;&#26159; multiple pass &#30340; 136 &#12290;</p>
<p>&#36825;&#26159; C++ &#30340;&#19968;&#31181;&#20856;&#22411;&#32570;&#38519;&#65292;&#21363;&#19968;&#26679;&#19996;&#35199;&#21306;&#20998;&#22768;&#26126;&#21644;&#23450;&#20041;&#65292;&#20195;&#30721;&#25918;&#21040;&#19981;&#21516;&#30340;&#25991;&#20214;&#20013;&#65292;&#36825;&#23601;&#26377;&#20986;&#29616;&#19981;&#19968;&#33268;&#30340;&#21487;&#33021;&#24615;&#12290;</p>
<p>&#23545;&#20110; class Foo&#65292;&#20197;&#19979;&#20960;&#31181;&#20351;&#29992;&#19981;&#38656;&#35201;&#30475;&#35265;&#20854;&#23436;&#25972;&#23450;&#20041;:</p>
<ul>
<li>&#23450;&#20041;&#25110;&#22768;&#26126; Foo* &#21644; Foo&amp;&#65292;&#21253;&#25324;&#29992;&#20110;&#20989;&#25968;&#21442;&#25968;&#12289;&#36820;&#22238;&#31867;&#22411;&#12289;&#23616;&#37096;&#21464;&#37327;&#12289;&#31867;&#25104;&#21592;&#21464;&#37327;&#31561;&#31561;&#12290;&#36825;&#26159;&#22240;&#20026; C++ &#30340;&#20869;&#23384;&#27169;&#22411;&#26159; flat &#30340;,Foo &#30340;&#23450;&#20041;&#26080;&#27861;&#25913;&#21464; Foo &#30340;&#25351;&#38024;&#25110;&#24341;&#29992;&#30340;&#21547;&#20041;&#12290;</li>
<li>&#22768;&#26126;&#19968;&#20010;&#20197; Foo &#20026;&#21442;&#25968;&#25110;&#36820;&#22238;&#31867;&#22411;&#30340;&#20989;&#25968;&#65292;&#22914; Foo bar() &#25110; void bar(Foo f)&#65292;&#20294;&#26159;&#65292;&#22914;&#26524;&#20195;&#30721;&#37324;&#35843;&#29992;&#36825;&#20010;&#20989;&#25968;&#23601;&#38656;&#35201;&#30693;&#36947; Foo &#30340;&#23450;&#20041;&#65292;&#22240;&#20026;&#32534;&#35793;&#22120;&#35201;&#20351;&#29992; Foo &#30340;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;&#21644;&#26512;&#26500;&#20989;&#25968;&#65292;&#22240;&#27492;&#33267;&#23569;&#35201;&#30475;&#21040;&#23427;&#20204;&#30340;&#22768;&#26126; (&#34429;&#28982;&#26500;&#36896;&#20989;&#25968;&#27809;&#26377;&#21442;&#25968;&#65292;&#20294;&#26159;&#26377;&#21487;&#33021;&#20301;&#20110; private &#21306;)&#12290;</li>
</ul>
<p>muduo &#20195;&#30721;&#20013;&#22823;&#37327;&#20351;&#29992;&#21069;&#21521;&#22768;&#26126;&#26469;&#20943;&#23569; include&#65292;&#24182;&#19988;&#36991;&#20813;&#25226;&#20869;&#37096; class &#30340;&#23450;&#20041;&#26292;&#38706;&#32473;&#29992;&#25143;&#20195;&#30721;&#12290;</p>
<p>&#22914;&#20309;&#21028;&#26029;&#19968;&#20010; C++ &#21487;&#25191;&#34892;&#25991;&#20214;&#26159; debug build &#36824;&#26159; release build? &#25442;&#35328;&#20043;&#65292;&#22914;&#20309;&#21028;&#26029;&#19968;&#20010;&#21487;&#25191;&#34892;&#25991;&#20214;&#26159; -O0 &#32534;&#35793;&#36824;&#26159; -O2 &#32534;&#35793;? &#25105;&#36890;&#24120;&#30340;&#20570;&#27861;&#26159;&#30475; class template &#30340;&#30701;&#25104;&#21592;&#20989;&#25968;&#26377;&#27809;&#26377;&#34987; inline &#23637;&#24320;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cat</span> vec.cc
<span class="co">#include &lt;vector&gt;</span>
<span class="co">#include &lt;stdio.h&gt;</span>
<span class="kw">int</span> main()
<span class="kw">{</span>
    <span class="kw">std</span>::vector<span class="kw">&lt;</span>int<span class="kw">&gt;</span> vi<span class="kw">;</span>
    <span class="kw">printf</span>(&#8221;%zd\n&#8221;, vi.size());
<span class="kw">}</span>

$ <span class="kw">g++</span> -Wall vec.cc
<span class="co"># non-optimized build</span>

$ <span class="kw">nm</span> ./a.out <span class="kw">|grep</span> size<span class="kw">|c++filt</span>
<span class="kw">00000000004007ac</span> W std::vector<span class="kw">&lt;</span>int, std::allocator<span class="kw">&lt;</span>int<span class="kw">&gt;</span> <span class="kw">&gt;</span>::size() <span class="kw">const</span>
<span class="kw">//</span> vector<span class="kw">&lt;</span>int<span class="kw">&gt;</span>::size() &#27809;&#26377; <span class="kw">inline</span> &#23637;&#24320;,&#30446;&#26631;&#25991;&#20214;&#20013;&#20986;&#29616;&#20102;&#20989;&#25968; (&#24369;) &#23450;&#20041;&#12290;

$ <span class="kw">g++</span> -Wall -O2 vec.cc <span class="co"># optimized build</span>
$ <span class="kw">nm</span> ./a.out <span class="kw">|grep</span> size<span class="kw">|c++filt</span>
<span class="kw">//</span> &#27809;&#26377;&#36755;&#20986;,&#22240;&#20026; vector<span class="kw">&lt;</span>int<span class="kw">&gt;</span>::size() &#34987; <span class="kw">inline</span> &#23637;&#24320;&#20102;</code></pre></div>
<p>&#22312;&#29616;&#22312;&#30340; C++ &#23454;&#29616;&#20013;&#65292;&#34394;&#20989;&#25968;&#30340;&#21160;&#24577;&#35843;&#29992; (&#21160;&#24577;&#32465;&#23450;&#12289;&#36816;&#34892;&#26399;&#20915;&#35758;) &#26159;&#36879;&#36807;&#34394;&#20989;&#25968;&#34920; (vtable) &#36827;&#34892;&#30340;&#65292;&#27599;&#20010;&#22810;&#24577; class &#37117;&#24212;&#35813;&#26377;&#19968;&#20221; vtable&#12290;&#23450;&#20041;&#25110;&#32487;&#25215;&#20102;&#34394;&#20989;&#25968;&#30340;&#23545;&#35937;&#20013;&#20250;&#26377;&#19968;&#20010;&#38544;&#21547;&#25104;&#21592;: &#25351;&#21521; vtable &#30340;&#25351;&#38024;&#65292;&#21363; vptr&#12290;&#22312;&#26500;&#36896;&#21644;&#26512;&#26500;&#23545;&#35937;&#30340;&#26102;&#20505;&#65292;&#32534;&#35793;&#22120;&#29983;&#25104;&#30340;&#20195;&#30721;&#20250;&#20462;&#25913;&#36825;&#20010; vptr &#25104;&#21592;&#65292;&#36825;&#23601;&#35201;&#29992;&#21040; vtable &#30340;&#23450;&#20041; (&#20351;&#29992;&#20854;&#22320;&#22336;)&#12290;</p>
<p>&#24635;&#32467;: &#30001;&#20110; C++ &#30340;&#22836;&#25991;&#20214;&#19982;&#28304;&#25991;&#20214;&#20998;&#31163;&#65292;&#24182;&#19988;&#30446;&#26631;&#25991;&#20214;&#37324;&#27809;&#26377;&#36275;&#22815;&#30340;&#20803;&#25968;&#25454;&#20379;&#32534;&#35793;&#22120;&#20351;&#29992;&#65292;&#22240;&#27492;&#24517;&#39035;&#21516;&#26102;&#25552;&#20379;&#24211;&#25991;&#20214;&#21644;&#22836;&#25991;&#20214;&#12290;&#20063;&#23601;&#26159;&#35828;&#35201;&#24819;&#20351;&#29992;&#19968;&#20010;&#24050;&#32463;&#32534;&#35793;&#22909;&#30340; C/C++ &#24211; (&#26080;&#35770;&#26159;&#38745;&#24577;&#24211;&#36824;&#26159;&#21160;&#24577;&#24211;) &#65292;&#25105;&#20204;&#38656;&#35201;&#20004;&#26679;&#19996;&#35199;&#65292;&#19968;&#26159;&#22836;&#25991;&#20214; (.h)&#65292;&#20108;&#26159;&#24211;&#25991;&#20214; (.a &#25110;.so)&#65292;&#36825;&#23601;&#23384;&#22312;&#20102;&#20004;&#26679;&#19996;&#35199;&#19981;&#21305;&#37197;&#30340;&#21487;&#33021;&#12290;&#36825;&#26159;&#36896;&#23601; C++ &#31616;&#38475;&#33030;&#24369;&#30340;&#27169;&#22359;&#26426;&#21046;&#30340;&#26681;&#26412;&#21407;&#22240;&#12290;C++ &#24211;&#20043;&#38388;&#30340;&#20381;&#36182;&#31649;&#29702;&#36828;&#27604;&#20854;&#20182;&#29616;&#20195;&#35821;&#35328;&#22797;&#26434;&#65292;&#22312;&#32534;&#20889;&#31243;&#24207;&#24211;&#21644;&#24212;&#29992;&#31243;&#24207;&#26102;&#65292;&#35201;&#29087;&#24713;&#21508;&#31181;&#26426;&#21046;&#30340;&#20248;&#32570;&#28857;&#65292;&#37319;&#29992;&#24320;&#21457;&#21450;&#32500;&#25252;&#25104;&#26412;&#36739;&#20302;&#30340;&#26041;&#24335;&#26469;&#32452;&#32455;&#21644;&#21457;&#24067;&#24211;&#12290;</p>
</dd>
<dt>16&#65289;Zero overhead &#21407;&#21017; <code class="fold">@</code></dt>
<dd><ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/18015.html" class="uri">http://www.open-std.org/jtc1/sc22/wg21/docs/18015.html</a></li>
<li><a href="http://www.aristeia.com/c++-in-embedded.html" class="uri">http://www.aristeia.com/c++-in-embedded.html</a></li>
</ul>
</dd>
<dt>Points <code class="fold">@</code></dt>
<dd><ul>
<li>&#20026;&#20160;&#20040; C++ &#35201;&#24341;&#20837; static_cast &#20043;&#31867;&#30340;&#36716;&#22411;&#25805;&#20316;&#31526;&#65292;&#21407;&#22240;&#20043;&#19968;&#23601;&#26159;&#20687; <code>(int*) pBuffer</code> &#36825;&#26679;&#30340;&#34920;&#36798;&#24335;&#22522;&#26412;&#19978;&#27809;&#21150;&#27861;&#29992; grep &#21028;&#26029;&#20986;&#23427;&#26159;&#20010;&#24378;&#21046;&#31867;&#22411;&#36716;&#25442;&#65292;&#20889;&#19981;&#20986;&#19968;&#20010;&#21018;&#22909;&#21482;&#21305;&#37197;&#31867;&#22411;&#36716;&#25442;&#30340;&#27491;&#21017;&#34920;&#36798;&#24335;&#12290;(again&#65292;&#35821;&#27861;&#26159;&#19978;&#19979;&#25991;&#26080;&#20851;&#30340;&#65292;&#26080;&#27861;&#29992;&#27491;&#21017;&#25630;&#23450;&#12290;)</li>
<li><p>&#37027;&#20040;&#20026;&#20160;&#20040; C &#35821;&#35328;&#20174;&#35806;&#29983;&#21040;&#29616;&#22312;&#19968;&#30452;&#27809;&#26377;&#32416;&#27491;&#36825;&#20010;&#23567;&#23567;&#30340;&#32570;&#38519;? &#27604;&#26041;&#35828;&#25226; O_RDONLY&#65292;O_WRONLY&#65292;O_RDWR &#20998;&#21035;&#23450;&#20041;&#20026; 1&#65292;2&#65292;3&#65292;&#36825;&#26679; <code>O_RDONLY | O_WRONLY == O_RDWR</code>&#65292;<strong>&#31526;&#21512;&#30452;&#35273;</strong>&#12290;&#32780;&#19988;&#36825;&#19977;&#20010;&#20540;&#37117;&#26159;&#23439;&#23450;&#20041;&#65292;&#20063;&#19981;&#38656;&#35201;&#20462;&#25913;&#29616;&#26377;&#30340;&#28304;&#20195;&#30721;&#65292;&#21482;&#38656;&#35201;&#25913;&#25913;&#31995;&#32479;&#30340;&#22836;&#25991;&#20214;&#23601;&#34892;&#20102;&#12290;</p>
<p>&#12304;A: &#22240;&#20026;&#36825;&#20040;&#20570;&#20250;&#30772;&#22351;&#20108;&#36827;&#21046;&#20860;&#23481;&#24615;&#12290;&#12305;</p></li>
<li>C++ ABI &#30340;&#20027;&#35201;&#20869;&#23481;:
<ul>
<li>&#20989;&#25968;&#21442;&#25968;&#20256;&#36882;&#30340;&#26041;&#24335;,&#27604;&#22914; x86-64 &#29992;&#23492;&#23384;&#22120;&#26469;&#20256;&#20989;&#25968;&#30340;&#21069; 4 &#20010;&#25972;&#25968;&#21442;&#25968;</li>
<li>&#34394;&#20989;&#25968;&#30340;&#35843;&#29992;&#26041;&#24335;,&#36890;&#24120;&#26159; vptr/vtbl &#28982;&#21518;&#29992; <code>vtbl[offset]</code> &#26469;&#35843;&#29992;</li>
<li>struct &#21644; class &#30340;&#20869;&#23384;&#24067;&#23616;,&#36890;&#36807;&#20559;&#31227;&#37327;&#26469;&#35775;&#38382;&#25968;&#25454;&#25104;&#21592;</li>
<li>name mangling</li>
<li>RTTI &#21644;&#24322;&#24120;&#22788;&#29702;&#30340;&#23454;&#29616;(&#20197;&#19979;&#26412;&#25991;&#19981;&#32771;&#34385;&#24322;&#24120;&#22788;&#29702;)</li>
</ul></li>
</ul>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>Essential C++ Effective STL, Effective C++, More Effective C++, Exceptional C++, More Exceptional C++, Exceptional C++ Style, C++ &#24517;&#30693;&#24517;&#20250; <code class="fold">@</code></dt>
<dd><ul>
<li>Essential C++</li>
<li>Effective STl</li>
<li>Effective C++</li>
<li>More Effective C++</li>
<li>Exceptional C++</li>
<li>More Exceptional C++</li>
<li>Exceptional C++ Style</li>
<li>C++ &#24517;&#30693;&#24517;&#20250;</li>
</ul>
<p>TODO!!!!</p>
</dd>
</dl></li>
<li><dl>
<dt>CSAPP &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#37325;&#28857;&#25512;&#33616;&#31532; 3 &#31456;&#8220;&#31243;&#24207;&#30340;&#26426;&#22120;&#32423;&#34920;&#31034;&#8221;&#12289;&#31532; 5 &#31456;&#8220;&#20248;&#21270;&#31243;&#24207;&#24615;&#33021;&#8221;&#12289;&#31532; 6 &#31456;&#8220;&#23384;&#20648;&#22120;&#23618;&#27425;&#32467;&#26500;&#8221;&#12289;&#31532; 10 &#31456;&#8220;&#34394;&#25311;&#23384;&#20648;&#22120;&#8221;&#12290;&#35273;&#24471;&#36825;&#22235;&#31456;&#20035;&#26159;&#20840;&#20070;&#20043;&#31934;&#21326;&#65292;&#30475;&#24471;&#20154;&#27442;&#32610;&#19981;&#33021;&#12290;</p>
<dl>
<dt><a href="http://www.cnblogs.com/figure9/archive/2010/04/10/1708942.html">&#28145;&#20837;&#29702;&#35299;&#35745;&#31639;&#26426;&#31995;&#32479;&#65288;Computer Systems: A Programmer&#8217;s Perspective&#65289;&#38405;&#35835;&#20307;&#20250; - <em>Luc</em> - &#21338;&#23458;&#22253;</a> <code class="fold">@</code></dt>
<dd><p>NB&#23398;&#26657;&#65292;&#33258;&#28982;&#29992;NB&#25945;&#26448;&#65292;&#26356;&#20309;&#20917;&#26159;CS&#37324;&#38750;&#24120;&#37325;&#35201;&#30340;&#35745;&#31639;&#26426;&#23548;&#35770;&#65292;&#32780;CMU&#30340;&#35745;&#31639;&#26426;&#23548;&#35770;&#25945;&#26448;&#23601;&#26159;CMU&#35745;&#31639;&#26426;&#31995;&#20027;&#20219;&#30340;&#20316;&#21697;&#65306;CSAPP&#12290;</p>
<dl>
<dt>&#31243;&#24207;&#30340;&#26426;&#22120;&#32423;&#34920;&#31034;</dt>
<dd><p>&#36825;&#19968;&#31456;&#20598;&#33457;&#20102;&#19981;&#23569;&#26102;&#38388;&#38405;&#35835;&#65292;&#27605;&#31455;&#20598;&#23398;&#36807;&#27719;&#32534;&#65292;&#22522;&#30784;&#22522;&#26412;&#20026;0&#12290;&#19981;&#36807;&#36825;&#26412;&#20070;&#37324;&#20986;&#29616;&#30340;&#27719;&#32534;&#25351;&#20196;&#32477;&#22823;&#22810;&#25968;&#37117;&#30001;&#36816;&#31639;&#12289;&#21462;&#25968;&#23384;&#25968;&#12289;&#36339;&#36716;&#36825;&#19977;&#31181;&#25351;&#20196;&#25152;&#32452;&#25104;&#65292;&#25152;&#20197;&#22312;&#38405;&#35835;&#19978;&#19981;&#20250;&#23384;&#22312;&#20219;&#20309;&#38590;&#24230;&#12290;</p>
<p>&#36825; &#37096;&#20998;&#34701;&#21512;&#20102;&#31243;&#24207;&#21592;&#25152;&#38656;&#20102;&#35299;&#30340;&#32534;&#35793;&#21644;&#27719;&#32534;&#36825;&#20004;&#26679;&#35838;&#31243;&#20013;&#30340;&#22522;&#30784;&#30693;&#35782;&#65306;&#24819;&#30693;&#36947;for&#12289;do..while&#12289;while&#19977;&#31181;&#24490;&#29615;&#30340;&#23454;&#36136;&#24615;&#21306;&#21035;&#65311;&#24819;&#30693;&#36947;&#22810;&#37325;if&#21644; switch&#30340;&#26412;&#36136;&#21306;&#21035;&#65311;&#24819;&#30693;&#36947;&#25968;&#32452;&#30340;&#23384;&#20648;&#26041;&#24335;&#65311;&#24819;&#30693;&#36947;&#25968;&#32452;&#19979;&#26631;&#35835;&#21462;&#21644;&#25351;&#38024;&#35835;&#21462;&#30340;&#21306;&#21035;&#65311;&#24819;&#30693;&#36947;&#36882;&#24402;&#36807;&#31243;&#35843;&#29992;&#30340;&#32972;&#21518;&#23454;&#29616;&#26426;&#29702;&#65311;&#30475;&#30475;&#36825;&#19968;&#31456;&#65292;&#30456;&#20449;&#20320;&#20250;&#23545;C&#35821;&#35328; &#20035;&#33267;&#31243;&#24207;&#35774;&#35745;&#35821;&#35328;&#26377;&#26356;&#28145;&#30340;&#29702;&#35299;&#12290;</p>
</dd>
<dt>&#31243;&#24207;&#24615;&#33021;&#20248;&#21270;</dt>
<dd><p>&#36825;&#19968;&#31456;&#23545;&#31243;&#24207;&#21592;&#23588;&#20854;&#23454;&#29992;</p>
<p>&#21807;&#19968;&#30340;&#36951;&#25022;&#23601;&#26159;&#36825;&#31456;&#30340;&#31687;&#24133;&#26377;&#20123;&#30701;&#23567;&#65292;&#23545;&#31243;&#24207;&#21592;&#26368;&#20026;&#37325;&#35201;&#30340;&#26426;&#22120;&#26080;&#20851;&#30340;&#31243;&#24207;&#20248;&#21270;&#20171;&#32461;&#30340;&#20063;&#24182;&#19981;&#20805;&#20998;&#65292;&#19982;&#27492;&#30456;&#27604;&#65292;&#20598;&#24863;&#35273;programming pearls&#21644; practice of programming&#37324;&#38754;&#23545;&#24615;&#33021;&#20248;&#21270;&#30340;&#20171;&#32461;&#26356;&#32988;&#19968;&#31609;&#12290;</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://github.com/cirosantilli/cpp-cheat/tree/master/cpp" class="heart">cpp-cheat/cpp at master &#183; cirosantilli/cpp-cheat</a> <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>Standards <code class="fold">@</code></dt>
<dd><ul>
<li>C++98</li>
<li>C++03</li>
<li>TR1 (Technical report 1), 2005, &#8211;&gt; C++11</li>
<li>TR2, C++1Y</li>
<li>C++11 (previously known as C++0x)
<ul>
<li>lots of new features: standard passes from 800 to 1300 lines.</li>
<li>gcc: <code>-std=c++0x</code> -&gt; <code>-std=c++11</code></li>
</ul></li>
<li>C++14
<ul>
<li>Will come after C++11. Known as C++1Y as many have doubts it will come out in 2014.</li>
</ul></li>
</ul>
<table style="width:68%;">
<colgroup>
<col width="11%" />
<col width="38%" />
<col width="18%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Year</th>
<th align="left">C++ Standard</th>
<th>Informal name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1998</td>
<td align="left">ISO/IEC 14882:1998</td>
<td>C++98</td>
</tr>
<tr class="even">
<td align="left">2003</td>
<td align="left">ISO/IEC 14882:2003</td>
<td>C++03</td>
</tr>
<tr class="odd">
<td align="left">2011</td>
<td align="left">ISO/IEC 14882:2011</td>
<td>C++11</td>
</tr>
<tr class="even">
<td align="left">2014</td>
<td align="left">ISO/IEC 14882:2014</td>
<td>C++14</td>
</tr>
<tr class="odd">
<td align="left">2017</td>
<td align="left">to be determined</td>
<td>C++17</td>
</tr>
</tbody>
</table>
</dd>
</dl></li>
<li><dl>
<dt>Compile time magic <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>constexpr (C++11 only) <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/*</span>
<span class="co">    ERROR: the compiler ensures that the function return is constexpr,</span>
<span class="co">    so this does not compile.</span>
<span class="co">*/</span>
<span class="dt">int</span> <span class="kw">constexpr</span> constexpr_func_bad(){
    <span class="kw">return</span> std::time();
}
<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="kw">constexpr</span> <span class="dt">long</span> <span class="dt">long</span> ConstexprFactorial( <span class="dt">long</span> <span class="dt">long</span> n ) {
    <span class="kw">return</span> (n == <span class="dv">1LL</span>) ? <span class="dv">1LL</span> : n * ConstexprFactorial(n - <span class="dv">1</span>);
    <span class="co">/*</span>
<span class="co">     * error: body of constexpr function</span>
<span class="co">     *      &#8216;constexpr int ConstexprFactorial(int)&#8217;</span>
<span class="co">     * not a return-statement</span>
<span class="co">     *</span>
<span class="co">    **/</span>

    <span class="co">//          if( n == 1LL ) {</span>
    <span class="co">//              return 1LL;</span>
    <span class="co">//          } else {</span>
    <span class="co">//              return n * ConstexprFactorial(n - 1);</span>
    <span class="co">//          }</span>
}

<span class="dt">int</span> main()
{
    printf( <span class="st">&quot;factorial(23): </span><span class="ch">%lld</span><span class="st">.</span><span class="ch">\n</span><span class="st">&quot;</span>, ConstexprFactorial(<span class="dv">23</span>) );

    <span class="dt">int</span> n;
    <span class="kw">while</span>( <span class="dv">1</span> == scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n ) ) {
        printf( <span class="st">&quot;factorial(</span><span class="ch">%d</span><span class="st">): </span><span class="ch">%lld</span><span class="st">.</span><span class="ch">\n</span><span class="st">&quot;</span>, n, ConstexprFactorial(n) );
    }
}</code></pre></div>
<p>&#20026;&#20160;&#20040;&#19981;&#33021;&#20889;&#25104;&#24456;&#22810;&#34892;&#65288;&#26377;&#22810;&#20010; statements&#65288;<code>;</code> &#20998;&#38548;&#65289;&#65289;&#65311;&#36825;&#37324;&#26377;&#35299;&#37322;&#65306; <a href="http://stackoverflow.com/questions/3226211/why-is-it-ill-formed-to-have-multi-line-constexpr-functions">c++ - Why is it ill-formed to have multi-line constexpr functions? - Stack Overflow</a>&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// okay</span>
<span class="kw">constexpr</span> <span class="dt">int</span> i = <span class="dv">0</span>;

<span class="co">// okay</span>
<span class="kw">constexpr</span> <span class="dt">int</span> i = <span class="dv">1</span> + <span class="dv">1</span>;
<span class="kw">constexpr</span> <span class="dt">int</span> i2 = i;

<span class="co">// okay</span>
<span class="dt">const</span> <span class="dt">int</span> i = <span class="dv">0</span>;
<span class="kw">constexpr</span> <span class="dt">int</span> i2 = i;

<span class="co">// error: for non built-in operators, only constexpr functions can be used.</span>
<span class="kw">constexpr</span> <span class="dt">int</span> i = not_constexpr_func();

<span class="co">// okay</span>
<span class="kw">constexpr</span> <span class="dt">int</span> i = constexpr_func(<span class="dv">1</span>);

<span class="co">// error</span>
<span class="kw">constexpr</span> <span class="dt">int</span> i = constexpr_func(std::time(NULL));

<span class="co">// error: cannot have constexpr to complex types, TODO rationale</span>
<span class="kw">constexpr</span> std::string s = <span class="st">&quot;abc&quot;</span>;</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>static_assert (C++11 only) <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">static_assert</span>(<span class="dv">0</span> &lt; <span class="dv">1</span>, <span class="st">&quot;msg&quot;</span>);

<span class="co">// ERROR: static assertion failed</span>
<span class="co">//static_assert(0 &gt; 1, &quot;msg&quot;);</span>

std::srand(time(NULL));
<span class="co">// ERROR: needs to be a constexpr</span>
<span class="co">//static_assert(std::rand() &gt;= 0);</span>

<span class="kw">static_assert</span>(<span class="kw">sizeof</span>(<span class="dt">unsigned</span> <span class="dt">int</span>) * CHAR_BIT == <span class="dv">32</span>);
<span class="kw">static_assert</span>(<span class="dv">-5</span> / <span class="dv">2</span> == <span class="dv">-2</span>);</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>typeid <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;typeinfo&gt;</span>

<span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="dv">0</span>;
    <span class="dt">int</span> &amp;ri = i;
    std::cout &lt;&lt; <span class="st">&quot;typeid(int).name() = </span><span class="ch">\&quot;</span><span class="st">&quot;</span> &lt;&lt; <span class="kw">typeid</span>(<span class="dt">int</span>).name() &lt;&lt; <span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">&quot;</span> &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="st">&quot;typeid( i ).name() = </span><span class="ch">\&quot;</span><span class="st">&quot;</span> &lt;&lt; <span class="kw">typeid</span>( i ).name() &lt;&lt; <span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">&quot;</span> &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="st">&quot;typeid( ri).name() = </span><span class="ch">\&quot;</span><span class="st">&quot;</span> &lt;&lt; <span class="kw">typeid</span>( ri).name() &lt;&lt; <span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">&quot;</span> &lt;&lt; std::endl;
}</code></pre></div>
<p>output:</p>
<pre><code>typeid(int).name() = &quot;i&quot;
typeid( i ).name() = &quot;i&quot;
typeid( ri).name() = &quot;i&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#19981;&#33021;&#22797;&#21046;</span>
std::type_info t = <span class="kw">typeid</span>(<span class="dt">int</span>);         <span class="co">// &#20250;&#20986;&#38169;</span>
std::type_index t = <span class="kw">typeid</span>(<span class="dt">int</span>);        <span class="co">// &#36825;&#20010;&#21487;&#20197;</span>

<span class="co">// &#21487;&#20197;&#29992; == &#21644; != &#26469;&#27604;&#36739;</span>
<span class="dt">int</span> i, i1;
<span class="dt">int</span>&amp; ia = i;
<span class="kw">class</span> Class {};
Class c;
assert(<span class="kw">typeid</span>(i)  == <span class="kw">typeid</span>(<span class="dt">int</span>) );
assert(<span class="kw">typeid</span>(ia) == <span class="kw">typeid</span>(<span class="dt">int</span>&amp;));
assert(<span class="kw">typeid</span>(i)  == <span class="kw">typeid</span>(i1)  );
assert(<span class="kw">typeid</span>(i)  != <span class="kw">typeid</span>(c)   );

<span class="co">// &#33258;&#24049;&#25552;&#20379; &lt; &#27604;&#36739;</span>
<span class="kw">struct</span> compare {
    <span class="dt">bool</span> <span class="kw">operator</span> ()(<span class="dt">const</span> type_info* a, <span class="dt">const</span> type_info* b) <span class="dt">const</span> {
        <span class="kw">return</span> a-&gt;before(*b);
    }
};

std::map&lt;<span class="dt">const</span> type_info*, std::string, compare&gt; m;

<span class="dt">void</span> f() {
    m[&amp;<span class="kw">typeid</span>(<span class="dt">int</span>)] = <span class="st">&quot;Hello world&quot;</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>auto, decltype <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> i = <span class="dv">4</span>;
<span class="kw">auto</span> &amp;ri = i;
<span class="kw">for</span>( <span class="kw">auto</span> &amp;i : vec ) { ... }
<span class="kw">for</span>( <span class="dt">const</span> <span class="kw">auto</span> &amp;i : vec ) { ... }

<span class="dt">int</span> i = <span class="dv">1</span>;
std::vector&lt;<span class="kw">decltype</span>(i)&gt; v; <span class="co">// std::vector&lt;int&gt; v</span>

<span class="dt">float</span> f = <span class="fl">2.0</span>;
<span class="kw">decltype</span>(i + f) f2 = <span class="fl">1.5</span>;   <span class="co">// float f2</span>
assert(f2 == <span class="fl">1.5</span>);

cout &lt;&lt; <span class="dv">1</span> + <span class="fl">1.5</span> &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>; <span class="co">// &quot;2.5&quot;</span>

<span class="co">// Implies reference while auto does not.</span>
{
    <span class="dt">int</span> i = <span class="dv">0</span>;
    <span class="dt">int</span>&amp; ir = i;
    <span class="kw">decltype</span>(ir) ir2 = ir;
    ir2 = <span class="dv">1</span>;
    assert(i == <span class="dv">1</span>);
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>nullptr <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstddef&gt;</span>
<span class="co">// basically the same</span>
std::nullptr_t p;
p = NULL;
p = <span class="dv">0</span>;

<span class="co">// Unlike in NULL, the size of nullptr_t is fixed.</span>
{
    assert(<span class="kw">sizeof</span>(std::nullptr_t) == <span class="kw">sizeof</span>(<span class="dt">void</span>*));
}
<span class="co">// sizeof(NULL) &#31561;&#20110; sizeof(0)&#65292;&#20272;&#35745;&#21644; int &#30340;&#38271;&#24230;&#19968;&#26679;&#12290;</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>refs <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span>&amp; getIntConstRef(<span class="dt">int</span>&amp; i) {
    i++;
    <span class="kw">return</span> i;
}

<span class="kw">class</span> X {

<span class="kw">public</span>:
    <span class="co">///</span> Value cannot be changed.
    <span class="dt">const</span> <span class="dt">int</span>&amp; getPrivateConstRef() <span class="dt">const</span> {<span class="kw">return</span> <span class="kw">this</span>-&gt;iPrivate;}

    <span class="co">// ERROR: const method cannot return noncosnt pointer!</span>
    <span class="co">//int* getPrivateAddress() const {return &amp;this-&gt;iPrivate;}</span>

    <span class="co">// this works</span>
    <span class="dt">const</span> <span class="dt">int</span>* getPrivateAddressConst() <span class="dt">const</span> {<span class="kw">return</span> &amp;<span class="kw">this</span>-&gt;iPrivate;}

<span class="kw">private</span>:
    <span class="dt">int</span> iPrivate;
};

<span class="dt">void</span> byref(<span class="dt">int</span>&amp; i) {i++;}
<span class="dt">void</span> bypointer(<span class="dt">int</span> *i) {(*i)++;}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>


<span class="dt">void</span> assign( <span class="dt">const</span> <span class="dt">int</span> * &amp;ip, <span class="dt">const</span> <span class="dt">int</span> *<span class="dt">const</span> &amp;jp) {
    ip = jp<span class="dv">+1</span>;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> buf = { <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };

    <span class="co">// int *p1 = &amp;buf, *p2 = &amp;buf;    // &#20026;&#20160;&#20040;&#36825;&#20010;&#19981;&#21487;&#20197;&#65311;&#19981;&#21152; const &#23621;&#28982;&#25253;&#38169;&#65311;&#65281;</span>
    <span class="dt">const</span> <span class="dt">int</span> *p1 = &amp;buf, *p2 = &amp;buf;

    printf( <span class="st">&quot;before assign: </span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, *p1, *p2 );
    assign( p1, p2 );
    printf( <span class="st">&quot;after  assign: </span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, *p1, *p2 );
}
<span class="co">/*</span>
<span class="co">before assign: 1 2</span>
<span class="co">after  assign: 3 2</span>
<span class="co">*/</span></code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://github.com/cirosantilli/cpp-cheat/blob/master/cpp/reference.cpp">cpp-cheat/reference.cpp at master &#183; cirosantilli/cpp-cheat</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>rvalue ref <code class="fold">@</code></dt>
<dd><p><a href="https://github.com/cirosantilli/cpp-cheat/blob/master/cpp/rvalue_reference.cpp">cpp-cheat/rvalue_reference.cpp at master &#183; cirosantilli/cpp-cheat</a></p>
</dd>
</dl></li>
<li><dl>
<dt>functions <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#20989;&#25968;&#23450;&#20041;&#12289;&#37325;&#36733; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#39318;&#20808;&#65292;&#36820;&#22238;&#20540;&#19981;&#33021;&#29992;&#26469;&#21306;&#21035;&#20989;&#25968;&#65292;&#36825;&#28857;&#27809;&#26377;&#20877;&#24517;&#35201;&#35752;&#35770;</span>

<span class="co">// ERROR: no compound literals in C++</span>
<span class="dt">void</span> foo (<span class="dt">int</span> bar[] = (<span class="dt">int</span>){<span class="dv">0</span> ,<span class="dv">1</span>});

<span class="co">// &#23454;&#38469;&#19978;&#65292;&#19979;&#38754;&#19977;&#20010;&#19968;&#26679;&#19968;&#26679;&#30340;</span>
<span class="dt">void</span> funtion( <span class="dt">int</span> buf[] );
<span class="dt">void</span> funtion( <span class="dt">int</span> buf );
<span class="dt">void</span> funtion( <span class="dt">int</span> *buf );

<span class="co">// Okay</span>
std::string overload(<span class="dt">float</span> i) { <span class="kw">return</span> <span class="st">&quot;f&quot;</span>; }
std::string overload(<span class="dt">int</span> i, <span class="dt">int</span> j) { <span class="kw">return</span> <span class="st">&quot;ii&quot;</span>; }
std::string overload(<span class="dt">float</span> i, <span class="dt">float</span> j, <span class="dt">float</span> k = <span class="fl">0.f</span>) { <span class="kw">return</span> <span class="st">&quot;iff&quot;</span>; }

<span class="co">// &#36825;&#19977;&#20010;&#20914;&#31361;&#20102;</span>
<span class="dt">void</span> overload(<span class="dt">int</span> i) {}
<span class="dt">void</span> overload(<span class="dt">const</span> <span class="dt">int</span> i){}
<span class="dt">void</span> overload(<span class="dt">int</span> i, <span class="dt">int</span> j=<span class="dv">0</span>){cout &lt;&lt; <span class="st">&quot;int int=&quot;</span>;}

<span class="co">// &#20026;&#20160;&#20040;&#20182;&#20204;&#19981;&#20914;&#31361;???</span>
<span class="dt">void</span> overloadValAddr(<span class="dt">const</span> <span class="dt">int</span> i) {}
<span class="dt">void</span> overloadValAddr(<span class="dt">const</span> <span class="dt">int</span>&amp; i) {}

<span class="co">// &#21487;&#20197;</span>
<span class="dt">void</span> defaultArgCase1(<span class="dt">int</span> i=<span class="dv">0</span>);
<span class="dt">void</span> defaultArgCase1(<span class="dt">int</span> i  ) { printf(<span class="st">&quot;case1: default is </span><span class="ch">%d</span><span class="st">.</span><span class="ch">\n</span><span class="st">&quot;</span>, i); }

<span class="co">// &#21487;&#20197;</span>
<span class="dt">void</span> defaultArgCase2(<span class="dt">int</span> i);
<span class="dt">void</span> defaultArgCase2(<span class="dt">int</span> i=<span class="dv">1</span>) { printf(<span class="st">&quot;case2: default is </span><span class="ch">%d</span><span class="st">.</span><span class="ch">\n</span><span class="st">&quot;</span>, i); }

<span class="co">// &#19981;&#21487;&#20197;</span>
<span class="dt">void</span> defaultArgCase3(<span class="dt">int</span> i=<span class="dv">3</span>);
<span class="dt">void</span> defaultArgCase3(<span class="dt">int</span> i=<span class="dv">4</span>) { printf(<span class="st">&quot;case3: default is </span><span class="ch">%d</span><span class="st">.</span><span class="ch">\n</span><span class="st">&quot;</span>, i); }</code></pre></div>
<p>&#19979;&#38754;&#36825;&#20010;&#20063;&#26159;&#21487;&#20197;&#30340;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="kw">class</span> X {
<span class="kw">public</span>:
    <span class="dt">void</span> func( <span class="dt">int</span> i );
};

<span class="dt">void</span> X::func( <span class="dt">int</span> i = <span class="dv">123</span> ) { printf(<span class="st">&quot;default is: </span><span class="ch">%d</span><span class="st">.</span><span class="ch">\n</span><span class="st">&quot;</span>, i); }

<span class="dt">int</span> main()
{
    X x;
    x.func();
}</code></pre></div>
<p>&#20294;&#22914;&#26524;&#20320;&#25226; X &#22768;&#26126;&#20877; X.h &#23454;&#29616;&#20877; X.cpp&#65292;&#28982;&#21518; include &#36827;&#26469; X.h&#65292;&#20320;&#23601;&#19981;&#33021;&#29992; <code>x.func()</code> &#20102;&#65292;&#22240;&#20026; include &#36827;&#26469;&#30340;&#22836;&#25991;&#20214;&#27809;&#26377; default arg&#12290;&#21153;&#24517;&#30041;&#24847;&#36825;&#19968;&#28857;&#12290;&#22240;&#20026;&#25105;&#20204;&#23454;&#36341;&#20013;&#36890;&#24120;&#37117;&#26159;&#36825;&#31181;&#24773;&#20917;&#12290;</p>
<p>&#24635;&#32467;&#65292;defalut arguments &#22312;&#22768;&#26126;&#21644;&#23454;&#29616;&#30340;&#26102;&#20505;&#8220;&#21578;&#35785;&#8221;&#32534;&#35793;&#22120;&#37117;&#21487;&#20197;&#65292;&#20294;&#26159;&#19981;&#33021;&#8220;&#21578;&#35785;&#8221;&#20004;&#27425;&#12290;&#27880;&#24847;&#20174;&#22836;&#25991;&#20214;&#24341;&#20837;&#30340;&#26102;&#20505;&#65292;&#20320;&#33021;&#30475;&#21040;&#20160;&#20040;&#65292;&#30475;&#19981;&#21040;&#20160;&#20040;&#65292;reason &#19968;&#19979;&#20854;&#23454;&#36825;&#20123;&#35268;&#21017;&#37117;&#26159;&#21512;&#29702;&#30340;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::string (*fi)(<span class="dt">int</span>) = overload;
std::string (*ff)(<span class="dt">float</span>) = overload;

<span class="co">// Uses the void f(char c); overload</span>
std::for_each(s.begin(), s.end(), <span class="kw">static_cast</span>&lt;<span class="dt">void</span> (*)(<span class="dt">char</span>)&gt;(&amp;f));
<span class="co">// Uses the void f(int i); overload</span>
std::for_each(s.begin(), s.end(), <span class="kw">static_cast</span>&lt;<span class="dt">void</span> (*)(<span class="dt">int</span>)&gt;(&amp;f));

<span class="co">// The compiler will figure out which f to use according to</span>
<span class="co">// the function pointer declaration.</span>
<span class="dt">void</span> (*fpc)(<span class="dt">char</span>) = &amp;f;
std::for_each(s.begin(), s.end(), fpc); <span class="co">// Uses the void f(char c); overload</span>
<span class="dt">void</span> (*fpi)(<span class="dt">int</span>) = &amp;f;
std::for_each(s.begin(), s.end(), fpi); <span class="co">// Uses the void f(int i); overload</span>

transform (numbers.begin(), numbers.end(), lengths.begin(), mem_fun(&amp;string::length));</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://www.cplusplus.com/reference/functional/mem_fun/">mem_fun - C++ Reference</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>operator overload <code class="fold">@</code></dt>
<dd><p>&#22914;&#27492;&#35814;&#32454;&#65292;&#25105;&#30452;&#25509; copy &#36807;&#26469;&#20102;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/*</span>
<span class="co"> * from: https://github.com/cirosantilli/cpp-cheat/blob/master/cpp/operator_overload.cpp</span>
<span class="co"> *</span>
<span class="co"># operator overload</span>
<span class="co">    Like regular functions, C++ also allows operators to be overloaded</span>
<span class="co">    This is not only eye candy, but also allows developpers to forget if they are dealing</span>
<span class="co">    with base types or not, thus making code easier to modify: if we ever decide to move</span>
<span class="co">    from base types to classes we just have to implement the operator overload on classes.</span>
<span class="co">    Great tutorial: &lt;http://stackoverflow.com/questions/4421706/operator-overloading?rq=1&gt;</span>
<span class="co">    Good tutorial, specially on how to implement `=`, `+=` and `+` cases:</span>
<span class="co">    &lt;http://courses.cms.caltech.edu/cs11/material/cpp/donnie/cpp-ops.html&gt;</span>
<span class="co">    The following operators can all be overloaded:</span>
<span class="co">        +    -    *    /    =    &lt;    &gt;    +=   -=   *=   /=   &lt;&lt; (shift left)   &gt;&gt; (shift right)</span>
<span class="co">        &lt;&lt;=  &gt;&gt;=  ==   !=   &lt;=   &gt;=   ++   --   %    &amp;    ^    !    |</span>
<span class="co">        ~    &amp;=   ^=   |=   &amp;&amp;   ||   %=   []   ()   ,    -&gt;*  -&gt;   new</span>
<span class="co">        delete    new[]     delete[]</span>
<span class="co">    - typecast operator overload `int()`, `float()`, etc.</span>
<span class="co">    Member or not</span>
<span class="co">        Certain operators can be both member functions and free functions.</span>
<span class="co">        This includes most operators such as `+`, `=`, `+=` and others.</span>
<span class="co">        See: &lt;http://stackoverflow.com/a/4421729/895245&gt; for a discussion on how to decide</span>
<span class="co">        between them.</span>
<span class="co">        One question is that being non member improves the incapsulation, since then those</span>
<span class="co">        functions do not have access to private members, and thus do not reflect changes that are</span>
<span class="co">        otherwise invisible.</span>
<span class="co">        Certain operators *cannot* be member functions, such as `&lt;&lt;`.</span>
<span class="co">        Other *must* be members. Those include:</span>
<span class="co">        - `=`  (assignment)</span>
<span class="co">        - `[]` (array subscription),</span>
<span class="co">        - `-&gt;` (member access)</span>
<span class="co">        - `()` (function call)</span>
<span class="co">*/</span>

<span class="ot">#include &quot;common.hpp&quot;</span>

<span class="co">/*</span>
<span class="co">ERROR: One of the arguments must be a Class or Enum.</span>
<span class="co">Just imagine the havoc if this were possible! =)</span>
<span class="co">*/</span>

    <span class="co">//int operator+(int i, int j){return i + j + 1;}</span>

<span class="co">/*</span>
<span class="co">class that shows the ideal methods of operator overloading.</span>
<span class="co">*/</span>
<span class="kw">class</span> OperatorOverload {

    <span class="kw">public</span>:

        <span class="dt">int</span> i;

        OperatorOverload() { <span class="kw">this</span>-&gt;i = <span class="dv">0</span>; }
        OperatorOverload(<span class="dt">int</span> i) { <span class="kw">this</span>-&gt;i = i; }

        <span class="co">/*</span>
<span class="co">        operator=</span>
<span class="co">            Special care must be taken with `=` when memory is dynamically alocated because</span>
<span class="co">            of copy and swap idiom questions.</span>
<span class="co">            This is not the case for this simple class.</span>
<span class="co">        Return non const reference</span>
<span class="co">            Return a *non* const reference because the following is possible for base types:</span>
<span class="co">                (a = b) = c</span>
<span class="co">            which is the same as:</span>
<span class="co">                a = b</span>
<span class="co">                a = c</span>
<span class="co">            so this obscure syntax should also work for classes.</span>
<span class="co">        */</span>
        OperatorOverload&amp; <span class="kw">operator</span>=(<span class="dt">const</span> OperatorOverload&amp; rhs) {
            <span class="kw">this</span>-&gt;i = rhs.i;
            <span class="kw">return</span> *<span class="kw">this</span>;
        }

        <span class="co">/*</span>
<span class="co">        operator+=</span>
<span class="co">            Implement the compound assign, and the non compound in terms of the compound.</span>
<span class="co">            Must return a non-const reference for the same reason as `=`.</span>
<span class="co">        */</span>
        OperatorOverload&amp; <span class="kw">operator</span>+=(<span class="dt">const</span> OperatorOverload&amp; rhs) {
            <span class="kw">this</span>-&gt;i += rhs.i;
            <span class="kw">return</span> *<span class="kw">this</span>;
        }

        <span class="co">/*</span>
<span class="co">        operator++</span>
<span class="co">            - http://stackoverflow.com/questions/3846296/how-to-overload-the-operator-in-two-different-ways-for-postfix-a-and-prefix</span>
<span class="co">            - http://stackoverflow.com/questions/6375697/do-i-have-to-return-a-reference-to-the-object-when-overloading-a-pre-increment-o</span>
<span class="co">            - http://stackoverflow.com/questions/3574831/why-does-the-postfix-increment-operator-take-a-dummy-parameter</span>
<span class="co">        */</span>


            <span class="co">// Prefix. Should return reference to match primitives.</span>
            <span class="dt">const</span> OperatorOverload&amp; <span class="kw">operator</span>++() {
                ++(<span class="kw">this</span>-&gt;i);
                <span class="kw">return</span> *<span class="kw">this</span>;
            }

            <span class="co">// Postfix. Should not return reference to match primitives.</span>
            <span class="dt">const</span> OperatorOverload <span class="kw">operator</span>++(<span class="dt">int</span>) {
                OperatorOverload old(*<span class="kw">this</span>);
                ++(*<span class="kw">this</span>);
                <span class="kw">return</span> old;
            }

        <span class="co">/*</span>
<span class="co">        Ambiguous call.</span>
<span class="co">            This cannot be distinguished from the member method,</span>
<span class="co">            since the member method gets am implicit `this` first argument.</span>
<span class="co">            Therefore any call to this operator would give an ambiguous message</span>
<span class="co">            if this were defined.</span>
<span class="co">            The effect is the same as the non member function, but the non member is preferred</span>
<span class="co">            because it improves encapsulation.</span>
<span class="co">        */</span>

            <span class="co">/*</span>
<span class="co">                OperatorOverload operator+(OperatorOverload i, OperatorOverload j){</span>
<span class="co">                    OperatorOverload ret;</span>
<span class="co">                    ret.i = i.i + j.i + 1;</span>
<span class="co">                    return ret;</span>
<span class="co">                }</span>
<span class="co">            */</span>

        <span class="co">/*</span>
<span class="co">        # typecast overload</span>
<span class="co">            Automatic conversions will be done using it.</span>
<span class="co">            Notable example on the stdlib: `ifstream::operator bool()` to be able to do `while(getline)`</span>
<span class="co">            becaues getline returns the updated ifstream.</span>
<span class="co">        */</span>

            <span class="kw">operator</span> <span class="dt">bool</span>() <span class="dt">const</span> { <span class="kw">return</span> i % <span class="dv">2</span> == <span class="dv">1</span>; }
            <span class="kw">operator</span> <span class="dt">int</span>() <span class="dt">const</span> { <span class="kw">return</span> i + <span class="dv">1</span>; }
            <span class="kw">operator</span> <span class="dt">float</span>() <span class="dt">const</span> { <span class="kw">return</span> ((<span class="dt">float</span>)i) + <span class="fl">0.5</span>; }
};

<span class="co">/*</span>
<span class="co">operator+</span>
<span class="co">    Implemented in terms of the compound assign.</span>
<span class="co">    Should be const because the following does nothing:</span>
<span class="co">        (a + b) = c</span>
<span class="co">    Should be an external method, since it is just a function of `+=`.</span>
<span class="co">*/</span>

    OperatorOverload <span class="kw">operator</span>+ (<span class="dt">const</span> OperatorOverload&amp; lhs, <span class="dt">const</span> OperatorOverload&amp; rhs) {
        <span class="kw">return</span> OperatorOverload(lhs) += rhs;
    }

<span class="co">/*</span>
<span class="co">Comparison operators: only two are needed: `==` and `&lt;`.</span>
<span class="co">The other are functions of those two.</span>
<span class="co">It is recommended to implement them as non-member functions to increase incapsulation.</span>
<span class="co">*/</span>

    <span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>==(<span class="dt">const</span> OperatorOverload&amp; lhs, <span class="dt">const</span> OperatorOverload&amp; rhs) {<span class="kw">return</span> lhs.i == rhs.i;}
    <span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>!=(<span class="dt">const</span> OperatorOverload&amp; lhs, <span class="dt">const</span> OperatorOverload&amp; rhs) {<span class="kw">return</span> !<span class="kw">operator</span>==(lhs,rhs);}
    <span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>&lt; (<span class="dt">const</span> OperatorOverload&amp; lhs, <span class="dt">const</span> OperatorOverload&amp; rhs) {<span class="kw">return</span> lhs.i &lt; rhs.i;}
    <span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>&gt; (<span class="dt">const</span> OperatorOverload&amp; lhs, <span class="dt">const</span> OperatorOverload&amp; rhs) {<span class="kw">return</span>  <span class="kw">operator</span>&lt; (rhs,lhs);}
    <span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>&lt;=(<span class="dt">const</span> OperatorOverload&amp; lhs, <span class="dt">const</span> OperatorOverload&amp; rhs) {<span class="kw">return</span> !<span class="kw">operator</span>&gt; (lhs,rhs);}
    <span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>&gt;=(<span class="dt">const</span> OperatorOverload&amp; lhs, <span class="dt">const</span> OperatorOverload&amp; rhs) {<span class="kw">return</span> !<span class="kw">operator</span>&lt; (lhs,rhs);}

<span class="co">/*</span>
<span class="co">operator&lt;&lt;</span>
<span class="co">    `&lt;&lt;` **cannot** be a member method, because if it were then</span>
<span class="co">    its first argument would be an implicit `Class` for the `this`,</span>
<span class="co">    but the first argument of `&lt;&lt;` must be the `ostream`.</span>
<span class="co">    Therefore it must be a free method outside of a class.</span>
<span class="co">    It is likely that it will need to be a friend of the class in order</span>
<span class="co">    to see its internal fields. This may not be the case in this overly simplified example.</span>
<span class="co">*/</span>

    std::ostream&amp; <span class="kw">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="dt">const</span> OperatorOverload&amp; c) {
        os &lt;&lt; c.i;
        <span class="kw">return</span> os;
    }

<span class="co">/*</span>
<span class="co"># number of arguments</span>
<span class="co">    One major difference between regular functions and operators is that operators can only</span>
<span class="co">    have  fixed number of arguments, because they have a very peculiar syntax.</span>
<span class="co">    For example, how could a ternary multiplication possibly be called? ` a * b ???? c` ?</span>
<span class="co">    There are some operators which exist for multiple numbers of arguments with different meaning:</span>
<span class="co">    - `-` with one argument:    unary minus</span>
<span class="co">    - `-` with two arguments:   subtraction</span>
<span class="co">    - `*` with one argument:    dereference</span>
<span class="co">    - `*` with two arguments:   multiplication</span>
<span class="co">    For this reason, we must take into account that member operator overloads *already have one extra argument*,</span>
<span class="co">    which is the `this` pointer, which is always passed as a first hidden parameter of member functions.</span>
<span class="co">*/</span>

    <span class="co">/*</span>
<span class="co">    A failed attemtpt to add the middle handside to `operator*`.</span>
<span class="co">    ERROR: operator* must have one or two arguments.</span>
<span class="co">    */</span>
    <span class="co">/*</span>
<span class="co">    const OperatorOverload operator* (const OperatorOverload&amp; lhs, const OperatorOverload&amp; mhs, const OperatorOverload&amp; rhs){</span>
<span class="co">        return OperatorOverload(lhs.i * mhs.i * rhs.i);</span>
<span class="co">    }</span>
<span class="co">    */</span>

<span class="co">/*</span>
<span class="co">operator*</span>
<span class="co">    operator* can be two things:</span>
<span class="co">    - multiplication `a * b` if it has  two arguments   (or one    in a member method)</span>
<span class="co">    - dereference `*ptr` if it has      one argument    (or none   in a member method)</span>
<span class="co">    It is only differenced by the number of arguments.</span>
<span class="co">*/</span>

    <span class="co">/*</span>
<span class="co">    This exists because it is the dereference operator.</span>
<span class="co">    This is implemented on classes which represent pointers, such as `shared_ptr`,</span>
<span class="co">    which is not the case for this class.</span>
<span class="co">    */</span>

        <span class="co">/*</span>
<span class="co">        Dereference operator.</span>
<span class="co">        This should not be implemented for this class since it makes no (usual) sense,</span>
<span class="co">        it is just to illustrate that it is possible.</span>
<span class="co">        */</span>
        <span class="dt">int</span> <span class="kw">operator</span>* (<span class="dt">const</span> OperatorOverload&amp; rhs){
            <span class="kw">return</span> rhs.i;
        }

        OperatorOverload <span class="kw">operator</span>* (<span class="dt">const</span> OperatorOverload&amp; lhs, <span class="dt">const</span> OperatorOverload&amp; rhs){
            <span class="kw">return</span> OperatorOverload(lhs.i * rhs.i);
        }

<span class="co">/*</span>
<span class="co">operator-</span>
<span class="co">- `-` with one argument:    unary minus</span>
<span class="co">- `-` with two arguments:   subtraction</span>
<span class="co">*/</span>

        <span class="co">/* Can be defined in terms of * if you class implements it. */</span>
        <span class="dt">const</span> OperatorOverload <span class="kw">operator</span>- (<span class="dt">const</span> OperatorOverload&amp; rhs){
            <span class="kw">return</span> OperatorOverload(<span class="dv">-1</span>) * rhs;
        }

        <span class="co">/* Defined in terms of unary minus and +. */</span>
        <span class="dt">const</span> OperatorOverload <span class="kw">operator</span>- (<span class="dt">const</span> OperatorOverload&amp; lhs, <span class="dt">const</span> OperatorOverload&amp; rhs){
            <span class="kw">return</span> lhs + (-rhs);
        }

<span class="co">/*</span>
<span class="co">Operator overload and templates</span>
<span class="co">    Operator overload and templates do not play very well together</span>
<span class="co">    because operator overload leads to special function calling syntax,</span>
<span class="co">    which does not go well with the template calling syntax.</span>
<span class="co">*/</span>

    <span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
    T <span class="kw">operator</span>/(<span class="dt">const</span> T&amp; i, <span class="dt">const</span> T&amp; j) {<span class="kw">return</span> i + j;}

<span class="dt">int</span> main() {
    <span class="co">// OperatorOverload overload `+`</span>
    {
        <span class="co">// ==</span>
        assert(OperatorOverload(<span class="dv">3</span>) == OperatorOverload(<span class="dv">3</span>));

        <span class="co">// &lt;</span>
        assert(OperatorOverload(<span class="dv">1</span>) &lt; OperatorOverload(<span class="dv">2</span>));

        <span class="co">// =</span>
        {
            OperatorOverload i(<span class="dv">1</span>);
            assert(i == OperatorOverload(<span class="dv">1</span>));
        }

        <span class="co">// +=</span>
        {
            OperatorOverload i(<span class="dv">1</span>);
            i += OperatorOverload(<span class="dv">2</span>);
            assert(i == OperatorOverload(<span class="dv">3</span>));
        }

        <span class="co">// +</span>
        assert(OperatorOverload(<span class="dv">1</span>) + OperatorOverload(<span class="dv">2</span>) == OperatorOverload(<span class="dv">3</span>));

        <span class="co">// # operator++</span>
        {
            <span class="co">// Prefix</span>
            {
                OperatorOverload i(<span class="dv">1</span>);
                assert(++i == OperatorOverload(<span class="dv">2</span>));
                assert(i == OperatorOverload(<span class="dv">2</span>));
            }

            <span class="co">// Postfix. TODO</span>
            {
                OperatorOverload i(<span class="dv">1</span>);
                assert(i++ == OperatorOverload(<span class="dv">1</span>));
                assert(i == OperatorOverload(<span class="dv">2</span>));
            }
        }

        <span class="co">// -</span>
        {
            <span class="co">// Unary</span>
            assert(-OperatorOverload(<span class="dv">1</span>) == OperatorOverload(<span class="dv">-1</span>));

            <span class="co">// Subtraction</span>
            assert(OperatorOverload(<span class="dv">2</span>) - OperatorOverload(<span class="dv">1</span>) == OperatorOverload(<span class="dv">1</span>));
        }

        <span class="co">// *</span>
        {
            <span class="co">// Dereference</span>
            assert(*(OperatorOverload(<span class="dv">1</span>)) == <span class="dv">1</span>);

            <span class="co">// Subtraction</span>
            assert(OperatorOverload(<span class="dv">2</span>) - OperatorOverload(<span class="dv">1</span>) == OperatorOverload(<span class="dv">1</span>));
        }

        <span class="co">// &lt;&lt;</span>
        {
            OperatorOverload i(<span class="dv">123</span>);
            std::stringstream os;
            os &lt;&lt; i;
            assert(os.str() == <span class="st">&quot;123&quot;</span>);
        }

        <span class="co">//typecast overload</span>
        {
            OperatorOverload oo(<span class="dv">1</span>);

            <span class="co">// Explicit typecast:</span>
            assert(((<span class="dt">bool</span>)oo) == <span class="kw">true</span>);
            assert(((<span class="dt">int</span>)oo) == <span class="dv">2</span>);
            assert(((<span class="dt">float</span>)oo) == <span class="fl">1.5</span>);

            <span class="co">// Implicit typecast:</span>
            assert(oo);

            <span class="dt">int</span> i = oo;
            assert(i == <span class="dv">2</span>);

            <span class="dt">float</span> f = oo;
            assert(f == <span class="fl">1.5f</span>);
        }
    }

    <span class="co">/*</span>
<span class="co">    Explicit call syntax.</span>
<span class="co">    Does the same as the implicit call syntax, but is uglier.</span>
<span class="co">    May be required when the function is also a template function.</span>
<span class="co">    */</span>
    {
        OperatorOverload i, j;
        i = OperatorOverload(<span class="dv">1</span>);
        j = OperatorOverload(<span class="dv">2</span>);

        assert(<span class="kw">operator</span>+(i, j) == OperatorOverload(<span class="dv">3</span>));

        i.<span class="kw">operator</span>=(j);
        assert(i == j);
    }

    <span class="co">/*</span>
<span class="co">    operator overload and templates</span>
<span class="co">    */</span>
    {
        <span class="co">// Works because of template ty.</span>
        assert(OperatorOverload(<span class="dv">1</span>) / OperatorOverload(<span class="dv">2</span>) == OperatorOverload(<span class="dv">3</span>));

        <span class="co">// ERROR: Impossible syntax</span>
        <span class="co">//assert(OperatorOverload(1) /&lt;OperatorOverload&gt; OperatorOverload(2) == OperatorOverload(3));</span>

        <span class="co">// If we needed to specify the template parameter to the operator on this case,</span>
        <span class="co">// an explicit `operator/` call would be needed</span>
        assert(<span class="kw">operator</span>/&lt;OperatorOverload&gt;(OperatorOverload(<span class="dv">1</span>), OperatorOverload(<span class="dv">2</span>)) == OperatorOverload(<span class="dv">3</span>));
    }
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://github.com/cirosantilli/cpp-cheat/blob/master/cpp/operator_overload.cpp">cpp-cheat/operator_overload.cpp at master &#183; cirosantilli/cpp-cheat</a></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>some C++ code snippets <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>function object <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="kw">struct</span> compare {
    <span class="dt">bool</span> <span class="kw">operator</span>()( <span class="dt">int</span> *a, <span class="dt">int</span> *b ) <span class="dt">const</span> {
        <span class="kw">return</span> *a &gt; *b;
    }
};

<span class="dt">int</span> main()
{
    <span class="kw">using</span> std::cout;
    <span class="dt">int</span> a, b;
    <span class="kw">while</span>( <span class="dv">2</span> == scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;a, &amp;b) ) {
        <span class="kw">if</span>( compare()(&amp;a,&amp;b) ) {
            cout &lt;&lt; <span class="st">&quot;big</span><span class="ch">\n</span><span class="st">&quot;</span>;
        } <span class="kw">else</span> {
            cout &lt;&lt; <span class="st">&quot;small</span><span class="ch">\n</span><span class="st">&quot;</span>;
        }
    }
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt><a href="http://www.cnblogs.com/AnnieKim/">AnnieKim - &#21338;&#23458;&#22253;</a> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> (*func(<span class="dt">int</span>*, <span class="dt">int</span>))(<span class="dt">const</span> string&amp;, <span class="dt">const</span> string&amp;);</code></pre></div>
<p>&#32534;&#35793;&#22120;&#22312;&#22788;&#29702;&#21021;&#22987;&#21270;&#38431;&#20237;&#26102;&#65292;&#20250;&#26681;&#25454;&#25104;&#21592;&#21464;&#37327;&#30340;&#22768;&#26126;&#27425;&#24207;&#37325;&#26032;&#25490;&#24207;&#12290;&#20063;&#23601;&#26159;&#35828;&#65292;&#34429;&#28982;&#26500;&#36896;&#26041;&#27861;&#26159;&#20808;&#23545; j &#36827;&#34892;&#21021;&#22987;&#21270;&#65292;&#20294;&#26159;&#65292;&#26681;&#25454; i &#21644; j &#30340;&#22768;&#26126;&#27425;&#24207;&#65292;&#23454;&#38469;&#19978;&#26159;&#20808;&#23545; i &#21021;&#22987;&#21270;&#65292;&#28982;&#21518;&#20877;&#23545; j &#36827;&#34892;&#21021;&#22987;&#21270;&#12290;</p>
<p>&#22312; Microsoft C++ &#31995;&#21015;&#30340;&#32534;&#35793;&#22120;&#20013;&#65292;&#36890;&#24120;&#20351;&#29992; stdcall &#35843;&#29992;&#35268;&#23450;&#65292;&#24182;&#19988; stdcall &#35268;&#23450;&#21442;&#25968;&#26159;&#20174;&#21491;&#21040;&#24038;&#20837;&#26632;&#12290;</p>
<p>&#19978;&#38754;&#30340;&#22768;&#26126;&#65292;&#23558; <code>func(int*, int)</code> &#22768;&#26126;&#20026;&#19968;&#20010;&#20989;&#25968;&#65292;&#36820;&#22238;&#20540;&#20026;&#20989;&#25968;&#25351;&#38024;&#65292;&#20989;&#25968;&#31867;&#22411;&#20026; <code>int (*)(const string&amp;, const string&amp;)</code>&#12290;</p>
<p><strong>&#20108;&#20998;&#25628;&#32034;</strong></p>
<p>&#23545;&#20110;&#19968;&#20010;&#38750;&#36127;&#25968; n&#65292;&#23427;&#30340;&#24179;&#26041;&#26681;&#19981;&#20250;&#22823;&#20110;&#65288;n/2+1&#65289;&#65288;&#35874;&#35874; <span class="citation">@linzhi-cs</span> &#25552;&#37266;&#65289;&#12290;&#22312; [0, n/2+1] &#36825;&#20010;&#33539;&#22260;&#20869;&#21487;&#20197;&#36827;&#34892;&#20108;&#20998;&#25628;&#32034;&#65292;&#27714;&#20986; n &#30340;&#24179;&#26041;&#26681;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> sqrt(<span class="dt">int</span> x) {
    <span class="dt">long</span> <span class="dt">long</span> i = <span class="dv">0</span>;
    <span class="dt">long</span> <span class="dt">long</span> j = x / <span class="dv">2</span> + <span class="dv">1</span>;
    <span class="kw">while</span> (i &lt;= j)
    {
        <span class="dt">long</span> <span class="dt">long</span> mid = (i + j) / <span class="dv">2</span>;
        <span class="dt">long</span> <span class="dt">long</span> sq = mid * mid;
        <span class="kw">if</span> (sq == x) <span class="kw">return</span> mid;
        <span class="kw">else</span> <span class="kw">if</span> (sq &lt; x) i = mid + <span class="dv">1</span>;   <span class="co">// &#36825;&#37324;&#21487;&#20197;&#29992; x / mid == mid &#26469;&#21028;&#26029;&#65292;&#20063;&#36991;&#20813;&#20102; long long &#31867;&#22411;</span>
        <span class="kw">else</span> j = mid - <span class="dv">1</span>;
    }
    <span class="kw">return</span> j;
}</code></pre></div>
<p><strong>&#29275;&#39039;&#36845;&#20195;&#27861;</strong></p>
<div class="figure">
<img src="http://images.cnitblog.com/blog/300640/201304/18155235-b272cc444a1845d3aede4c72a87f83dc.jpg" />

</div>
<p>&#32463;&#36807; (xi&#65292;f(xi)) &#36825;&#20010;&#28857;&#30340;&#20999;&#32447;&#26041;&#31243;&#20026; f(x) = f(xi) + f&#8217;(xi)(x - xi)&#65292;&#20854;&#20013; f&#8217;(x) &#20026; f(x) &#30340;&#23548;&#25968;&#65292;&#26412;&#39064;&#20013;&#20026; 2x&#12290;&#20196;&#20999;&#32447;&#26041;&#31243;&#31561;&#20110; 0&#65292;&#21363;&#21487;&#27714;&#20986; x_{i+1}=xi - f(xi) / f&#8217;(xi)&#12290;</p>
<p>&#32487;&#32493;&#21270;&#31616;&#65292;x{i+1}=xi - (xi2 - n) / (2xi) = xi - xi / 2 + n / (2xi) = xi / 2 + n / 2xi = (xi + n/xi) / 2&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> sqrt(<span class="dt">int</span> x) {
    <span class="kw">if</span> (x == <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">0</span>;
    <span class="dt">double</span> last = <span class="dv">0</span>;
    <span class="dt">double</span> res = <span class="dv">1</span>;
    <span class="co">// &#24863;&#35273;&#36825;&#37324;&#24212;&#35813;&#29992; fabs(res-last) &lt; 1e-6&#65292;</span>
    <span class="co">// &#20294;&#23454;&#38469;&#27979;&#35797;&#65292;&#27809;&#26377;&#38382;&#39064;</span>
    <span class="kw">while</span> (res != last)
    {
        last = res;
        res = (res + x / res) / <span class="dv">2</span>;
    }
    <span class="kw">return</span> <span class="dt">int</span>(res);
}</code></pre></div>
<ol start="41" style="list-style-type: decimal">
<li>First Missing Positive <code class="fold">@</code></li>
</ol>
<p>: Given an unsorted integer array, find the first missing positive integer.</p>
<pre><code>For example,
Given [1,2,0] return 3,
and [3,4,-1,1] return 2.

Your algorithm should run in O(n) time and uses constant space.

```cpp
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;map&gt;
using namespace std;

#define INT_MAX      2147483647

/*
 *  Idea:
 *
 *    We can move the num to the place whcih the index is the num.
 *
 *    for example,  (considering the array is zero-based.
 *       1 =&gt; A[0], 2 =&gt; A[1], 3=&gt;A[2]
 *
 *    Then, we can go through the array check the i+1 == A[i], if not ,just return i+1;
 *
 *    This solution comes from StackOverflow.com
 *    http://stackoverflow.com/questions/1586858/find-the-smallest-integer-not-in-a-list
*/
int firstMissingPositive_move(int A[], int n) {
    if (n&lt;=0) return 1;
    cout &lt;&lt; &quot;\n&quot;;
    copy( A, A+n, ostream_iterator&lt;int&gt;(cout, &quot; &quot;) );
    cout &lt;&lt; &quot;\t[before]\n&quot;;
    int num;
    for(int i=0; i&lt;n; i++) {
        num = A[i];
        while (num&gt;0 &amp;&amp; num&lt;n &amp;&amp; A[num-1]!=num) {
            swap(A[i], A[num-1]);
            num = A[i];
        }
    }
    copy( A, A+n, ostream_iterator&lt;int&gt;(cout, &quot; &quot;) );
    cout &lt;&lt; &quot;\t[after]\n&quot;;
    for (int i=0; i&lt;n; i++){
        if (i+1 != A[i]){
            return i+1;
        }
    }
    return n+1;
}

/*
 *    The idea is simple:
 *
 *    1) put all of number into a map.
 *    2) for each number a[i] in array, remove its continous number in the map
 *        2.1)  remove ... a[i]-3, a[i]-2, a[i]-1, a[i]
 *        2.2)  remove a[i]+1, a[i]+2, a[i]+3,...
 *    3) during the removeing process, if some number cannot be found, which means it&#39;s missed.
 *
 *    considering a case [-2, -1, 4,5,6],
 *        [-2, -1] =&gt; missed 0
 *        [4,5,6]  =&gt; missed 3
 *
 *    However, we missed 1, so, we have to add dummy number 0 whatever.
 *
 *    NOTE: this solution is not constant space slution!!!!
 *
 */
int firstMissingPositive_map(int A[], int n) {
    map&lt;int, int&gt; cache;
    for(int i=0; i&lt;n; i++){
        cache[A[i]] = i;
    }

    //add dummy
    if (cache.find(0)==cache.end() ) {
        cache[0] = -1;
    }

    int miss = INT_MAX;
    int x;
    for (int i=-1; i&lt;n &amp;&amp; cache.size()&gt;0; i++){

        if (i == -1){
            x = 0; //checking dummy
        }else{
            x = A[i];
        }

        if ( cache.find(x)==cache.end() ){
            continue;
        }

        int num ;
        // remove the ... x-3, x-2, x-1, x
        for( num=x; cache.find(num)!=cache.end(); num--){
            cache.erase(cache.find(num));
        }
        if ( num&gt;0 &amp;&amp; num &lt; miss  ){
            miss = num;
        }
        // remove the x+1, x+2, x+3 ...
        for ( num=x+1; cache.find(num)!=cache.end(); num++){
            cache.erase(cache.find(num));
        }
        if ( num&gt;0 &amp;&amp; num &lt; miss) {
            miss = num;
        }
    }


    return miss;
}

int firstMissingPositive(int A[], int n) {
    srand(time(0));
    if (rand()%2){
        return firstMissingPositive_move(A, n);
    }
    return firstMissingPositive_map(A, n);
}


void printArray(int a[], int n){
    cout &lt;&lt; &quot;[ &quot;;
    for(int i=0; i&lt;n-1; i++) {
        cout &lt;&lt; a[i] &lt;&lt; &quot;, &quot;;
    }
    cout &lt;&lt; a[n-1] &lt;&lt; &quot; ]&quot;;
}

void Test(int a[], int n, int expected) {
    printArray(a, n);
    int ret = firstMissingPositive(a, n);
    cout &lt;&lt; &quot;\t   missed = &quot; &lt;&lt; ret &lt;&lt; &quot;  &quot; &lt;&lt; (ret==expected?&quot;passed!&quot;:&quot;failed!&quot;) &lt;&lt; endl;
    //printArray(a, n);
    //cout &lt;&lt;endl;
}

int main()
{
#define TEST(a, e) Test(a, sizeof(a)/sizeof(int), e)

    int a0[]={1};
    TEST(a0, 2);

    int a1[]={1,2,0};
    TEST(a1, 3);

    int a2[]={3,4,-1,1};
    TEST(a2, 2);

    int a3[]={1000,-1};
    TEST(a3, 1);

    int a4[]={1000, 200};
    TEST(a4, 1);

    int a5[]={2,5,3,-1};
    TEST(a5, 1);

    int a6[]={1, 100};
    TEST(a6, 2);

    int a7[]={7,8,9,11};
    TEST(a7, 1);

    int a8[]={4,3,2,1};
    TEST(a8, 5);

    return 0;
}
```

refs and see also

-   [arrays - Find the Smallest Integer Not in a List - Stack Overflow](http://stackoverflow.com/questions/1586858/find-the-smallest-integer-not-in-a-list)
-   [First Missing Positive | LeetCode OJ](https://leetcode.com/problems/first-missing-positive/)</code></pre>
<p>refs and see also</p>
<ul>
<li><a href="http://www.cnblogs.com/AnnieKim/archive/2011/11/20/2255813.html">&#24700;&#20154;&#30340;&#20989;&#25968;&#25351;&#38024;&#65288;&#19968;&#65289; - AnnieKim - &#21338;&#23458;&#22253;</a></li>
<li><a href="http://www.cnblogs.com/AnnieKim/archive/2011/12/04/2275589.html">&#24700;&#20154;&#30340;&#20989;&#25968;&#25351;&#38024;&#65288;&#20108;&#65289;&#65306;&#25351;&#21521;&#31867;&#25104;&#21592;&#30340;&#25351;&#38024; - AnnieKim - &#21338;&#23458;&#22253;</a></li>
<li><a href="http://www.cnblogs.com/AnnieKim/archive/2011/05/22/2053581.html">&#20851;&#20110;&#26500;&#36896;&#26041;&#27861;&#30340;&#19968;&#20010;&#26377;&#36259;&#30340;&#38382;&#39064;&#65306;&#21021;&#22987;&#21270;&#38431;&#20237; - AnnieKim - &#21338;&#23458;&#22253;</a></li>
<li><a href="http://www.cnblogs.com/AnnieKim/archive/2011/05/16/2048062.html">&#31508;&#35797;&#39064;&#20043;&#20108;&#65306;&#20989;&#25968;&#21442;&#25968;&#20837;&#26632;&#38382;&#39064; - AnnieKim - &#21338;&#23458;&#22253;</a></li>
<li><a href="http://www.cnblogs.com/AnnieKim/archive/2011/05/17/2048632.html">&#31508;&#35797;&#39064;&#20043;&#19977;&#65306;C++ dynamic_cast&#38382;&#39064; - AnnieKim - &#21338;&#23458;&#22253;</a></li>
<li><a href="http://www.cnblogs.com/AnnieKim/archive/2013/04/18/3028607.html">LeetCode(Q69) Sqrt(x) (&#32534;&#31243;&#23454;&#29616;sqrt) - AnnieKim - &#21338;&#23458;&#22253;</a> <code class="fold">@</code></li>
<li><a href="http://www.cnblogs.com/AnnieKim/archive/2013/04/21/3034631.html">LeetCode(Q41) First Missing Positive (&#20081;&#24207;&#25968;&#32452;&#20013;&#23547;&#25214;&#31532;&#19968;&#20010;&#26410;&#20986;&#29616;&#30340;&#27491;&#25972;&#25968;) - AnnieKim - &#21338;&#23458;&#22253;</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt><a href="http://blog.csdn.net/hackbuteer1">Hackbuteer1&#30340;&#19987;&#26639; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a> <code class="fold">@</code></dt>
<dd><p>TODO</p>
</dd>
</dl></li>
</ul>
<h2 id="&#26434;&#19971;&#26434;&#20843;">&#26434;&#19971;&#26434;&#20843;</h2>
<ul>
<li><p><a href="https://github.com/4ker/C">4ker/C: C&#35821;&#35328;</a></p></li>
<li><p><a href="https://github.com/4ker/Cpp-Primer">4ker/Cpp-Primer: C++ Primer 5ed answers</a></p></li>
<li><dl>
<dt><a href="https://github.com/sib9/cpp1x-study-resource">sib9/cpp1x-study-resource: &#26088;&#22312;&#25628;&#38598;&#22269;&#20869;&#22806;&#21508;&#31181; C++11 &#30340;&#23398;&#20064;&#36164;&#28304;&#65292;&#20379;&#22823;&#23478;&#21442;&#32771;&#12289;&#23398;&#20064;&#12290;</a> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[](<span class="dt">int</span> x, <span class="dt">int</span> y) { <span class="kw">return</span> x + y; } <span class="co">// implicit return type from &#39;return&#39; statement</span>
[](<span class="dt">int</span>&amp; x) { ++x; }   <span class="co">// no return statement -&gt; lambda function&#39;s return type is &#39;void&#39;</span>
[]() { ++global_x; }  <span class="co">// no parameters, just accessing a global variable</span>
[]{ ++global_x; }     <span class="co">// the same, so () can be omitted</span>


[](<span class="dt">int</span> x, <span class="dt">int</span> y) -&gt; <span class="dt">int</span> { <span class="dt">int</span> z = x + y; <span class="kw">return</span> z; }</code></pre></div>
<p>lambda &#20989;&#25968;&#21487;&#20197;&#20351;&#29992; lambda &#20989;&#25968;&#22806;&#38754;&#30340;&#26631;&#24535;&#31526;&#12290;&#36825;&#20123;&#21464;&#37327;&#30340;&#38598;&#21512;&#36890;&#24120;&#34987;&#25104;&#20026;<a href="https://en.wikipedia.org/wiki/Closure_(computer_science)#Function_objects_.28C.2B.2B.29">&#38381;&#21253;</a>&#65292;&#38381;&#21253;&#22312; lambda &#34920;&#36798;&#24335;&#30340; <code>[]</code> &#20013;&#23450;&#20041;&#65292;&#20801;&#35768;&#26159;&#20540;&#25110;&#32773;&#24341;&#29992;&#12290;&#22914;&#19979;&#25152;&#31034;&#65306;</p>
<pre><code>[]        //no variables defined. Attempting to use any external variables in the lambda is an error.
[x, &amp;y]   //x is captured by value, y is captured by reference
[&amp;]       //any external variable is implicitly captured by reference if used
[=]       //any external variable is implicitly captured by value if used
[&amp;, x]    //x is explicitly captured by value. Other variables will be captured by reference
[=, &amp;z]   //z is explicitly captured by reference. Other variables will be captured by value</code></pre>
<p>&#19979;&#38754;&#30340;&#20004;&#20010;&#20363;&#23376;&#28436;&#31034;&#20102; lambda &#34920;&#36798;&#24335;&#30340;&#29992;&#27861;&#65306;</p>
<pre><code>std::vector&lt;int&gt; some_list{ 1, 2, 3, 4, 5 };
int total = 0;
std::for_each(begin(some_list), end(some_list), [&amp;total](int x) {
  total += x;
});</code></pre>
<p>&#35745;&#31639; <code>some_list</code> &#30340;&#21152;&#21644;&#65292;&#23384;&#20648;&#21040; <code>total</code> &#20013;(&#24341;&#29992;&#20256;&#36882;)&#12290;</p>
<pre><code>std::vector&lt;int&gt; some_list{ 1, 2, 3, 4, 5 };
int total = 0;
int value = 5;
std::for_each(begin(some_list), end(some_list), [&amp;, value, this](int x) {
  total += x * value * this-&gt;some_func();
});</code></pre>
<p>&#38500; value &#21644; this &#22806;&#65292;&#24341;&#29992;&#20256;&#36882;&#12290;&#35745;&#31639;&#24471;&#21040; total &#30340;&#20540;&#12290;&#21482;&#33021;&#25235;&#21462;&#38381;&#21253;&#20013;&#30340;&#38750;&#38745;&#24577;&#20989;&#25968;&#65292;lambda &#21644;&#21019;&#24314;&#23427;&#30340;&#26102;&#20505;&#20855;&#26377;&#30456;&#21516;&#30340;&#23384;&#21462;&#26435;&#38480;&#65292;&#19981;&#31649;&#26159;&#21542; protected/private &#25104;&#21592;&#12290;</p>
<p>&#36825;&#31687;&#25991;&#31456;&#26159;&#25105;&#20174; <a href="http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html">Move semantics and rvalue references in C++11</a> &#32763;&#35793;&#32780;&#26469;&#30340;&#12290;&#20540;&#24471;&#19968;&#25552;&#30340;&#26159;&#65292;&#19981;&#26159;&#20840;&#25991; / &#21407;&#25991;&#36880;&#23383;&#36880;&#21477;&#30340;&#32763;&#35793;&#65292;&#21152;&#20102;&#19968;&#20123;&#25105;&#20010;&#20154;&#30340;&#29702;&#35299;&#65292;&#24182;&#36827;&#34892;&#20102;&#19968;&#23450;&#30340;&#31934;&#31616;&#12290;</p>
<p>&#21491;&#20540;&#24341;&#29992;&#20250;&#21644;&#19968;&#20010;&#20020;&#26102;&#23545;&#35937;&#32465;&#23450;&#12290;&#27604;&#22914;&#65292;&#22312; C++11 &#20043;&#21069;&#65292;&#22914;&#26524;&#20320;&#26377;&#19968;&#20010;&#20020;&#26102;&#23545;&#35937;&#65292;&#20320;&#21487;&#20197;&#29992;<code>regular</code>&#25110;&#32773;<code>lvalue reference</code> &#21435;&#32465;&#23450;&#23427;&#65292;&#20294;&#26159;&#20165;&#20165;&#26159;&#22312;<code>const</code>&#30340;&#24773;&#20917;&#19979;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> string &amp; name = get_name(); <span class="co">// ok</span>
string&amp; name = get_name(); <span class="co">// NOT ok</span></code></pre></div>
<p>&#22312; C++11 &#20013;&#65292;&#21491;&#20540;&#24341;&#29992;&#20801;&#35768;&#20320;&#20026;&#21491;&#20540;&#32465;&#23450;&#19968;&#20010;&#21487;&#21464;&#24341;&#29992;&#65292;&#20294;&#26159;&#19981;&#33021;&#26159;&#19968;&#20010;&#24038;&#20540;&#12290;&#25442;&#21477;&#35805;&#35828;&#65292;&#21491;&#20540;&#24341;&#29992;&#21487;&#20197;&#26816;&#27979;&#21040;&#19968;&#20010;&#23545;&#35937;&#26159;&#19981;&#26159;&#20020;&#26102;&#23545;&#35937;&#12290;&#21491;&#20540;&#24341;&#29992;&#20351;&#29992; <code>&amp;&amp;</code> &#35821;&#27861;&#26469;&#22768;&#26126;&#32780;&#19981;&#26159; <code>&amp;</code>&#65292;&#21487;&#20197;&#26159;&#24120;&#37327;&#65292;&#20063;&#21487;&#20197;&#26159;&#38750;&#24120;&#37327;&#12290;&#21644;&#24038;&#20540;&#24341;&#29992;&#19968;&#26679;&#65292;&#23613;&#31649;&#20320;&#24456;&#23569;&#35265;&#21040;&#19968;&#20010;&#24120;&#37327;&#21491;&#20540;&#24341;&#29992;&#12290;</p>
<pre><code>const string &amp;&amp; name = get_name(); // ok
string &amp;&amp; name = get_name();  // alse ok - praise be!

void print_ref(const std::string &amp; str)
{
    std::cout &lt;&lt; str &lt;&lt; std::endl;
}

void print_ref(std::string &amp;&amp; str)
{
    std::cout &lt;&lt; str &lt;&lt; std::endl;
}

std::string name(&quot;jerryzhang&quot;);
print_ref(name); // calls the first print_ref function, taking an lvalue reference
print_ref(get_name()); // calls the second print_ref function, taking a mutable rvalue reference</code></pre>
</dd>
</dl></li>
<li><p><a href="http://vdisk.weibo.com/s/G-kaugh7dbcL">The Essence of C++_Bjarne Stroustrup.pptx_&#24494;&#30424;&#19979;&#36733;</a></p></li>
<li><dl>
<dt><a href="https://github.com/isocpp/CppCoreGuidelines" class="heart">isocpp/CppCoreGuidelines: The C++ Core Guidelines are a set of tried-and-true guidelines, rules, and best practices about coding in C++</a> <code class="fold">@</code></dt>
<dd><p><strong>C++ Core Guidelines</strong></p>
<ul>
<li><p>A well-designed library expresses intent (what is to be done, rather than just how something is being done) far better than direct use of language features.</p></li>
<li><p>flag uses of casts (casts neuter the type system)</p></li>
<li><p>P.3: Express intent</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> (<span class="dt">const</span> <span class="kw">auto</span>&amp; x : v) { <span class="co">/* do something with x */</span> }
for_each(v, [](<span class="dt">int</span> x) { <span class="co">/* do something with x */</span> });
for_each(parallel.v, [](<span class="dt">int</span> x) { <span class="co">/* do something with x */</span> });   <span class="co">// &#39034;&#24207;&#26080;&#20851;</span></code></pre></div></li>
<li><p><code>f(T*, int)</code> interfaces vs. <code>f(span&lt;T&gt;)</code> interfaces</p></li>
<li><p><code>static_assert(sizeof(Int) &gt;= 4);    // do: compile-time check</code></p></li>
<li><p>P.8: Don&#8217;t leak any resources, prefer RAII</p></li>
<li><p>no singleton</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">X&amp; myX()
{
    <span class="dt">static</span> X my_x {<span class="dv">3</span>};
    <span class="kw">return</span> my_x;
}</code></pre></div></li>
<li><p>Pass ownership using a &#8220;smart pointer&#8221;, such as unique_ptr (for exclusive ownership) and shared_ptr (for shared ownership).</p></li>
<li><p>I.23: Keep the number of function arguments low</p></li>
<li><p>I.25: Prefer abstract classes as interfaces to class hierarchies</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Shape {    <span class="co">// better: Shape is a pure interface</span>
<span class="kw">public</span>:
    <span class="kw">virtual</span> Point center() <span class="dt">const</span> = <span class="dv">0</span>;   <span class="co">// pure virtual function</span>
    <span class="kw">virtual</span> <span class="dt">void</span> draw() <span class="dt">const</span> = <span class="dv">0</span>;
    <span class="kw">virtual</span> <span class="dt">void</span> rotate(<span class="dt">int</span>) = <span class="dv">0</span>;
    <span class="co">// ...</span>
    <span class="co">// ... no data members ...</span>
};</code></pre></div></li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">CppCoreGuidelines/CppCoreGuidelines.md at master &#183; isocpp/CppCoreGuidelines</a></li>
<li><a href="https://github.com/lynnboy/CppCoreGuidelines-zh-CN/blob/master/CppCoreGuidelines-zh-CN.md">CppCoreGuidelines-zh-CN/CppCoreGuidelines-zh-CN.md at master &#183; lynnboy/CppCoreGuidelines-zh-CN</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>MISC of MISC <code class="fold">@</code></dt>
<dd><p>&#38382;&#39064;&#22312;&#20110; Bear &#21644; Raccoon &#30340;&#22522;&#31867;&#26500;&#36896;&#20989;&#25968;&#37117;&#25552;&#20379;&#20102;&#19968;&#20010;&#24102;&#26377;&#26174;&#24335;&#23454;&#21442;&#38598;&#21512;&#30340; ZooAnimal &#26500;&#36896;&#20989;&#25968;&#12290;&#26356;&#21152;&#31967;&#31957;&#30340;&#26159;&#65292;&#22312;&#25105;&#20204;&#30340;&#20363;&#23376;&#20013;&#65292;&#36825;&#20010;&#34987;&#29992;&#20316;&#31185;&#30446;&#21517;&#65288;name&#65289;&#30340;&#23454;&#21442;&#19981;&#20294;&#19981;&#30456;&#21516;&#65292;&#32780;&#19988;&#23545; Panda &#31867;&#26080;&#25928;&#12290;</p>
<p>&#22312;&#38750;&#34394;&#25311;&#27966;&#29983;&#20013;&#65292;&#27966;&#29983;&#31867;&#21482;&#33021;&#26174;&#24335;&#21021;&#22987;&#21270;&#20854;&#30452;&#25509;&#22522;&#31867;&#12290;&#20363;&#22914;&#65292;&#22312; ZooAnimal &#30340;&#38750;&#34394;&#25311;&#27966;&#29983;&#20013;&#65292;Panda &#31867;&#19981;&#33021;&#22312; Panda &#25104;&#21592;&#21021;&#22987;&#21270;&#34920;&#20013;&#30452;&#25509;&#35843;&#29992; ZooAnimal &#30340;&#26500;&#36896;&#20989;&#25968;&#12290;&#28982;&#32780;&#65292;&#22312;&#34394;&#25311;&#27966;&#29983;&#20013;&#65292;&#21482;&#26377; Panda &#21487;&#20197;&#30452;&#25509;&#35843;&#29992;&#20854; ZooAnimal &#34394;&#25311;&#22522;&#31867;&#30340;&#26500;&#36896;&#20989;&#25968;&#12290;</p>
<p>&#34394;&#25311;&#22522;&#31867;&#30340;&#21021;&#22987;&#21270;&#21464;&#25104;&#20102;&#26368;&#32456;&#27966;&#29983;&#31867;&#30340;&#36131;&#20219;&#65292;&#36825;&#20010;&#26368;&#32456;&#27966;&#29983;&#31867;&#26159;&#30001;&#27599;&#20010;&#29305;&#23450;&#31867;&#23545;&#35937;&#30340;&#22768;&#26126;&#26469;&#20915;&#23450;&#30340;&#12290;</p>
<p><a href="http://blog.csdn.net/skiing_886/article/details/7933402">&#20851;&#20110; C++ &#20013;&#30340;&#34394;&#25311;&#32487;&#25215;&#30340;&#19968;&#20123;&#24635;&#32467; - skiing_886 &#30340;&#19987;&#26639; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></p>
<p><a href="http://blog.chinaunix.net/uid-26722078-id-3484674.html">&#35814;&#35299;C++&#34394;&#25311;&#32487;&#25215;-iWonderLinux-ChinaUnix&#21338;&#23458;</a></p>
<p>class &#30340;&#34394;&#20989;&#25968;&#34920;&#34987;&#30772;&#22351;&#26159;&#19981;&#21487;&#33021;&#30340;&#65292;&#22240;&#20026;&#36825;&#20010; vtable &#26159;&#25918;&#22312; rodata &#21306;&#65292;&#26159;&#21482;&#35835;&#30340;&#12290;&#20462;&#25913; vtable &#20250;&#23548;&#33268; segment fault&#65292;&#36825;&#26679;&#25343; coredump &#19968;&#30475;&#23601;&#30693;&#36947;&#21738;&#26465;&#35821;&#21477;&#22312;&#24178;&#22351;&#20107;&#12290;</p>
<p>class object &#37324;&#30340; vptr &#34987;&#20462;&#25913;&#20498;&#26159;&#26377;&#21487;&#33021;&#12290;</p>
<p>Some Useful Code Tips</p>
<ul>
<li>&#22810;&#21152; assert&#65292;&#36991;&#20813;&#26410;&#26399;&#26395;&#30340;&#34892;&#20026;&#36867;&#36920;</li>
<li>&#36991;&#20813;&#21407;&#29983;&#30340; new &#19982; delete&#65292;&#20351;&#29992;&#26234;&#33021;&#25351;&#38024;</li>
<li>&#24536;&#35760; C &#30340;&#32534;&#30721;&#26041;&#24335;&#65292;&#20351;&#29992; C++</li>
</ul>
<p>&#26126;&#30333;&#24322;&#24120;&#30340;&#24320;&#38144;&#65292;&#33509;&#19981;&#20250;&#21457;&#29983;&#24322;&#24120;&#65292;&#21152;&#19978; noexcept&#12290;</p>
<p>&#20026;&#20320;&#30340;&#31867;&#21152;&#20837; move &#26500;&#36896;&#20989;&#25968;&#19982; move &#36171;&#20540;&#25805;&#20316;&#31526;</p>
<p>&#25351;&#38024;&#26159;&#32534;&#35793;&#22120;&#20248;&#21270;&#30340;&#8220;&#19975;&#24694;&#20043;&#28304;&#8221;&#65292;&#20351;&#29992; restrict &#32771;&#34385;&#24110;&#21161;&#32534;&#35793;&#22120;&#20570; Pointer Alias &#20248;&#21270;&#12290;</p>
<p><a href="https://www.zhihu.com/question/27459122">&#20026;&#20160;&#20040; bs &#34394;&#20989;&#25968;&#34920;&#30340;&#22320;&#22336; <code>(int*)(&amp;bs)</code> &#19982;&#34394;&#20989;&#25968;&#22320;&#22336; <code>(int*)*(int*)(&amp;bs)</code> &#19981;&#26159;&#21516;&#19968;&#20010;&#65311; - &#30693;&#20046;</a></p>
<p><a href="https://www.zhihu.com/question/29256578/answer/43725188">&#19968;&#36947;&#38463;&#37324;&#23454;&#20064;&#29983;&#31508;&#35797;&#39064;&#30340;&#30097;&#24785;&#65311; - RednaxelaFX &#30340;&#22238;&#31572; - &#30693;&#20046;</a></p>
<p>memory locality</p>
<ul>
<li><dl>
<dt><a href="http://www.math.pku.edu.cn/teachers/qiuzy/c/reading/pitfall.htm" class="featured heart">Pitfalls of C</a> <code class="fold">@</code></dt>
<dd><p>&#36825;&#20070;&#23621;&#28982;&#22312;&#32593;&#19978;&#30452;&#25509;&#25918;&#30528;&#65288;&#20854;&#23454;&#32771;&#30740;&#22797;&#35797;&#37027;&#27573;&#26102;&#38388;&#25105;&#30475;&#23436;&#20102;&#65292;&#26377;&#26102;&#38388;&#20877;&#30475;&#19968;&#19979;&#65292;note some&#65289;</p>
<p>SHIT.</p>
<p>The C language is like a carving knife: simple, sharp, and extremely useful in skilled hands. Like any sharp tool, C can injure people who don&#8217;t know how to handle it.</p>
<p>Once we know how to declare the variable, we know how to cast a constant to that type: just drop the name from the variable declaration. Thus, we cast 0 to a &#8220;pointer to function returning void&#8217;&#8217; by saying:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">(<span class="dt">void</span>(*)())<span class="dv">0</span></code></pre></div>
<p>and we can now replace fp by (void(*)())0:</p>
<p><code>(*(void(*)())0)();</code></p>
<p>The semicolon on the end turns the expression into a statement. and we can now replace <code>fp</code> by <code>(void(*)())0</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> (flags &amp; FLAG != <span class="dv">0</span>) ...  <span class="co">//  if (flags &amp; (FLAG != 0)) ...</span>
r = h&lt;&lt;<span class="dv">4</span> + l;               <span class="co">//  r = h &lt;&lt; (4 + l);</span></code></pre></div>
<p>One way to avoid these problems is to parenthesize everything, but expressions with too many parentheses are hard to understand, so it is probably useful to try to remember the precedence levels in C. Unfortunately, there are fifteen of them, so this is not always easy to do. It can be made easier, though, by classifying them into groups.</p>
<p>The operators that bind the most tightly are the ones that aren&#8217;t really operators: subscripting, function calls, and structure selection. These all associate to the left.</p>
<p>Next come the unary operators. These have the highest precedence of any of the true operators. Because function calls bind more tightly than unary operators, you must write <code>(*p)()</code> to call a function pointed to by <code>p</code>; <code>*p()</code> implies that <code>p</code> is a function that returns a pointer. Casts are unary operators and have the same precedence as any other unary operator. Unary operators are right-associative, so <code>*p++</code> is interpreted as <code>*(p++)</code> and not as <code>(*p)++</code>.</p>
<p>Next come the true binary operators. The arithmetic operators have the highest precedence, then the shift operators, the relational operators, the logical operators, the assignment operators, and finally the conditional operator. The two most important things to keep in mind are:</p>
<ol style="list-style-type: decimal">
<li>Every logical operator has lower precedence than every relational operator.</li>
<li>The shift operators bind more tightly than the relational operators but less tightly than the arithmetic operators.</li>
</ol>
<p>Within the various operator classes, there are few surprises. Multiplication, division, and remainder have the same precedence, addition and subtraction have the same precedence, and the two shift operators have the same precedence.</p>
</dd>
</dl></li>
<li><a href="https://www.amazon.cn/gp/product/B005LAJ9F6/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;creative=3132&amp;creativeASIN=B005LAJ9F6&amp;linkCode=as2&amp;tag=lucida-23">&#12298;C &#35821;&#35328;&#25509;&#21475;&#19982;&#23454;&#29616;: &#21019;&#24314;&#21487;&#37325;&#29992;&#36719;&#20214;&#30340;&#25216;&#26415;&#12299; David R. Hanson, &#37101;&#26093;&#12304;&#25688;&#35201; &#20070;&#35780; &#35797;&#35835;&#12305;&#22270;&#20070;</a></li>
<li><a href="https://en.wikipedia.org/wiki/Generic_programming">Generic programming - Wikipedia, the free encyclopedia</a></li>
<li><a href="http://www.serpentine.com/blog/2011/06/29/here-be-dragons-advances-in-problems-you-didnt-even-know-you-had/">Here be dragons: advances in problems you didn&#8217;t even know you had | teideal glic deisbh&#233;alach</a></li>
<li><a href="https://notabug.org/koz.ross/awesome-c">awesome-c - NotABug.org: Free code hosting</a></li>
</ul>
</dd>
</dl></li>
</ul>
<p><a href="https://www.zhihu.com/question/35050138">c++&#37324;&#22914;&#20309;&#29702;&#35299;vector&#26159;&#21160;&#24577;&#25968;&#32452;&#65292;&#32780;&#36825;&#20010;&#21333;&#35789;&#26412;&#20041;&#26159;&#21521;&#37327;&#65311;&#20026;&#20160;&#20040;&#36825;&#20040;&#21483;&#65311; - &#30693;&#20046;</a></p>
<p>&#27604;&#22914;&#24819;&#24403;&#28982;&#22320;&#25226; C &#37324;&#30340;&#31867;&#20284;&#30693;&#35782;&#20195;&#20837; C++&#65292;&#32467;&#26524;&#20889;&#20986;&#26377;&#38382;&#39064;&#20195;&#30721;&#30340;&#65306;</p>
<p>int *p = new int; if (p == nullptr) { // &#38169;&#35823;&#22788;&#29702; }</p>
<p>&#23454;&#38469;&#19978;&#27704;&#36828;&#19981;&#21487;&#33021;&#21040;&#36798;&#38169;&#35823;&#22788;&#29702;&#65292;&#22240;&#20026; new &#22833;&#36133;&#19981;&#36820;&#22238; nullptr&#65292;&#32780;&#26159;&#25243;&#24322;&#24120;&#12290;</p>
<hr />
<p>&#26512;&#26500;&#20989;&#25968;&#26159;&#29305;&#21035;&#30340;&#25104;&#21592;&#20989;&#25968;&#65292;&#34892;&#20026;&#21644;&#19968;&#33324;&#25104;&#21592;&#20989;&#25968;&#19981;&#19968;&#26679;&#12290;</p>
<p>&#38382;&#39064;&#20013;&#35848;&#21040;&#19968;&#33324;&#25104;&#21592;&#20989;&#25968;&#38656;&#35201;&#26377;&#30456;&#21516;&#30340;&#31614;&#21517;&#65288;&#38500;&#36820;&#22238;&#31867;&#22411;&#65289;&#65292;&#36825;&#26159;&#22240;&#20026;&#19968;&#20010;&#31867;&#21487;&#33021;&#26377;&#22810;&#20010;&#34394;&#20989;&#25968;&#65292;&#38656;&#20197;&#27492;&#35268;&#21017;&#21435;&#21305;&#37197;&#31867;&#23618;&#27425;&#26550;&#26500;&#20013;&#21738;&#20123;&#26159;&#21516;&#19968;&#32452;&#34394;&#20989;&#25968;&#12290;&#32780;&#27599;&#20010;&#31867;&#21482;&#33021;&#26377;&#19968;&#20010;&#26512;&#26500;&#20989;&#25968;&#65292;&#21305;&#37197;&#19981;&#25104;&#38382;&#39064;&#12290;</p>
<p>&#22914;&#26524;&#23450;&#20041;C++&#35821;&#27861;&#26102;&#65292;&#26512;&#26500;&#20989;&#25968;&#19981;&#26159;&#21629;&#21517;&#20026;<sub>className()&#65292;&#32780;&#26159;&#36873;&#25321;&#25152;&#26377;&#31867;&#37117;&#30456;&#21516;&#30340;&#21517;&#23383;&#65292;&#22914;</sub>()&#65292;&#24212;&#35813;&#20063;&#19981;&#20250;&#36896;&#25104;&#38382;&#39064;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="https://www.zhihu.com/question/36083262">C++&#20013;&#34394;&#26512;&#26500;&#20989;&#25968;&#65288;virtual destructor&#65289;&#30340;&#20989;&#25968;&#21517;&#20026;&#20160;&#20040;&#21487;&#20197;&#19981;&#19968;&#26679;&#65311; - &#30693;&#20046;</a></li>
</ul>
<p><a href="http://en.cppreference.com/w/cpp/container/vector/emplace_back">std::vector::emplace_back - cppreference.com</a></p>
<p>: <code>cpp     template&lt; class... Args &gt;                           (since C++11)     void emplace_back( Args&amp;&amp;... args );     template&lt; class... Args &gt;                           (until C++17)     reference emplace_back( Args&amp;&amp;... args );             (since C++17)</code></p>
<pre><code>Appends a new element to the end of the container. The element is
constructed through `std::allocator_traits::construct`, which typically
**uses placement-new to construct the element in-place at the location** provided by
the container. The arguments `args...` are forwarded to the constructor as `std::forward&lt;Args&gt;(args)...`.

If the new `size()` is greater than `capacity()` then all iterators and
references (including the past-the-end iterator) are invalidated. Otherwise
only the past-the-end iterator is invalidated.

The following code uses emplace_back to append an object of type President
to a std::vector. It demonstrates how emplace_back forwards parameters to
the President constructor and shows how using emplace_back avoids the extra
copy or move operation required when using `push_back`.

&gt;   `emplace_back` avoids the extra copy or move operation required when using `push_back`.

```cpp
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

struct President
{
    std::string name;
    std::string country;
    int year;

    President(std::string p_name, std::string p_country, int p_year)
        : name(std::move(p_name)), country(std::move(p_country)), year(p_year)
    {
        std::cout &lt;&lt; &quot;I am being constructed.\n&quot;;
    }
    President(President&amp;&amp; other)
        : name(std::move(other.name)), country(std::move(other.country)), year(other.year)
    {
        std::cout &lt;&lt; &quot;I am being moved.\n&quot;;
    }
    President&amp; operator=(const President&amp; other) = default;
};

int main()
{
    std::vector&lt;President&gt; elections;
    std::cout &lt;&lt; &quot;emplace_back:\n&quot;;
    elections.emplace_back(&quot;Nelson Mandela&quot;, &quot;South Africa&quot;, 1994);

    std::vector&lt;President&gt; reElections;
    std::cout &lt;&lt; &quot;\npush_back:\n&quot;;
    reElections.push_back(President(&quot;Franklin Delano Roosevelt&quot;, &quot;the USA&quot;, 1936));

    std::cout &lt;&lt; &quot;\nContents:\n&quot;;
    for (President const&amp; president: elections) {
        std::cout &lt;&lt; president.name &lt;&lt; &quot; was elected president of &quot;
                  &lt;&lt; president.country &lt;&lt; &quot; in &quot; &lt;&lt; president.year &lt;&lt; &quot;.\n&quot;;
    }
    for (President const&amp; president: reElections) {
        std::cout &lt;&lt; president.name &lt;&lt; &quot; was re-elected president of &quot;
                  &lt;&lt; president.country &lt;&lt; &quot; in &quot; &lt;&lt; president.year &lt;&lt; &quot;.\n&quot;;
    }
}
```

```
emplace_back:
I am being constructed.

push_back:
I am being constructed.
I am being moved.

Contents:
Nelson Mandela was elected president of South Africa in 1994.
Franklin Delano Roosevelt was re-elected president of the USA in 1936.
```</code></pre>
<dl>
<dt><a href="http://en.cppreference.com/w/cpp/utility/pair/make_pair">std::make_pair - cppreference.com</a> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Defined in header &lt;utility&gt;

<span class="kw">template</span>&lt; <span class="kw">class</span> T1, <span class="kw">class</span> T2 &gt;                      (until C+<span class="dv">+11</span>)
std::pair&lt;T1,T2&gt; make_pair( T1 t, T2 u );
<span class="kw">template</span>&lt; <span class="kw">class</span> T1, <span class="kw">class</span> T2 &gt;                      (since C+<span class="dv">+11</span>)
std::pair&lt;V1,V2&gt; make_pair( T1&amp;&amp; t, T2&amp;&amp; u );
<span class="kw">template</span>&lt; <span class="kw">class</span> T1, <span class="kw">class</span> T2 &gt;                      (until C+<span class="dv">+14</span>)
<span class="kw">constexpr</span> std::pair&lt;V1,V2&gt; make_pair( T1&amp;&amp; t, T2&amp;&amp; u );</code></pre></div>
<p>Creates a <code>std::pair</code> object, deducing the target type from the types of arguments.</p>
<p>The deduced types V1 and V2 are <code>std::decay&lt;T1&gt;::type</code> and <code>std::decay&lt;T2&gt;::type</code> (the usual type transformations applied to arguments of functions passed by value) unless application of <code>std::decay</code> results in <code>std::reference_wrapper&lt;X&gt;</code> for some type X, in which case the deduced type is <code>X&amp;</code>.</p>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/9270563/purpose-of-stdmake-pair">c++ - Purpose of std::make_pair - Stack Overflow</a></li>
</ul>
</dd>
</dl>
<p><a href="http://blog.csdn.net/zhangyifei216/article/details/50933104">&lt;<Effective C++>&gt;&#35835;&#20070;&#31508;&#35760;(&#19977;) - zyfforlinux - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></p>
<dl>
<dt><a href="https://www.zhihu.com/question/50697955#answer-44416899">&#22914;&#20309;&#22312;&#19968;&#20010;&#26376;&#20869;&#25552;&#39640; C++ &#27700;&#24179;? - &#30693;&#20046;</a> <code class="fold">@</code></dt>
<dd><p>&#8220;&#21734;&#65281;&#21407;&#26469;&#20320;&#35828;&#30340;&#26159; Two phase name look up mechanism &#21834;&#65281;&#65288;&#20572;&#39039;&#65289;&#23545;&#20110;&#36825;&#20010; Question&#65292;&#34429;&#28982; C++ 11&#65288;&#35835;&#20316;&#8220;&#20234;&#26469;&#38395;&#8221;&#65292;&#19981;&#35835;&#8220;&#23630;&#36951;&#8221;&#65292;&#19979;&#21516;&#65289; standard &#22312; Draft N3028&#65288;&#35835;&#20316;&#8220;&#29791;&#28155;&#33216;&#28155;&#35830;&#29305;&#8221;&#65292;&#19981;&#35835;&#8220;&#25955;&#34507;&#38463;&#29240;&#8221;&#65292;&#19979;&#21516;&#65289;&#26102;&#23601;&#24050;&#32463; final decision &#20102;&#65292; C++17 &#19978;&#23545;&#20110; Chapter 14&#65292;section 3.3.1 &#26465;&#27454; 5,7,15 &#19978;&#20570;&#20102;&#36827;&#19968;&#27493;&#35843;&#25972;&#65292;&#20294;&#26159;&#36804;&#20170;&#20026;&#27490;&#21508;&#23478; compiler vendor &#30340; implementation &#20173;&#28982; slighty difference&#12290;&#25152;&#20197;&#21487;&#33021;&#25105;&#20204;&#22312;&#19981;&#21516;&#30340; Compiler &#19978;&#37117;&#26159;&#23545;&#30340;&#12290;&#25105;&#30340;&#31572;&#26696;&#26159;&#22312; IBM XL C++ 13 &#19978;&#33719;&#24471;&#30340;&#65292;Linux Z&#65288;&#37325;&#38899;&#65289; System on Power 8&#65292;not MSVC on Windows x64&#65288;&#35835;&#20316;&#8220;&#22467;&#20811;&#26031;&#30862;&#20811;&#27515;&#22825;&#20315;&#8221;&#65292;&#19981;&#33021;&#35835;&#8220;&#25554;&#29275;&#23630;&#8221;&#65289;&#65292;you know&#12290;&#65288;&#20572;&#39039;&#65289;Our experience &#21487;&#33021;&#19981;&#22826;&#19968;&#26679;&#12290;&#25105;&#21018;&#21018;&#20180;&#32454;&#30340;&#32771;&#34385;&#36807;&#20320;&#30340; Result&#65292;&#24212;&#35813;&#26159; Make Sense &#30340;&#12290;&#20851;&#20110;&#36825;&#20010;&#38382;&#39064;&#30340;&#36827;&#19968;&#27493;&#35752;&#35770;&#65292;&#25105;&#24819;&#25105;&#20204;&#21487;&#20197;&#21442;&#32771;&#19968;&#19979; TCPL &#30340; 275 &#39029;&#65288;&#38543;&#20415;&#25253;&#20010;&#39029;&#25968;&#23601;&#21487;&#20197;&#20102;&#65292;&#27809;&#20154;&#20250;&#30495;&#21435;&#26597;&#30340;&#65289;&#12290;&#8221;</p>
<p>&#27880;&#24847;&#65292;&#19968;&#23450;&#35201;&#29992;&#33521;&#35821;&#65292;&#19968;&#23450;&#35201;&#33258;&#20449;&#12290;&#35828;&#20013;&#25991;&#23601;&#35828;&#19981;&#30693;&#36947;&#65292;&#27809;&#30475;&#36807;&#12290;99.99%&#30340;&#38754;&#35797;&#23448;&#19981;&#25954;&#35828;&#33258;&#24049;&#27809;&#21548;&#25026;&#12290;</p>
<p>&#25152;&#20197;&#24635;&#32467;&#19968;&#19979;&#65292;&#38754;&#35797;&#30340;&#26102;&#20505;&#20320;&#24590;&#20040;&#26679;&#24182;&#19981;&#35201;&#32039;&#65292;&#20320;&#21482;&#38656;&#35201;&#20570;&#21040;&#20197;&#19979;&#20960;&#28857;&#20013;&#30340;&#20219;&#24847;&#19968;&#26465;&#65306;</p>
<ol style="list-style-type: decimal">
<li>&#35753;&#38754;&#35797;&#23448;&#35273;&#24471;&#20320;&#25026;</li>
<li>&#21644;&#38754;&#35797;&#23448;&#30340;&#31572;&#26696;&#30456;&#21516;</li>
<li>&#35753;&#38754;&#35797;&#23448;&#35273;&#24471;&#20182;&#20063;&#19981;&#25026;</li>
</ol>
<p>&#36825;&#26679;&#23601;&#26159;&#19968;&#20010;&#25104;&#21151;&#30340;&#38754;&#35797;&#20102;&#12290;</p>
<p>&#160;&#160;&#33267;&#20110;&#20320;&#35828;&#36827;&#21435;&#20197;&#21518;&#24590;&#20040;&#21150;&#65292;&#21335;&#37101;&#20808;&#29983;&#30340;&#25925;&#20107;&#21548;&#36807;&#21527;&#12290;<br />
&#160;&#160;&#22914;&#26524;&#22823;&#23478;&#37117;&#29275;&#36924;&#65292;&#20063;&#23601;&#27809;&#20154;&#22312;&#20046;&#20320;&#26159;&#19981;&#26159;&#23630;&#12290;<br />
&#160;&#160;&#22914;&#26524;&#22823;&#23478;&#37117;&#19981;&#29275;&#36924;&#65292;&#37027;&#19968;&#22376;&#23630;&#20174;&#36947;&#24503;&#19978;&#23601;&#19981;&#33021;&#23244;&#24323;&#20854;&#20182;&#23630;&#12290;<br />
&#160;&#160;&#22914;&#26524;&#20048;&#22242;&#25286;&#20998;&#20102;&#65292;&#35760;&#20303;&#65292;&#19981;&#35201;&#21435;&#24403;&#20048;&#25163;&#20102;&#65292;&#35201;&#25552;&#21069;&#36716;&#22411;&#65292;&#24403;&#20048;&#22242;&#32769;&#26495;&#21543;&#12290;</p>
</dd>
</dl>
</div>
<script src="../lazyload.min.js"></script>
<script src="../jquery-3.0.0.min.js"></script>
<script src="../jquery.idTabs.min.js"></script>
<script src="../egg.min.js"></script>
<script src="../clipboard.min.js"></script>
<script src="../notes.js"></script>
</body>
</html>
