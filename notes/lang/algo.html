<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="author" content="district10" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Algorithms</title>
    <link rel="stylesheet" href="../github-markdown.css" type="text/css" />
    <link rel="stylesheet" href="../highlight.css" type="text/css" />
    <link rel="stylesheet" href="../notes.css" type="text/css" />
<!--<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>-->
    <script src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body class="markdown-body">
<a href="https://github.com/district10/notes">
    <img
        style="position: absolute; top: 0; right: 0; border: 0; width: 149px; height: 149px;"
        src="../fork-me-on-github.png" alt="Fork me on GitHub"></a>
<div id="navigator">
    <a id="gotoindex" href="index.html" title="&#12304;&#22238;&#21040;&#31508;&#35760;&#32034;&#24341; | Back to Index&#12305;">&#9763;</a></div>
<span id="help">&#25353;&#19979; "h" &#33719;&#21462;&#39029;&#38754;&#24110;&#21161;&#12290;</span>
<div id="main-body">
<h1 id="algorithms">Algorithms</h1>
<blockquote>
<p>&#21516;&#26679;&#21160;&#20316;&#37325;&#22797; 300 &#27425;&#65292;&#32908;&#32905;&#23601;&#20250;&#26377;&#35760;&#24518;&#65292;&#32780;&#19968;&#20010;&#21160;&#20316;&#37325;&#22797; 600 &#27425;&#65292;&#33034;&#26894;&#23601;&#20250;&#26377;&#35760;&#24518;&#12290;</p>
<p>&#8212; &#26446;&#23567;&#40857;</p>
</blockquote>
<dl>
<dt>ASCII table <code class="fold">@</code></dt>
<dd><pre><code>                         +------------------------------------------+
                         |  SP      &quot;               &amp;   &#39;   (   )   |
                         |  )   !   @   #   $   %   ^   &amp;   *   (   |
                         |  0   1   2   3   4   5   6   7   8   9   |
                         +--|---------------------------------------+
                            |
                            |                                           aqaq @ grave
  0         16      32      |48     64      80      96      112
  00        10      20      |30     40      50      60      70
                            |       &#38463;      &#21345;      &#29747;      &#37233;
  NULL     DEL      SP      0       @       P       `       p           |   &lt;-------------- 0
                     !      1       A       Q       a       q           |   &lt;-------------- 1
                     &quot;      2                                           |   &lt;-------------- 2
                     .      .                                           |   &lt;-------------- .
------------------------------------------------------------------------+
    0       1       2       3       4       5       6       7</code></pre>
<pre><code>Usage: ascii [-dxohv] [-t] [char-alias...]
   -t = one-line output  -d = Decimal table  -o = octal table  -x = hex table
   -h = This help screen -v = version information
Prints all aliases of an ASCII character. Args may be chars, C \-escapes,
English names, ^-escapes, ASCII mnemonics, or numerics in decimal/octal/hex.

Dec Hex    Dec Hex    Dec Hex  Dec Hex  Dec Hex  Dec Hex   Dec Hex   Dec Hex
  0 00 NUL  16 10 DLE  32 20    48 30 0  64 40 @  80 50 P   96 60 `  112 70 p
  1 01 SOH  17 11 DC1  33 21 !  49 31 1  65 41 A  81 51 Q   97 61 a  113 71 q
  2 02 STX  18 12 DC2  34 22 &quot;  50 32 2  66 42 B  82 52 R   98 62 b  114 72 r
  3 03 ETX  19 13 DC3  35 23 #  51 33 3  67 43 C  83 53 S   99 63 c  115 73 s
  4 04 EOT  20 14 DC4  36 24 $  52 34 4  68 44 D  84 54 T  100 64 d  116 74 t
  5 05 ENQ  21 15 NAK  37 25 %  53 35 5  69 45 E  85 55 U  101 65 e  117 75 u
  6 06 ACK  22 16 SYN  38 26 &amp;  54 36 6  70 46 F  86 56 V  102 66 f  118 76 v
  7 07 BEL  23 17 ETB  39 27 &#39;  55 37 7  71 47 G  87 57 W  103 67 g  119 77 w
  8 08 BS   24 18 CAN  40 28 (  56 38 8  72 48 H  88 58 X  104 68 h  120 78 x
  9 09 HT   25 19 EM   41 29 )  57 39 9  73 49 I  89 59 Y  105 69 i  121 79 y
 10 0A LF   26 1A SUB  42 2A *  58 3A :  74 4A J  90 5A Z  106 6A j  122 7A z
 11 0B VT   27 1B ESC  43 2B +  59 3B ;  75 4B K  91 5B [  107 6B k  123 7B {
 12 0C FF   28 1C FS   44 2C ,  60 3C &lt;  76 4C L  92 5C \  108 6C l  124 7C |
 13 0D CR   29 1D GS   45 2D -  61 3D =  77 4D M  93 5D ]  109 6D m  125 7D }
 14 0E SO   30 1E RS   46 2E .  62 3E &gt;  78 4E N  94 5E ^  110 6E n  126 7E ~
 15 0F SI   31 1F US   47 2F /  63 3F ?  79 4F O  95 5F _  111 6F o  127 7F DEL</code></pre>
<div class="figure">
<img src="http://whudoc.qiniudn.com/ascii.png" />

</div>
</dd>
<dt>Cheatsheet <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// misc</span>

    <span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// typedef</span>

    <span class="kw">typedef</span> <span class="dt">int</span> Point;
    <span class="kw">typedef</span> <span class="kw">struct</span> { Point x, y; } Point2d;
    <span class="kw">typedef</span> Point2d Triangle[<span class="dv">3</span>];    <span class="co">// Triangle tri;    // 6 ints inside</span>
    <span class="kw">typedef</span> Point2d (*FuncPtr)( Point2d p1, Point2d p2 );

<span class="co">// pointers</span>

    <span class="dt">int</span> *array = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">5</span>];
    <span class="kw">delete</span>[] array;

    <span class="dt">int</span> *i = <span class="kw">new</span> <span class="dt">int</span>;
    <span class="kw">delete</span> i;

<span class="co">// vector</span>

    <span class="ot">#include &lt;vector&gt;</span>
    vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; mat( row, vector&lt;<span class="dt">int</span>&gt;(col, <span class="dv">0</span>) );
    vector&lt;<span class="dt">int</span>&gt; vec;
    vec.reserve(<span class="dv">10</span>);
    vec.resize(<span class="dv">5</span>);
    vec.clear();
    vector&lt;<span class="dt">int</span>&gt;().swap(vec);

<span class="co">// char manip</span>

    <span class="ot">#include &lt;ctype&gt;</span>
    <span class="dt">int</span> isalnum(    <span class="dt">int</span> c   );
    <span class="dt">int</span> isalpha(    <span class="dt">int</span> c   );
    <span class="dt">int</span> isascii(    <span class="dt">int</span> c   );
    <span class="dt">int</span> isblank(    <span class="dt">int</span> c   );
    <span class="dt">int</span> iscntrl(    <span class="dt">int</span> c   );
    <span class="dt">int</span> isdigit(    <span class="dt">int</span> c   );
    <span class="dt">int</span> isgraph(    <span class="dt">int</span> c   );
    <span class="dt">int</span> isprint(    <span class="dt">int</span> c   );
    <span class="dt">int</span> ispunct(    <span class="dt">int</span> c   );
    <span class="dt">int</span> isspace(    <span class="dt">int</span> c   );
    <span class="dt">int</span> isxdigit(   <span class="dt">int</span> c   );

<span class="co">// equal?</span>

    <span class="dt">int</span> i;
    i%<span class="dv">2</span> == <span class="dv">0</span>
    i%<span class="dv">2</span> != <span class="dv">0</span>

    <span class="dt">double</span> a, b;
    fabs(a-b) &lt; <span class="fl">1e-9</span>

<span class="co">// memory</span>

    <span class="ot">#include &lt;stdlib.h&gt;                 </span><span class="co">// malloc</span>
    <span class="ot">#include &lt;string.h&gt;                 </span><span class="co">// memcpy</span>
    malloc( size    );
    calloc( nmemb, size );
    realloc(  ptr, size );
    free(   ptr     );

    memset( buf, value, numbytes );
    memcpy( dst, src, size );
    <span class="dt">int</span> strcmp(     s1,     s2  );
    <span class="dt">int</span> strncmp(    s1,     s2,     n );
    <span class="dt">char</span> *strcpy(   <span class="dt">char</span> *dest, <span class="dt">const</span> <span class="dt">char</span> *src );
    <span class="dt">char</span> *strncpy(  <span class="dt">char</span> *dest, <span class="dt">const</span> <span class="dt">char</span> *src, size_t n );

        <span class="dt">char</span> buf1[<span class="dv">9</span>] = <span class="st">&quot;01234567&quot;</span>;
        <span class="dt">char</span> buf2[<span class="dv">6</span>] = <span class="st">&quot;abcde&quot;</span>;
        strncpy( buf1, buf2, <span class="dv">4</span> );
        printf( <span class="st">&quot;</span><span class="ch">%s\n</span><span class="st">&quot;</span>, buf1 ); <span class="co">// &quot;abcd4567&quot;</span>

       <span class="dt">char</span> * strncpy( <span class="dt">char</span> *dest, <span class="dt">const</span> <span class="dt">char</span> *src, size_t n ) {
           <span class="co">// at most n char will be altered</span>
           size_t i;
           <span class="kw">for</span>( i = <span class="dv">0</span>; i &lt; n &amp;&amp; src[i] != <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>; ++i ) {
               dest[i] = src[i];
           }
           <span class="kw">for</span>( ; i &lt; n; ++i ) {
               dest[i] = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>;
           }
           <span class="kw">return</span> dest;
       }

    <span class="dt">char</span> *strchr(   <span class="dt">const</span> <span class="dt">char</span> *s, <span class="dt">int</span> c );
    <span class="dt">char</span> *strrchr(  <span class="dt">const</span> <span class="dt">char</span> *s, <span class="dt">int</span> c );

    memcmp( s1, s2, nbytes ); <span class="co">// -1, 0, 1</span>

<span class="co">// file io</span>

    <span class="ot">#include &lt;stdio.h&gt;</span>
    FILE *fp = fopen(filename, <span class="st">&quot;r&quot;</span>);
    <span class="kw">while</span>( <span class="dv">2</span> == fscanf( fp, <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%s</span><span class="st">&quot;</span>, &amp;index, buf ) ) { ... }
    fclose(fp);
    size_t fread(        <span class="dt">void</span> *ptr, size_t size, size_t nmemb, FILE *stream );
    size_t fwrite( <span class="dt">const</span> <span class="dt">void</span> *ptr, size_t size, size_t nmemb, FILE *stream );

    <span class="ot">#include &lt;fstream&gt;</span>
    ifstream file( filename.c_str(), ifstream::in );
    ifstream file;
    file.open( filename.c_str(), ifstream::in );
    <span class="kw">if</span> ( !file )                    { ... }
    <span class="kw">if</span> ( !file.is_open() )          { ... }

    string line;
    <span class="kw">while</span> ( getline(file, line) )   { ... }
    sort( line.begin(), line.end() );

    string s( n, <span class="st">&#39;0&#39;</span> );

    ofstream file;
    file.open( <span class="st">&quot;example.txt&quot;</span> );
    file &lt;&lt; <span class="st">&quot;Writing this to a file.</span><span class="ch">\n</span><span class="st">&quot;</span>;
    file.close();

<span class="co">// string</span>

    sscanf( string.c_str(), format, ...)
    <span class="dt">int</span> fscanf ( FILE * stream, <span class="dt">const</span> <span class="dt">char</span> * format, ... );
    fgets( buf, <span class="kw">sizeof</span>(buf), stdin );
    sprintf( str, %d<span class="st">&quot;, num );</span>

    <span class="ot">#include &lt;sstream&gt;</span>
    string input;
    istringstream stream(input);
    <span class="kw">while</span>( stream &gt;&gt; i ) { ... }

    string output;
    ostringstream ss;
    ss &lt;&lt; i &lt;&lt; d &lt;&lt; s;
    output = ss.str();

<span class="co">// atoi, etc</span>

    <span class="ot">#include &lt;stdlib.h&gt;</span>
    <span class="dt">double</span>      atof(  <span class="dt">const</span> <span class="dt">char</span> *str );
    <span class="dt">int</span>         atoi(  <span class="dt">const</span> <span class="dt">char</span> *str );
    <span class="dt">long</span>        atol(  <span class="dt">const</span> <span class="dt">char</span> *str );
    <span class="dt">long</span> <span class="dt">long</span>   atoll( <span class="dt">const</span> <span class="dt">char</span> *str );

<span class="co">// stl</span>

    fill(   v.begin(),  v.end(),    <span class="dv">-1</span> );
    fill_n( v.begin(),  v.size(),   <span class="dv">-1</span> );
    fill_n( &amp;v[<span class="dv">0</span>],      v.size(),   <span class="dv">-1</span> );

    reverse_iterator&lt;string::iterator&gt;  r = s.rbegin(); ++r;
    string::reverse_iterator            r = s.rbegin(); ++r;

    <span class="kw">for</span> (<span class="kw">auto</span> i : v)
    <span class="kw">for</span> (<span class="kw">auto</span> <span class="dt">const</span> &amp;n : nums)

    vector&lt;<span class="dt">char</span>&gt; vec( str.begin(), str.end() );

    binary_search( haystack.begin(), haystack.end(), needle) );
    search( haystack.begin(), haystack.end(), needles.begin(), needles.end() ) != haystack.end();

    <span class="dt">int</span> i = <span class="dv">32</span>;
    vector&lt;<span class="dt">int</span>&gt; vi = { <span class="dv">10</span>, <span class="dv">21</span>, <span class="dv">32</span>, <span class="dv">43</span> };
    <span class="kw">auto</span> it1 = search( vi.begin(), vi.end(), &amp;i, &amp;i<span class="dv">+1</span> );
    printf( <span class="st">&quot;index: </span><span class="ch">%d</span><span class="st">, value: </span><span class="ch">%d\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>)distance(vi.begin(), it1), *it1 );
    <span class="co">//  index: 2, value: 32</span>

    string s = <span class="st">&quot;two&quot;</span>;
    vector&lt;string&gt; vs = { <span class="st">&quot;zero&quot;</span>, <span class="st">&quot;one&quot;</span>, <span class="st">&quot;two&quot;</span>, <span class="st">&quot;three&quot;</span> };
    <span class="kw">auto</span> it2 = search( vs.begin(), vs.end(), &amp;s, &amp;s<span class="dv">+1</span> );
    printf( <span class="st">&quot;index: </span><span class="ch">%d</span><span class="st">, value: </span><span class="ch">%s\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>)distance(vs.begin(), it2), it2-&gt;c_str() );
    <span class="co">//  index: 2, value: two</span>

    <span class="kw">struct</span> Sum {
        Sum(): sum{<span class="dv">0</span>} { }
        <span class="dt">void</span> <span class="kw">operator</span>()(<span class="dt">int</span> n) { sum += n; }
        <span class="dt">int</span> sum;
    };
    vector&lt;<span class="dt">int</span>&gt; nums{<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>};
    for_each( nums.begin(), nums.end(), [](<span class="dt">int</span> &amp;n){ n++; } );   <span class="co">// 2, 3, 6</span>
    Sum s = for_each( nums.begin(), nums.end(), Sum() );
    <span class="dt">int</span> s = for_each( nums.begin(), nums.end(), Sum() ).sum;    <span class="co">// 11</span>

    min( <span class="dv">1</span>, <span class="dv">9999</span> );
    max( <span class="dv">1</span>, <span class="dv">9999</span> );
    pair&lt;<span class="dt">const</span> T&amp;, <span class="dt">const</span> T&amp;&gt; minmax( <span class="dt">const</span> T&amp; a, <span class="dt">const</span> T&amp; b, Compare comp );

    vector&lt;<span class="dt">int</span>&gt;::iterator result = max_element( v.begin(), v.end() );
    <span class="dt">int</span> idx = distance( v.begin(), result );
    <span class="dt">int</span> val = v[idx];

    <span class="dt">int</span> nums[<span class="dv">50</span>];
    <span class="dt">int</span> highest = *max_element( nums, nums<span class="dv">+50</span> );

    <span class="kw">auto</span> iter = prev( it, <span class="dv">2</span> );
    <span class="kw">auto</span> iter = next( it, <span class="dv">2</span> );
    advance( it, <span class="dv">2</span> );

    swap( a, b );

    partial_sum( first, last, d_first );

    <span class="kw">for</span>( deque&lt;<span class="dt">int</span>&gt;::iterator it = q.begin(); it != q.end(); ++it )
        cout &lt;&lt; *it &lt;&lt; endl;
    }

    <span class="ot">#include &lt;iterator&gt;</span>
    <span class="kw">auto</span> lower = lower_bound(data.begin(), data.end(), <span class="dv">4</span>);
    <span class="kw">auto</span> upper = upper_bound(data.begin(), data.end(), <span class="dv">4</span>);
    copy(lower, upper, std::ostream_iterator&lt;<span class="dt">int</span>&gt;(std::cout, <span class="st">&quot; &quot;</span>));

    transform( s.begin(), s.end(), s.begin(), [](<span class="dt">unsigned</span> <span class="dt">char</span> c) { <span class="kw">return</span> toupper(c); } );

    str1.erase( remove(str1.begin(), str1.end(), <span class="st">&#39; &#39;</span>), str1.end() );
    <span class="kw">auto</span> last = unique(v.begin(), v.end());
    v.erase( last, v.end() );

    <span class="co">// stack</span>
        <span class="ot">#include &lt;stack&gt;</span>
        stack&lt;<span class="dt">int</span>&gt; s;
        s.push( <span class="dv">7</span> );
        s.pop();
        s.top();
        <span class="kw">for</span>( stack&lt;<span class="dt">int</span>&gt; dump = s; !dump.empty(); dump.pop() ) {
            cout &lt;&lt; dump.top() &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
        }

    <span class="co">// queue</span>
        <span class="ot">#include &lt;functional&gt;                                           </span><span class="co">// std::greater</span>
        <span class="ot">#include &lt;queue&gt;</span>

        <span class="co">// priority_queue</span>
        priority_queue&lt;<span class="dt">int</span>&gt; pq;
        priority_queue&lt;<span class="dt">int</span>, std::vector&lt;<span class="dt">int</span>&gt;, std::greater&lt;<span class="dt">int</span>&gt; &gt; pq;   <span class="co">// default is less&lt;T&gt;</span>
        pq.push( <span class="dv">7</span> );                                                   <span class="co">// like stack</span>
        pq.pop();
        pq.top();

        <span class="co">// queue</span>
        queue&lt;<span class="dt">int</span>&gt; q;
        q.push( <span class="dv">7</span> );
        q.pop();
        q.front();      q.back();

    <span class="co">// set</span>
        <span class="co">// set</span>
        <span class="ot">#include &lt;set&gt;</span>
        set&lt;<span class="dt">int</span>&gt; s;
        s.insert( <span class="dv">5</span> );
        s.erase(  <span class="dv">5</span> );
        <span class="kw">for</span>( <span class="kw">auto</span> i : s ) { cout &lt;&lt; i &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>; }
        <span class="kw">for</span>( set&lt;<span class="dt">int</span>&gt;::iterator it = s.begin(); it != s.end(); ++it ) { cout &lt;&lt; *it &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>; }


        <span class="co">// unoreder_set</span>
        <span class="ot">#include &lt;unordered_set&gt;</span>
        unordered_set&lt;<span class="dt">int</span>&gt; us;
        us.insert( <span class="dv">5</span> );
        us.erase(  <span class="dv">5</span> );
        <span class="kw">for</span>( <span class="kw">auto</span> i : s ) { cout &lt;&lt; i &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>; }
        <span class="kw">for</span>( unordered_set&lt;<span class="dt">int</span>&gt;::iterator it = s.begin(); it != s.end(); ++it ) { cout &lt;&lt; *it &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>; }

    <span class="co">// map</span>
        <span class="co">// map</span>
        <span class="ot">#include &lt;map&gt;</span>
        map&lt;string, <span class="dt">int</span>&gt; m;
        ++m[key];       <span class="co">// &#31532;&#19968;&#27425;&#20351;&#29992;&#20063;&#19981;&#29992;&#21019;&#24314;&#65292;&#22240;&#20026;&#27809;&#26377;&#36825;&#20010; key &#30340;&#26102;&#20505;&#65292;&#20250;&#33258;&#21160;&#29983;&#25104;&#24182;&#25226; int &#21021;&#22987;&#21270;&#20026; 0&#12290;</span>
                        <span class="co">//                  std::map&lt;char, int&gt; m;</span>
                        <span class="co">//                  std::cout &lt;&lt; m[&#39;a&#39;] &lt;&lt; &quot;\n&quot;;    // 0</span>
                        <span class="co">//                  ++m[&#39;b&#39;];</span>
                        <span class="co">//                  std::cout &lt;&lt; m[&#39;b&#39;] &lt;&lt; &quot;\n&quot;;    // 1</span>
                        <span class="co">//                  m[&#39;c&#39;] = 5;</span>
                        <span class="co">//                  std::cout &lt;&lt; m[&#39;c&#39;] &lt;&lt; &quot;\n&quot;;    // 5</span>
        <span class="kw">if</span>( m.find(<span class="dv">2</span>) != m.end() )      { ... }
        <span class="kw">if</span>( m.count(<span class="dv">2</span>) )                { ...}

        map&lt;string, <span class="dt">int</span>&gt; m = {{<span class="st">&quot;one&quot;</span>, <span class="dv">1</span>}, {<span class="st">&quot;two&quot;</span>, <span class="dv">2</span>}};
        m[<span class="st">&quot;zero&quot;</span>];
        <span class="kw">for</span>( <span class="kw">auto</span> p : m ) { cout &lt;&lt; p.first &lt;&lt; <span class="st">&quot; -&gt; &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>; }
        <span class="kw">for</span>( map&lt;string, <span class="dt">int</span>&gt;::iterator it = m.begin(); it != m.end(); ++it ) { cout &lt;&lt; it-&gt;first &lt;&lt; <span class="st">&quot; -&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>; }

        <span class="co">// unordered_map</span>
        <span class="ot">#include &lt;unordered_map&gt;</span>
        unordered_map&lt;string, <span class="dt">int</span>&gt; m = {{<span class="st">&quot;one&quot;</span>, <span class="dv">1</span>}, {<span class="st">&quot;two&quot;</span>, <span class="dv">2</span>}};
        m[<span class="st">&quot;zero&quot;</span>];
        <span class="kw">for</span>( <span class="kw">auto</span> p : m ) { cout &lt;&lt; p.first &lt;&lt; <span class="st">&quot; -&gt; &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>; }
        <span class="kw">for</span>( unordered_map&lt;string, <span class="dt">int</span>&gt;::iterator it = m.begin(); it != m.end(); ++it ) { cout &lt;&lt; it-&gt;first &lt;&lt; <span class="st">&quot; -&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>; }

<span class="co">// flags</span>

    <span class="ot">#include &lt;climits&gt;</span>
    <span class="ot">#include &lt;cstddef&gt;</span>
    CHAR_MAX,                   UCHAR_MAX
    SHRT_MAX,                   USHRT_MAX
    INT_MAX,                    UINT_MAX
    LONG_MAX,                   ULONG_MAX
    LLONG_MAX,                  ULLONG_MAX
    DBL_MAX
    FLT_MAX</code></pre></div>
</dd>
<dt>FAQ <code class="fold">@</code></dt>
<dd><dl>
<dt>&#21047;&#39064;&#21047;&#21040;&#20160;&#20040;&#31243;&#24230;&#21487;&#20197;&#21435;&#38754;&#35797;&#20102;&#21602;&#65311;</dt>
<dd>lintcode 70% &#39064;&#30446;&#21047;&#20004;&#36941;&#65292; 60% &#39064;&#30446;&#20570;&#21040; bug free&#65292;&#23601;&#27604;&#36739;&#22909;&#21862;&#12290;
</dd>
<dt>&#21069;&#31471;&#24037;&#31243;&#24072; / &#25968;&#25454;&#31185;&#23398;&#23478;&#38656;&#35201;&#21047;&#39064;&#20040;&#65311;</dt>
<dd>&#24403;&#28982;&#38656;&#35201;&#21862;&#65292;60% &#32771;&#31639;&#27861;&#65292;40% &#32771;&#30456;&#20851;&#32972;&#26223;&#25216;&#26415;&#25110;&#39033;&#30446;&#32463;&#39564;&#12290;
</dd>
<dt>&#22312;&#21738;&#37324;&#21487;&#20197;&#25214;&#21040;&#38754;&#32463;?</dt>
<dd>glassdoor, &#19968;&#20137;&#19977;&#20998;&#22320;&#65292;themianjing.com, mitbbs&#65292;&#31561;&#31561;&#12290;
</dd>
<dt>&#20808;&#21047;&#39064;&#36824;&#26159;&#20808;&#30475;&#38754;&#32463;&#25423;&#65311;</dt>
<dd>&#19968;&#33324;&#24314;&#35758;&#20808;&#21047;&#19968;&#28857;&#39064;&#30446;&#65292;&#28982;&#21518;&#20877;&#21435;&#30475;&#38754;&#32463;&#12290;&#36825;&#26679;&#36731;&#26494;&#19968;&#28857;&#65292;&#36935;&#21040;&#20250;&#30340;&#39064;&#30446;&#23601;&#36339;&#36807;&#65292;&#19981;&#20250;&#30340;&#39064;&#30446;&#22909;&#22909;&#24819;&#19968;&#24819;&#65292;&#26102;&#38388;&#20801;&#35768;&#36824;&#21487;&#20197;&#23454;&#29616;&#19968;&#19979;&#12290;&#22914;&#26524;&#26102;&#38388;&#24456;&#32039;&#24352;&#20102;&#65292;&#24314;&#35758;&#19968;&#36793;&#21047;&#39064;&#19968;&#36793;&#30475;&#38754;&#32463;&#12290;
</dd>
<dt>&#21738;&#37324;&#21487;&#20197;&#25237;&#31616;&#21382;&#65311;&#25214;&#20869;&#25512;&#65311;</dt>
<dd><ul>
<li>&#25237;&#31616;&#21382;&#65306; indeed&#65292;monster, hired.com, linkedin, readyforce.com&#65292;&#20197;&#21450;&#21508;&#22823;&#20844;&#21496;&#23448;&#32593;&#12290;</li>
<li>&#25214;&#20869;&#25512;&#65306; mitbbs&#65292;&#19968;&#20137;&#19977;&#20998;&#22320;, linkedin</li>
</ul>
</dd>
</dl>
</dd>
<dt>TODOs &amp; Notes <code class="fold">@</code></dt>
<dd><ul>
<li><p><code>(left+right)/2</code> &#21644; <code>left + (right-left)/2</code> &#38500;&#20102;&#22312;&#36127;&#25968;&#30340;&#26102;&#20505;&#19981;&#21516;&#20043;&#22806;&#65292;&#21518;&#32773;&#36824;&#19981;&#20250;&#36234;&#30028;&#12290;</p></li>
<li><dl>
<dt>How to compile &amp;&amp; run</dt>
<dd><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># compile</span>
<span class="kw">g++</span> code.cpp -o code --std=c++11
<span class="co"># run</span>
<span class="kw">cat</span> input.txt <span class="kw">|</span> <span class="kw">./code</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>fib, fac <code class="fold">@</code></dt>
<dd><p>fibonacci. factorial.</p>
</dd>
</dl></li>
</ul>
</dd>
</dl>
<h2 id="section">0.</h2>
<dl>
<dt>&#25105;&#30340;&#31639;&#27861;&#23398;&#20064;&#20043;&#36335; - Lucida <code class="fold">@</code></dt>
<dd><p>&#22522;&#21451;&#22312;&#20154;&#20154;&#21457;&#30334;&#24230;&#23454;&#20064;&#20869;&#25512;&#36148;&#65292;&#24403;&#26102;&#33258;&#25105;&#24863;&#35273;&#29275;&#36924;&#38378;&#38378;&#25918;&#20809;&#33426;&#65292;&#20110;&#26159;&#23601;&#25265;&#30528;&#30475;&#30475;&#22269;&#20869; IT &#29615;&#22659; + &#34384;&#34384;&#38754;&#35797;&#23448;&#30340;&#21464;&#24577;&#24515;&#29702;&#25237;&#20102;&#31616;&#21382;&#65292;&#32467;&#26524;&#22312;&#31532;&#19968;&#38754;&#23601;&#33258;&#24049;&#30340;&#24072;&#20804;&#29190;&#20986;&#32724;&#65306;&#20182;&#35753;&#25105;&#20889;&#19968;&#20010; <code>stof</code>&#65288;&#23383;&#31526;&#20018;&#36716;&#28014;&#28857;&#25968;&#65289;&#65292;&#25105;&#30952;&#30952;&#21799;&#21799;&#21322;&#22825;&#20063;&#27809;&#20889;&#20986;&#23436;&#25972;&#23454;&#29616;&#65292;&#20043;&#21518;&#22238;&#21040;&#23487;&#33293;&#36214;&#24555;&#20889;&#20102;&#19968;&#20010;&#29256;&#26412;&#21457;&#21040;&#24072;&#20804;&#30340;&#37038;&#31665;&#65292;&#32467;&#26524;&#23545;&#26041;&#21387;&#26681;&#27809;&#40479;&#25105;&#12290;</p>
<p>&#36825;&#20214;&#20107;&#23545;&#25105;&#20135;&#29983;&#20102;&#24456;&#22823;&#30340;&#38663;&#21160;&#8212;&#8212;</p>
<ul>
<li>&#21407;&#26469;&#33258;&#24049;&#36830;&#30334;&#24230;&#23454;&#20064;&#38754;&#35797;&#37117;&#36807;&#19981;&#21435;&#12290;</li>
<li>&#21407;&#26469;&#33258;&#24049;&#36824;&#26159;&#19968;&#20010;<strong>&#32534;&#31243;&#24369;&#36924;</strong>&#12290;</li>
<li>&#21407;&#26469;&#33258;&#24049;&#36824;&#26159;&#19968;&#20010;<strong>&#31639;&#27861;&#33756;&#36924;</strong>&#12290;</li>
</ul>
<p>&#25105;&#20063;&#24456; happy&#65292;&#22240;&#20026;&#27809;&#24819;&#21040;&#33258;&#24049;&#20889;&#30340;&#24211;&#23621;&#28982;&#27604; MS &#30340;&#36824;&#35201;&#24555;&#20960;&#21313;&#20493;&#65292;&#21516;&#26102;&#23567;&#21313;&#20960;&#20493;&#12290;</p>
<p>&#20174;&#36825;&#20010;&#20107;&#24773;&#20043;&#21518;&#25105;&#21464;&#24471;&#29305;&#21035;&#29702;&#35299;&#37027;&#20123;&#36896;&#36718;&#23376;&#30340;&#20154;&#8212;&#8212;&#20320;&#35201;&#24819;&#24819;&#65292;&#22914;&#26524;&#20320;&#38656;&#35201;&#19968;&#20010;&#39134;&#26426;&#36718;&#23376;&#20294;&#24066;&#22330;&#19978;&#21482;&#26377;&#33258;&#34892;&#36710;&#36718;&#23376;&#32780;&#19988;&#32769;&#26495;&#36824;&#20652;&#30528;&#20320;&#20132;&#24037;&#65292;&#20320;&#33021;&#24590;&#20040;&#25630;&#12290;</p>
<p>&#23454;&#20064;&#23454;&#20064;&#30528;&#23601;&#21040;&#20102;&#30740;&#20108;&#26257;&#20551;&#65292;&#25509;&#19979;&#26469;&#23601;&#26159;&#27714;&#32844;&#23395;&#12290;</p>
<p>&#27714;&#32844;&#23395;&#26102;&#25105;&#26377;&#19968;&#31181;&#33707;&#21517;&#30340;&#22797;&#20167;&#24863;&#8212;&#8212;&#23612;&#29595;&#20043;&#21069;&#30334;&#24230;&#23454;&#20064;&#38754;&#35797;&#32769;&#23376;&#34987;&#20320;&#20204;&#40657;&#30340;&#28459;&#22825;&#39134;&#32724;&#65292;&#36825;&#22238;&#27714;&#32844;&#32769;&#23376;&#35201;&#25226;&#20320;&#20204;&#19968;&#20010;&#20010;&#40657;&#22238;&#26469;&#65292;&#23612;&#29595;&#12290;</p>
<p>&#29616;&#22312;&#22238;&#24819;&#24403;&#26102;&#30340;&#24515;&#29702;&#23454;&#23646;&#20667;&#36924; + &#24188;&#31258;&#65292;&#20294;&#36825;&#31181;&#40657;&#26263;&#24515;&#29702;&#20063;&#36215;&#20102;&#19968;&#23450;&#30340;&#31215;&#26497;&#20316;&#29992;&#65306;&#25105;&#19997;&#27627;&#19981;&#25954;&#26377;&#20219;&#20309;&#24608;&#24930;&#65292;&#20197;&#33267;&#20110;&#22312; 5 &#26376;&#20221;&#24213;&#25105;&#23601;&#24320;&#22987;&#20934;&#22791;&#27714;&#32844;&#31508;&#35797;&#38754;&#35797;&#65292;&#27604;&#36523;&#36793;&#30340;&#21516;&#23398;&#26089;&#20102;&#20004;&#20010;&#26376;&#19981;&#27490;&#12290;</p>
<p>&#25105;&#27809;&#26377;&#20687;&#36523;&#36793;&#30340;&#21516;&#23398;&#37027;&#33324;&#21047;&#39064;&#8212;&#8212;&#32780;&#26159;&#32487;&#32493;&#30475;&#20070;&#25220;&#20195;&#30721;&#23398;&#31639;&#27861;&#65292;&#22240;&#20026;&#25105;&#35748;&#20026;&#37027;&#20123;&#38590;&#24471;&#31163;&#35889;&#30340;&#39064;&#38754;&#35797;&#23448;&#20063;&#19981;&#20250;&#38382;&#8212;&#8212;&#20107;&#23454;&#19978;&#20063;&#26159;&#22914;&#27492;&#12290;</p>
<p><strong>&#32534;&#31243;&#29664;&#29585;</strong> &amp; &#26356;&#22810;&#30340;&#32534;&#31243;&#29664;&#29585;</p>
<p>&#27809;&#21548;&#35828;&#36807;&#36825;&#20004;&#26412;&#20070;&#35831;&#33258;&#34892;&#38754;&#22721;&#12290;&#21069;&#32773;&#20559;&#31639;&#27861;&#29702;&#35770;&#65292;&#21518;&#32773;&#20559;&#31639;&#27861;&#36726;&#20107;&#65292;&#21069;&#32773;&#25552;&#21319;&#33021;&#21147;&#65292;&#21518;&#32773;&#22686;&#38271;&#35848;&#36164;&#65292;&#37117;&#20540;&#24471;&#19968;&#35835;&#12290;</p>
<p>&#35777;&#26126;&#31616;&#21333;&#20195;&#30721;&#27573;&#30340;&#27491;&#30830;&#24615;&#26159;&#19968;&#20010;&#24456;&#31070;&#22855;&#30340;&#25216;&#33021;&#8212;&#8212;&#22240;&#20026;&#38754;&#35797;&#26102;&#22823;&#22810;&#25968;&#20844;&#21496;&#37117;&#20250;&#35201;&#27714;&#22312;&#32440;&#19978;&#20889;&#19968;&#27573;&#20195;&#30721;&#65292;&#28982;&#21518;&#38754;&#35797;&#23448;&#26816;&#26597;&#36825;&#27573;&#20195;&#30721;&#65292;&#22914;&#26524;&#20320;&#33021;&#22815;&#33258;&#24049;&#35777;&#26126;&#33258;&#24049;&#20889;&#30340;&#20195;&#30721;&#26159;&#27491;&#30830;&#30340;&#65292;&#38754;&#35797;&#23448;&#36824;&#33021;&#25361;&#21076;&#20160;&#20040;&#21602;&#65311;</p>
<p>&#20043;&#21518;&#23601;&#26159;&#21508;&#31181;&#38754;&#35797;&#65292;&#35814;&#24773;&#35265;&#20043;&#21069;&#30340;&#21338;&#23458;&#65292;&#24635;&#20043;&#23601;&#26159;<strong>&#39033;&#30446;&#32463;&#21382;</strong>&#12289;<strong>&#12304;&#32440;&#19978;&#20195;&#30721;&#12305;</strong>&#21152;<strong>&#12304;&#27491;&#30830;&#24615;&#35777;&#26126;&#12305;</strong>&#36825;&#19977;&#26495;&#26023;&#65292;&#25703;&#26543;&#25289;&#26429;&#12290;</p>
<p>MIT &#25945;&#25480; Erik Demaine &#21017;&#26356;&#20026;&#30452;&#25509;&#65306;</p>
<blockquote>
<p><strong>If you want to become a good programmer, you can spend 10 years programming, or spend 2 years programming and learning algorithms.</strong></p>
</blockquote>
<p>refs and see also</p>
<ul>
<li><a href="http://lucida.me/blog/on-learning-algorithms/">&#25105;&#30340;&#31639;&#27861;&#23398;&#20064;&#20043;&#36335; - Lucida</a></li>
</ul>
</dd>
<dt>9 &#20010; offer&#65292;12 &#23478;&#20844;&#21496;&#65292;35 &#22330;&#38754;&#35797;&#65292;&#20174;&#24494;&#36719;&#21040;&#35895;&#27468;&#65292;&#24212;&#23626;&#35745;&#31639;&#26426;&#27605;&#19994;&#29983;&#30340; 2012 &#27714;&#32844;&#20043;&#36335; <code class="fold">@</code></dt>
<dd><p>&#22806;&#20225;&#65288;Google&#12289;MS&#12289;Yahoo &#31561;&#65289; &gt; &#22269;&#20869;&#20114;&#32852;&#32593;&#65288;&#38463;&#37324;&#12289;&#33150;&#35759;&#12289;&#30334;&#24230;&#12289;&#32593;&#26131;&#31561;&#65289; &gt; &#20225;&#20107;&#19994;&#21333;&#20301;&#65288;&#22522;&#26412;&#19981;&#32771;&#34385;&#65289;</p>
<p>&#25105;&#30340;&#24494;&#36719; mentor &#26366;&#25552;&#21040;&#36807;&#65292;&#25105;&#30340;&#23454;&#20064;&#38754;&#35797;&#34920;&#29616;&#19968;&#33324;&#65292;&#20294;&#21518;&#26469;&#34920;&#29616;&#20986;&#30340;&#21160;&#25163;&#33021;&#21147;&#22823;&#22823;&#36229;&#20986;&#20043;&#21069;&#38754;&#35797;&#30340;&#39044;&#20272;&#65292;&#32780;&#26377;&#20123;&#38754;&#35797;&#34920;&#29616;&#24456;&#20986;&#33394;&#65292;&#38382;&#39064;&#23545;&#31572;&#22914;&#27969;&#30340;&#36873;&#25163;&#65292;&#20837;&#32844;&#20043;&#21518;&#21453;&#32780;&#19981;&#26159;&#24456;&#29702;&#24819;&#65292;&#33267;&#23569;&#27809;&#26377;&#36798;&#21040;&#38754;&#35797;&#26102;&#21457;&#25381;&#20986;&#30340;&#27700;&#20934;&#12290;</p>
<p>&#36825;&#35828;&#26126;&#19968;&#20010;&#38382;&#39064;&#65292;&#23601;&#26159;<strong>&#31508;&#35797;&#38754;&#35797;&#65292;&#20934;&#22791;&#21644;&#19981;&#20934;&#22791;&#20250;&#24046;&#24322;&#24456;&#22823;</strong>&#12290;&#22914;&#26524;&#20320;&#30340;&#31616;&#21382;&#19981;&#26159;&#37027;&#20040; NB&#65292;&#37027;&#23601;&#21482;&#33021;&#38752;&#31508;&#35797;&#21644;&#38754;&#35797;&#30340;&#21152;&#20998;&#25745;&#22330;&#38754;&#12290;&#36523;&#36793;&#32463;&#24120;&#26377;&#21516;&#23398;&#32435;&#38391;&#36825;&#26679;&#20195;&#30721;&#37117;&#32534;&#19981;&#21033;&#32034;&#30340;&#20667;&#23628;&#37117;&#33021;&#36827; MS &#20026;&#20160;&#20040;&#25105;&#19981;&#33021;&#36827;&#65292;&#31572;&#26696;&#24448;&#24448;&#24456;&#31616;&#21333;&#65306;&#20154;&#23478;&#27604;&#20320;&#22810;&#20934;&#22791;&#20102;&#19968;&#20010;&#26376;&#12290;&#24179;&#26102;&#30005;&#33041;&#19978;&#20889;&#31243;&#24207;&#21487;&#33021;&#24456;&#21033;&#32034;&#65292;&#31508;&#35797;&#38754;&#35797;&#26102;&#22312;&#32440;&#19978;&#20889;&#20889;&#35797;&#35797;&#20320;&#23601;&#30693;&#36947;&#20160;&#20040;&#21483;&#25305;&#35745;&#12290;</p>
<p>IT &#20844;&#21496;&#30340;&#31508;&#35797;&#21644;&#38754;&#35797;&#30340;&#39064;&#37327;&#37117;&#19981;&#22823;&#65288;&#30456;&#23545;&#20110;&#20225;&#20107;&#19994;&#21333;&#20301;&#21644;&#38134;&#34892;&#21160;&#36740;&#19978;&#30334;&#36947;&#36873;&#25321;&#39064;&#30340;&#39064;&#37327;&#65292;&#31639;&#26159;&#24456;&#23569;&#65289;&#65292;&#19968;&#33324;&#21313;&#20960;&#36947;&#36873;&#25321;&#39064;&#65292;&#19977;&#22235;&#36947;&#22823;&#39064;&#23601;&#31639;&#39064;&#37327;&#24456;&#22823;&#12290;&#20294;&#35745;&#31639;&#26426;&#30340;&#19996;&#35199;&#23454;&#22312;&#21448;&#26159;&#22826;&#22810;&#65292;&#31243;&#24207;&#35774;&#35745;&#12289;&#25968;&#25454;&#32467;&#26500;&#12289;&#31639;&#27861;&#35774;&#35745;&#12289;&#25805;&#20316;&#31995;&#32479;&#12289;&#20307;&#31995;&#32467;&#26500;&#12289;&#32534;&#35793;&#21407;&#29702;&#12289;&#25968;&#25454;&#24211;&#12289;&#36719;&#20214;&#24037;&#31243;&#31561;&#20998;&#25903;&#65292;&#32534;&#35793;&#30340;&#35805;&#22826;&#38590;&#65288;&#19968;&#21315;&#20010;&#30721;&#20892;&#37324;&#20063;&#27809;&#20960;&#20010;&#20154;&#33021;&#22312;&#32440;&#19978;&#20889;&#19968;&#20010;&#26368;&#22522;&#30784;&#30340;&#36882;&#24402;&#19979;&#38477; LLParser&#65289;&#65292;&#36719;&#20214;&#24037;&#31243;&#12289;&#20307;&#31995;&#32467;&#26500;&#12289;&#25968;&#25454;&#24211;&#36825;&#20123;&#22826;&#27700;&#65288;&#19981;&#26159;&#35828;&#36825;&#20123;&#20998;&#25903;&#27809;&#29992;&#65292;&#32780;&#26159;&#23427;&#20204;&#24456;&#38590;&#32771;&#23519;&#65292;&#23588;&#20854;&#23545;&#24212;&#23626;&#29983;&#26469;&#35828;&#36825;&#20123;&#37117;&#26159;&#20123;&#25991;&#23383;&#28216;&#25103;&#65292;&#27604;&#22914;&#35828;&#38754;&#21521;&#23545;&#35937;&#30340;&#19977;&#35201;&#32032;&#20116;&#21407;&#21017;&#65292;&#26377;&#20010;&#40479;&#29992;&#65289;&#65292;&#36825;&#20040;&#19968;&#25490;&#38500;&#65292;&#20877;&#25226;&#25968;&#25454;&#32467;&#26500;&#21644;&#31639;&#27861;&#35774;&#35745;&#19968;&#21512;&#24182;&#65292;&#23601;&#21097;&#19979;<strong>&#31243;&#24207;&#35774;&#35745;</strong>&#12289;<strong>&#31639;&#27861;</strong>&#21644;<strong>&#25805;&#20316;&#31995;&#32479;</strong>&#12290;&#27809;&#38169;&#65292;&#36825;&#19977;&#39033;&#25630;&#23450;&#65292;&#22269;&#20869;&#22806; IT &#20844;&#21496;&#36890;&#26432;&#12290;</p>
<p><strong>Tips</strong></p>
<ul>
<li>&#37325;&#28201;&#20043;&#21069;&#33258;&#24049;&#20570;&#36807;&#30340;&#38752;&#35889;&#39033;&#30446;&#65292;&#24182;&#24635;&#32467;&#37324;&#38754;&#30340;&#20851;&#38190;&#38590;&#39064;&#21644;&#35299;&#20915;&#24605;&#36335;</li>
<li>&#37325;&#35835; Programming Pearls &#21644; More Programming Pearls&#65292;&#24182;&#23436;&#25104;&#25152;&#26377;&#35838;&#21518;&#39064;</li>
<li>&#29420;&#31435;&#35299;&#20915;&#32534;&#31243;&#20043;&#32654;&#37324;&#38754;&#30340;&#39064;&#30446;&#65288;&#22269;&#20869;&#19981;&#23569;&#20225;&#19994;&#36873;&#39064;&#29992;&#30340;&#36825;&#26412;&#20070;&#65289;</li>
<li>&#23436;&#25104; Careercup &#37324; Amazon&#12289;Google &#21644; Microsoft &#36825;&#19977;&#20010;&#20998;&#31867;&#19979;&#38754;&#30340;&#21069; 20 &#39029;&#38754;&#35797;&#39064;</li>
<li>&#23436;&#25104; TopCoder &#30340;&#25968;&#21313;&#36947; D1L2~D2L1 &#38590;&#24230;&#21306;&#38388;&#30340;&#31639;&#27861;&#39064;&#30446;</li>
<li>&#37325;&#35835; Computer Systems a Programmer&#8217;s Perspective &#30340;&#20851;&#38190;&#31456;&#33410;&#65292;&#22238;&#39038;&#37324;&#38754;&#30340;&#20851;&#38190;&#28857;</li>
</ul>
<p>&#20174;&#19971;&#26376;&#24213;&#24320;&#22987;&#19968;&#30452;&#21040;&#21313;&#19968;&#26376;&#65292;&#33457;&#20102;&#25509;&#36817;&#22235;&#20010;&#26376;&#65292;&#24456;&#22810;&#19996;&#35199;&#37117;&#26159;&#19968;&#36793;&#38754;&#35797;&#19968;&#36793;&#20934;&#22791;&#65306;<strong>&#38754;&#35797;-&gt;&#21457;&#29616;&#30450;&#28857;-&gt;&#20462;&#22797;&#30450;&#28857;</strong>&#12290;</p>
<p>&#31616;&#21382;</p>
<ul>
<li>&#31687;&#24133;&#12290;&#25511;&#21046;&#22312;&#19968;&#39029;&#20197;&#20869;&#12290;&#20498;&#19981;&#26159;&#35828;&#19981;&#33021;&#20889;&#20004;&#39029;&#65292;&#32780;&#26159; HR &#27809;&#26102;&#38388;&#30475;&#20004;&#39029;&#36825;&#20040;&#22810;&#12290;&#32780;&#19988;&#23601;&#25105;&#30475;&#36807;&#30340;&#20960;&#30334;&#23553;&#31616;&#21382;&#32780;&#35328;&#65292;&#20961;&#26159;&#36229;&#36807;&#20004;&#39029;&#30340;&#27809;&#19968;&#20010;&#38752;&#35889;&#65292;&#26377;&#36825;&#20040;&#39640;&#30340;&#20808;&#39564;&#27010;&#29575;&#65292;HR &#25165;&#27809;&#24037;&#22827;&#19968;&#20010;&#20010;&#31579;&#65292;&#21453;&#27491;&#20013;&#22269;&#26377;&#30340;&#26159;&#20154;&#12290;</li>
<li>&#37325;&#28857;&#12290;&#19968;&#23450;&#35201;&#26377;&#37325;&#28857;&#65292;&#20570;&#21040;&#35753; HR &#36890;&#36807;&#31616;&#21382;&#22312; 20 &#31186;&#20869;&#30830;&#23450;&#20320;&#38752;&#19981;&#38752;&#35889;&#12290;&#21487;&#20197;&#29992;&#21152;&#40657;&#23383;&#20307;&#36827;&#34892;&#35270;&#35273;&#24341;&#23548;&#12290;</li>
<li>&#21035;&#23383;&#12290;&#21315;&#19975;&#19981;&#35201;&#20986;&#29616;&#38169;&#21035;&#23383;&#65292;&#21035;&#23383;&#31616;&#21382;&#19968;&#33324;&#30452;&#25509;&#24178;&#25481;&#12290;&#19968;&#39029;&#30340;&#31616;&#21382;&#37117;&#33021;&#20986;&#38382;&#39064;&#65292;&#19968;&#33324;&#19981;&#20250;&#38752;&#35889;&#12290;</li>
</ul>
<p>&#20294;&#26159;&#30740;&#21457;&#30340;&#31639;&#27861;&#39064;&#26159;&#19968;&#26679;&#30340;&#65292;&#26368;&#21518;&#19968;&#36947;&#31639;&#27861;&#39064;&#24456;&#26377;&#24847;&#24605;&#65292;&#25105;&#33457;&#20102;&#19968;&#20010;&#22810;&#23567;&#26102;&#25165;&#24819;&#21040;&#21033;&#29992;&#32452;&#21512;&#25968;&#23398;&#37324;&#38754;&#30340;&#30693;&#35782;&#65288;&#22810;&#20803;&#19968;&#27425;&#26041;&#31243;&#38750;&#36127;&#35299;&#65289;&#32473;&#20986;&#35774;&#35745;&#26041;&#26696;&#65292;&#21518;&#26469;&#21644;&#38754;&#35797;&#23448;&#32842;&#36825;&#36947;&#39064;&#26102;&#20182;&#20204;&#20063;&#25402;&#21507;&#24778;&#65292;&#22240;&#20026;&#25105;&#30340;&#26041;&#26696;&#27604;&#20182;&#20204;&#30340;&#31572;&#26696;&#36824;&#35201;&#20248;&#21270;&#12290;</p>
<p>&#24494;&#36719;&#65306;</p>
<ul>
<li>&#39064;&#22411;&#21482;&#26377;<strong>&#20108;&#21313;&#36947;&#19981;&#23450;&#39033;&#36873;&#25321;&#39064;</strong>&#65292;&#38590;&#24230;&#36739;&#38590;&#65292;&#35201;&#27714;&#22312;&#19968;&#23567;&#26102;&#22235;&#21313;&#20998;&#38047;&#23436;&#25104;&#12290;&#38590;&#24230;&#36739;&#38590;&#65292;&#35206;&#30422;&#38754;&#38750;&#24120;&#24191;&#65292;&#20174;&#35774;&#35745;&#27169;&#24335;&#65292;&#31639;&#27861;&#20998;&#26512;&#65292;&#20195;&#30721;&#38405;&#35835;&#21040; C++ &#35821;&#35328;&#29305;&#24615;&#65292;&#29978;&#33267;&#36830;&#20919;&#38376;&#30340;&#20989;&#25968;&#24335;&#31243;&#24207;&#35774;&#35745;&#35821;&#35328;&#37117;&#26377;&#28041;&#21450;&#12290;</li>
<li>&#24494;&#36719;&#30340;&#31508;&#35797;&#39064;&#30446; BT &#20043;&#22788;&#22312;&#20110;&#20854;&#29420;&#29305;&#30340;&#31215;&#20998;&#26426;&#21046;&#65306;&#31572;&#23545;&#20102;&#21152;&#20998;&#65292;&#19981;&#31572;&#26080;&#20998;&#65292;&#31572;&#38169;&#20102;&#20498;&#25187;&#12290;&#36825;&#23601;&#20351;&#24471;&#24456;&#22810; ds &#31572;&#23436;&#35797;&#21367;&#24863;&#35273;&#33258;&#25105;&#33391;&#22909;&#20294;&#23454;&#38469;&#24050;&#32463;&#34987;&#20498;&#25187;&#20986;&#32724;&#12290;&#20197;&#26368;&#21518;&#19968;&#36947;&#39064;&#20026;&#20363;&#65292;&#31572;&#23545;&#20102;&#21152; 7 &#20998;&#65292;&#31572;&#38169;&#20498;&#25187; 13 &#20998;&#65292;&#30456;&#24403;&#20110;&#19968;&#19979;&#23376;&#25439;&#22833; 20 &#20998;&#12290;&#25152;&#20197;&#24494;&#36719;&#30340;&#31508;&#35797;&#39064;&#20250;&#20570;&#23601;&#24471;&#20570;&#23545;&#65292;&#19981;&#20250;&#20570;&#23601;&#21035;&#33945;&#65292;&#35201;&#19981;&#26356;&#24808;&#12290;</li>
<li>&#27492;&#22806;&#65292;&#24494;&#36719;&#30340;&#31508;&#35797;&#39064;&#26159;&#33521;&#25991;&#30340;&#65292;&#21152;&#19978;&#26102;&#38388;&#27604;&#36739;&#30701;&#65292;&#26377;&#20123;&#20154;&#39064;&#37117;&#35835;&#19981;&#23436;&#65292;&#26377;&#20123; ds &#36830; functional language &#26159;&#20160;&#20040;&#37117;&#19981;&#30693;&#36947;&#65292;&#33258;&#28982;&#36133;&#30340;&#24456;&#24808;&#12290;</li>
</ul>
<p>&#20174;&#31508;&#35797;&#39064;&#21487;&#20197;&#26126;&#26174;&#30475;&#20986;&#65292;&#22269;&#22806;&#30340;&#22823;&#22411; IT &#20844;&#21496;&#65288;&#27604;&#22914;&#38597;&#34382;&#65292;&#24494;&#36719;&#21644;&#35895;&#27468;&#31561;&#65289;&#24182;&#19981;&#22312;&#24847;&#20320;&#29616;&#22312;&#30340; skill set&#65292;&#32780;&#26356;&#30475;&#37325;&#20320;&#30340; potential&#65292;&#22240;&#27492;&#39064;&#30446;&#22823;&#22810;&#24456;&#22522;&#30784;&#65292;&#24182;&#20855;&#22791;&#30456;&#24403;&#30340;&#28145;&#24230;&#65292;&#20197;&#30830;&#20445;&#20320;&#23545; CS &#26377;&#28145;&#21051;&#30340;&#29702;&#35299;&#24182;&#33021;&#22815;&#36208;&#30340;&#24456;&#36828;&#65307;&#32780;&#22269;&#20869;&#30340; IT &#20844;&#21496;&#65288;&#27604;&#22914;&#30334;&#24230;&#12289;&#25628;&#29399;&#21644;&#20154;&#20154;&#31561;&#65289;&#26356;&#30475;&#37325;&#20320;&#29616;&#22312;&#30340; skill set&#65292;&#22240;&#27492;&#20250;&#20986;&#29616;&#19981;&#23569;&#35821;&#35328;&#29305;&#24615;&#65292;OS &#25805;&#20316;&#20043;&#31867;&#30340;&#20855;&#20307;&#39064;&#30446;&#65292;&#20197;&#30830;&#20445;&#20320;&#33021;&#22815;&#20197;&#23613;&#24555;&#30340;&#36895;&#24230;&#19978;&#25163;&#24178;&#27963;&#65292;&#33267;&#20110;&#33021;&#21457;&#23637;&#21040;&#21861;&#31243;&#24230;&#20182;&#20204;&#23601;&#19981; care &#20102;&#12290;</p>
<p>&#32771;&#34385;&#21040;&#20960;&#20046;&#25152;&#26377;&#30340;&#20844;&#21496;&#37117;&#26377;&#32534;&#31243;&#39064;&#30446;&#65292;&#20063;&#23601;&#26159;&#22312;&#32440;&#19978;&#20889;&#20195;&#30721;&#65292;&#36825;&#37324;&#25512;&#33616;&#20960;&#26412;&#30456;&#20851;&#20070;&#31821;&#65306;</p>
<ul>
<li>1 <strong>Elements of programming style</strong> 2nd&#65292;&#20889;&#20986;&#33391;&#22909;&#39118;&#26684;&#30340;&#20195;&#30721;&#12290;&#32440;&#19978;&#20195;&#30721;&#19968;&#33324;&#19981;&#38271;&#65292;&#20294;&#30701;&#30701;&#20960;&#34892;&#20195;&#30721;&#24448;&#24448;&#21487;&#20197;&#30475;&#20986;&#36825;&#20010;&#20154;&#30340;&#27700;&#20934;&#65292;&#39118;&#26684;&#24456;&#24046;&#30340;&#20195;&#30721;&#24448;&#24448;&#20250;&#34987; pass &#25481;&#12290;</li>
<li>2 <strong>Algorithm design manual</strong> 2nd&#65292;&#20316;&#20026;&#38750; ACM &#20986;&#36523;&#30340;&#30721;&#20892;&#65292;&#36825;&#26412;&#20070;&#27604;&#31639;&#23548;&#23454;&#29992;&#24456;&#22810;&#65292;&#35838;&#21518;&#39064;&#20063;&#24456;&#23454;&#22312;&#65292;&#23545;&#22238;&#28335;&#65292;&#21160;&#24577;&#35268;&#21010;&#36825;&#20123;&#32534;&#31243;&#25216;&#24039;&#35762;&#30340;&#38750;&#24120;&#28165;&#26970;&#12290;</li>
<li>3 <strong>C interfaces and implementation</strong>&#65292;&#26080;&#35770;&#26159;&#38754;&#35797;&#36824;&#26159;&#31508;&#35797;&#65292;&#19968;&#33324;&#37117;&#20250;&#29992; C &#20889;&#31243;&#24207;&#65292;&#36825;&#26412;&#20070;&#21253;&#21547;&#22823;&#37327;&#30340;&#24037;&#19994;&#32423; C &#20195;&#30721;&#65292;&#32477;&#20339;&#30340;&#21442;&#32771;&#21644;&#27169;&#20223;&#32032;&#26448;&#12290;</li>
</ul>
<p>&#26368;&#21518;&#25512;&#33616;&#19979; Elements of programming &#21644; Structure and interpretation of computer programs&#65292;&#36825;&#20004;&#26412;&#20070;&#38590;&#24230;&#24456;&#39640;&#65292;&#38656;&#35201;&#22823;&#37327;&#30340;&#26102;&#38388;&#38405;&#35835;&#65292;&#19981;&#36866;&#21512;&#20020;&#22330;&#38405;&#35835;&#20934;&#22791;&#65292;&#20294;&#35835;&#36807;&#21518;&#65292;&#20889;&#20986;&#30340;&#20195;&#30721;&#32477;&#36924;&#20250;&#19978;&#20004;&#20010;&#23618;&#27425;&#65292;&#36825;&#37324;&#25105;&#23601;&#19981;&#22810;&#20171;&#32461;&#20102;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.cnblogs.com/figure9/archive/2013/01/09/2853649.html">9 &#20010; offer&#65292;12 &#23478;&#20844;&#21496;&#65292;35 &#22330;&#38754;&#35797;&#65292;&#20174;&#24494;&#36719;&#21040;&#35895;&#27468;&#65292;&#24212;&#23626;&#35745;&#31639;&#26426;&#27605;&#19994;&#29983;&#30340; 2012 &#27714;&#32844;&#20043;&#36335; - <em>Luc</em> - &#21338;&#23458;&#22253;</a></li>
</ul>
</dd>
<dt>&#30333;&#26495;&#32534;&#31243;&#27973;&#35848;&#8212;&#8212;Why, What, How &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#25216;&#26415;&#38754;&#35797;&#20013;&#30340;&#38382;&#39064;&#22823;&#33268;&#21487;&#20197;&#20998;&#20026; 5 &#31867;&#65306;</p>
<ul>
<li><dl>
<dt>&#32534;&#30721;</dt>
<dd>&#32771;&#23519;&#38754;&#35797;&#32773;&#30340;&#32534;&#30721;&#33021;&#21147;&#65292;&#19968;&#33324;&#35201;&#27714;&#38754;&#35797;&#32773;&#22312; 20 ~ 30 &#20998;&#38047;&#20043;&#20869;&#32534;&#20889;&#19968;&#27573;&#38656;&#27714;&#26126;&#30830;&#30340;&#23567;&#31243;&#24207;&#65288;&#20363;&#65306;&#32534;&#20889;&#19968;&#20010;&#20989;&#25968;&#21010;&#20998;&#19968;&#20010;&#25972;&#24418;&#25968;&#32452;&#65292;&#25226;&#36127;&#25968;&#25918;&#22312;&#24038;&#36793;&#65292;&#38646;&#25918;&#22312;&#20013;&#38388;&#65292;&#27491;&#25968;&#25918;&#22312;&#21491;&#36793;&#65289;&#65307;
</dd>
</dl></li>
<li><dl>
<dt>&#35774;&#35745;</dt>
<dd>&#32771;&#23519;&#38754;&#35797;&#32773;&#30340;&#35774;&#35745;/&#34920;&#36798;&#33021;&#21147;&#65292;&#19968;&#33324;&#35201;&#27714;&#38754;&#35797;&#32773;&#22312; 30 &#20998;&#38047;&#24038;&#21491;&#20869;&#32473;&#20986;&#19968;&#20010;&#31995;&#32479;&#30340;&#22823;&#33268;&#35774;&#35745;&#65288;&#20363;&#65306;&#35774;&#35745;&#19968;&#20010;&#31867;&#20284;&#24494;&#21338;&#30340;&#31995;&#32479;&#65289;
</dd>
</dl></li>
<li><dl>
<dt>&#39033;&#30446;</dt>
<dd>&#32771;&#23519;&#38754;&#35797;&#32773;&#30340;&#35774;&#35745;/&#34920;&#36798;&#33021;&#21147;&#20197;&#21450;&#20854;&#31616;&#21382;&#30340;&#30495;&#23454;&#24230;&#65288;&#20363;&#65306;&#25551;&#36848;&#20320;&#20570;&#36807;&#30340; xxx &#31995;&#32479;&#20013;&#30340;&#38590;&#28857;&#65292;&#20197;&#21450;&#20320;&#26159;&#22914;&#20309;&#20811;&#26381;&#36825;&#20123;&#38590;&#28857;&#65289;
</dd>
</dl></li>
<li><dl>
<dt>&#33041;&#31563;&#24613;&#36716;&#24367;</dt>
<dd>&#32771;&#23519;&#38754;&#35797;&#32773;&#30340;&#12302;&#21453;&#24212;/&#26234;&#21147;&#12303;&#65288;&#20363;&#65306;&#22914;&#26524;&#20320;&#21464;&#25104;&#34434;&#34433;&#22823;&#23567;&#28982;&#21518;&#34987;&#25172;&#36827;&#19968;&#20010;&#25605;&#25292;&#26426;&#37324;&#65292;&#20320;&#23558;&#22914;&#20309;&#33073;&#36523;&#65311;&#65289;
</dd>
</dl></li>
<li><dl>
<dt>&#26597;&#28431;</dt>
<dd>&#32771;&#23519;&#38754;&#35797;&#32773;&#23545;&#26576;&#31181;&#25216;&#26415;&#30340;&#29087;&#32451;&#24230;&#65288;&#20363;&#65306;Java &#30340;&#22522;&#26412;&#31867;&#22411;&#26377;&#20960;&#31181;&#65311;&#65289;
</dd>
</dl></li>
</ul>
<p>&#22240;&#20026;&#20960;&#20046;&#25152;&#26377;&#30340;&#24403;&#38754;&#65288;On-site&#65289;&#25216;&#26415;&#38754;&#35797;&#22343;&#35201;&#27714;&#38754;&#35797;&#32773;&#22312;&#30333;&#26495;&#19978;&#20889;&#20986;&#20195;&#30721;&#65292;&#32780;&#19981;&#26159;&#22312;&#38754;&#35797;&#32773;&#29087;&#24713;&#30340; IDE &#25110;&#26159;&#32534;&#36753;&#22120;&#20013;&#20889;&#20986;&#12290;</p>
<dl>
<dt>&#20026;&#20160;&#20040;&#35201;&#36827;&#34892;&#30333;&#26495;&#32534;&#31243;&#65288;WHY&#65289;</dt>
<dd><ul>
<li>&#38500;&#20102;&#21028;&#23450;&#38754;&#35797;&#32773;&#30340;&#24320;&#21457;&#25928;&#29575;&#65292;&#30333;&#26495;&#32534;&#31243;&#36824;&#26377;&#21161;&#20110;&#23637;&#31034;&#38754;&#35797;&#32773;&#30340;&#32534;&#31243;&#24605;&#36335;&#65292;&#24182;&#20415;&#20110;&#38754;&#35797;&#32773;&#21644;&#38754;&#35797;&#23448;&#36827;&#34892;&#20132;&#27969;</li>
<li>&#35753;&#38754;&#35797;&#32773;&#22312;&#35299;&#39064;&#30340;&#36807;&#31243;&#20013;&#23558;&#20182;/&#20182;&#30340;&#24605;&#32500;&#36807;&#31243;&#21644;&#32534;&#30721;&#20064;&#24815;&#23637;&#29616;&#22312;&#38754;&#35797;&#23448;&#38754;&#21069;&#65292;&#20197;&#20415;&#38754;&#35797;&#23448;&#21028;&#23450;&#38754;&#35797;&#32773;&#26159;&#21542;&#20855;&#22791;&#28165;&#26224;&#30340;&#36923;&#36753;&#24605;&#32500;&#21644;&#33391;&#22909;&#30340;&#32534;&#31243;&#32032;&#20859;</li>
<li>&#22914;&#26524;&#38754;&#35797;&#32773;&#38519;&#20837;&#22256;&#22659;&#25110;&#26159;&#38519;&#38449;&#65292;&#38754;&#35797;&#23448;&#20063;&#21487;&#20197;&#20026;&#20854;&#25552;&#20379;&#36866;&#24403;&#30340;&#36741;&#21161;&#65292;&#20197;&#20813;&#38754;&#35797;&#38519;&#20837;&#26080;&#20154;&#21457;&#35328;&#30340;&#23604;&#23596;&#22659;&#22320;</li>
</ul>
</dd>
<dt>&#20160;&#20040;&#26159;&#21512;&#36866;&#30340;&#30333;&#26495;&#32534;&#31243;&#39064;&#30446;&#65288;WHAT&#65289;</dt>
<dd><p>&#19979;&#38754;&#26159;&#19968;&#20123;&#38382;&#28389;&#30340;&#32534;&#31243;&#38382;&#39064;&#65306;</p>
<ul>
<li>&#32534;&#31243;&#20043;&#32654; &#20070;&#37324;&#30340;&#25152;&#26377;&#39064;&#30446;&#65307;</li>
<li>July &#30340;&#31639;&#27861;&#21338;&#23458; &#20013;&#30340;&#32477;&#22823;&#22810;&#25968;&#39064;&#30446;&#65288;&#21253;&#25324; &#38754;&#35797; 100 &#39064; &#20013;&#30340;&#25152;&#26377;&#39064;&#30446;&#65289;&#65307;</li>
<li>leecode &#37324;&#30340;&#22823;&#37096;&#20998;&#39064;&#30446;&#65307;</li>
</ul>
<p>&#38656;&#35201;&#27880;&#24847;&#30340;&#26159;&#65292;&#23613;&#31649;&#36807;&#20110;&#30452;&#25509;&#30340;&#31639;&#27861;&#39064;&#30446;&#19981;&#36866;&#21512;&#38754;&#35797;&#65292;&#20294;&#26159;&#25105;&#20204;&#21487;&#20197;&#23558;&#20854;&#36827;&#34892;&#19968;&#28857;&#25913;&#21160;&#65292;&#20174;&#32780;&#20351;&#20854;&#21464;&#25104;&#21512;&#29702;&#30340;&#39064;&#30446;&#65292;&#20363;&#22914;&#31283;&#23450;&#21010;&#20998;&#21644;&#20108;&#20998;&#25628;&#32034;&#35745;&#25968;&#65288;&#32473;&#20986;&#26377;&#24207;&#25968;&#32452;&#20013;&#26576;&#20010;&#20803;&#32032;&#20986;&#29616;&#30340;&#27425;&#25968;&#65289;&#23601;&#19981;&#38169;&#65292;&#23613;&#31649;&#23427;&#20204;&#23454;&#38469;&#26159;&#24555;&#36895;&#25490;&#24207;&#21644;&#20108;&#20998;&#25628;&#32034;&#30340;&#21464;&#31181;</p>
<p>&#36825;&#20123;&#39064;&#30446;&#24448;&#24448;&#35201;&#27714;&#38754;&#35797;&#32773;&#25317;&#26377;&#26497;&#24378;&#30340;&#31639;&#27861;&#32972;&#26223;&#65292;&#23613;&#31649;&#31639;&#27861;&#38382;&#39064;&#26159;&#21542;&#36807;&#20110;&#22797;&#26434;&#22240;&#20154;&#32780;&#24322;</p>
<ul>
<li>&#38656;&#35201; aha! moment&#65288;&#21442;&#32771; &#33041;&#31563;&#24613;&#36716;&#24367;&#65289;</li>
<li>&#38656;&#35201;&#20351;&#29992;&#26576;&#20123;&#12302;&#38750;&#20027;&#27969;&#12303;&#25968;&#25454;&#32467;&#26500;/&#31639;&#27861;&#25165;&#33021;&#27714;&#35299;</li>
<li>&#32791;&#26102;&#36807;&#38271;&#65288;&#20363;&#22914;&#23454;&#29616;&#32418;&#40657;&#26641;&#30340;&#25554;&#20837;/&#21024;&#38500;&#65289;</li>
</ul>
<p>&#24212;&#35813;&#38382;&#20160;&#20040;&#38382;&#39064;</p>
<ul>
<li><dl>
<dt>&#19981;&#27490;&#19968;&#31181;&#35299;&#27861; <code class="fold">@</code></dt>
<dd><p>&#33391;&#22909;&#30340;&#32534;&#31243;&#38382;&#39064;&#37117;&#20250;&#26377;&#19981;&#27490;&#19968;&#31181;&#35299;&#27861;&#12290;&#36825;&#26679;&#38754;&#35797;&#32773;&#21487;&#20197;&#22312;&#30701;&#26102;&#38388;&#20869;&#32473;&#20986;&#19968;&#20010;&#19981;&#37027;&#20040;&#32874;&#26126;&#20294;&#21487;&#23454;&#29616;&#30340;&#12302;&#31895;&#31961;&#12303;&#31639;&#27861;&#65292;&#28982;&#21518;&#36890;&#36807;&#24605;&#32771;&#65288;&#25110;&#38754;&#35797;&#23448;&#25552;&#31034;&#65289;&#36880;&#27493;&#24471;&#21040;&#26356;&#21152;&#20248;&#21270;&#30340;&#35299;&#27861;&#65292;&#38754;&#35797;&#23448;&#21487;&#20197;&#36890;&#36807;&#36825;&#20010;&#36807;&#31243;&#35266;&#23519;&#21040;&#38754;&#35797;&#32773;&#30340;&#24605;&#32500;&#26041;&#24335;&#65292;&#20174;&#32780;&#23545;&#38754;&#35797;&#32773;&#36827;&#34892;&#26356;&#23458;&#35266;&#30340;&#35780;&#20272;&#12290;</p>
<p>&#20197;&#12304;&#25968;&#32452;&#26368;&#22823;&#23376;&#24207;&#21015;&#21644;&#12305;&#20026;&#20363;&#65292;&#23427;&#26377;&#19968;&#20010;&#24456;&#26174;&#28982;&#30340; O(n3) &#35299;&#27861;&#65292;&#23558; O(n3) &#35299;&#27861;&#31245;&#21152;&#25913;&#21160;&#21487;&#20197;&#24471;&#21040; O(n2) &#35299;&#27861;&#65292;&#21033;&#29992;&#20998;&#27835;&#24605;&#24819;&#65292;&#21487;&#20197;&#24471;&#21040; O(nlogn) &#35299;&#27861;&#65292;&#38500;&#27492;&#20043;&#22806;&#23427;&#36824;&#26377;&#19968;&#20010; O(n) &#35299;&#27861;&#12290;&#65288;&#32534;&#31243;&#29664;&#29585; &#21644; &#25968;&#25454;&#32467;&#26500;&#19982;&#31639;&#27861;&#20998;&#26512; C &#35821;&#35328;&#25551;&#36848; &#23545;&#36825;&#36947;&#39064;&#22343;&#26377;&#38750;&#24120;&#31934;&#24425;&#30340;&#25551;&#36848;&#65292;&#26377;&#20852;&#36259;&#30340;&#26379;&#21451;&#21487;&#20197;&#33258;&#34892;&#38405;&#35835;&#65289;</p>
</dd>
</dl></li>
<li><p>&#32771;&#23519;&#28857;&#26126;&#30830;</p></li>
<li><dl>
<dt>&#24310;&#20280;&#38382;&#39064;</dt>
<dd><p>&#33391;&#22909;&#30340;&#32534;&#31243;&#38382;&#39064;&#24212;&#25317;&#26377;&#24310;&#20280;&#38382;&#39064;&#12290;&#24310;&#20280;&#38382;&#39064;&#26082;&#21487;&#20197;&#24212;&#23545;&#38754;&#35797;&#32773;&#32972;&#39064;&#30340;&#24773;&#20917;&#65292;&#20063;&#21487;&#20197;&#28176;&#36827;&#30340;&#65288;Incremental&#65289;&#32771;&#23519;&#38754;&#35797;&#32773;&#30340;&#32534;&#31243;&#33021;&#21147;&#65292;&#21516;&#26102;&#36824;&#20445;&#35777;&#20102;&#38754;&#35797;&#30340;&#24310;&#32493;&#24615;&#65288;Continuity&#65289;&#12290;</p>
</dd>
</dl></li>
</ul>
</dd>
<dt>&#22914;&#20309;&#36827;&#34892;&#30333;&#26495;&#32534;&#31243;&#65288;HOW&#65289;</dt>
<dd><p>&#38754;&#35797;&#32773;&#24212;&#35813;&#20570;&#20160;&#20040;</p>
<ul>
<li><p>&#38754;&#35797;&#21069; &#9829;&#65039;</p>
<ul>
<li>&#25317;&#26377;&#25166;&#23454;&#30340;&#25968;&#25454;&#32467;&#26500;/&#31639;&#27861;&#22522;&#30784;</li>
<li>&#30693;&#36947;&#22914;&#20309;&#21033;&#29992; <strong>&#21069;&#26465;&#20214;/&#19981;&#21464;&#24335;/&#21518;&#26465;&#20214;</strong> &#36825;&#20123;&#24037;&#20855;&#32534;&#20889;&#27491;&#30830;&#30340;&#31243;&#24207;</li>
<li>&#33021;&#22815;&#22312;&#30333;&#26495;&#65288;&#25110;&#32440;&#19978;&#65289;&#23454;&#29616;&#22522;&#26412;&#30340;&#25968;&#25454;&#32467;&#26500;&#21644;&#31639;&#27861;&#65288;&#22914;&#26524; 1 &#21644; 2 &#20570;&#21040;&#36825;&#19968;&#27493;&#26159;&#27700;&#21040;&#28192;&#25104;&#65289;</li>
<li><strong>&#22312; leetcode &#25110; careercup &#19978;&#38754;&#36827;&#34892;&#36807;&#32451;&#20064;&#65292;&#20102;&#35299;&#24120;&#35265;&#30340;&#25216;&#26415;&#38754;&#35797;&#39064;&#30446;&#65288;&#25105;&#20010;&#20154;&#19981;&#40723;&#21169;&#21047;&#39064;&#65292;&#20294;&#22312;&#38754;&#35797;&#21069;&#24314;&#31435;&#36215;&#23545;&#38754;&#35797;&#39064;&#30340;&#12302;&#24863;&#35273;&#12303;&#38750;&#24120;&#37325;&#35201;&#65289;</strong></li>
</ul></li>
<li><p>&#38754;&#35797;&#20013;</p>
<ul>
<li><p>&#29702;&#35299;&#39064;&#30446;&#65292;<strong>&#30830;&#35748;&#38656;&#27714;</strong></p></li>
<li><dl>
<dt>&#20351;&#29992;&#23454;&#20363;&#25968;&#25454;<strong>&#39564;&#35777;</strong> (testing is important) &#33258;&#24049;&#30340;&#31243;&#24207; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Given range [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">1</span>] <span class="kw">and</span> pivot <span class="dv">3</span>

[ <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">1</span> ]
  ^             ^
 p,b            e

[ <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">1</span> ]
     ^          ^
    p,b         e

[ <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">1</span> ]
     ^  ^       ^
     p  b       e

[ <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">1</span> ]
     ^     ^    ^
     p     b    e

[ <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">3</span> ]
        ^     ^ ^
        p     b e

[ <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">3</span> ]
        ^       ^
        p      b,e

Now we have all [<span class="dv">0</span>, p) &lt; <span class="dv">3</span> <span class="kw">and</span> all [p, e) &gt;= <span class="dv">3</span></code></pre></div>
</dd>
</dl></li>
<li><p>&#20182;&#20204;&#22312;&#38754;&#35797;&#26102;&#20250;&#33258;&#24102;&#19968;&#26681;&#32454;&#31508;&#36857;&#30340;&#27700;&#31508;&#65292;&#19987;&#38376;&#29992;&#20110;&#30333;&#26495;&#32534;&#31243;&#12290;</p></li>
</ul></li>
</ul>
<p>&#19981;&#20250;&#20570;&#24590;&#20040;&#21150;</p>
<ul>
<li>&#33267;&#23569;&#20808;&#32473;&#20986;&#19968;&#20010;&#26292;&#21147;&#65288;Brute force&#65289;&#35299;&#27861;</li>
<li>&#23547;&#25214;&#21512;&#36866;&#30340;&#25968;&#25454;&#32467;&#26500;&#65288;&#20363;&#22914;&#26632; / &#38431;&#21015; / &#26641; / &#22534; / &#22270;&#65289;&#21644;&#31639;&#27861;&#65288;&#20363;&#22914;&#20998;&#27835; / &#22238;&#28335; / &#21160;&#24577;&#35268;&#21010; / &#36138;&#23146;&#65289;</li>
<li>&#20174;&#23567;&#25968;&#25454;&#38598;&#24320;&#22987;&#23581;&#35797;</li>
<li>&#22914;&#26524;&#36824;&#26159;&#27809;&#26377;&#22836;&#32490;&#65292;&#37325;&#26032;&#32771;&#34385;&#39064;&#30446;&#30340;&#21069;&#26465;&#20214;&#65292;&#24605;&#32771;&#26159;&#21542;&#28431;&#25481;&#20102;&#26465;&#20214;&#65288;&#25110;&#26159;&#38544;&#21547;&#30340;&#26465;&#20214;&#65289;</li>
<li>&#22914;&#26524; 3 &#20998;&#38047;&#36807;&#21518;&#36824;&#26159;&#27809;&#26377;&#20219;&#20309;&#24605;&#36335;&#65292;&#35831;&#27714;&#38754;&#35797;&#23448;&#25552;&#31034;&#65292;&#19981;&#35201;&#35273;&#24471;&#19981;&#22909;&#24847;&#24605;&#8212;&#8212; &#32463;&#36807;&#25552;&#31034;&#32473;&#20986;&#31572;&#26696;&#36828;&#24378;&#20110;&#27809;&#26377;&#31572;&#26696;</li>
</ul>
</dd>
</dl>
<p>&#20010;&#20154;&#19981;&#24314;&#35758;&#38754;&#35797;&#32773;&#22312;&#38754;&#35797;&#20043;&#21518;&#25226;&#39064;&#30446;&#21457;&#21040;&#32593;&#19978;&#65292;&#24456;&#22810;&#20844;&#21496;&#22312;&#38754;&#35797;&#21069;&#37117;&#20250;&#21644;&#38754;&#35797;&#32773;&#25171;&#25307;&#21628;&#65292;&#26377;&#30340;&#20250;&#31614;&#35746; NDA&#65288;Non Disclosure Agreement&#65289;&#26465;&#27454;&#20197;&#30830;&#20445;&#38754;&#35797;&#32773;&#19981;&#20250;&#27844;&#38706;&#38754;&#35797;&#39064;&#30446;&#12290;&#23613;&#31649;&#20182;&#20204;&#24456;&#23569;&#30495;&#30340;&#21435;&#26597;&#65292;&#20294;&#22914;&#26524;&#34987;&#26597;&#21040;&#37027;&#32477;&#23545;&#26159;&#24471;&#19981;&#20607;&#22833;&#12290;</p>
<p>&#25105;&#33258;&#24049;&#22312;&#38754;&#35797;&#20043;&#21518;&#20250;&#25226;&#38754;&#35797;&#20013;&#30340;&#32534;&#31243;&#39064;&#30446;&#21160;&#25163;&#20889;&#19968;&#36941;&#65288;&#38500;&#38750;&#39064;&#30446;&#36807;&#20110;&#31616;&#21333;&#19981;&#20540;&#24471;&#65289;&#65292;&#36825;&#26679;&#26082;&#33021;&#22815;&#39564;&#35777;&#33258;&#24049;&#20889;&#30340;&#20195;&#30721;&#65292;&#20063;&#21487;&#20197;&#20445;&#35777;&#33258;&#24049;&#19981;&#20250;&#22312;&#21516;&#19968;&#20010;&#22320;&#26041;&#25684;&#20498;&#20004;&#27425;&#12290;</p>
<p>&#160;&#160;&#19996;&#28699;&#20462;&#28860;&#32477;&#19990;&#27494;&#21151;&#65288;&#22312;&#26657;&#21051;&#33510;&#23398;&#20064;&#25216;&#26415;&#65289;&#65307;<br />
&#160;&#160;&#36828;&#36212;&#20013;&#21407;&#25361;&#25112;&#32676;&#38596;&#65288;&#21363;&#23558;&#27605;&#19994;&#24320;&#22987;&#27714;&#32844;&#65289;&#65307;<br />
&#160;&#160;&#25300;&#21073;&#21066;&#26543;&#26525;&#20316;&#25112;&#20070;&#65288;&#25776;&#20889;&#31616;&#21382;&#36827;&#34892;&#38754;&#35797;&#65289;&#65307;<br />
&#160;&#160;&#24778;&#21160;&#20013;&#21407;&#31532;&#19968;&#39640;&#25163;&#65288;&#31616;&#21382; / &#38754;&#35797;&#24471;&#21040;&#36175;&#35782;&#65289;&#65307;<br />
&#160;&#160;&#28023;&#19978;&#20915;&#25112;&#21517;&#25196;&#22825;&#19979;&#65288;&#24471;&#21040; Offer &#25630;&#23450;&#24037;&#20316;&#65289;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://lucida.me/blog/whiteboard-coding-demystified/" class="heart">&#30333;&#26495;&#32534;&#31243;&#27973;&#35848;&#8212;&#8212;Why, What, How - Lucida</a></li>
</ul>
</dd>
<dt>&#30693;&#20854;&#25152;&#20197;&#28982;&#65288;&#20197;&#31639;&#27861;&#23398;&#20064;&#20026;&#20363;&#65289; <code class="fold">@</code></dt>
<dd><p>&#24464;&#23461;&#22312;&#35752;&#35770;&#20013;&#25552;&#21040;&#65292;&#36825;&#31181;&#31574;&#30053;&#30340;&#26412;&#36136;&#21487;&#20197;&#27010;&#25324;&#25104;&#8220;&#35753;&#26410;&#30693;&#19990;&#30028;&#26080;&#26426;&#21487;&#20056;&#8221;&#12290;&#23427;&#26159;&#27809;&#26377;&#8220;&#24369;&#28857;&#30340;&#8221;&#65292;&#31572;&#26696;&#30340;&#20219;&#20309;&#19968;&#20010;&#20998;&#25903;&#37117;&#26159;&#31561;&#27010;&#29575;&#30340;&#12290;&#21453;&#20043;&#65292;&#19968;&#26086;&#26576;&#20010;&#20998;&#25903;&#34164;&#21547;&#30340;&#21487;&#33021;&#24615;&#26356;&#22810;&#65292;&#24403;&#24773;&#20917;&#33853;&#21040;&#37027;&#20010;&#20998;&#25903;&#19978;&#30340;&#26102;&#20505;&#20320;&#23601;&#37057;&#38391;&#20102;&#12290;&#27604;&#22914;&#29468;&#25968;&#23383;&#28216;&#25103;&#26368;&#31967;&#31957;&#30340;&#31574;&#30053;&#23601;&#26159;&#19968;&#20010;&#19968;&#20010;&#30340;&#29468;&#65306;&#26159; 1 &#21527;&#65311;&#26159; 2 &#21527;&#65311;&#8230; &#22240;&#20026;&#36825;&#31181;&#29468;&#27861;&#26368;&#24046;&#30340;&#24773;&#20917;&#19979;&#38656;&#35201; 64 &#27425;&#25165;&#33021;&#29468;&#23545;&#65292;&#19979;&#30028;&#38750;&#24120;&#31967;&#31957;&#12290;&#20108;&#20998;&#25628;&#32034;&#20026;&#20160;&#20040;&#22909;&#65292;&#23601;&#26159;&#22240;&#20026;&#23427;&#27599;&#27425;&#37117;&#23558;&#21487;&#33021;&#24615;&#25490;&#38500;&#19968;&#21322;&#24182;&#19988;&#26080;&#35770;&#22914;&#20309;&#37117;&#33021;&#25490;&#38500;&#19968;&#21322;&#65288;&#23427;&#26159;&#26368;&#31967;&#24773;&#20917;&#19979;&#34920;&#29616;&#26368;&#22909;&#30340;&#65289;&#12290;</p>
<p>&#22914;&#20309;&#31216;&#30340;&#25351;&#23548;&#21407;&#21017;&#26377;&#20102;&#65292;&#26500;&#36896;&#19968;&#20010;&#31216;&#30340;&#31574;&#30053;&#23601;&#19981;&#26159;&#20160;&#20040;&#22826;&#22256;&#38590;&#30340;&#20107;&#24773;&#20102;&#12290;&#39318;&#20808;&#19981;&#22952;&#35299;&#37322;&#19968;&#19979;&#20026;&#20160;&#20040;&#26368;&#30452;&#35266;&#30340;&#31216;&#27861;&#19981;&#26159;&#26368;&#20248;&#30340;&#8212;&#8212;6&#12289;6 &#31216;&#65306;&#22312; 6&#12289;6 &#31216;&#30340;&#26102;&#20505;&#65292;&#22825;&#24179;&#24179;&#34913;&#30340;&#21487;&#33021;&#24615;&#26159; 0&#12290;&#21018;&#25165;&#35828;&#20102;&#65292;&#26368;&#20248;&#31574;&#30053;&#24212;&#35813;&#20351;&#24471;&#22825;&#24179;&#19977;&#31181;&#29366;&#24577;&#30340;&#27010;&#29575;&#22343;&#31561;&#65292;&#36825;&#26679;&#25165;&#33021;&#19977;&#31561;&#20998;&#31572;&#26696;&#30340;&#25152;&#26377;&#21487;&#33021;&#24615;&#12290;</p>
<p>&#22312;&#22534;&#25490;&#37324;&#38754;&#26377;&#22823;&#37327;&#36825;&#31181;&#36817;&#20046;&#26080;&#25928;&#30340;&#27604;&#36739;&#65292;&#22240;&#20026;&#34987;&#25343;&#21040;&#22534;&#39030;&#30340;&#37027;&#20010;&#20803;&#32032;&#20960;&#20046;&#32943;&#23450;&#26159;&#24456;&#23567;&#30340;&#65292;&#32780;&#38752;&#36817;&#22534;&#39030;&#30340;&#20803;&#32032;&#21448;&#20960;&#20046;&#32943;&#23450;&#26159;&#24456;&#22823;&#30340;&#65292;&#23558;&#19968;&#20010;&#24456;&#23567;&#30340;&#25968;&#21644;&#19968;&#20010;&#24456;&#22823;&#30340;&#25968;&#27604;&#36739;&#65292;&#32467;&#26524;&#20960;&#20046;&#32943;&#23450;&#26159;&#8220;&#23567;&#20110;&#8221;&#30340;&#65292;&#36825;&#23601;&#24847;&#21619;&#30528;&#38382;&#39064;&#30340;&#21487;&#33021;&#24615;&#21482;&#34987;&#25490;&#38500;&#25481;&#20102;&#24456;&#23567;&#19968;&#37096;&#20998;&#12290;</p>
<p>&#36825;&#23601;&#26159;&#20026;&#20160;&#20040;&#22534;&#25490;&#27604;&#36739;&#24930;&#65288;&#22534;&#25490;&#34429;&#28982;&#21644;&#24555;&#25490;&#19968;&#26679;&#22797;&#26434;&#24230;&#37117;&#26159; O(NlogN) &#20294;&#22534;&#25490;&#22797;&#26434;&#24230;&#30340;&#24120;&#31995;&#25968;&#26356;&#22823;&#65289;</p>
<p>&#26412;&#26469;&#21602;&#65292;MacKay &#20889;&#37027;&#31687;&#25991;&#31456;&#26159;&#24819;&#29992;&#20449;&#24687;&#35770;&#26469;&#35299;&#37322;&#20026;&#20160;&#20040;&#22534;&#25490;&#24930;&#65292;&#20197;&#21450;&#20026;&#20160;&#20040;&#24555;&#25490;&#20063;&#24930;&#30340;&#12290;MacKay &#22312;&#20182;&#30340;&#25991;&#31456;&#20013;&#30340;&#35299;&#37322;&#26159;&#65292;&#21482;&#26377;&#25552;&#20986;&#27599;&#31181;&#31572;&#26696;&#30340;&#27010;&#29575;&#37117;&#22343;&#31561;&#30340;&#38382;&#39064;&#65292;&#25165;&#33021;&#33719;&#24471;&#26368;&#22823;&#20449;&#24687;&#37327;&#12290;&#28982;&#32780;&#65292;&#20180;&#32454;&#19968;&#24819;&#65292;&#20854;&#23454;&#36825;&#37324;&#20449;&#24687;&#35770;&#24182;&#19981;&#26159;&#22240;&#65292;&#32780;&#26159;&#26524;&#12290;&#36825;&#37324;&#19981;&#38656;&#35201;&#29992;&#20449;&#24687;&#35770;&#23601;&#23436;&#20840;&#33021;&#22815;&#35299;&#37322;&#65292;&#32780;&#19988;&#26356;&#26126;&#30333;&#12290;&#20449;&#24687;&#35770;&#21482;&#26159;&#23545;&#36825;&#20010;&#35299;&#37322;&#30340;&#19968;&#20010;&#24418;&#24335;&#21270;&#12290;</p>
<blockquote>
<p>&#21478;&#22806;&#65292;&#36825;&#20960;&#22825;&#25105;&#37325;&#26032;&#25226; TAOCP &#31532;&#19977;&#21367; (&#31532;&#20108;&#29256;) &#32763;&#20986;&#26469;&#30475;&#20102;&#30475; Knuth &#24590;&#20040;&#35828;&#36825;&#20010;&#38382;&#39064;&#30340;, &#21457;&#29616;&#30495;&#26159;&#29275;&#22823;&#20102;&#65306;</p>
<p>&#20808;&#35828;&#24615;&#33021;&#65306;</p>
<p>pp148, section 5.2.3 &#35828;&#65306;</p>
<p>When N = 1000, the approximate average runiing time on MIX are</p>
<ul>
<li>160000u for heapsort</li>
<li>130000u for shellsort</li>
<li>80000u for quicksort</li>
</ul>
<p>&#36825;&#37324;, Knuth &#21516;&#23398;&#21457;&#29616;&#19968;&#33324;&#24773;&#20917;&#19979; heapsort &#34920;&#29616;&#24456;&#19981;&#22909;. &#20110;&#26159;&#65292;&#22312;&#19979;&#25991;&#20182;&#23601;&#35828;&#65292;&#20064;&#39064; 18 (pp156, &#38590;&#24230; 21)</p>
<p>(R.W.Floyd) During the selection phase of heapsort, the key K tends to be quite small, so that nearly all the comparisons in step H6 find K&lt;K_j. Show how to modify the algorithm so that K is not compared with K_j in the main loop of the computation, thereby nearly cutting the average number of comparisons in half.</p>
<p>&#31572;&#26696;&#37324;&#38754;&#30340;&#26041;&#27861;&#21644; DMK &#30340;&#26041;&#27861;&#26159;&#19968;&#26679;&#30340;&#12290;(&#25105;&#35273;&#24471; DMK &#26159;&#30475;&#20102;&#36825;&#20010;&#35770;&#25991;&#25110;&#32773; TAoCP &#30340;) &#36825;&#37324;&#35828; by half&#65292;&#23601;&#27491;&#22909;&#21644;&#24555;&#25490;&#24046;&#19981;&#22810;&#20102;&#12290;</p>
<p>&#20877;&#35828;&#20449;&#24687;&#35770;&#20998;&#26512;&#65306;</p>
<p>&#22312; 5.3.1 (pp181) &#39640;&#29239;&#29239;&#23601;&#35828;, &#8220;&#25490;&#24207;&#38382;&#39064;&#21487;&#20197;&#30475;&#25104;&#26159;&#19968;&#20010;&#26641;&#19978;&#30340;&#40479;&#20799;&#25490;&#25490;&#31449;&#30340;&#38382;&#39064;. (&#36824;&#29305;&#22320;&#30011;&#20102;&#19968;&#26869;&#26641;), &#19979;&#19968;&#27573;&#23601;&#35828;, &#20854;&#23454;&#36825;&#20010;&#20063;&#26377;&#31561;&#20215;&#35828;&#27861;, &#23601;&#26159;&#20449;&#24687;&#35770;, &#25105;&#20204;&#20174;&#31216;&#29699;&#38382;&#39064;&#35828;&#36215;&#8230;&#8221;</p>
<p>&#28982;&#21518;&#21518;&#38754;&#19968;&#30452;&#35762;&#20449;&#24687;&#35770;&#21644;&#26368;&#23567;&#27604;&#36739;&#25490;&#24207;&#8230;</p>
</blockquote>
<p>&#39640;&#29239;&#29239;&#30495;&#19981;&#24871;&#26159;&#22995;&#39640;&#30340;&#65292;&#22247; rz..</p>
<p>refs and see also</p>
<ul>
<li><a href="http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/">&#30693;&#20854;&#25152;&#20197;&#28982;&#65288;&#20197;&#31639;&#27861;&#23398;&#20064;&#20026;&#20363;&#65289;</a></li>
<li><a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">&#25968;&#23398;&#20043;&#32654;&#30058;&#22806;&#31687;&#65306;&#24555;&#25490;&#20026;&#20160;&#20040;&#37027;&#26679;&#24555;</a></li>
<li><a href="http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/">&#30693;&#20854;&#25152;&#20197;&#28982;&#65288;&#19977;&#65289;&#65306;&#20026;&#20160;&#20040;&#31639;&#27861;&#36825;&#20040;&#38590;&#65311;</a></li>
<li><a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">&#25968;&#23398;&#20043;&#32654;&#30058;&#22806;&#31687;&#65306;&#24555;&#25490;&#20026;&#20160;&#20040;&#37027;&#26679;&#24555;</a></li>
</ul>
</dd>
<dt>&#26377;&#21738;&#20123;&#23398;&#20064;&#31639;&#27861;&#30340;&#32593;&#31449;&#25512;&#33616;&#65311; <code class="fold">@</code></dt>
<dd><p>&#25152;&#20197;, &#20542;&#24773;&#25512;&#33616;:</p>
<p><a href="http://oj.leetcode.com" class="uri">http://oj.leetcode.com</a> LeetCode Online Judge</p>
<p>&#21482;&#35201;&#27599;&#36947;&#39064;&#37117;&#21487;&#20197;&#20445;&#35777; 3 &#36941;&#20197;&#20869;&#36807;, &#25152;&#26377;&#28286;&#21306;&#24037;&#20316; entry level &#38543;&#20415;&#25361;. &#28041;&#21450;&#21040;&#30340;&#22522;&#26412;&#37117;&#26159; Linked List, DP, BST &#36825;&#26679;&#30340;&#31616;&#21333;&#25968;&#25454;&#32467;&#26500;&#25110;&#32773;&#31639;&#27861;&#39064;.</p>
<p>&#19981;&#38590;, &#20294;&#26159;&#23545;&#20110;&#21021;&#23398;&#31639;&#27861;&#30340;&#20154;&#26469;&#35828;, &#33021;&#29087;&#32451;&#36816;&#29992;&#36825;&#20123;&#31639;&#27861;&#24050;&#32463;&#24456;&#19981;&#23481;&#26131;&#20102;. &#21487;&#20197;&#35828;&#26159;&#38750;&#24120;&#19981;&#23481;&#26131;&#20102;. <strong>&#22240;&#20026;&#22826;&#22810;&#30340;&#20154;&#30524;&#39640;&#25163;&#20302;.</strong></p>
<p>&#25152;&#20197;&#35828;, &#36824;&#26159;&#20570;&#39064;&#26368;&#26377;&#25928;. &#23601;&#31639;&#26159;&#20320;&#30475;&#20102;&#31639;&#27861;&#23548;&#35770;&#30340;&#21069;&#20960;&#39029;, &#30693;&#36947;&#20102;&#20160;&#20040;&#26159; insertion sort, &#19981;&#35265;&#24471;&#20320;&#20889;&#20986;&#26469;&#30340;&#20195;&#30721;&#23601;&#26159;&#23545;&#30340;. &#19981;&#20449;&#30340;&#35805;, &#25171;&#24320; Insertion Sort List, &#35797;&#35797;&#33021;&#19981;&#33021;&#36890;&#36807;.</p>
<p>refs and see also</p>
<ul>
<li><a href="https://www.zhihu.com/question/20368410">&#26377;&#21738;&#20123;&#23398;&#20064;&#31639;&#27861;&#30340;&#32593;&#31449;&#25512;&#33616;&#65311; - &#30693;&#20046;</a></li>
</ul>
</dd>
</dl>
<h2 id="section-1">1.</h2>
<dl>
<dt>A Bit of Logic <code class="fold">@</code></dt>
<dd><table>
<colgroup>
<col width="43%" />
<col width="56%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">&#12304;Axiom&#12305;</th>
<th align="left">&#12304;Signification&#12305;</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>Associativity</strong> (&#32467;&#21512;&#24459;) of addition</td>
<td align="left"><code>u + (v + w) = (u + v) + w</code></td>
</tr>
<tr class="even">
<td align="left"><strong>Commutativity</strong> <code>[k&#601;,mju&#720;t&#601;'t&#618;v&#618;t&#618;]</code> (&#20132;&#25442;&#24459;) of addition</td>
<td align="left"><code>u + v = v + u</code></td>
</tr>
<tr class="odd">
<td align="left"><strong>Identity element</strong> of addition</td>
<td align="left">There exists an element 0 &#8712; V, called the zero vector, such that <code>v + 0 = v</code> for all v &#8712; V.</td>
</tr>
<tr class="even">
<td align="left"><strong>Inverse elements</strong> of addition</td>
<td align="left">For every v &#8712; V, there exists an element &#8722;v &#8712; V, called the additive inverse of v, such that v + (&#8722;v) = 0</td>
</tr>
</tbody>
</table>
<p>XOR: either one, but not both</p>
<table style="width:67%;">
<colgroup>
<col width="11%" />
<col width="55%" />
</colgroup>
<thead>
<tr class="header">
<th>Symbol</th>
<th align="left">Operator</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&amp;</code></td>
<td align="left">bitwise AND</td>
</tr>
<tr class="even">
<td><code>|</code></td>
<td align="left">bitwise inclusive OR</td>
</tr>
<tr class="odd">
<td><code>^</code></td>
<td align="left">bitwise XOR (eXclusive OR)</td>
</tr>
<tr class="even">
<td><code>&lt;&lt;</code></td>
<td align="left">left shift</td>
</tr>
<tr class="odd">
<td><code>&gt;&gt;</code></td>
<td align="left">right shift</td>
</tr>
<tr class="even">
<td><code>~</code></td>
<td align="left">bitwise NOT (one&#8217;s complement) (unary)</td>
</tr>
</tbody>
</table>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Bitwise_operation">Bitwise operation - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Bitwise_operations_in_C">Bitwise operations in C - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Exclusive_or">Exclusive or - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Linear_algebra">Linear algebra - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Bit_field">Bit field - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
<dt>&#20061;&#31456;&#31639;&#27861;&#29677;/&#24378;&#21270;&#29677; (JiuZhang) &#9829;&#65039; &#9829;&#65039; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><blockquote>
<p>&#27809;&#26377;&#25253;&#36825;&#20010;&#29677;&#65288;&#20851;&#38190;&#26159;&#31351; ==&#65289;&#65292;&#20294;&#20174;&#36825;&#20010;&#21015;&#34920;&#65288;syllabus&#65289;&#65292;&#21487;&#20197;&#21046;&#23450;&#33258;&#24049;&#30340;&#22797;&#20064;&#20869;&#23481;&#12290;</p>
</blockquote>
<dl>
<dt>&#65288;&#25105;&#25226; ACM-Cheatsheet &#21644; AOAPC &#20004;&#26412;&#20070;&#30340;&#20869;&#23481;&#25972;&#21512;&#36807;&#26469;&#20102;&#12290;&#65289; <code class="fold">@</code></dt>
<dd><dl>
<dt>ACM-Cheatsheet <code class="fold">@</code></dt>
<dd><p>ditched. have been merged into JiuZhang.</p>
<ul>
<li>chap2. Linear List</li>
<li>chap3. String</li>
<li>chap4. Stack and Queue</li>
<li>chap5. Tree</li>
<li>chap6. Searching</li>
<li>chap7. Sorting</li>
<li>chap8. Brute Force</li>
<li>chap9. BFS</li>
<li>chap10. DFS</li>
<li>chap11. Divide &amp; Conquer</li>
<li>chap12. Greedy</li>
<li>chap13. DP</li>
<li>chap14. Graph</li>
<li>chap15. Math Methods and Models</li>
<li>chap16. Big Integer</li>
<li>chap17. Functionalities</li>
</ul>
</dd>
<dt>aoapc-book <code class="fold">@</code></dt>
<dd><p>ditched. have been merged into JiuZhang.</p>
<p><strong>&#31532;&#19968;&#37096;&#20998;&#65306;&#35821;&#35328;&#31687;</strong></p>
<ul>
<li>&#31532; 1 &#31456;&#65292;&#31243;&#24207;&#35774;&#35745;&#20837;&#38376;</li>
<li>&#31532; 2 &#31456;&#65292;&#24490;&#29615;&#32467;&#26500;&#31243;&#24207;&#35774;&#35745;</li>
<li>&#31532; 3 &#31456;&#65292;&#25968;&#32452;&#21644;&#23383;&#31526;&#20018;</li>
<li>&#31532; 4 &#31456;&#65292;&#20989;&#25968;&#21644;&#36882;&#24402;</li>
</ul>
<p><strong>&#31532;&#20108;&#37096;&#20998;&#65306;&#22522;&#30784;&#31687;</strong></p>
<ul>
<li>&#31532; 6 &#31456;&#65292;&#25968;&#25454;&#32467;&#26500;&#22522;&#30784;</li>
<li>&#31532; 7 &#31456;&#65292;&#26292;&#21147;&#27714;&#35299;&#27861;</li>
</ul>
<p><strong>&#31532;&#19977;&#37096;&#20998;&#65306;&#31454;&#36187;&#31687;</strong></p>
<ul>
<li>&#31532; 8 &#31456;&#65292;&#39640;&#32423;&#31639;&#27861;&#35774;&#35745;</li>
<li>&#31532; 9 &#31456;&#65292;&#21160;&#24577;&#35268;&#21010;&#21021;&#27493;</li>
<li>&#31532; 10 &#31456;&#65292;&#25968;&#23398;&#27010;&#24565;&#19982;&#26041;&#27861;</li>
<li>&#31532; 11 &#31456;&#65292;&#22270;&#35770;&#27169;&#22411;&#19982;&#31639;&#27861;</li>
<li>&#31532; 12 &#31456;&#65292;&#39640;&#32423;&#19987;&#39064;</li>
</ul>
</dd>
</dl>
</dd>
<dt>Lessons for Whom? <code class="fold">@</code></dt>
<dd><ul>
<li>&#26080;&#31639;&#27861;&#22522;&#30784;&#65292;&#25110;&#31639;&#27861;&#22522;&#30784;&#34180;&#24369;&#65292;&#19981;&#31995;&#32479;</li>
<li>&#24076;&#26395;&#27714;&#32844; Facebook, Google, Linkedin, Airbnb, Uber &#31561;&#30789;&#35895;&#30693;&#21517;&#20225;&#19994;</li>
<li>&#38754;&#35797;&#32463;&#39564;&#23569;&#25110;&#26080;&#38754;&#35797;&#32463;&#39564;&#65292;&#19981;&#30693;&#36947;&#19982;&#38754;&#35797;&#23448;&#22914;&#20309;&#27491;&#30830;&#30340;&#27807;&#36890;&#21644;&#23637;&#29616;&#33258;&#24049;</li>
<li>&#32593;&#19978;&#32451;&#20064;&#39064;&#30446;&#37027;&#20040;&#22810;&#65292;&#19981;&#30693;&#36947;&#35813;&#20174;&#21738;&#20123;&#39064;&#24320;&#22987;&#20934;&#22791;</li>
<li>&#33719;&#21462;&#26368;&#26032;&#38754;&#35797;&#21160;&#21521;</li>
<li>&#35748;&#35782;&#19968;&#36215;&#25214;&#24037;&#20316;&#30340;&#20854;&#20182;&#23567;&#20249;&#20276;</li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/07/31 &#19978;&#21320; 9:30:00 1. Introducing Algorithm Interview &amp;&amp; Coding Style&#12304;&#20813;&#36153;&#35797;&#21548;&#12305; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#36890;&#36807; strStr &#36825;&#19968;&#36947;&#24120;&#35265;&#38754;&#35797;&#39064;&#35762;&#35299;&#38754;&#35797;&#20013;&#30340;&#24120;&#35265;&#35823;&#21306; <code class="fold">@</code></dt>
<dd><p>&#29992;&#24120;&#35268;&#30340;&#24490;&#29615;&#26469;&#20570;&#30340;&#35805;&#65292;&#22797;&#26434;&#24230;&#26159; O(mn)&#65292;&#21442;&#32771;&#20195;&#30721;&#22914;&#19979;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> strstr(<span class="dt">char</span> *str, <span class="dt">char</span> *sub)
{
    <span class="kw">if</span> ( !str || !sub) { <span class="kw">return</span> <span class="dv">-1</span>; }

    <span class="dt">int</span> nstr = strlen(str);
    <span class="dt">int</span> nsub = strlen(sub);
    <span class="kw">if</span> ( nstr &lt; nsub ) { <span class="kw">return</span> <span class="dv">-1</span>; }

    <span class="dt">int</span> len = nstr - nsub;
    <span class="dt">int</span> i,j;
    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= len; ++i ) {          <span class="co">// &#22914;&#26524;&#20004;&#20010;&#23383;&#31526;&#20018;&#31561;&#38271;, &#33267;&#23569;&#35201;&#27604;&#36739;&#19968;&#19979;, &#23545;&#21543;.</span>
        <span class="dt">int</span> j;
        <span class="kw">for</span> ( j = <span class="dv">0</span>; j &lt; nsub; ++j ) {
            <span class="kw">if</span> ( str[i+j] != sub[j] ) {
                <span class="kw">break</span>;
            }
        }
        <span class="kw">if</span> ( j == nsub ) {
            <span class="kw">return</span> i + <span class="dv">1</span>;
        }
    }
    <span class="kw">return</span> <span class="dv">-1</span>;
}</code></pre></div>
<p>&#35823;&#21306;&#65311;&#65306;</p>
<ul>
<li>&#32467;&#26524;&#27491;&#30830; v.s. &#26465;&#29702;&#28165;&#26224;</li>
<li>&#20195;&#30721;&#39118;&#26684;</li>
<li>&#20998;&#26512;&#12289;&#25551;&#36848;&#38382;&#39064;</li>
<li>&#36793;&#30028;&#26816;&#26597;&#65311;</li>
<li>&#38590;&#24230;&#65311;</li>
</ul>
<p>&#36825;&#20010;&#21338;&#23458;&#24456;&#22909;&#30340;&#35828;&#26126;&#20102;&#38754;&#35797;&#23448;&#30340;&#32771;&#23519;&#24605;&#36335;&#65306;</p>
<dl>
<dt><a href="http://lucida.me/blog/from-wuxia-to-programmer-interview/">&#20174;&#27494;&#20384;&#23567;&#35828;&#21040;&#31243;&#24207;&#21592;&#38754;&#35797; - Lucida</a> <code class="fold">@</code></dt>
<dd><p>&#22238;&#21040;&#31243;&#24207;&#21592;&#38754;&#35797;&#65292;&#22823;&#22810;&#25968;&#31508;&#35797; / &#38754;&#35797;&#39064;&#30446;&#37117;&#21487;&#20197;&#22312;&#32593;&#19978;&#25214;&#21040;&#65292;&#32780;&#19968;&#20123;&#20844;&#21496;&#22312;&#25307;&#32856;&#26102;&#20026;&#20102;&#30465;&#20107;&#29978;&#33267;&#30452;&#25509;&#21040;&#32593;&#19978;&#25628;&#39064;&#65292;&#36825;&#23601;&#23548;&#33268;&#30475;&#20284;&#24456;&#39640;&#30340;&#31243;&#24207;&#21592;&#38754;&#35797;&#38376;&#27099;&#23454;&#38469;&#21464;&#30340;&#24456;&#20302;&#8212;&#8212;&#24471;&#21040;&#19968;&#20221;&#36824;&#19981;&#38169;&#30340;&#24037;&#20316;&#24182;&#19981;&#38656;&#35201;&#33457;&#19968;&#20004;&#24180;&#31995;&#32479;&#30340;&#23398;&#20064;&#35745;&#31639;&#26426;&#25216;&#26415;&#65292;&#32780;&#21482;&#38656;&#19968;&#20004;&#20010;&#26376;&#21040; leetcode&#12289; CareerCup &#20197;&#21450;&#26410;&#21517;&#27714;&#32844;&#29256;&#21047;&#39064;&#30446;&#12290;&#21407;&#26412;&#24456;&#26377;&#21306;&#20998;&#24230;&#30340;&#31639;&#27861;&#39064;&#30446;&#20063;&#21464;&#30340;&#27627;&#26080;&#20215;&#20540;&#8212;&#8212;&#35841;&#30693;&#36947;&#20320;&#26159;&#33258;&#24049;&#24819;&#20986;&#26469;&#30340;&#36824;&#26159;&#32972;&#20986;&#26469;&#30340;&#12290;&#23601;&#20687;&#36731;&#21151;&#27700;&#19978;&#28418;&#65292;&#35841;&#30693;&#36947;&#20320;&#26159;&#30495;&#30340;&#21151;&#21147;&#28145;&#21402;&#65292;&#36824;&#26159;&#25552;&#21069;&#22312;&#27700;&#24213;&#25171;&#20102;&#26263;&#26729;&#12290;</p>
<p>&#25509;&#19979;&#26469;&#25105;&#20250;&#38382;&#38754;&#35797;&#32773;&#33021;&#19981;&#33021;&#25913;&#21892;&#23427;&#30340;<strong>&#21487;&#35835;&#24615;&#65288;Readability&#65289;</strong>: <code>input - 32</code> -&gt; <code>input - 'a' + 'A'</code></p>
<p>&#20854;&#23454;&#23601;&#26159;&#29992; <code>'a' &lt;= input &amp;&amp; input &lt;= 'z'</code> &#26367;&#20195; <code>input &gt;= 'a' &amp;&amp; input &lt;= 'z'</code> &#8212;&#8212; &#36825;&#20010;&#25216;&#24039;&#28304;&#33258;&#20110;&#20195;&#30721;&#22823;&#20840;&#65292;&#20195;&#30721;&#22823;&#20840;&#37324;&#38754;&#19987;&#38376;&#26377;&#19968;&#33410;&#35762;&#35299;&#22914;&#20309;&#32534;&#20889;&#21487;&#35835;&#30340;&#24067;&#23572;&#34920;&#36798;&#24335;&#12290;&#20174;&#36825;&#37324;&#25105;&#21487;&#20197;&#30475;&#20986;&#36825;&#20123;&#38754;&#35797;&#32773;&#37117;&#27809;&#26377;&#35835;&#36807;&#20195;&#30721;&#22823;&#20840;&#65292;&#32771;&#34385;&#21040;&#20195;&#30721;&#22823;&#20840;&#20960;&#20046;&#26159;&#31243;&#24207;&#35774;&#35745;&#30340;&#24517;&#35835;&#20070;&#31821;&#65292;&#25105;&#21487;&#20197;&#25512;&#26029;&#20986;&#36825;&#20123;&#38754;&#35797;&#32773;&#24456;&#21487;&#33021;&#27809;&#26377;&#38405;&#35835;&#20064;&#24815;&#65292;&#32780;&#19981;&#38405;&#35835;&#30340;&#31243;&#24207;&#21592;&#19968;&#33324;&#37117;&#19981;&#20250;&#22826;&#20986;&#33394;&#12290;</p>
<p>&#25509;&#19979;&#26469;&#25105;&#20250;&#35810;&#38382;&#33021;&#19981;&#33021;&#36827;&#19968;&#27493;&#25552;&#21319;&#24615;&#33021;: table</p>
<p>&#22914;&#26524;&#38754;&#35797;&#32773;&#33021;&#25552;&#21040;&#20182;&#26159;&#20174; C &#35821;&#35328;&#26631;&#20934;&#24211; &#37324;&#38754;&#23398;&#21040;&#36825;&#20010;&#25216;&#24039;&#65292;&#21152; 10 &#20998; :&#8211;)</p>
<p>&#26377;&#30340;&#38754;&#35797;&#32773;&#20250;&#24819;&#21040;&#20351;&#29992;&#23439;&#65306; <code>#define TO_UPPER(input) convert_table[input]</code> &#36825;&#26102;&#25105;&#20250;&#35810;&#38382;&#23439;&#30340;&#20248;&#28857;&#21644;&#32570;&#28857;&#65292;&#20197;&#21450;&#22312;&#36825;&#37324;&#20351;&#29992;&#23439;&#20250;&#19981;&#20250;&#26377;&#38169;&#35823;&#12290;&#24635;&#20043;&#23601;&#26159;&#30830;&#23450;&#38754;&#35797;&#32773;&#30830;&#23454;&#29702;&#35299;&#23439;&#65292;&#32780;&#19981;&#26159;&#20174;&#21738;&#37324;&#65288;&#27604;&#22914;&#32534;&#31243;&#20043;&#32654;&#20043;&#31867;&#30340;&#38754;&#35797;&#20070;&#31821;&#65289;&#32972;&#20102;&#19968;&#20010;&#31572;&#26696;&#20986;&#26469;&#12290;</p>
<p>&#25509;&#19979;&#26469;&#65292;&#35753;&#25105;&#20204;&#22238;&#39038;&#36825;&#36947;&#31616;&#21333;&#30340;&#39064;&#30446;&#37117;&#32771;&#23519;&#20102;&#21738;&#20123;&#28857;&#65306;</p>
<ul>
<li><p>&#20989;&#25968;&#30340;&#27010;&#24565;&#65288;&#32780;&#19981;&#26159;&#20889;&#22312; main &#37324;&#65289;;</p></li>
<li><p>&#32553;&#36827;&#21644;&#21629;&#21517;&#65288;&#32780;&#19981;&#26159;&#25340;&#38899;&#65289;&#65307;</p></li>
<li><p>&#20351;&#29992;&#21487;&#35835;&#30340;&#23383;&#38754;&#37327;&#65288;&#8216;a&#8217; - &#8217;A&#8217;&#32780;&#38750; 32&#65289;&#65307;</p></li>
<li><p><strong>API &#35774;&#35745;</strong>&#65288;&#24403; to_upper &#25509;&#25910;&#21040;&#38750;&#23567;&#20889;&#23383;&#27597;&#23383;&#31526;&#24212;&#35813;&#36820;&#22238;&#20160;&#20040;&#65311;0&#65311;&#25253;&#38169;&#65311;&#36824;&#26159;&#36820;&#22238;&#21407;&#20540;&#65311;&#32771;&#34385;&#21040; to_upper &#30340;&#24212;&#29992;&#22330;&#26223;&#26159;&#25226;&#19968;&#20010;&#23383;&#31526;&#20018;&#20013;&#30340;&#23567;&#20889;&#23383;&#27597;&#36716;&#21270;&#20026;&#22823;&#20889;&#65292;&#36820;&#22238;&#21407;&#20540;&#26174;&#28982;&#26356;&#21512;&#29702;&#65289;&#65307;</p></li>
<li><p><strong>&#26159;&#21542;&#26377;&#38405;&#35835;&#20064;&#24815;</strong>&#65288;&#33267;&#23569;&#21487;&#20197;&#30475;&#20986;&#20320;&#26377;&#27809;&#26377;&#35748;&#30495;&#30340;&#35835;&#36807;&#20195;&#30721;&#22823;&#20840;&#65289;&#65307;</p></li>
<li><dl>
<dt>&#26159;&#21542;&#35835;&#36807; C &#26631;&#20934;&#24211;&#28304;&#30721;&#65288;&#25351;&#20986; toupper &#25968;&#32452;&#23454;&#29616;&#30340;&#20986;&#22788;&#65289;&#65307; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* Note: this is decimal, not hex, to avoid accidental promotion to unsigned */</span>
<span class="ot">#define _toupper(__c) ((__c) &amp; ~32)             </span><span class="co">// turn off one bit, -32</span>
<span class="ot">#define _tolower(__c) ((__c) | 32)              </span><span class="co">// turn on  one bit, +32</span>

<span class="kw">enum</span> {                                          <span class="co">// flags</span>
    __ctype_upper = (<span class="dv">1</span> &lt;&lt; <span class="dv">0</span>),
    __ctype_lower = (<span class="dv">1</span> &lt;&lt; <span class="dv">1</span>),
    __ctype_digit = (<span class="dv">1</span> &lt;&lt; <span class="dv">2</span>),
    __ctype_xdigit = (<span class="dv">1</span> &lt;&lt; <span class="dv">3</span>),
    __ctype_space = (<span class="dv">1</span> &lt;&lt; <span class="dv">4</span>),
    __ctype_print = (<span class="dv">1</span> &lt;&lt; <span class="dv">5</span>),
    __ctype_punct = (<span class="dv">1</span> &lt;&lt; <span class="dv">6</span>),
    __ctype_cntrl = (<span class="dv">1</span> &lt;&lt; <span class="dv">7</span>),
};

<span class="dt">extern</span> <span class="dt">const</span> <span class="dt">unsigned</span> <span class="dt">char</span> __ctypes[];          <span class="co">// lookup table</span>

__ctype_inline <span class="dt">int</span> islower(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> __ctypes[__c + <span class="dv">1</span>] &amp; __ctype_lower;
}

__ctype_inline <span class="dt">int</span> isupper(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> __ctypes[__c + <span class="dv">1</span>] &amp; __ctype_upper;
}

__ctype_inline <span class="dt">int</span> toupper(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> islower(__c) ? _toupper(__c) : __c;
}

__ctype_inline <span class="dt">int</span> tolower(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> isupper(__c) ? _tolower(__c) : __c;
}</code></pre></div>
<dl>
<dt>/usr/lib/syslinux/com32/include/ctype.h <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/*</span>
<span class="co"> * ctype.h</span>
<span class="co"> *</span>
<span class="co"> * This assumes ISO 8859-1, being a reasonable superset of ASCII.</span>
<span class="co"> */</span>

<span class="ot">#ifndef _CTYPE_H</span>
<span class="ot">#define _CTYPE_H</span>

<span class="ot">#include &lt;klibc/extern.h&gt;</span>

<span class="ot">#ifndef __CTYPE_NO_INLINE</span>
<span class="ot"># define __ctype_inline static __inline__</span>
<span class="ot">#else</span>
<span class="ot"># define __ctype_inline</span>
<span class="ot">#endif</span>

<span class="co">/*</span>
<span class="co"> * This relies on the following definitions:</span>
<span class="co"> *</span>
<span class="co"> * cntrl = !print</span>
<span class="co"> * alpha = upper|lower</span>
<span class="co"> * graph = punct|alpha|digit</span>
<span class="co"> * blank = &#39;\t&#39; || &#39; &#39; (per POSIX requirement)</span>
<span class="co"> */</span>
<span class="kw">enum</span> {
    __ctype_upper = (<span class="dv">1</span> &lt;&lt; <span class="dv">0</span>),
    __ctype_lower = (<span class="dv">1</span> &lt;&lt; <span class="dv">1</span>),
    __ctype_digit = (<span class="dv">1</span> &lt;&lt; <span class="dv">2</span>),
    __ctype_xdigit = (<span class="dv">1</span> &lt;&lt; <span class="dv">3</span>),
    __ctype_space = (<span class="dv">1</span> &lt;&lt; <span class="dv">4</span>),
    __ctype_print = (<span class="dv">1</span> &lt;&lt; <span class="dv">5</span>),
    __ctype_punct = (<span class="dv">1</span> &lt;&lt; <span class="dv">6</span>),
    __ctype_cntrl = (<span class="dv">1</span> &lt;&lt; <span class="dv">7</span>),
};

<span class="dt">extern</span> <span class="dt">const</span> <span class="dt">unsigned</span> <span class="dt">char</span> __ctypes[];

__ctype_inline <span class="dt">int</span> isalnum(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> __ctypes[__c + <span class="dv">1</span>] &amp; (__ctype_upper | __ctype_lower | __ctype_digit);
}

__ctype_inline <span class="dt">int</span> isalpha(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> __ctypes[__c + <span class="dv">1</span>] &amp; (__ctype_upper | __ctype_lower);
}

__ctype_inline <span class="dt">int</span> isascii(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> !(__c &amp; ~<span class="bn">0x7f</span>);
}

__ctype_inline <span class="dt">int</span> isblank(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> (__c == <span class="st">&#39;</span><span class="ch">\t</span><span class="st">&#39;</span>) || (__c == <span class="st">&#39; &#39;</span>);
}

__ctype_inline <span class="dt">int</span> iscntrl(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> __ctypes[__c + <span class="dv">1</span>] &amp; __ctype_cntrl;
}

__ctype_inline <span class="dt">int</span> isdigit(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> ((<span class="dt">unsigned</span>)__c - <span class="st">&#39;0&#39;</span>) &lt;= <span class="dv">9</span>;
}

__ctype_inline <span class="dt">int</span> isgraph(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> __ctypes[__c + <span class="dv">1</span>] &amp;
    (__ctype_upper | __ctype_lower | __ctype_digit | __ctype_punct);
}

__ctype_inline <span class="dt">int</span> islower(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> __ctypes[__c + <span class="dv">1</span>] &amp; __ctype_lower;
}

__ctype_inline <span class="dt">int</span> isprint(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> __ctypes[__c + <span class="dv">1</span>] &amp; __ctype_print;
}

__ctype_inline <span class="dt">int</span> ispunct(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> __ctypes[__c + <span class="dv">1</span>] &amp; __ctype_punct;
}

__ctype_inline <span class="dt">int</span> isspace(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> __ctypes[__c + <span class="dv">1</span>] &amp; __ctype_space;
}

__ctype_inline <span class="dt">int</span> isupper(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> __ctypes[__c + <span class="dv">1</span>] &amp; __ctype_upper;
}

__ctype_inline <span class="dt">int</span> isxdigit(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> __ctypes[__c + <span class="dv">1</span>] &amp; __ctype_xdigit;
}

<span class="co">/* Note: this is decimal, not hex, to avoid accidental promotion to unsigned */</span>
<span class="ot">#define _toupper(__c) ((__c) &amp; ~32)</span>
<span class="ot">#define _tolower(__c) ((__c) | 32)</span>

__ctype_inline <span class="dt">int</span> toupper(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> islower(__c) ? _toupper(__c) : __c;
}

__ctype_inline <span class="dt">int</span> tolower(<span class="dt">int</span> __c)
{
    <span class="kw">return</span> isupper(__c) ? _tolower(__c) : __c;
}

__extern <span class="dt">char</span> *skipspace(<span class="dt">const</span> <span class="dt">char</span> *p);
__extern <span class="dt">void</span> chrreplace(<span class="dt">char</span> *source, <span class="dt">char</span> old, <span class="dt">char</span> <span class="kw">new</span>);

<span class="ot">#endif </span><span class="co">/* _CTYPE_H */</span></code></pre></div>
</dd>
</dl>
</dd>
</dl></li>
<li><p>&#25968;&#32452;&#30340;&#36816;&#29992;&#65288;&#20351;&#29992;&#36716;&#25442;&#34920;&#65289;&#65307;</p></li>
<li><p>&#20102;&#35299;&#23439;&#65292;&#20197;&#21450;&#23439;&#30340;&#21361;&#23475;&#65288;&#20351;&#29992;&#23439;&#65289;&#65307;</p></li>
<li><p>&#26159;&#21542;&#32972;&#36807;&#36825;&#36947;&#39064;&#65288;&#22312;&#31532;&#19968;&#26102;&#38388;&#32473;&#20986;&#20351;&#29992;&#25968;&#32452; + &#23439;&#30340;&#26368;&#20248;&#26041;&#26696;&#65289;&#65307;</p></li>
<li><p>EOF &#20197;&#21450; C &#26631;&#20934;&#24211;&#39118;&#26684;&#12290;</p></li>
</ul>
<p>&#25509;&#19979;&#26469;&#25105;&#36824;&#20250;&#35201;&#27714;&#38754;&#35797;&#32773;&#27979;&#35797;&#36825;&#20010;&#20989;&#25968;&#24182;&#32473;&#20986;<strong>&#27979;&#35797;</strong>&#20195;&#30721;&#65292;&#36825;&#37324;&#24661;&#19981;&#36184;&#36848;&#12290;</p>
<p>&#25105;&#30340;&#31572;&#26696;&#26159;&#65292;&#25490;&#38500;&#23545;&#31639;&#27861;&#30340;&#30450;&#30446;&#23815;&#25308;&#65292;&#22240;&#20026;&#36825;&#26679;&#30340;&#39064;&#30446;&#38750;&#24120;&#38590;&#20986;&#65292;&#32780;&#19988;&#23545;&#38754;&#35797;&#23448;&#30340;&#35201;&#27714;&#21448;&#24456;&#39640;&#65292;&#25152;&#20197;&#32477;&#22823;&#22810;&#25968;&#38754;&#35797;&#23448;&#37117;&#36873;&#25321;&#21435;&#32593;&#19978;&#25628;&#39064;&#30446;&#32780;&#19981;&#26159;&#33258;&#24049;&#20986;&#39064;&#36825;&#26465;&#25463;&#24452;&#12290;&#27530;&#19981;&#30693;&#36825;&#26465;&#25463;&#24452;&#27491;&#26159;&#20154;&#25165;&#25307;&#32856;&#22833;&#36133;&#30340;&#28304;&#27849;&#8212;&#8212;&#20248;&#31168;&#30340;&#31243;&#24207;&#21592;&#22240;&#20026;&#27809;&#26377;&#32972;&#39064;&#32780;&#34987;&#25298;&#32477;&#65292;&#32780;&#27700;&#24179;&#24179;&#24179;&#30340;&#8220;&#35032;&#21315;&#19976;&#8221;&#20204;&#21364;&#22240;&#20026;&#32972;&#36807;&#39064;&#30446;&#32780;&#34987;&#24405;&#29992;&#65292;&#36825;&#20123;&#24405;&#29992;&#30340;&#8220;&#35032;&#21315;&#19976;&#8221;&#20204;&#21448;&#20250;&#29992;&#21516;&#26679;&#30340;&#26041;&#24335;&#25307;&#32856;&#19979;&#19968;&#25209;&#26356;&#21152;&#31967;&#31957;&#30340;&#8220;&#35032;&#21315;&#19976;&#8221;&#65292;&#35773;&#21050;&#33267;&#32423;&#12290;</p>
</dd>
</dl>
<p>&#20174;&#38754;&#35797;&#32773;&#30340;&#35282;&#24230;&#26469;&#35828;&#65292;&#20986;&#39064;&#30340;&#30446;&#30340;&#65311;: <strong>qualified.</strong></p>
<ul>
<li>tell them you are professional</li>
<li>tell them you are smart</li>
<li>tell them you match</li>
</ul>
<p>&#24605;&#36335;&#65306;</p>
<ul>
<li>&#21487;&#20197;&#29992; bitmap</li>
<li>&#21487;&#20197;&#25490;&#24207;&#65292;&#28982;&#21518;&#29992; i&#65292;j &#26469;&#21028;&#26029;&#12290;</li>
</ul>
<p>&#36824;&#21487;&#20197;&#29992;&#29275;&#36924;&#38378;&#38378;&#30340; KMP &#31639;&#27861;&#12290;</p>
<dl>
<dt>KMP &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>KMP &#31639;&#27861;&#26159; Knuth&#12289;Morris &#21644; Pratt &#22312; 1976 &#24180;&#21457;&#34920;&#30340;&#12290;&#23427;&#30340;&#22522;&#26412;&#24605;&#24819;&#26159;&#65292;&#24403;&#20986;&#29616;&#19981;&#21305;&#37197;&#26102;&#65292;&#23601;&#33021;&#30693;&#26195;&#19968;&#37096;&#20998;&#25991;&#26412;&#30340;&#20869;&#23481;&#65288;&#22240;&#20026;&#22312;&#21305;&#37197;&#22833;&#36133;&#20043;&#21069;&#23427;&#20204;&#24050;&#32463;&#21644;&#27169;&#24335;&#30456;&#21305;&#37197;&#65289;&#12290;&#25105;&#20204;&#21487;&#20197;&#21033;&#29992;&#36825;&#20123;&#20449;&#24687;&#36991;&#20813;&#23558;&#25351;&#38024;&#22238;&#36864;&#21040;&#25152;&#26377;&#36825;&#20123;&#24050;&#30693;&#30340;&#23383;&#31526;&#20043;&#21069;&#12290;&#36825;&#26679;&#65292;&#24403;&#20986;&#29616;&#19981;&#21305;&#37197;&#26102;&#65292;&#21487;&#20197;&#25552;&#21069;&#21028;&#26029;&#22914;&#20309;&#37325;&#26032;&#24320;&#22987;&#26597;&#25214;&#65292;<strong>&#32780;&#36825;&#31181;&#21028;&#26029;&#21482;&#21462;&#20915;&#20110;&#27169;&#24335;&#26412;&#36523;</strong>&#12290;</p>
<p>&#25512;&#33616;&#32593;&#19978;&#30340;&#20960;&#31687;&#27604;&#36739;&#22909;&#30340;&#21338;&#23458;&#65292;&#35762;&#30340;&#26159;&#37096;&#20998;&#21305;&#37197;&#34920; (partial match table) &#30340;&#26041;&#27861;&#65288;&#21363; next &#25968;&#32452;&#65289;:</p>
<ul>
<li><dl>
<dt><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">&#23383;&#31526;&#20018;&#21305;&#37197;&#30340;KMP&#31639;&#27861; - &#38446;&#19968;&#23792;&#30340;&#32593;&#32476;&#26085;&#24535;</a> <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://image.beekka.com/blog/201305/bg2013050109.png" />

</div>
<p>&#31227;&#21160;&#20301;&#25968; = &#24050;&#21305;&#37197;&#30340;&#23383;&#31526;&#25968; - &#23545;&#24212;&#30340;&#37096;&#20998;&#21305;&#37197;&#20540;</p>
<div class="figure">
<img src="http://image.beekka.com/blog/201305/bg2013050110.png" />

</div>
<div class="figure">
<img src="http://image.beekka.com/blog/201305/bg2013050114.png" />

</div>
<div class="figure">
<img src="http://whudoc.qiniudn.com/2016/kmp-table.png" />

</div>
<p>&#8220;&#37096;&#20998;&#21305;&#37197;&#8221;&#30340;&#23454;&#36136;&#26159;&#65292;&#26377;&#26102;&#20505;&#65292;&#23383;&#31526;&#20018;&#22836;&#37096;&#21644;&#23614;&#37096;&#20250;&#26377;&#37325;&#22797;&#12290;&#27604;&#22914;&#65292; &#8220;ABCDAB&#8221;&#20043;&#20013;&#26377;&#20004;&#20010;&#8220;AB&#8221;&#65292;&#37027;&#20040;&#23427;&#30340;&#8220;&#37096;&#20998;&#21305;&#37197;&#20540;&#8221;&#23601;&#26159; 2&#65288;&#8220;AB&#8221;&#30340;&#38271;&#24230;&#65289;&#12290;&#25628;&#32034;&#35789;&#31227;&#21160;&#30340;&#26102;&#20505;&#65292;&#31532;&#19968;&#20010;&#8220;AB&#8221;&#21521;&#21518;&#31227;&#21160; 4 &#20301;&#65288;&#23383;&#31526;&#20018;&#38271;&#24230; - &#37096;&#20998;&#21305;&#37197;&#20540;&#65289;&#65292;&#23601;&#21487;&#20197;&#26469;&#21040;&#31532;&#20108;&#20010;&#8220;AB&#8221;&#30340;&#20301;&#32622;&#12290;</p>
<p><a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">&#23383;&#31526;&#20018;&#21305;&#37197;&#30340; Boyer-Moore &#31639;&#27861; - &#38446;&#19968;&#23792;&#30340;&#32593;&#32476;&#26085;&#24535;</a></p>
<p>&#22312;&#19968;&#20010;&#23383;&#31526;&#20018;&#20013;&#25214;&#21040;&#31532;&#19968;&#20010;&#21482;&#20986;&#29616;&#19968;&#27425;&#30340;&#23383;&#31526;&#12290;&#22914;&#36755;&#20837; abaccdeff&#65292;&#21017;&#36755;&#20986; b&#12290;</p>
<pre><code>    A   B   C   D   A   B   D
    0   0   0   0   1   2   0

&quot;&#37096;&#20998;&#21305;&#37197;&#20540;&quot;&#23601;&#26159;&quot;&#21069;&#32512;&quot;&#21644;&quot;&#21518;&#32512;&quot;&#30340;&#26368;&#38271;&#30340;&#20849;&#26377;&#20803;&#32032;&#30340;&#38271;&#24230;&#12290;&#20197;&quot;ABCDABD&quot;&#20026;&#20363;&#65292;
-   &quot;A&quot;&#30340;&#21069;&#32512;&#21644;&#21518;&#32512;&#37117;&#20026;&#31354;&#38598;&#65292;&#20849;&#26377;&#20803;&#32032;&#30340;&#38271;&#24230;&#20026; 0&#65307;
-   &quot;AB&quot;&#30340;&#21069;&#32512;&#20026; [A]&#65292;&#21518;&#32512;&#20026; [B]&#65292;&#20849;&#26377;&#20803;&#32032;&#30340;&#38271;&#24230;&#20026; 0&#65307;
-   &quot;ABC&quot;&#30340;&#21069;&#32512;&#20026; [A, AB]&#65292;&#21518;&#32512;&#20026; [BC, C]&#65292;&#20849;&#26377;&#20803;&#32032;&#30340;
    &#38271;&#24230; 0&#65307;
-   &quot;ABCD&quot;&#30340;&#21069;&#32512;&#20026; [A, AB, ABC]&#65292;&#21518;&#32512;&#20026; [BCD, CD, D]&#65292;
    &#20849;&#26377;&#20803;&#32032;&#30340;&#38271;&#24230;&#20026; 0&#65307;
-   &quot;ABCDA&quot;&#30340;&#21069;&#32512;&#20026; [A, AB, ABC, ABCD]&#65292;&#21518;&#32512;&#20026;
    [BCDA, CDA, DA, A]&#65292;&#20849;&#26377;&#20803;&#32032;&#20026;&quot;A&quot;&#65292;&#38271;&#24230;&#20026; 1&#65307;
-   &quot;ABCDAB&quot;&#30340;&#21069;&#32512;&#20026; [A, AB, ABC, ABCD, ABCDA]&#65292;&#21518;&#32512;
    &#20026; [BCDAB, CDAB, DAB, AB, B]&#65292;&#20849;&#26377;&#20803;&#32032;&#20026;&quot;AB&quot;&#65292;&#38271;
    &#24230;&#20026; 2&#65307;
-   &quot;ABCDABD&quot;&#30340;&#21069;&#32512;&#20026; [A, AB, ABC, ABCD, ABCDA, ABCDAB]&#65292;
    &#21518;&#32512;&#20026; [BCDABD, CDABD, DABD, ABD, BD, D]&#65292;&#20849;&#26377;&#20803;&#32032;&#30340;&#38271;&#24230;&#20026; 0&#12290;

          |
BBC ABCDAB ABCDABCDABDE
    ABCDABD
          |

BBC ABCDAB ABCDABCDABDE
        --
    ABCDABD
    --</code></pre>
</dd>
</dl></li>
<li><dl>
<dt><a href="http://www.matrix67.com/blog/archives/115">KMP&#31639;&#27861;&#35814;&#35299; | Matrix67: The Aha Moments</a> <code class="fold">@</code></dt>
<dd><pre><code>i = 1 2 3 4 5 6 7 8 9 &#8230;&#8230;
A = a b a b a b a a b a b &#8230;
B = a b a b a c b
j = 1 2 3 4 5 6 7
              ^

i = 1 2 3 4 5 6 7 8 9 &#8230;&#8230;
A = a b a b a b a a b a b &#8230;
B =     a b a b a c b
j =     1 2 3 4 5 6 7</code></pre>
<p>&#39044;&#22788;&#29702;&#19981;&#38656;&#35201;&#25353;&#29031; P &#30340;&#23450;&#20041;&#20889;&#25104; <code>O(m^2)</code> &#29978;&#33267; <code>O(m^3)</code> &#30340;&#12290;&#25105;&#20204;&#21487;&#20197;&#36890;&#36807; <code>P, P, &#8230;, P[j-1]</code> &#30340;&#20540;&#26469;&#33719;&#24471; <code>P[j]</code> &#30340;&#20540;&#12290;&#23545;&#20110;&#21018;&#25165;&#30340; <code>B=&quot;ababacb&quot;</code>&#65292;&#20551;&#22914;&#25105;&#20204;&#24050;&#32463;&#27714;&#20986;&#20102; <code>P, P, P</code> &#21644; <code>P</code>&#65292;&#30475;&#30475;&#25105;&#20204;&#24212;&#35813;&#24590;&#20040;&#27714;&#20986; <code>P</code> &#21644; <code>P</code>&#12290;<code>P = 2</code>&#65292;&#37027;&#20040; <code>P</code> &#26174;&#28982;&#31561;&#20110; <code>P+1</code>&#65292;&#22240;&#20026;&#30001; <code>P</code> &#21487;&#20197;&#30693;&#36947;&#65292;<code>B[1,2]</code> &#24050;&#32463;&#21644; <code>B[3,4]</code> &#30456;&#31561;&#20102;&#65292;&#29616;&#22312;&#21448;&#26377; <code>B=B</code>&#65292;&#25152;&#20197; <code>P</code> &#21487;&#20197;&#30001; <code>P</code> &#21518;&#38754;&#21152;&#19968;&#20010;&#23383;&#31526;&#24471;&#21040;&#12290;<code>P</code> &#20063;&#31561;&#20110; <code>P+1</code> &#21527;&#65311;&#26174;&#28982;&#19981;&#26159;&#65292;&#22240;&#20026; <code>B[ P+1 ] != B</code>&#12290;&#37027;&#20040;&#65292;&#25105;&#20204;&#35201;&#32771;&#34385;&#8220;&#36864;&#19968;&#27493;&#8221;&#20102;&#12290;&#25105;&#20204;&#32771;&#34385; <code>P</code> &#26159;&#21542;&#26377;&#21487;&#33021;&#30001; <code>P</code> &#30340;&#24773;&#20917;&#25152;&#21253;&#21547;&#30340;&#23376;&#20018;&#24471;&#21040;&#65292;&#21363;&#26159;&#21542; <code>P=P[ P ]+1</code>&#12290;&#36825;&#37324;&#24819;&#19981;&#36890;&#30340;&#35805;&#21487;&#20197;&#20180;&#32454;&#30475;&#19968;&#19979;&#65306;</p>
<pre><code>    1 2 3 4 5 6 7
B = a b a b a c b
P = 0 0 1 2 3 ?</code></pre>
<p><code>P=3</code> &#26159;&#22240;&#20026; <code>B[1..3]</code> &#21644; <code>B[3..5]</code> &#37117;&#26159; &#8220;aba&#8221;&#65307;&#32780; <code>P=1</code> &#21017;&#21578;&#35785;&#25105;&#20204;&#65292;<code>B</code>&#12289;<code>B</code> &#21644; <code>B</code> &#37117;&#26159;&#8220;a&#8221;&#12290;&#26082;&#28982; <code>P</code> &#19981;&#33021;&#30001; <code>P</code> &#24471;&#21040;&#65292;&#25110;&#35768;&#21487;&#20197;&#30001; <code>P</code> &#24471;&#21040;&#65288;&#22914;&#26524; <code>B</code> &#24688;&#22909;&#21644; <code>B</code> &#30456;&#31561;&#30340;&#35805;&#65292;<code>P</code> &#23601;&#31561;&#20110; <code>P+1</code> &#20102;&#65289;&#12290;&#26174;&#28982;&#65292;<code>P</code> &#20063;&#19981;&#33021;&#36890;&#36807; <code>P</code> &#24471;&#21040;&#65292;&#22240;&#20026; <code>B != B</code>&#12290;&#20107;&#23454;&#19978;&#65292;&#36825;&#26679;&#19968;&#30452;&#25512;&#21040; <code>P</code> &#20063;&#19981;&#34892;&#65292;&#26368;&#21518;&#65292;&#25105;&#20204;&#24471;&#21040;&#65292;<code>P=0</code>&#12290;</p>
<p>&#24590;&#20040;&#36825;&#20010;&#39044;&#22788;&#29702;&#36807;&#31243;&#36319;&#21069;&#38754;&#30340; KMP &#20027;&#31243;&#24207;&#36825;&#20040;&#20687;&#21602;&#65311;&#20854;&#23454;&#65292; KMP &#30340;&#39044;&#22788;&#29702;&#26412;&#36523;&#23601;&#26159;&#19968;&#20010; B &#20018;&#8220;&#33258;&#25105;&#21305;&#37197;&#8221;&#30340;&#36807;&#31243;&#12290;&#23427;&#30340;&#20195;&#30721;&#21644;&#19978;&#38754;&#30340;&#20195;&#30721;&#31070;&#20284;&#65306;</p>
<pre><code>P:=0;
j:=0;
for i:=2 to m do
begin
   while (j&gt;0) and (B[j+1]&lt;&gt;B[i]) do j:=P[j];
   if B[j+1]=B[i] then j:=j+1;
   P[i]:=j;
end;</code></pre>
</dd>
</dl></li>
<li><a href="http://www.ics.uci.edu/~eppstein/161/960227.html">Knuth-Morris-Pratt Algorithm</a></li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/7041827">&#20174;&#22836;&#21040;&#23614;&#24443;&#24213;&#29702;&#35299;KMP&#65288;2014&#24180;8&#26376;22&#26085;&#29256;&#65289; - &#32467;&#26500;&#20043;&#27861; &#31639;&#27861;&#20043;&#36947; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="dt">void</span> compute_prefix(<span class="dt">const</span> <span class="dt">char</span> *pattern, <span class="dt">int</span> next[]) {
    <span class="dt">int</span> i;
    <span class="dt">int</span> j = <span class="dv">-1</span>;
    <span class="dt">const</span> <span class="dt">int</span> m = strlen(pattern);

    next = j;
    <span class="kw">for</span> ( i = <span class="dv">1</span>; i &lt; m; i++ ) {
        <span class="kw">while</span> (j &gt; <span class="dv">-1</span> &amp;&amp; pattern[j + <span class="dv">1</span>] != pattern[i]) { j = next[j]; }
        <span class="kw">if</span>( pattern[i] == pattern[j + <span class="dv">1</span>] ) { j++; }
        next[i] = j;
    }
}

<span class="dt">int</span> kmp(<span class="dt">const</span> <span class="dt">char</span> *text, <span class="dt">const</span> <span class="dt">char</span> *pattern) {
    <span class="dt">int</span> i;
    <span class="dt">int</span> j = <span class="dv">-1</span>;
    <span class="dt">const</span> <span class="dt">int</span> n = strlen(text);
    <span class="dt">const</span> <span class="dt">int</span> m = strlen(pattern);
    <span class="kw">if</span> (n == <span class="dv">0</span> &amp;&amp; m == <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">0</span>; <span class="co">/* &quot;&quot;,&quot;&quot; */</span>
    <span class="kw">if</span> (m == <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">0</span>;  <span class="co">/* &quot;a&quot;,&quot;&quot; */</span>
    <span class="dt">int</span> *next = (<span class="dt">int</span>*)malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>) * m);

    compute_prefix(pattern, next);

    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; i++) {
        <span class="co">//              printf( &quot;\n\n\n&quot; );</span>
        <span class="co">//              printf( &quot;      %*si = %d\n&quot;, i, &quot;&quot;, i );</span>
        <span class="co">//              printf( &quot;      %*s|\n&quot;, i, &quot;&quot;);</span>
        <span class="co">//              printf( &quot;text: %s\n&quot;, text );</span>
        <span class="co">//              while (j &gt; -1 &amp;&amp; pattern[j + 1] != text[i]) {</span>
        <span class="co">//                  printf( &quot;\nj: %d-&gt;&quot;, j );</span>
        <span class="co">//                  j = next[j];</span>
        <span class="co">//                  printf( &quot;%d\n&quot;, j );</span>
        <span class="co">//              }</span>
        <span class="co">//              printf( &quot;      %*s%s\n&quot;, i-j-1, &quot;&quot;, pattern );</span>
        <span class="co">//              printf( &quot;      %*s|\n&quot;, i, &quot;&quot;);</span>
        <span class="co">//              printf( &quot;      %*sj:%d-&gt;&quot;, i-1, &quot;&quot;, j );</span>

        <span class="kw">if</span> (text[i] == pattern[j + <span class="dv">1</span>]) j++;
        <span class="kw">if</span> (j == m - <span class="dv">1</span>) {
            free(next);
            <span class="kw">return</span> i-j;
        }
    }

    free(next);
    <span class="kw">return</span> <span class="dv">-1</span>;
}


<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[]) {
    <span class="dt">char</span> text[] = <span class="st">&quot;ABC ABCDAB ABCDABCDABDE&quot;</span>;
    <span class="dt">char</span> pattern[] = <span class="st">&quot;ABCDABD&quot;</span>;
    <span class="dt">char</span> *ch = text;
    <span class="dt">int</span> i = kmp(text, pattern);

    <span class="kw">if</span> (i &gt;= <span class="dv">0</span>) printf(<span class="st">&quot;matched @: </span><span class="ch">%s\n</span><span class="st">&quot;</span>, ch + i);

    <span class="co">//              const char *needles[] = {</span>
    <span class="co">//                  &quot;ABCDABD&quot;,</span>
    <span class="co">//                  &quot;ABC&quot;,</span>
    <span class="co">//                  &quot;ABC&quot;</span>
    <span class="co">//              };</span>
    <span class="co">//              for( int i = 0; i &lt; sizeof(needles)/sizeof(needles); ++i ) {</span>
    <span class="co">//                  const char *pattern = needles[i];</span>
    <span class="co">//                  static int next;</span>
    <span class="co">//                  int m = strlen( pattern );</span>
    <span class="co">//                  memset( next, 0, sizeof(next) );</span>
    <span class="co">//                  compute_prefix( pattern, next );</span>
    <span class="co">//                  printf( &quot;next[] for: &quot; );</span>
    <span class="co">//                  for( int i = 0; i &lt; m; ++i ) { printf(&quot;  %c  &quot;, pattern[i] ); }</span>
    <span class="co">//                  printf( &quot;\n&quot; );</span>
    <span class="co">//                  printf( &quot;            &quot; );</span>
    <span class="co">//                  for( int i = 0; i &lt; m; ++i ) { printf(&quot;%3d  &quot;, next[i] ); }</span>
    <span class="co">//                  printf( &quot;\n&quot; );</span>
    <span class="co">//              }</span>
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> compute_prefix(<span class="dt">const</span> <span class="dt">char</span> *pattern, <span class="dt">int</span> next[]) {
    <span class="dt">int</span> i;
    <span class="dt">int</span> j = <span class="dv">-1</span>;
    <span class="dt">const</span> <span class="dt">int</span> m = strlen(pattern);

    next = j;
    <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt; m; i++) {
        <span class="kw">while</span> (j &gt; <span class="dv">-1</span> &amp;&amp; pattern[j + <span class="dv">1</span>] != pattern[i]) j = next[j];

        <span class="kw">if</span> (pattern[i] == pattern[j + <span class="dv">1</span>]) j++;
        next[i] = j;
    }
}

next[] <span class="kw">for</span>:   A    B    C    D    A    B    D
             <span class="dv">-1</span>
                  <span class="dv">-1</span>                                p[i=<span class="dv">1</span>] != p[j<span class="dv">+1</span>=<span class="dv">0</span>]
                       <span class="dv">-1</span>                           p[i=<span class="dv">2</span>] != p[j<span class="dv">+1</span>=<span class="dv">0</span>]
                            <span class="dv">-1</span>                      p[i=<span class="dv">3</span>] != p[j<span class="dv">+1</span>=<span class="dv">0</span>]
                                  <span class="dv">0</span>                 p[i=<span class="dv">4</span>] == p[j<span class="dv">+1</span>=<span class="dv">0</span>], ++j, (j=<span class="dv">1</span> now)
                                       ?            p   == p, <span class="kw">not</span> inside <span class="kw">while</span>
                                       <span class="dv">1</span>            p[i=<span class="dv">5</span>] == p[j<span class="dv">+1</span>=<span class="dv">1</span>], ++j, (j=<span class="dv">2</span> now)
                                            ?       p   != p, j = next[j=<span class="dv">2</span>] = <span class="dv">-1</span>
                                           <span class="dv">-1</span>
so:
             <span class="dv">-1</span>   <span class="dv">-1</span>   <span class="dv">-1</span>   <span class="dv">-1</span>    <span class="dv">0</span>    <span class="dv">1</span>   <span class="dv">-1</span></code></pre></div>
<pre><code>      i = 0
      |
text: ABC ABCDAB ABCDABCDABDE
      ABCDABD
      |
     j:-1

       i = 1
       |
text: ABC ABCDAB ABCDABCDABDE
      ABCDABD
       |
      j:0

        i = 2
        |
text: ABC ABCDAB ABCDABCDABDE
      ABCDABD
        |
       j:1

         i = 3
         |
text: ABC ABCDAB ABCDABCDABDE
      ABCDABD, j: 2-&gt;-1 (&quot;ABC&quot; -&gt; [&quot;A&quot;, &quot;AB&quot;], [&quot;BC&quot;, &quot;C&quot;])
         ABCDABD
         |
        j:-1

          i = 4
          |
text: ABC ABCDAB ABCDABCDABDE
          ABCDABD
          |
         j:-1

           i = 5
           |
text: ABC ABCDAB ABCDABCDABDE
          ABCDABD
           |
          j:0

            i = 6
            |
text: ABC ABCDAB ABCDABCDABDE
          ABCDABD
            |
           j:1

             i = 7
             |
text: ABC ABCDAB ABCDABCDABDE
          ABCDABD
             |
            j:2

              i = 8
              |
text: ABC ABCDAB ABCDABCDABDE
          ABCDABD
              |
             j:3

               i = 9
               |
text: ABC ABCDAB ABCDABCDABDE
          ABCDABD
               |
              j:4

+-----------------------------------------------------------------------+
|       while (j &gt; -1 &amp;&amp; pattern[j + 1] != text[i]) { j = next[j]; }    |
|       j &gt; -1                          : may backroll                  |
|       pattern[j+1] != text[i]         : mismatch                      |
+-----------------------------------------------------------------------+
|                     0    1    2    3    4    5    6                   |
|       next[] for:   A    B    C    D    A    B    D                   |
|                    -1   -1   -1   -1    0    1   -1                   |
|                     0    0    0    0    1    2    0                   |
+-----------------------------------------------------------------------+

                i = 10
                |
text: ABC ABCDAB ABCDABCDABDE
          ABCDABD               jump:   5   -&gt;   1
              ABCDABD           jump:   1   -&gt;  -1
                ABCDABD
                |
               j:-1

                 i = 11
                 |
text: ABC ABCDAB ABCDABCDABDE
                 ABCDABD
                 |
                j:-1

                  i = 12
                  |
text: ABC ABCDAB ABCDABCDABDE
                 ABCDABD
                  |
                 j:0

                   i = 13
                   |
text: ABC ABCDAB ABCDABCDABDE
                 ABCDABD
                   |
                  j:1

                    i = 14
                    |
text: ABC ABCDAB ABCDABCDABDE
                 ABCDABD
                    |
                   j:2

                     i = 15
                     |
text: ABC ABCDAB ABCDABCDABDE
                 ABCDABD
                     |
                    j:3

                      i = 16
                      |
text: ABC ABCDAB ABCDABCDABDE
                 ABCDABD
                      |
                     j:4

                       i = 17
                       |
text: ABC ABCDAB ABCDABCDABDE
                 ABCDABD        jump:   5   -&gt;   1
                     ABCDABD
                       |
                      j:1

                        i = 18
                        |
text: ABC ABCDAB ABCDABCDABDE
                     ABCDABD
                        |
                       j:2


                         i = 19
                         |
text: ABC ABCDAB ABCDABCDABDE
                     ABCDABD
                         |
                        j:3

                          i = 20
                          |
text: ABC ABCDAB ABCDABCDABDE
                     ABCDABD
                          |
                         j:4

                           i = 21
                           |
text: ABC ABCDAB ABCDABCDABDE
                     ABCDABD
                           |
                          j:5</code></pre>
<p>see more?</p>
<ul>
<li><dl>
<dt>Boyer-Moore <code class="fold">@</code></dt>
<dd><p>&#25512;&#33616;&#32593;&#19978;&#30340;&#20960;&#31687;&#27604;&#36739;&#22909;&#30340;&#21338;&#23458;&#65292;<a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">&#8220;&#23383;&#31526;&#20018;&#21305;&#37197;&#30340; Boyer-Moore &#31639;&#27861;&#8221;</a>&#65292;&#22270;&#25991;&#24182;&#33538;&#65292;&#38750;&#24120;&#36890;&#20439;&#26131;&#25026;&#65292;&#20316;&#32773;&#26159;&#38446;&#19968;&#23792;&#65307;<a href="http://www-igm.univ-mlv.fr/~lecroq/string/node14.html">Boyer-Moore algorithm</a>&#12290;</p>
<p>&#26377;&#20852;&#36259;&#30340;&#35835;&#32773;&#36824;&#21487;&#20197;&#30475;&#21407;&#22987;&#35770;&#25991;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/**</span>
 * &#26412;&#20195;&#30721;&#21442;&#32771;&#20102; http:<span class="co">//www-igm.univ-mlv.fr/~lecroq/string/node14.html</span>
<span class="er"> * &#31934;&#21147;&#26377;&#38480;&#30340;&#35805;&#65292;&#21487;&#20197;&#21482;&#35745;&#31639;&#22351;&#23383;&#31526;&#30340;&#21518;&#31227;&#65292;&#22909;&#21518;&#32512;&#30340;&#20301;&#31227;&#26159;&#21487;&#36873;&#30340;&#65292;&#22240;&#27492;&#21487;&#20197;&#21024;&#38500;</span>
 * suffixes(), pre_gs() &#20989;&#25968;
 */
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="ot">#define ASIZE 256  </span><span class="co">/* ASCII&#23383;&#27597;&#30340;&#31181;&#31867; */</span>

<span class="co">/*</span>
<span class="co"> * @brief &#39044;&#22788;&#29702;&#65292;&#35745;&#31639;&#27599;&#20010;&#23383;&#27597;&#26368;&#38752;&#21491;&#30340;&#20301;&#32622;.</span>
<span class="co"> *</span>
<span class="co"> * @param[in] pattern &#27169;&#24335;&#20018;</span>
<span class="co"> * @param[out] right &#27599;&#20010;&#23383;&#27597;&#26368;&#38752;&#21491;&#30340;&#20301;&#32622;</span>
<span class="co"> * @return &#26080;</span>
<span class="co"> */</span>
<span class="dt">static</span> <span class="dt">void</span> pre_right(<span class="dt">const</span> <span class="dt">char</span> *pattern, <span class="dt">int</span> right[]) {
    <span class="dt">int</span> i;
    <span class="dt">const</span> <span class="dt">int</span> m = strlen(pattern);

    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; ASIZE; ++i) right[i] = <span class="dv">-1</span>;
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; m; ++i) right[(<span class="dt">unsigned</span> <span class="dt">char</span>)pattern[i]] = i;
}

<span class="dt">static</span> <span class="dt">void</span> suffixes(<span class="dt">const</span> <span class="dt">char</span> *pattern, <span class="dt">int</span> suff[]) {
    <span class="dt">int</span> f, g, i;
    <span class="dt">const</span> <span class="dt">int</span> m = strlen(pattern);

    suff[m - <span class="dv">1</span>] = m;
    g = m - <span class="dv">1</span>;
    <span class="kw">for</span> (i = m - <span class="dv">2</span>; i &gt;= <span class="dv">0</span>; --i) {
        <span class="kw">if</span> (i &gt; g &amp;&amp; suff[i + m - <span class="dv">1</span> - f] &lt; i - g)
            suff[i] = suff[i + m - <span class="dv">1</span> - f];
        <span class="kw">else</span> {
            <span class="kw">if</span> (i &lt; g)
                g = i;
            f = i;
            <span class="kw">while</span> (g &gt;= <span class="dv">0</span> &amp;&amp; pattern[g] == pattern[g + m - <span class="dv">1</span> - f])
                --g;
            suff[i] = f - g;
        }
    }
}

<span class="co">/*</span>
<span class="co"> * @brief &#39044;&#22788;&#29702;&#65292;&#35745;&#31639;&#22909;&#21518;&#32512;&#30340;&#21518;&#31227;&#20301;&#32622;.</span>
<span class="co"> *</span>
<span class="co"> * @param[in] pattern &#27169;&#24335;&#20018;</span>
<span class="co"> * @param[out] gs &#22909;&#21518;&#32512;&#30340;&#21518;&#31227;&#20301;&#32622;</span>
<span class="co"> * @return &#26080;</span>
<span class="co"> */</span>
<span class="dt">static</span> <span class="dt">void</span> pre_gs(<span class="dt">const</span> <span class="dt">char</span> pattern[], <span class="dt">int</span> gs[]) {
    <span class="dt">int</span> i, j;
    <span class="dt">const</span> <span class="dt">int</span> m = strlen(pattern);
    <span class="dt">int</span> *suff = (<span class="dt">int</span>*)malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>) * (m + <span class="dv">1</span>));

    suffixes(pattern, suff);

    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; m; ++i) gs[i] = m;

    j = <span class="dv">0</span>;
    <span class="kw">for</span> (i = m - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; --i) <span class="kw">if</span> (suff[i] == i + <span class="dv">1</span>)
        <span class="kw">for</span> (; j &lt; m - <span class="dv">1</span> - i; ++j) <span class="kw">if</span> (gs[j] == m)
            gs[j] = m - <span class="dv">1</span> - i;
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt;= m - <span class="dv">2</span>; ++i)
        gs[m - <span class="dv">1</span> - suff[i]] = m - <span class="dv">1</span> - i;
    free(suff);
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Rabin-Karp :TODO: <code class="fold">@</code></dt>
<dd><p>TODO</p>
</dd>
</dl></li>
</ul>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>&#20174;&#38754;&#35797;&#23448;&#30340;&#35282;&#24230;&#20998;&#26512;&#38754;&#35797;&#30340;&#32771;&#23519;&#28857; <code class="fold">@</code></dt>
<dd><ul>
<li>&#22914;&#26524;&#27809;&#26377; strlen&#65311;&#35201;&#33258;&#24049;&#20889;&#19968;&#20010;&#65311;&#36824;&#26159;&#34701;&#27719;&#22312;&#30340;&#33258;&#24049;&#20195;&#30721;&#37324;&#12290;</li>
<li>&#36755;&#20837;&#21442;&#25968;&#19978;&#65292;<code>char *str</code> &#25913;&#25104; <code>const char *str</code> &#26159;&#19981;&#26159;&#26356;&#22909;&#65311;</li>
<li>&#21442;&#25968;&#21629;&#21517;&#19978;&#65292;str &#21644; sub &#22909;&#19981;&#22909;&#65311;&#35201;&#19981;&#25442;&#25104; haystack &#21644; needle &#24590;&#20040;&#26679;&#65311;</li>
<li>int len = strlen(str) &#36825;&#37324; len &#30340;&#31867;&#22411;&#25442;&#25104; size_t &#26159;&#19981;&#26159;&#26356;&#22909;&#65311; int &#22411;&#26368;&#22810;&#34920;&#31034;&#22810;&#38271;&#30340;&#23383;&#33410;&#65311; 2<sup>31</sup>-1 / 2<sup>10</sup> (k) / 2<sup>10</sup> (m) / 2<sup>10</sup> (g) = 2<sup>31-30</sup> = 2 GB&#12290;&#25105;&#29468;&#23436;&#20840;&#27809;&#26377;&#24517;&#35201;&#29992;&#8230;&#8230;</li>
</ul>
<p>&#19978;&#38754;&#30340;&#38382;&#39064;&#20320;&#24590;&#20040;&#22238;&#31572;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#20174; Subset &#20013;&#20102;&#35299;&#31639;&#27861;&#38754;&#35797;&#20013;<strong>&#27169;&#26495;&#30340;&#37325;&#35201;&#24615;</strong> <code class="fold">@</code></dt>
<dd><p>&#25402;&#37325;&#35201;&#12290;</p>
<blockquote>
<p>&#21516;&#26679;&#21160;&#20316;&#37325;&#22797; 300 &#27425;&#65292;&#32908;&#32905;&#23601;&#20250;&#26377;&#35760;&#24518;&#65292;&#32780;&#19968;&#20010;&#21160;&#20316;&#37325;&#22797; 600 &#27425;&#65292;&#33034;&#26894;&#23601;&#20250;&#26377;&#35760;&#24518;&#12290;</p>
<p>&#8212; &#26446;&#23567;&#40857;</p>
</blockquote>
</dd>
</dl></li>
<li><dl>
<dt>&#31243;&#24207;&#35774;&#35745;&#20837;&#38376;&#24314;&#35758; <code class="fold">@</code></dt>
<dd><ul>
<li><p>&#25105;&#20204;&#30340;&#30446;&#26631;&#26159;&#35299;&#20915;&#38382;&#39064;&#65292;&#32780;&#19981;&#26159;&#20026;&#20102;&#20889;&#31243;&#24207;&#32780;&#20889;&#31243;&#24207;&#65292;&#21516;&#26102;&#24212;&#20445;&#25345;&#31616;&#21333;&#65288;<strong>Keep It Simple and Stupid, KISS</strong>&#65289;&#65292;&#32780;&#19981;&#26159;&#33258;&#24049;<strong>&#21019;&#36896;&#26465;&#20214;&#21435;&#23637;&#31034;&#32534;&#31243;&#25216;&#24039;</strong>&#12290;</p></li>
<li><dl>
<dt>&#19977;&#25972;&#25968;&#25490;&#24207;</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> main() {
    <span class="dt">int</span> a, b, c, t;
    scanf( <span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, &amp;a, &amp;b, &amp;c );
    <span class="kw">if</span>( a &gt; b ) { t = a; a = b; b = t; } <span class="co">// a &lt;= b</span>
    <span class="kw">if</span>( a &gt; c ) { t = a; a = c; c = t; } <span class="co">// a &lt;= c</span>
    <span class="kw">if</span>( b &gt; c ) { t = b; b = c; c = t; } <span class="co">// a &lt;= b &lt;= c</span>
    printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, a, b, c );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>step by step, get closer to your goal.</p>
</dd>
</dl></li>
<li><p>&#37325;&#23450;&#21521;&#65288;&#20415;&#20110;&#26412;&#22320;&#27979;&#35797;&#65289; &#9829;&#65039;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">freopen( <span class="st">&quot;data.in&quot;</span>,  <span class="st">&quot;r&quot;</span>, stdin  );
freopen( <span class="st">&quot;data.out&quot;</span>, <span class="st">&quot;w&quot;</span>, stdout );</code></pre></div></li>
<li><p>&#32534;&#31243;&#19981;&#26159;&#30475;&#20070;&#30475;&#20250;&#30340;&#65292;&#20063;&#19981;&#26159;&#21548;&#35838;&#21548;&#20250;&#30340;&#65292;&#32780;&#26159;<strong>&#32451;</strong>&#20250;&#30340;&#12290;</p></li>
</ul>
</dd>
</dl></li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="http://blog.csdn.net/v_JULY_v/article/details/6417600">&#31243;&#24207;&#21592;&#32534;&#31243;&#33402;&#26415;&#65306;&#31532;&#22235;&#31456;&#12289;&#29616;&#22330;&#32534;&#20889;&#31867;&#20284; strstr/strcpy/strpbrk &#30340;&#20989;&#25968; - &#32467;&#26500;&#20043;&#27861; &#31639;&#27861;&#20043;&#36947; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/00/00 &#19978;&#21320; 9:30:00 0. &#32534;&#31243;&#21021;&#27493;&#20197;&#21450; STL &#20837;&#38376; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#31532; 3 &#31456;&#65292;&#25968;&#32452;&#21644;&#23383;&#31526;&#20018; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#34503;&#24418;&#22635;&#25968; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#define maxn 20</span>
<span class="dt">int</span> a[maxn][maxn];

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, x, y, tot = <span class="dv">0</span>;
    <span class="kw">while</span>( <span class="dv">1</span> == scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n ) &amp;&amp; n &gt; <span class="dv">0</span> &amp;&amp; n &lt; maxn ) {
        memset( a, <span class="dv">0</span>, <span class="kw">sizeof</span>(a) );
        tot = a[x=<span class="dv">0</span>][y=n<span class="dv">-1</span>] = <span class="dv">1</span>;
        <span class="kw">while</span>( tot &lt; n*n ) {
            <span class="kw">while</span>( x<span class="dv">+1</span> &lt;  n &amp;&amp; !a[x<span class="dv">+1</span>][y] ) { a[++x][y] = ++tot; }
            <span class="kw">while</span>( y<span class="dv">-1</span> &gt;= <span class="dv">0</span> &amp;&amp; !a[x][y<span class="dv">-1</span>] ) { a[x][--y] = ++tot; }
            <span class="kw">while</span>( x<span class="dv">-1</span> &gt;= <span class="dv">0</span> &amp;&amp; !a[x<span class="dv">-1</span>][y] ) { a[--x][y] = ++tot; }
            <span class="kw">while</span>( y<span class="dv">+1</span> &lt;  n &amp;&amp; !a[x][y<span class="dv">+1</span>] ) { a[x][++y] = ++tot; }
        }
        <span class="kw">for</span>( x = <span class="dv">0</span>; x &lt; n; ++x ) {
            <span class="kw">for</span>( y = <span class="dv">0</span>; y &lt; n; ++y ) {
                printf( <span class="st">&quot;</span><span class="ch">%5d</span><span class="st">&quot;</span>, a[x][y] );
            }
            printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><p>&#26368;&#22909;<strong>&#22312;&#20570;&#19968;&#20214;&#20107;&#20043;&#21069;&#26816;&#26597;&#26159;&#19981;&#26159;&#21487;&#20197;&#20570;&#65292;&#32780;&#19981;&#35201;&#20570;&#23436;&#20877;&#21518;&#24724;</strong>&#12290;&#22240;&#20026;&#8220;&#27585;&#26827;&#8221;&#24448;&#24448;&#27604;&#36739;&#40635;&#28902;&#12290;</p></li>
<li><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span>( strchr( s, c ) == NULL ) { ... }

<span class="dt">int</span> idx = strchr(s, c) - s;
<span class="kw">if</span>( s[idx] ) {
    ...
}</code></pre></div></li>
<li><p><code>fgetc</code> &#36820;&#22238; int&#65311;&#22240;&#20026; EOF&#65288;&#20540;&#20026; -1&#65289;&#19981;&#23481;&#26131;&#36716;&#21270;&#25104; char&#12290;</p></li>
<li><dl>
<dt>&#22238;&#25991;&#35789;&#65288;Palindromes&#65289; <code class="fold">@</code></dt>
<dd><p>&#36755;&#20837;&#20013;&#27809;&#26377; &#8220;0&#8221;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;ctype.h&gt;</span>
<span class="co">//                 ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789</span>
<span class="dt">const</span> <span class="dt">char</span> *rev = <span class="st">&quot;A   3  HIL JM O   2TUVWXY51SE Z  8 &quot;</span>;
<span class="dt">const</span> <span class="dt">char</span> *msg[] = {   <span class="st">&quot;not a palindrome&quot;</span>,
                        <span class="st">&quot;a regular palindrome&quot;</span>,
                        <span class="st">&quot;a mirrored string&quot;</span>,
                        <span class="st">&quot;a mirrored palindrome&quot;</span> };

<span class="dt">char</span> r( <span class="dt">char</span> ch ) {
    <span class="kw">if</span>( isupper(ch) ) {
        <span class="kw">return</span> rev[ch-<span class="st">&#39;A&#39;</span>];
    } <span class="kw">else</span> <span class="kw">if</span>( <span class="st">&#39;0&#39;</span> &lt; ch &amp;&amp; ch &lt;= <span class="st">&#39;9&#39;</span> ) {
        <span class="kw">return</span> rev[ch-<span class="st">&#39;1&#39;</span><span class="dv">+26</span>];
    } <span class="kw">else</span> {
        <span class="kw">return</span> <span class="dv">0</span>; <span class="co">// then should not equal</span>
    }
}

<span class="dt">int</span> main() {
    <span class="dt">char</span> s;
    <span class="kw">while</span>( scanf( <span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, s ) == <span class="dv">1</span> ) {
        <span class="dt">int</span> len = strlen(s);
        <span class="dt">int</span> p = <span class="dv">1</span>, m = <span class="dv">1</span>;
        <span class="co">// &#19981;&#26159; len/2&#65292;&#20320;&#35828;&#20026;&#20160;&#20040;&#21602;&#65311; because:          s[i] === s[i] but, s[i] !== rev(s[i]), not always</span>
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; (len<span class="dv">+1</span>)/<span class="dv">2</span>; ++i ) {
            <span class="kw">if</span>(   s[i]  != s[len<span class="dv">-1</span>-i] ) { p = <span class="dv">0</span>; }
            <span class="kw">if</span>( r(s[i]) != s[len<span class="dv">-1</span>-i] ) { m = <span class="dv">0</span>; }
            <span class="kw">if</span>( !p &amp;&amp; !m ) { <span class="kw">break</span>; }
        }
        printf( <span class="st">&quot;</span><span class="ch">%s</span><span class="st"> -- is </span><span class="ch">%s</span><span class="st">.</span><span class="ch">\n\n</span><span class="st">&quot;</span>, s, msg[m*<span class="dv">2</span>+p] );
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>&#32534;&#35793;&#36816;&#34892;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">gcc</span> palindromes.c -o palindromes -std=c99

$ <span class="kw">cat</span> input.txt
<span class="kw">NOTAPALINDROME</span>
<span class="kw">ISAPALINILAPASI</span>
<span class="kw">2A3MEAS</span>
<span class="kw">ATOYOTA</span>

$ <span class="kw">cat</span> input.txt <span class="kw">|</span> <span class="kw">palindromes</span>
<span class="kw">NOTAPALINDROME</span> -- is not a palindrome.

<span class="kw">ISAPALINILAPASI</span> -- is a regular palindrome.

<span class="kw">2A3MEAS</span> -- is a mirrored string.

<span class="kw">ATOYOTA</span> -- is a mirrored palindrome.</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#29615;&#29366;&#24207;&#21015;&#65288;Circular Sequence&#65289; <code class="fold">@</code></dt>
<dd><pre><code>+---------&gt;---------+
|  T  C    G       \|/
|              A    |
| C               G |
^                   |
| G               T |
|     G    A  C     |
+-----&lt;----^--------+
            \
             +----- &#26368;&#23567;&#20174;&#36825;&#37324;&#24320;&#22987;</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#define maxn 105</span>

<span class="dt">int</span> less( <span class="dt">const</span> <span class="dt">char</span> *s, <span class="dt">int</span> p, <span class="dt">int</span> q ) {
    <span class="dt">int</span> n = strlen(s);
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
        <span class="kw">if</span>( s[(p+i)%n] != s[(q+i)%n] ) {
            <span class="kw">return</span> s[(p+i)%n] &lt; s[(q+i)%n];
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>; <span class="co">// equal</span>
}

<span class="dt">int</span> main() {
    <span class="dt">char</span> s[maxn];
    <span class="kw">while</span>( <span class="dv">1</span> == scanf( <span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, s ) ) {
        <span class="dt">int</span> ans = <span class="dv">0</span>;
        <span class="dt">int</span> n = strlen(s);
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt; n; ++i ) {
            <span class="kw">if</span>( less(s, i, ans) ) { ans = i; }
        }
        printf( <span class="st">&quot;</span><span class="ch">%s</span><span class="st"> --&gt; </span><span class="ch">\&quot;</span><span class="st">&quot;</span>, s );
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
            putchar( s[(i+ans)%n] );
        }
        printf( <span class="st">&quot;</span><span class="ch">\&quot;\n</span><span class="st">&quot;</span> );
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#29468;&#25968;&#23383; &#128542; <code class="fold">@</code></dt>
<dd><p>&#36755;&#20837;&#65306;</p>
<pre><code>4                           # &#23545;&#20110;&#19968;&#20010; case&#65292;4 &#34920;&#31034;&#27599;&#34892;&#22235;&#20010;&#25968;&#23383;
1   3   5   5               # &#29468;&#27979;&#30340;&#25968;&#23383;
1   1   2   3               # &#27491;&#30830;&#30340;&#25968;&#23383;
4   3   3   5               # &#29468;&#27979;
6   5   5   1               # &#27491;&#30830;
6   1   3   5
1   3   5   5
0   0   0   0               # &#20840; 0&#65292;&#32467;&#26463;
0                           # 0&#65292;&#34920;&#31034;&#25152;&#26377;&#36755;&#20837;&#32467;&#26463;</code></pre>
<p>&#32479;&#35745;&#36755;&#20986;&#26377;&#22810;&#23569;&#25968;&#23383;&#20301;&#32622;&#27491;&#30830;&#65288;A&#65289;&#65292;&#22810;&#23569;&#25968;&#23383;&#22312;&#20004;&#20010;&#24207;&#21015;&#22810;&#20986;&#29616;&#20102;&#20294;&#20301;&#32622;&#19981;&#23545;&#65288;B&#65289;&#12290;</p>
<p>&#20998;&#26512;&#65306;</p>
<p>&#32479;&#35745;&#21487;&#20197;&#24471;&#21040; A&#12290;&#23545; 1~9&#65292;&#32479;&#35745;&#20004;&#32773;&#20986;&#29616;&#30340;&#27425;&#25968; c1 &#21644; c2&#65292;&#21017; min( c1, c2 ) &#23601;&#26159;&#35813;&#25968;&#23383;&#23545; B &#30340;&#36129;&#29486;&#65288;&#26368;&#21518;&#35201;&#20943;&#21435; A &#30340;&#37096;&#20998;&#65289;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;stdio.h&gt;</span>
<span class="ot">#define maxn 1000 + 10</span>

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, a[maxn], b[maxn];
    <span class="dt">int</span> kase = <span class="dv">0</span>;
    <span class="kw">while</span>( scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span> &amp;&amp; n ) {            <span class="co">// n=0 &#26102;&#36755;&#20837;&#32467;&#26463;</span>
        printf( <span class="st">&quot;Game </span><span class="ch">%d</span><span class="st">:</span><span class="ch">\n</span><span class="st">&quot;</span>, ++kase );
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++ ) { scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;a[i]); }
        <span class="kw">for</span>( ; ; ) {
            <span class="dt">int</span> A = <span class="dv">0</span>, B = <span class="dv">0</span>;
            <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++ ) {
                scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;b[i] );
                <span class="kw">if</span>( a[i] == b[i] ) { A++; }         <span class="co">// &#32479;&#35745; A</span>
            }
            <span class="kw">if</span>( b == <span class="dv">0</span> ) { <span class="kw">break</span>; }                 <span class="co">// &#27491;&#24120;&#30340;&#29468;&#27979;&#24207;&#21015;&#19981;&#20250;&#26377; 0&#65292;&#25152;&#20197;&#21482;&#21028;&#26029;&#31532;&#19968;&#20010;&#25968;&#26159;&#21542;&#20026; 0 &#21363;&#21487;</span>
            <span class="kw">for</span>(<span class="dt">int</span> d = <span class="dv">1</span>; d &lt;= <span class="dv">9</span>; d++) {
                <span class="dt">int</span> c1 = <span class="dv">0</span>, c2 = <span class="dv">0</span>;                 <span class="co">// &#32479;&#35745;&#25968;&#23383; d &#22312;&#31572;&#26696;&#24207;&#21015;&#21644;&#29468;&#27979;&#24207;&#21015;&#20013;&#21508;&#20986;&#29616;&#22810;&#23569;&#27425;</span>
                <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
                    <span class="kw">if</span>(a[i] == d) c1++;
                    <span class="kw">if</span>(b[i] == d) c2++;
                }
                B += c1 &lt; c2 ? c1 : c2;
            }
            printf(<span class="st">&quot;    (</span><span class="ch">%d</span><span class="st">,</span><span class="ch">%d</span><span class="st">)</span><span class="ch">\n</span><span class="st">&quot;</span>, A, B-A);
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#29983;&#25104;&#20803; &#128542; <code class="fold">@</code></dt>
<dd><p>x &#21152;&#19978; x &#30340;&#21508;&#20010;&#25968;&#23383;&#24471;&#21040; y&#65292;&#23601;&#35828; x &#26159; y &#30340;&#29983;&#25104;&#20803;&#12290;&#32473;&#20986; n &#65288;1&lt;=n&lt;=100000&#65289;&#65292;&#27714;&#26368;&#23567;&#29983;&#25104;&#20803;&#12290;&#26080;&#35299;&#36755;&#20986; 0&#12290;&#20363;&#22914;&#65292;n=216&#65292;121&#65292;2005 &#26102;&#30340;&#35299;&#22260; 198&#65292;0&#65292; 1979&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;stdio.h&gt;</span>
<span class="ot">#include&lt;string.h&gt;</span>
<span class="ot">#define maxn 100005</span>
<span class="dt">int</span> ans[maxn];

<span class="dt">int</span> main() {
  <span class="dt">int</span> T, n;
  memset(ans, <span class="dv">0</span>, <span class="kw">sizeof</span>(ans));
  <span class="kw">for</span>(<span class="dt">int</span> m = <span class="dv">1</span>; m &lt; maxn; m++) {
    <span class="dt">int</span> x = m, y = m;
    <span class="kw">while</span>(x &gt; <span class="dv">0</span>) { y += x % <span class="dv">10</span>; x /= <span class="dv">10</span>; }
    <span class="kw">if</span>(ans[y] == <span class="dv">0</span> || m &lt; ans[y]) ans[y] = m;
  }
  scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
  <span class="kw">while</span>(T--) {
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
    printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans[n]);
  }
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>&#25105;&#30340;&#20998;&#26512;&#65306;&#19968;&#20010;&#20116;&#20301;&#25968;&#65288;&#26368;&#22810;&#65289;&#65292;&#26368;&#22810;&#33021;&#28155;&#21152; 9x5&#65292;&#25152;&#20197;&#35201;&#27714; y &#30340;&#29983;&#25104;&#20803;&#65292;&#21482;&#35201;&#22312; <code>[y-9*5, y)</code> &#26522;&#20030;&#23601;&#21487;&#20197;&#20102;&#12290;&#20070;&#20013;&#32473;&#30340;&#20195;&#30721;&#36866;&#21512;&#26412;&#26469;&#23601;&#26377;&#24456;&#22810;&#25968;&#23383;&#38656;&#35201;&#21028;&#26029;&#65292;&#25105;&#30340;&#36866;&#21512;&#20110;&#21482;&#26377;&#19968;&#20004;&#20010;&#25968;&#23383;&#38656;&#35201;&#21028;&#26029;&#12290;&#20195;&#30721;&#23601;&#19981;&#36148;&#20102;&#65288;&#22240;&#20026;&#24456;&#31616;&#21333;&#65289;&#12290;</p>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#31532; 4 &#31456;&#65292;&#20989;&#25968;&#21644;&#36882;&#24402; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#30693;&#35782;&#28857; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><ul>
<li>&#30001;&#20110;&#20351;&#29992;&#20102;&#35843;&#29992;&#26632;&#65292;C &#35821;&#35328;&#33258;&#28982;&#25903;&#25345;&#20102;&#36882;&#24402;&#12290;&#22312; C &#35821;&#35328;&#20013;&#65292;&#35843;&#29992;&#33258;&#24049;&#21644;&#35843;&#29992;&#20854;&#20182;&#20989;&#25968;&#24182;&#27809;&#26377;&#26412;&#36136;&#19981;&#21516;&#12290;</li>
<li><p>&#27491;&#25991;&#27573;&#65288;Text Segment&#65289;&#23384;&#20648;&#25351;&#20196;&#65292;<strong>&#25968;&#25454;&#27573;&#65288;Data Segment&#65289;&#29992;&#20110;&#23384;&#20648;&#24050;&#32463;&#21021;&#22987;&#21270;&#30340;&#20840;&#23616;&#21464;&#37327;&#65307;</strong> BSS &#27573;&#65288;BSS Segment&#65289;&#29992;&#20110;&#23384;&#20648;&#27809;&#36171;&#20540;&#30340;&#20840;&#23616;&#21464;&#37327;&#25152;&#38656;&#30340;&#31354;&#38388;&#12290;&#36816;&#34892;&#26102;&#21019;&#24314;&#30340;&#35843;&#29992;&#26632;&#25152;&#22312;&#27573;&#21306;&#34987;&#31216;&#20026;&#22534;&#26632;&#27573;&#65288;Stack Segment&#65289;&#65292;&#36234;&#30028;&#35775;&#38382;&#23601;&#20250;&#20986;&#29616; Segment Fault&#12290;&#26632;&#24103;&#22826;&#22810;&#65292;&#21487;&#33021;&#36234;&#30028;&#65292;&#36825;&#21483;&#26632;&#28322;&#20986;&#65288;Stack Overflow&#65289;&#12290;</p>
<p>&#21487;&#20197;&#29992; <code>ulimit -a</code> &#26174;&#31034; stack size&#65292;&#29992; <code>ulimit -s 32768</code> &#35774;&#32622;&#20026; 32 MB&#12290; Windows &#19978;&#20063;&#21487;&#20197;&#35774;&#32622;&#12290;</p>
<p>&#23616;&#37096;&#21464;&#37327;&#22826;&#22823;&#65292;&#20063;&#21487;&#33021; stack overflow&#12290;</p></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#21476;&#32769;&#30340;&#23494;&#30721; &#128542; <code class="fold">@</code></dt>
<dd><p>&#19968;&#20010;&#38543;&#24847;&#30340;&#23383;&#31526;&#20018; JWPUDJSTVP &#33021;&#19981;&#33021;&#36890;&#36807;&#23383;&#31526;&#21464;&#25442;&#21464;&#25104; VICTORIOUS&#65292;&#21482;&#35201;&#32479;&#35745;&#21333;&#35789;&#30340;&#39057;&#29575;&#65292;&#30475;&#26159;&#21542;&#21305;&#37197;&#23601;&#21487;&#20197;&#20102;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;                                             </span><span class="co">// strlen</span>
<span class="ot">#include &lt;stdlib.h&gt;                                             </span><span class="co">// qsort</span>

<span class="ot">#define ASCIISZIE 128</span>

<span class="dt">int</span> cmp( <span class="dt">const</span> <span class="dt">void</span> *a, <span class="dt">const</span> <span class="dt">void</span> *b ) {
    <span class="kw">return</span> *(<span class="dt">int</span> *)a - *(<span class="dt">int</span> *)b;
}

<span class="dt">int</span> main() {
    <span class="dt">char</span> s1, s2;
    <span class="kw">while</span>( scanf( <span class="st">&quot;</span><span class="ch">%s%s</span><span class="st">&quot;</span>, s1, s2 ) == <span class="dv">2</span> ) {
        <span class="dt">int</span> n = strlen(s1);
        <span class="co">// assert( strlen(s1) == strlen(s2) );</span>
        <span class="dt">int</span> cnt1[ASCIISIZE] = {<span class="dv">0</span>}, cnt2[ASCIISIZE] = {<span class="dv">0</span>};
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++ ) { cnt1[s1[i] - <span class="st">&#39;A&#39;</span>]++; }   <span class="co">// &#32479;&#35745;</span>
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++ ) { cnt2[s2[i] - <span class="st">&#39;A&#39;</span>]++; }
        qsort( cnt1, ASCIISIZE, <span class="kw">sizeof</span>( <span class="dt">int</span> ), cmp );           <span class="co">// &#23545;&#23383;&#39057;&#25490;&#24207;</span>
        qsort( cnt2, ASCIISIZE, <span class="kw">sizeof</span>( <span class="dt">int</span> ), cmp );
        <span class="dt">int</span> ok = <span class="dv">1</span>;
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; ASCIISIZE; i++ ) {
            <span class="kw">if</span>( cnt1[i] != cnt2[i] ) { ok = <span class="dv">0</span>; }                <span class="co">// &#26159;&#21542;&#21305;&#37197;&#65311;</span>
        }
        <span class="kw">if</span>( ok ) {
            printf( <span class="st">&quot;YES</span><span class="ch">\n</span><span class="st">&quot;</span> );
        } <span class="kw">else</span> {
            printf( <span class="st">&quot;NO</span><span class="ch">\n</span><span class="st">&quot;</span> );
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>&#20063;&#21487;&#20197;&#29992; c++ &#30340; sort&#65292;&#20462;&#25913;&#22914;&#19979;&#20960;&#34892;&#21363;&#21487;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;algorithm&gt;                                             </span><span class="co">// sort</span>
sort( cnt1, cnt1 + <span class="dv">26</span> );
sort( cnt2, cnt2 + <span class="dv">26</span> );</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#39600;&#23376;&#28034;&#33394; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>rbgggr &#21644; rggbgr &#19968;&#26679;&#12290;</p>
<pre><code>            +-------------+
           /             /|  +------------5
          /      1      / | /
         /             /  |/
        +------------+/   |
3 ----&gt; |            |    |
        |            | 4  /
        |     2      |   /
        |            |  /
        |            | /
        +------------+/
              ^
              |
              +-- 6</code></pre>
</dd>
</dl></li>
<li><dl>
<dt>&#22825;&#24179; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>input:</p>
<pre><code>1

0 2 0 4
0 3 0 1
1 1 1 1
2 4 4 2
1 6 3 2</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">bool</span> solve( <span class="dt">int</span> &amp;W ) {
    <span class="dt">int</span> W1, D1, W2, D2;
    <span class="dt">bool</span> b1 = <span class="kw">true</span>, b2 = <span class="kw">true</span>;
    cin &gt;&gt; W1 &gt;&gt; D1 &gt;&gt; W2 &gt;&gt; D2;
    <span class="kw">if</span>( !W1 ) { b1 = solve( W1 ); }
    <span class="kw">if</span>( !W2 ) { b2 = solve( W2 ); }
    W = W1 + W2;
    <span class="kw">return</span> b1 &amp;&amp; b2 &amp;&amp; ( W1*D1 == W2*D2 );
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T, W;
    cin &gt;&gt; T;
    <span class="kw">while</span>( T-- ) {
        <span class="kw">if</span>( solve(W) ) {
            cout &lt;&lt; <span class="st">&quot;YES</span><span class="ch">\n</span><span class="st">&quot;</span>;
        } <span class="kw">else</span> {
            cout &lt;&lt; <span class="st">&quot;No</span><span class="ch">\n</span><span class="st">&quot;</span>;
        }
        <span class="kw">if</span>( T ) { cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>; }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#31532; 5 &#31456;&#65292;C++ &#19982; STL &#20837;&#38376; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>5.1 From C to C++ <code class="fold">@</code></dt>
<dd><p>template, reference, containers, iostream, operators, etc</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
T sum( T *begin, T *end ) {
    T ans = <span class="dv">0</span>;
    <span class="kw">for</span>( T *p = begin; p != end; ++p ) {
        ans = ans + *p;
    }
    <span class="kw">return</span> ans;
}</code></pre></div>
<p>see tutorial: <a href="c-cpp.html">C/C++ notes</a>.</p>
</dd>
</dl></li>
<li><dl>
<dt>5.2 STL 101 <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#22823;&#29702;&#30707;&#22312;&#21738;&#20799;&#65311; <code>sort, lower_bound</code> <code class="fold">@</code></dt>
<dd><pre><code>input:

    4   1
    2   3   5   1
    5
    5   2
    1   3   3   3   1

output:

    CASE# 1:
    5 found at 4
    CASE# 2:
    2 not found
    3 found at 3</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">10000</span>;

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, q, x a[maxn], kase = <span class="dv">0</span>;
    <span class="kw">while</span>( scanf( <span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;q ) == <span class="dv">2</span> &amp;&amp; n ) {
        printf( <span class="st">&quot;CASE# </span><span class="ch">%d</span><span class="st">:</span><span class="ch">\n</span><span class="st">&quot;</span>, ++kase );
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) { scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;a[i] ); }
        sort( a, a+n );
        <span class="kw">while</span>( q-- ) {
            scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;x );
            <span class="dt">int</span> p = lower_bound( a, a+n, x ) - a;       <span class="co">// offset</span>
            <span class="kw">if</span>( a[p] == x ) {
                printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> found at </span><span class="ch">%d\n</span><span class="st">&quot;</span>, x, p<span class="dv">+1</span> );
            } <span class="kw">else</span> {
                printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> not found</span><span class="ch">\n</span><span class="st">&quot;</span>, x );
            }
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>run it:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">echo</span> <span class="st">&quot;4 1\n2 3 5 1\n5&quot;</span> <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">CASE</span># 1:
<span class="kw">5</span> found at 4</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Set, Map <code>set&lt;int&gt;::iterator</code> <code class="fold">@</code></dt>
<dd><p>elements in <strong>set</strong> already sorted.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main() {
    string s, buf;
    set&lt;string&gt; dict;
    <span class="kw">while</span>( cin &gt;&gt; s ) {
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; s.length(); ++i ) {
            <span class="kw">if</span>( isalpha(s[i]) ) {
                s[i] = tolower(s[i]);
            } <span class="kw">else</span> {
                s[i] = <span class="st">&#39; &#39;</span>;
            }
        }
        stringstream ss( s );
        <span class="kw">while</span>( ss &gt;&gt; buf ) {
            dict.insert( buf );                                                         <span class="co">// set.insert( item )</span>
        }
        <span class="kw">for</span>( set&lt;string&gt;::iterator it = dict.begin(); it != dict.end(); ++it ) {        <span class="co">// &#36845;&#20195;&#22120;&#36755;&#20986;&#25152;&#26377;&#20803;&#32032;</span>
            cout &lt;&lt; *it &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;                                                        <span class="co">// already sorted</span>
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p><strong>map</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">string repr( <span class="dt">const</span> string &amp;s ) {                    <span class="co">// signature</span>
    string ans = s;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; ans.length(); ++i ) {
        ans[i] = tolower(ans[i]);
    }
    sort( ans.begin(), ans.end() );
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main() {
    ...
    <span class="kw">while</span>( cin &gt;&gt; s ) {
        string r = repr( s );
        <span class="kw">if</span>( !cnt.count(r) ) { cnt[r] = <span class="dv">0</span>; }         <span class="co">// this is optional</span>
        ++cnt[r];
    }
    vector&lt;string&gt; ans;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; words.size(); ++i ) {
        <span class="kw">if</span>( cnt[repr(words[i])] == <span class="dv">1</span> ) {
            ans.push_back( words[i] );
        }
    }
    sort( ans.begin(), ans.end() );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; ans.size(); ++i ) {
        coutt &lt;&lt; ans[i] &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>&#38656;&#35201;&#27880;&#24847;&#30340;&#26159;&#65306;</p>
<ul>
<li>&#30452;&#25509;&#29992; <code>++cnt[r]</code> &#20063;&#26159;&#21487;&#20197;&#30340;&#65307;</li>
<li><code>map.count( key )</code> &#36820;&#22238; 1 &#25110;&#32773; 0&#65307;</li>
<li><code>map.find( key )</code> &#36820;&#22238; iter&#65292;&#21487;&#33021;&#26159; <code>map.end()</code></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Stack, Queue, Priority Queue <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>stack <code class="fold">@</code></dt>
<dd><blockquote>
<p>&#26126;&#30333; stack&#65292;&#20197;&#21450;&#24120;&#29992;&#30340; <code>push(item)</code>, <code>item = top()</code>, <code>pop()</code> &#25805;&#20316;&#12290;</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//  print stack contents</span>
<span class="kw">for</span>( std::stack&lt;<span class="dt">int</span>&gt; dump = stack; !dump.empty(); dump.pop() ) {
    std::cout &lt;&lt; dump.top() &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre></div>
<p>The SetStack Computer&#65292;&#25903;&#25345;&#22914;&#19979;&#25805;&#20316;&#65306;</p>
<ul>
<li>PUSH&#65306;&#31354;&#38598;&#8220;{}&#8221;&#20837;&#26632;</li>
<li>DUP&#65306;&#22797;&#21046;&#26632;&#39030;&#24182;&#20837;&#26632;</li>
<li>UNION&#65306;&#20986;&#26632;&#20004;&#20010;&#20803;&#32032;&#65292;&#27714; union &#24182;&#20837;&#26632;</li>
<li>INTERSECT&#65306;&#20986;&#26632;&#20004;&#20010;&#20803;&#32032;&#65292;&#27714; intersect &#24182;&#20837;&#26632;</li>
<li>ADD&#65306;&#20986;&#26632;&#20004;&#20010;&#20803;&#32032;&#65292;&#25226;&#20808;&#20986;&#30340;&#20803;&#32032;&#21152;&#21040;&#21518;&#20986;&#30340;&#20803;&#32032;&#65292;&#28982;&#21518;&#20837;&#26632;</li>
</ul>
<p>&#38598;&#21512;&#30340;&#38598;&#21512;&#30340;&#34920;&#31034;&#65311;</p>
<p>&#19968;&#20010;&#38598;&#21512;&#26377;&#25972;&#24418;&#30340; id&#65292;&#23427;&#30340;&#20869;&#23481;&#29992; <code>set&lt;int&gt;</code> &#34920;&#31034;&#12290;&#25972;&#20010;&#26632;&#29992; <code>stack&lt;int&gt;</code> &#34920;&#31034;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12096 The SetStack Computer</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;set&gt;</span>
<span class="ot">#include &lt;map&gt;</span>
<span class="ot">#include &lt;stack&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#define ALL(x) x.begin(), x.end()</span>
<span class="ot">#define INS(x) inserter(x, x.begin())</span>

<span class="kw">typedef</span> set&lt;<span class="dt">int</span>&gt; Set;
map&lt;Set,<span class="dt">int</span>&gt; IDcache;                                       <span class="co">// &#25226;&#38598;&#21512;&#26144;&#23556;&#25104; ID</span>
vector&lt;Set&gt; Setcache;                                       <span class="co">// &#26681;&#25454; ID &#21462;&#38598;&#21512;</span>

<span class="co">// &#26597;&#25214;&#32473;&#23450;&#38598;&#21512; x &#30340; ID&#12290;&#22914;&#26524;&#25214;&#19981;&#21040;&#65292;&#20998;&#37197;&#19968;&#20010;&#26032; ID</span>
<span class="dt">int</span> ID( Set x ) {
    <span class="kw">if</span>( IDcache.count( x ) ) { <span class="kw">return</span> IDcache[x]; }
    Setcache.push_back( x );                                <span class="co">// &#28155;&#21152;&#26032;&#38598;&#21512;</span>
    <span class="kw">return</span> IDcache[x] = Setcache.size() - <span class="dv">1</span>;
}

<span class="dt">int</span> main () {
    <span class="dt">int</span> T;
    cin &gt;&gt; T;
    <span class="kw">while</span>( T-- ) {
        stack&lt;<span class="dt">int</span>&gt; s;                                       <span class="co">// &#39064;&#30446;&#20013;&#30340;&#26632;</span>
        <span class="dt">int</span> n;
        cin &gt;&gt; n;
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++ ) {
            string op;
            cin &gt;&gt; op;
            <span class="kw">if</span>( op == <span class="st">&#39;P&#39;</span> ) {
                s.push( ID( Set() ) );                      <span class="co">// push &#39;{}&#39;</span>
            } <span class="kw">else</span> <span class="kw">if</span>( op == <span class="st">&#39;D&#39;</span> ) {
                s.push( s.top(  ) );                        <span class="co">// dup</span>
            } <span class="kw">else</span> {
                Set x1 = Setcache[s.top()]; s.pop();
                Set x2 = Setcache[s.top()]; s.pop();
                Set x;
                <span class="kw">if</span>( op == <span class="st">&#39;U&#39;</span> ) { set_union ( ALL( x1 ), ALL( x2 ), INS( x ) ); }
                <span class="kw">if</span>( op == <span class="st">&#39;I&#39;</span> ) { set_intersection ( ALL( x1 ), ALL( x2 ), INS( x ) ); }
                <span class="kw">if</span>( op == <span class="st">&#39;A&#39;</span> ) { x = x2; x.insert( ID( x1 ) ); }
                s.push(ID(x));
            }
            cout &lt;&lt; Setcache[s.top()].size() &lt;&lt; endl;
        }
        cout &lt;&lt; <span class="st">&quot;***&quot;</span> &lt;&lt; endl;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>queue <code class="fold">@</code></dt>
<dd><blockquote>
<p><code>cpp   queue&lt;int&gt; q;   q.push( val );   q.pop();   q.front();   q.back();</code></p>
</blockquote>
<p>t &#20010;&#38431;&#20237;&#25490;&#38431;&#12290;&#26032;&#26469;&#30340;&#20154;&#65292;&#22914;&#26524;&#26377;&#38431;&#21451;&#65292;&#23601;&#25554;&#20837;&#21040;&#38431;&#21451;&#21518;&#38754;&#65292;&#22914;&#26524;&#27809;&#26377;&#65292;&#23601;&#21482;&#33021;&#25490;&#26368;&#21518;&#38754;&#12290;&#36755;&#20837;&#27599;&#20010;&#22242;&#38431;&#20013;&#25152;&#26377;&#38431;&#21592;&#30340;&#32534;&#21495;&#65292;&#35201;&#27714;&#25903;&#25345;&#22914;&#19979; 3 &#20013;&#21629;&#20196;&#65306;</p>
<ul>
<li>ENQUEUE x&#65306;&#25226; x &#20837;&#38431;</li>
<li>DEQUEUE</li>
<li>STOP&#65306;&#20572;&#27490;&#27169;&#25311;</li>
</ul>
<p>&#23545;&#20110;&#27599;&#20010; DEQUEUE &#25351;&#20196;&#65292;&#36755;&#20986;&#20986;&#23545;&#30340;&#20154;&#30340;&#32534;&#21495;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa540 Team Queue</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;map&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxt = <span class="dv">1000</span> + <span class="dv">10</span>;

<span class="dt">int</span> main() {
    <span class="dt">int</span> t, kase = <span class="dv">0</span>;
    <span class="kw">while</span>( scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;t ) == <span class="dv">1</span> &amp;&amp; t ) {
        printf( <span class="st">&quot;Scenario #</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ++kase );

        map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; team;                                     <span class="co">// team[x] &#34920;&#31034;&#32534;&#21495;&#20026; x &#30340;&#20154;&#25152;&#22312;&#30340;&#22242;&#38431;&#32534;&#21495;</span>
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; t; i++ ) {
            <span class="dt">int</span> n, x;
            scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n );
            <span class="kw">while</span>( n-- ) { scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;x ); team[x] = i; }
        }

        <span class="co">// &#27169;&#25311;</span>
        queue&lt;<span class="dt">int</span>&gt; q, q2[maxt];                                 <span class="co">// q &#26159;&#22242;&#38431;&#30340;&#38431;&#21015;&#65292;&#32780; q2[i] &#26159;&#22242;&#38431; i &#25104;&#21592;&#30340;&#38431;&#21015;</span>

        <span class="kw">for</span>( ;; ) {
            <span class="dt">int</span> x;
            <span class="dt">char</span> cmd;
            scanf( <span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, cmd );
            <span class="kw">if</span>( cmd == <span class="st">&#39;S&#39;</span> ) { <span class="kw">break</span>; }
            <span class="kw">else</span> <span class="kw">if</span>( cmd == <span class="st">&#39;D&#39;</span> ) {
                <span class="dt">int</span> t = q.front();
                printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, q2[t].front() ); q2[t].pop(  );
                <span class="kw">if</span>( q2[t].empty(  ) ) { q.pop(); }              <span class="co">// &#22242;&#20307; t &#20840;&#20307;&#20986;&#38431;&#21015;</span>
            }
            <span class="kw">else</span> <span class="kw">if</span>( cmd == <span class="st">&#39;E&#39;</span> ) {
                scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;x );
                <span class="dt">int</span> t = team[x];
                <span class="kw">if</span>( q2[t].empty() ) q.push( t );                <span class="co">// &#22242;&#38431; t &#36827;&#20837;&#38431;&#21015;</span>
                q2[t].push( x );
            }
        }
        printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
    }

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>priority_queue &#9829;&#65039; <code class="fold">@</code></dt>
<dd><blockquote>
<p><code>cpp   pq.push();   pq.top();   pq.pop();</code></p>
</blockquote>
<p>ugly number &#26159;&#19981;&#33021;&#34987; 2&#65292;3&#65292;5 &#20197;&#20026;&#30340;&#20854;&#20182;&#32032;&#25968;&#25972;&#38500;&#30340;&#25968;&#12290;&#65288;&#30456;&#27604;&#36136;&#25968;&#19981;&#26159;&#37027;&#20040;&#20005;&#26684;&#12290;&#65289;&#20063;&#23601;&#26159; 2&#65292;3&#65292;5 &#30340;&#21508;&#31181;&#65289;&#20056;&#31215;&#30340;&#32452;&#21512;&#12290;</p>
<p>&#22914;&#26524; x &#26159; ugly number&#65292;2x&#65292;3x &#21644; 5x &#37117;&#20250;&#26159; ugly number&#12290;&#29992;&#20248;&#20808;&#38431;&#21015;&#21363;&#21487;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;set&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL;

<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    <span class="kw">while</span>( scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) &amp;&amp; n ) {
        priority_queue&lt;LL, vector&lt;LL&gt;, greater&lt;LL&gt; &gt; pq;                            <span class="co">// greater &#20110;&#26159; ascend &#25490;&#24207;</span>
        pq.push( <span class="dv">1LL</span> );
        set&lt;LL&gt; s;
        s.insert( <span class="dv">1LL</span> );

        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; ; ++i ) {
            LL x = pq.top(); pq.pop();  <span class="co">// the smallest ugly number</span>
            <span class="kw">if</span>( i == n ) {
                cout &lt;&lt; <span class="st">&quot;The &quot;</span> &lt;&lt; n &lt;&lt; <span class="st">&quot;&#39;th ugly number is &quot;</span> &lt;&lt; x &lt;&lt; <span class="st">&quot;.</span><span class="ch">\n</span><span class="st">&quot;</span>;
                <span class="dt">int</span> j = <span class="dv">0</span>;
                <span class="kw">for</span>( set&lt;LL&gt;::iterator it = s.begin(); it != s.end(); ++it ) {
                    <span class="kw">if</span>( ++j == n ) {
                        cout &lt;&lt; <span class="st">&quot;The &quot;</span> &lt;&lt; n &lt;&lt; <span class="st">&quot;&#39;th ugly number is &quot;</span> &lt;&lt; *it &lt;&lt; <span class="st">&quot;.</span><span class="ch">\n</span><span class="st">&quot;</span>;
                    }
                }
                <span class="kw">break</span>;
            }
            <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">3</span>; ++j ) {
                <span class="dt">const</span> <span class="dt">int</span> coeff = {  <span class="dv">2</span>,  <span class="dv">3</span>,  <span class="dv">5</span>   };
                LL x2 = x * coeff[j];
                <span class="kw">if</span>( !s.count(x2) ) {
                    s.insert( x2 );
                    pq.push( x2 );
                }
            }
        }
    }
}</code></pre></div>
<p>output:</p>
<pre><code>$ a.out
1500&lt;RET&gt;
The 1500&#39;th ugly number is 859963392.
The 1500&#39;th ugly number is 859963392.</code></pre>
<p>&#20174;&#38431;&#21015;&#21069;&#38754;&#21462;&#20986;&#30340;&#31532; n &#20010;&#25968;&#27491;&#22909;&#26159;&#31532; n &#20010;&#22823;&#30340; ugly number&#12290;</p>
<p>&#27880;&#65306;</p>
<ul>
<li><code>priority_queue&lt;int&gt; pq</code> &#26159;&#36234;&#23567;&#30340;&#25972;&#25968;&#20248;&#20808;&#32423;&#36234;&#20302;&#65288;&#36870;&#24207;&#65289;</li>
<li><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq</code> &#26159;&#36234;&#22823;&#30340;&#25972;&#25968;&#20248;&#20808;&#32423;&#36234;&#20302;&#65288;&#27491;&#24207;&#65289;</li>
<li><strong>queue &#20351;&#29992; <code>front()</code>&#65292;priority queue &#20351;&#29992; <code>top()</code></strong></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Test STL <code class="fold">@</code></dt>
<dd><p>tips and guidelines</p>
<ul>
<li>RAND_MAX may be only 32767 (2<sup>15</sup>-1)</li>
<li>use <code>assert( ... )</code>, header file is <code>&lt;assert.h&gt;</code></li>
<li>vector, set, map are fast.</li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>5.3 Big Integer <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> <span class="kw">operator</span> &gt;  ( <span class="dt">const</span> T &amp;rhs ) <span class="dt">const</span> { <span class="kw">return</span>   rhs &lt; *<span class="kw">this</span>;     }
<span class="dt">bool</span> <span class="kw">operator</span> &lt;= ( <span class="dt">const</span> T &amp;rhs ) <span class="dt">const</span> { <span class="kw">return</span> !(rhs &lt; *<span class="kw">this</span>);    }
<span class="dt">bool</span> <span class="kw">operator</span> != ( <span class="dt">const</span> T &amp;rhs ) <span class="dt">const</span> { <span class="kw">return</span> !(*<span class="kw">this</span> == rhs);   }</code></pre></div>
<p>&#22312; 32 &#20301; CPU &#19979;&#65292;C/C++ &#20013;&#30340; int &#33021;&#34920;&#31034;&#30340;&#33539;&#22260;&#26159; -2<sup>31</sup> ~ 2<sup>32</sup>-1&#65292; unsigned int &#33021;&#34920;&#31034;&#30340;&#33539;&#22260;&#26159; 0 ~ 2<sup>32</sup>&#12290;&#25152;&#20197;&#65292;int &#21644; unsigned int &#37117;&#19981;&#33021;&#20445;&#23384;&#36229;&#36807; 10 &#20301;&#30340;&#25972;&#25968; (&#35299;&#26041;&#31243; 10<sup>x</sup> &lt;= 2<sup>32</sup>&#65292;&#21487;&#24471; x &lt;= 9.63&#12290;) &#26377;&#26102;&#25105;&#20204;&#38656;&#35201;&#21442;&#19982;&#36816;&#31639;&#30340;&#25972;&#25968;&#65292;&#21487;&#33021;&#20250;&#36828;&#36828;&#19981;&#27490; 10 &#20301;&#65292;&#25105;&#20204;&#31216;&#36825;&#31181;&#22522;&#26412;&#25968;&#25454;&#31867;&#22411;&#26080;&#27861;&#34920;&#31034;&#30340;&#25972;&#25968;&#20026;&#22823;&#25972;&#25968;&#12290;&#22914;&#20309;&#34920;&#31034;&#21644;&#23384;&#25918;&#22823;&#25972;&#25968;&#21602;&#65311;&#22522;&#26412;&#30340;&#24605;&#24819;&#26159;&#65306;&#29992;&#25968;&#32452;&#27169;&#25311;&#22823;&#25972;&#25968;&#12290;&#19968;&#20010;&#25968;&#32452;&#20803;&#32032;&#65292;&#23384;&#25918;&#22823;&#25972;&#25968;&#20013;&#30340;&#19968;&#20301;&#12290;</p>
<p>&#20363;&#22914;&#65292;&#19968;&#20010; 200 &#20301;&#30340;&#21313;&#36827;&#21046;&#25972;&#25968;&#65292;&#21487;&#20197;&#29992; <code>int x[200]</code> &#26469;&#34920;&#31034;&#65292;&#19968;&#20010;&#25968;&#32452;&#20803;&#32032;&#23545;&#24212;&#19968;&#20010;&#20301;&#12290;&#36825;&#26679;&#20570;&#26377;&#28857;&#28010;&#36153;&#31354;&#38388;&#65292;&#22240;&#20026;&#19968;&#20010; int &#21487;&#20197;&#34920;&#31034;&#30340;&#33539;&#22260;&#36828;&#36828;&#22823;&#20110; 10&#12290;&#22240;&#27492;&#65292;&#25105;&#20204;&#21487;&#20197;&#29992;&#19968;&#20010;&#25968;&#32452;&#20803;&#32032;&#65292;&#34920;&#31034; 4 &#20010;&#25968;&#20301;&#65288;&#19968;&#20010; int &#21487;&#20197;&#34920;&#31034;&#30340;&#33539;&#22260;&#20063;&#36828;&#36828;&#22823;&#20110; 10000&#65292;&#20026;&#20160;&#20040;&#19968;&#20010;&#25968;&#32452;&#20803;&#32032;&#21482;&#34920;&#31034; 4 &#20010;&#25968;&#20301;&#65292;&#21487;&#19981;&#21487;&#20197;&#34920;&#31034; 9 &#20010;&#25968;&#20301;&#65311;&#30041;&#32473;&#35835;&#32773;&#24605;&#32771;&#65289;&#65292;&#36825;&#26102;&#65292;&#25968;&#32452;&#19981;&#20877;&#26159; 10 &#36827;&#21046;&#65292;&#32780;&#26159; 10000 &#36827;&#21046;&#12290;&#20351;&#29992;&#19975;&#36827;&#21046;&#65292;&#25968;&#32452;&#38271;&#24230;&#21487;&#20197;&#32553;&#20943;&#21040;&#21407;&#26469;&#30340; 1/4&#12290;</p>
<p>(&#25105;&#35273;&#24471;, &#19975;&#36827;&#21046;&#26041;&#20415;&#23454;&#29616;&#20056;&#27861;, &#19981;&#23481;&#26131;&#36234;&#30028;.)</p>
<dl>
<dt>&#22823;&#25972;&#25968;&#21152;&#27861; <code class="fold">@</code></dt>
<dd><p>&#27714;&#20004;&#20010;&#38750;&#36127;&#30340;&#22823;&#25972;&#25968;&#30456;&#21152;&#30340;&#21644;&#12290;</p>
<pre><code>&#36755;&#20837;

    &#26377;&#20004;&#34892;&#65292;&#27599;&#34892;&#26159;&#19968;&#20010;&#19981;&#36229;&#36807; 200 &#20301;&#30340;&#38750;&#36127;&#25972;&#25968;&#65292;&#21487;&#33021;&#26377;&#22810;&#20313;&#30340;&#21069;&#23548; 0&#12290;

    33333333333333333333
    22222222222222222222

    234123412341324190834500091234087501234087
    190834500091234087501234087412340871234609

    234123412341324190834500091234087501234087234444444444444444444444
    12134123442134190834500091234087501234087412340871234609

    999999999999999
    5

    999999999999999999999999999999999999999999999999999999999999999999
    1

&#36755;&#20986;

    &#19968;&#34892;&#65292;&#21363;&#30456;&#21152;&#21518;&#30340;&#32467;&#26524;&#12290;&#32467;&#26524;&#37324;&#19981;&#33021;&#26377;&#22810;&#20313;&#30340;&#21069;&#23548; 0&#65292;&#21363;&#22914;&#26524;&#32467;&#26524;&#26159; 342&#65292;&#37027;&#20040;&#23601;&#19981;
    &#33021;&#36755;&#20986;&#20026; 0342&#12290;

    33333333333333333333 +
    22222222222222222222 =
    55555555555555555555

    234123412341324190834500091234087501234087 +
    190834500091234087501234087412340871234609 =
    424957912432558278335734178646428372468696

    234123412341324190834500091234087501234087234444444444444444444444 +
    12134123442134190834500091234087501234087412340871234609 =
    234123412353458314276634282068587592468174735678531856785315679053

    999999999999999 +
    5 =
    1000000000000004

    999999999999999999999999999999999999999999999999999999999999999999 +
    1 =
    1000000000000000000000000000000000000000000000000000000000000000000</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>

<span class="co">// &#19968;&#20010;&#25968;&#32452;&#20803;&#32032;&#34920;&#31034; 4 &#20010;&#21313;&#36827;&#21046;&#20301;&#65292;&#21363;&#25968;&#32452;&#26159;&#19975;&#36827;&#21046;&#30340;</span>
<span class="ot">#define BIGINT_RADIX 10000</span>
<span class="ot">#define RADIX_LEN 4</span>
<span class="ot">#define MAX_LEN (200/RADIX_LEN+1)                               </span><span class="co">// &#25972;&#25968;&#30340;&#26368;&#22823;&#20301;&#25968;</span>

<span class="dt">char</span> a[MAX_LEN * RADIX_LEN], b[MAX_LEN * RADIX_LEN];
<span class="dt">int</span>  x[MAX_LEN], y[MAX_LEN];
<span class="dt">int</span>  z[MAX_LEN * <span class="dv">2</span>]; <span class="co">// bigint_mul</span>

<span class="dt">void</span> bigint_print( <span class="dt">const</span> <span class="dt">int</span> x[], <span class="dt">const</span> <span class="dt">int</span> n ) {
    <span class="dt">bool</span> start_output = <span class="kw">false</span>;              <span class="co">// &#29992;&#20110;&#36339;&#36807;&#21069;&#23548; 0</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = n - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; --i ) {
        <span class="kw">if</span>( start_output ) {                <span class="co">// &#22914;&#26524;&#22810;&#20313;&#30340; 0 &#24050;&#32463;&#37117;&#36339;&#36807;&#65292;&#21017;&#36755;&#20986;</span>
            printf( <span class="st">&quot;</span><span class="ch">%04d</span><span class="st">&quot;</span>, x[i] );
            <span class="kw">continue</span>;
        }
        <span class="kw">if</span>( x[i] &gt; <span class="dv">0</span> ) {
            printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, x[i] );           <span class="co">// &#26412;&#39064;&#36755;&#20986;&#27604;&#36739;&#22353;&#29241;&#65292;&#26368;&#39640;&#20301;&#25968;&#23383;&#26377;&#21069;&#23548; 0</span>
            start_output = <span class="kw">true</span>;            <span class="co">// &#30896;&#21040;&#31532;&#19968;&#20010;&#38750; 0 &#30340;&#20540;&#65292;&#23601;&#35828;&#26126;&#22810;&#20313;&#30340; 0 &#24050;&#32463;&#37117;&#36339;&#36807;</span>
        }
    }

    <span class="kw">if</span> ( !start_output ) { printf(<span class="st">&quot;0&quot;</span>); }   <span class="co">// &#24403; x &#20840;&#20026; 0 &#26102;</span>
}

<span class="co">// x &#22823;&#25972;&#25968;&#65292;&#29992;&#25968;&#32452;&#34920;&#31034;&#65292;&#20302;&#20301;&#22312;&#20302;&#22320;&#22336;</span>
<span class="dt">void</span> bigint_input( <span class="dt">const</span> <span class="dt">char</span> s[], <span class="dt">int</span> x[] ) {
    <span class="co">// memset( x, 0, sizeof(x) ); sizeof(x) == sizeof(int *)</span>
    memset( x, <span class="dv">0</span>, MAX_LEN*<span class="kw">sizeof</span>(<span class="dt">int</span>) );
    <span class="dt">int</span> j = <span class="dv">0</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = strlen(s); i &gt; <span class="dv">0</span>; i -= RADIX_LEN ) {  <span class="co">/* [i-RADIX_LEN, i) */</span>
        <span class="dt">int</span> low = i-RADIX_LEN &gt; <span class="dv">0</span> ? i-RADIX_LEN : <span class="dv">0</span>;
        <span class="dt">int</span> temp = <span class="dv">0</span>;
        <span class="kw">for</span>( <span class="dt">int</span> k = low; k &lt; i; ++k ) {
            temp = temp * <span class="dv">10</span> + s[k] - <span class="st">&#39;0&#39;</span>;
        }
        x[j++] = temp;
    }
}

<span class="dt">void</span> bigint_add( <span class="dt">const</span> <span class="dt">int</span> x[], <span class="dt">const</span> <span class="dt">int</span> y[], <span class="dt">int</span> z[] ) {
    memset( z, <span class="dv">0</span>, (MAX_LEN*<span class="dv">2</span>)*<span class="kw">sizeof</span>(<span class="dt">int</span>) );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; MAX_LEN; ++i ) {
        z[i] += x[i] + y[i];
        <span class="kw">if</span>( z[i  ] &gt;= BIGINT_RADIX ) {
            z[i<span class="dv">+1</span>] += z[i] / BIGINT_RADIX;
            z[i  ] %= BIGINT_RADIX;
        }
    }
}

<span class="dt">int</span> main() {
    <span class="kw">while</span>( <span class="dv">2</span> == scanf( <span class="st">&quot;</span><span class="ch">%s</span><span class="st"> </span><span class="ch">%s</span><span class="st">&quot;</span>, a, b ) ) {
        bigint_input( a, x );
        bigint_input( b, y );
        bigint_add( x, y, z );
        bigint_print( x, <span class="kw">sizeof</span>(x)/<span class="kw">sizeof</span>(x[<span class="dv">0</span>]) ); printf(<span class="st">&quot; + </span><span class="ch">\n</span><span class="st">&quot;</span>);
        bigint_print( y, <span class="kw">sizeof</span>(y)/<span class="kw">sizeof</span>(y[<span class="dv">0</span>]) ); printf(<span class="st">&quot; = </span><span class="ch">\n</span><span class="st">&quot;</span>);
        bigint_print( z, <span class="kw">sizeof</span>(z)/<span class="kw">sizeof</span>(z[<span class="dv">0</span>]) ); printf(<span class="st">&quot;</span><span class="ch">\n\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<pre><code>## more about bigint input

void bigint_input( const char s[], int x[] ) {  // x &#22823;&#25972;&#25968;&#65292;&#29992;&#25968;&#32452;&#34920;&#31034;&#65292;&#20302;&#20301;&#22312;&#20302;&#22320;&#22336;
    // don&#39;t not use &#39;memset( x, 0, sizeof(x) );&#39; because &#39;sizeof(x) == sizeof(int *)&#39;
    memset( x, 0, MAX_LEN*sizeof(int) );
    int j = 0;
    for( int i = strlen(s); i &gt; 0; i -= RADIX_LEN ) {
        // (i, i-RADIX_LEN]
        int low = i-RADIX_LEN &gt; 0 ? i-RADIX_LEN : 0;
        int temp = 0;
        printf( &quot;s[%d, %d) = \&quot;&quot;, low, i );
        for( int k = low; k &lt; i; ++k ) {
            temp = temp * 10 + s[k] - &#39;0&#39;;
            printf( &quot;%c&quot;, s[k] );
        }
        printf( &quot;\&quot;, \t\t&quot; ); printf( &quot;x[j=%d] = %d\n&quot;, j, temp );
        x[j++] = temp;
    }
}

111222333444555666777888999

111
  2223
      3344
          4555
               6667
                   7788
                       8999

                       8        = 0*10      +   [8]
                       89       = 8*10      +   [9]
                       899      = 89*10     +   [9]
                       8999     = 899*10    +   [9]

s[23, 27) = &quot;8999&quot;,         x[j=0] = 8999
s[19, 23) = &quot;7788&quot;,         x[j=1] = 7788
s[15, 19) = &quot;6667&quot;,         x[j=2] = 6667
s[11, 15) = &quot;4555&quot;,         x[j=3] = 4555
s[ 7, 11) = &quot;3344&quot;,         x[j=4] = 3344
s[ 3,  7) = &quot;2223&quot;,         x[j=5] = 2223
s[ 0,  3) =  &quot;111&quot;,         x[j=6] =  111</code></pre>
</dd>
<dt>&#22823;&#25972;&#25968;&#20943;&#27861; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> bigint_sub( <span class="dt">const</span> <span class="dt">int</span> x[], <span class="dt">const</span> <span class="dt">int</span> y[], <span class="dt">int</span> z[] ) {
    memset( z, <span class="dv">0</span>, (MAX_LEN*<span class="dv">2</span>)*<span class="kw">sizeof</span>(<span class="dt">int</span>) );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; MAX_LEN; ++i ) {
        z[i] += x[i] - y[i];
        <span class="kw">while</span>( z[i] &lt; <span class="dv">0</span> ) {                  <span class="co">// &#30475;&#26159;&#21542;&#35201;&#20511;&#20301;</span>
            z[i] += BIGINT_RADIX;
            --z[i<span class="dv">+1</span>];
        }
    }
}</code></pre></div>
<pre><code>33333333333333333333 -
22222222222222222222 =
11111111111111111111

234123412341324190834500091234087501234087 -
190834500091234087501234087412340871234609 =
43288912250090103333266003821746629999478

234123412341324190834500091234087501234087234444444444444444444444 -
12134123442134190834500091234087501234087412340871234609 =
234123412329190067392365900399587409999999733210357032103573209835

999999999999999 -
5 =
999999999999994

999999999999999999999999999999999999999999999999999999999999999999 -
1 =
999999999999999999999999999999999999999999999999999999999999999998</code></pre>
</dd>
<dt>&#22823;&#25972;&#25968;&#20056;&#27861; <code class="fold">@</code></dt>
<dd><p>&#20004;&#20010; 200 &#20301;&#30340;&#25968;&#30456;&#20056;&#65292;&#31215;&#26368;&#22810;&#20250;&#26377; 400 &#20301;&#12290;</p>
<p>&#35745;&#31639;&#30340;&#36807;&#31243;&#22522;&#26412;&#19978;&#21644;&#23567;&#23398;&#29983;&#21015;&#31446;&#24335;&#20570;&#20056;&#27861;&#30456;&#21516;&#12290;&#20026;&#32534;&#31243;&#26041;&#20415;&#65292;&#24182;&#19981;&#24613;&#20110;&#22788;&#29702;&#36827;&#20301;&#65292;&#32780;&#23558;&#36827;&#20301;&#38382;&#39064;&#30041;&#24453;&#26368;&#21518;&#32479;&#19968;&#22788;&#29702;&#12290;</p>
<p>&#19968;&#20010;&#25968;&#30340;&#31532; i &#20301;&#21644;&#21478;&#19968;&#20010;&#25968;&#30340;&#31532; j &#20301;&#30456;&#20056;&#25152;&#24471;&#30340;&#25968;&#65292;&#19968;&#23450;&#26159;&#35201;&#32047;&#21152;&#21040;&#32467;&#26524;&#30340;&#31532; i+j &#20301;&#19978;&#12290;&#36825;&#37324; i, j &#37117;&#26159;&#20174;&#21491;&#24448;&#24038;&#65292;&#20174; 0 &#24320;&#22987;&#25968;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> bigint_mul( <span class="dt">const</span> <span class="dt">int</span> x[], <span class="dt">const</span> <span class="dt">int</span> y[], <span class="dt">int</span> z[] ) {
    memset( z, <span class="dv">0</span>, (MAX_LEN*<span class="dv">2</span>)*<span class="kw">sizeof</span>(<span class="dt">int</span>) );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; MAX_LEN; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; MAX_LEN; ++j ) {
            z[i + j] += y[i] * x[j];                    <span class="co">// &#20004;&#25968;&#31532; i, j &#20301;&#30456;&#20056;&#65292;&#32047;&#21152;&#21040;&#32467;&#26524;&#30340;&#31532; i+j &#20301;</span>
            <span class="kw">if</span>( z[i + j] &gt;= BIGINT_RADIX ) {            <span class="co">// &#30475;&#26159;&#21542;&#35201;&#36827;&#20301;</span>
                z[i+j<span class="dv">+1</span>] += z[i + j] / BIGINT_RADIX;
                z[i + j] %= BIGINT_RADIX;
            }
        }
    }
}</code></pre></div>
<pre><code>33333333333333333333 x
22222222222222222222 =
740740740740740740725925925925925925926

234123412341324190834500091234087501234087 x
190834500091234087501234087412340871234609 =
44678824353810467183442287509177670164600699173891564239282307776984043046804916983

234123412341324190834500091234087501234087234444444444444444444444 x
12134123442134190834500091234087501234087412340871234609 =
2840882386043311185404680351433686312716618743780815470159469535469124552403228890832162235291280220562627816737390562396

999999999999999 x
5 =
4999999999999995

999999999999999999999999999999999999999999999999999999999999999999 x
1 =
999999999999999999999999999999999999999999999999999999999999999999</code></pre>
</dd>
<dt>&#22823;&#25972;&#25968;&#20056;&#27861; <code class="fold">@</code></dt>
<dd><p>&#22522;&#26412;&#30340;&#24605;&#24819;&#26159;&#21453;&#22797;&#20570;&#20943;&#27861;&#65292;&#30475;&#30475;&#20174;&#34987;&#38500;&#25968;&#37324;&#26368;&#22810;&#33021;&#20943;&#21435;&#22810;&#23569;&#20010;&#38500;&#25968;&#65292;&#21830;&#23601;&#26159;&#22810;&#23569;&#12290;&#19968;&#20010;&#19968;&#20010;&#20943;&#26174;&#28982;&#22826;&#24930;&#65292;&#22914;&#20309;&#20943;&#24471;&#26356;&#24555;&#19968;&#20123;&#21602;&#65311;&#20197; 7546 &#38500;&#20197; 23 &#20026;&#20363;&#26469;&#30475;&#19968;&#19979;&#65306;&#24320;&#22987;&#21830;&#20026; 0&#12290;&#20808;&#20943;&#21435; 23 &#30340; 100 &#20493;&#65292;&#23601;&#26159; 2300&#65292;&#21457;&#29616;&#22815;&#20943; 3 &#27425;&#65292;&#20313;&#19979; 646&#12290;&#20110;&#26159;&#21830;&#30340;&#20540;&#23601;&#22686;&#21152; 300&#12290;&#28982;&#21518;&#29992; 646 &#20943;&#21435; 230&#65292;&#21457;&#29616;&#22815;&#20943; 2 &#27425;&#65292;&#20313;&#19979; 186&#65292;&#20110;&#26159;&#21830;&#30340;&#20540;&#22686;&#21152; 20&#12290;&#26368;&#21518;&#29992; 186 &#20943;&#21435; 23&#65292;&#22815;&#20943;8 &#27425;&#65292;&#22240;&#27492;&#26368;&#32456;&#21830;&#23601;&#26159; 328&#12290;</p>
<p>&#25152;&#20197;&#26412;&#39064;&#30340;&#26680;&#24515;&#26159;&#35201;&#20889;&#19968;&#20010;&#22823;&#25972;&#25968;&#30340;&#20943;&#27861;&#20989;&#25968;&#65292;&#28982;&#21518;&#21453;&#22797;&#35843;&#29992;&#35813;&#20989;&#25968;&#36827;&#34892;&#20943;&#27861;&#25805;&#20316;&#12290;</p>
<p>&#35745;&#31639;&#38500;&#25968;&#30340; 10 &#20493;&#12289;100 &#20493;&#30340;&#26102;&#20505;&#65292;&#19981;&#29992;&#20570;&#20056;&#27861;&#65292;&#30452;&#25509;&#22312;&#38500;&#25968;&#21518;&#38754;&#34917; 0 &#21363;&#21487;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> length( <span class="dt">const</span> <span class="dt">int</span> x[] ) {
    <span class="dt">int</span> result = <span class="dv">0</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = MAX_LEN - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; --i ) {
        <span class="kw">if</span>( x[i] &gt; <span class="dv">0</span> ) { result = i + <span class="dv">1</span>; <span class="kw">break</span>; }
    }
    <span class="kw">return</span> result;
}
<span class="dt">int</span> helper_sub( <span class="dt">int</span> x[], <span class="dt">const</span> <span class="dt">int</span> y[] ) {
    <span class="dt">int</span> lenx = length(x);
    <span class="dt">int</span> leny = length(y);
    <span class="co">// &#21028;&#26029; x &#26159;&#21542;&#27604; y &#22823;</span>
    <span class="kw">if</span>( lenx &lt; leny ) { <span class="kw">return</span> <span class="dv">-1</span>; }
    <span class="kw">if</span>( lenx == leny ) {
        <span class="dt">int</span> larger = <span class="dv">0</span>;
        <span class="kw">for</span>( <span class="dt">int</span> i = lenx - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; --i ) {
            <span class="kw">if</span>( x[i] &gt; y[i] ) {
                larger = <span class="dv">1</span>;
            } <span class="kw">else</span> <span class="kw">if</span> ( x[i] &lt; y[i] ) {
                <span class="kw">if</span>( !larger ) { <span class="kw">return</span> <span class="dv">-1</span>; }
            }
        }
    }

    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; MAX_LEN; ++i ) {    <span class="co">// &#36880;&#20301;&#30456;&#20943;</span>
        x[i] -= y[i];
        <span class="kw">while</span>( x[i] &lt; <span class="dv">0</span> ) {                 <span class="co">// &#30475;&#26159;&#21542;&#35201;&#20511;&#20301;</span>
            x[i] += BIGINT_RADIX;
            x[i<span class="dv">+1</span>] --;
        }
    }
    <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="dt">void</span> bigint_div( <span class="dt">int</span> x[], <span class="dt">const</span> <span class="dt">int</span> y[], <span class="dt">int</span> z[] ) {
    <span class="dt">int</span> xlen = length(x);
    <span class="dt">int</span> ylen = length(y);
    <span class="dt">int</span> times = xlen - ylen;

    memset( z, <span class="dv">0</span>, (MAX_LEN*<span class="dv">2</span>)*<span class="kw">sizeof</span>(<span class="dt">int</span>) );

    <span class="kw">if</span>( times &lt; <span class="dv">0</span> ) { <span class="kw">return</span>; }                     <span class="co">// z = 0</span>

    <span class="dt">int</span> *yy = (<span class="dt">int</span> *)malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>) * MAX_LEN); <span class="co">// y &#30340;&#21103;&#26412;</span>
    memcpy( yy, y, <span class="kw">sizeof</span>(<span class="dt">int</span>) * MAX_LEN );

    <span class="co">// &#23558; yy &#21491;&#31227; times &#20301;&#65292;&#20351;&#20854;&#38271;&#24230;&#21644; x &#30456;&#21516;&#65292;&#21363; yy &#20056;&#20197; 10000 &#30340; times &#27425;&#24130;</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = xlen - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; --i ) {
        <span class="kw">if</span>( i &gt;= times ) {
            yy[i] = yy[i - times];
        } <span class="kw">else</span> {
            yy[i] = <span class="dv">0</span>;
        }
    }

    <span class="co">// &#20808;&#20943;&#21435;&#33509;&#24178;&#20010; y&#215;(10000 &#30340; times &#27425;&#26041;)&#65292;&#19981;&#22815;&#20943;&#20102;&#65292;&#20877;&#20943;&#21435;&#33509;&#24178;&#20010; y&#215;(10000 &#30340;</span>
    <span class="co">// times-1 &#27425;&#26041;) &#19968;&#30452;&#20943;&#21040;&#19981;&#22815;&#20943;&#20026;&#27490;</span>
    ylen = xlen;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= times; ++i ) {
        <span class="kw">while</span>( helper_sub( x, yy) &gt;= <span class="dv">0</span> ) {
            ++z[times - i];
        }
        <span class="co">// yy &#38500;&#20197;BIGINT_RADIX&#65292;&#21363;&#24038;&#31227;&#19968;&#20301;</span>
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">1</span>; j &lt; ylen; ++j ) {
            yy[j - <span class="dv">1</span>] = yy[j];
        }
        yy[--ylen] = <span class="dv">0</span>;
    }
    free( yy );

    <span class="co">// &#19979;&#38754;&#30340;&#24490;&#29615;&#32479;&#19968;&#22788;&#29702;&#36827;&#20301;</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; MAX_LEN - <span class="dv">1</span>; ++i ) {
        <span class="kw">if</span>( z[i  ] &gt;= BIGINT_RADIX ) {          <span class="co">// &#30475;&#26159;&#21542;&#35201;&#36827;&#20301;</span>
            z[i<span class="dv">+1</span>] += z[i] / BIGINT_RADIX;      <span class="co">// &#36827;&#20301;</span>
            z[i  ] %= BIGINT_RADIX;
        }
    }
}</code></pre></div>
<pre><code>$ cat input.txt
33333333333333333333
22222222222222222222

234123412341324190834500091234087501234087
190834500091234087501234087412340871234609

234123412341324190834500091234087501234087234444444444444444444444
12134123442134190834500091234087501234087412340871234609

999999999999999
5

999999999999999999999999999999999999999999999999999999999999999999
1

12345678900
98765432100

2405337312963373359009260457742057439230496493930355595797660791082739646
2987192585318701752584429931160870372907079248971095012509790550883793197894

10000000000000000000000000000000000000000
10000000000

5409656775097850895687056798068970934546546575676768678435435345
1

2405337312963373359009260457742057439230496493930355595797660791082739646
2987192585318701752584429931160870372907079248971095012509790550883793197894

10000000000000000000000000000000000000000
10000000000

5409656775097850895687056798068970934546546575676768678435435345
1

$ cat input.txt | ./a.out
33333333333333333333 /
22222222222222222222 =
1

234123412341324190834500091234087501234087 /
190834500091234087501234087412340871234609 =
1

234123412341324190834500091234087501234087234444444444444444444444 /
12134123442134190834500091234087501234087412340871234609 =
19294629188

999999999999999 /
5 =
199999999999999

999999999999999999999999999999999999999999999999999999999999999999 /
1 =
999999999999999999999999999999999999999999999999999999999999999999

12345678900 /
98765432100 =
0

2405337312963373359009260457742057439230496493930355595797660791082739646 /
2987192585318701752584429931160870372907079248971095012509790550883793197894 =
0

10000000000000000000000000000000000000000 /
10000000000 =
1000000000000000000000000000000

5409656775097850895687056798068970934546546575676768678435435345 /
1 =
5409656775097850895687056798068970934546546575676768678435435345

2405337312963373359009260457742057439230496493930355595797660791082739646 /
2987192585318701752584429931160870372907079248971095012509790550883793197894 =
0

10000000000000000000000000000000000000000 /
10000000000 =
1000000000000000000000000000000

5409656775097850895687056798068970934546546575676768678435435345 /
1 =
5409656775097850895687056798068970934546546575676768678435435345</code></pre>
</dd>
<dt>&#22823;&#25968;&#38454;&#20056; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#22823;&#25968;&#38454;&#20056;&#30340;&#20301;&#25968; <code class="fold">@</code></dt>
<dd><p>&#27714; n! &#30340;&#20301;&#25968;&#65292; 0 &lt;= n &lt;= 10^7&#12290;</p>
<pre><code>&#36755;&#20837;

    &#31532;&#19968;&#34892;&#26159;&#19968;&#20010;&#27491;&#25972;&#25968; T&#65292;&#34920;&#31034;&#27979;&#35797;&#29992;&#20363;&#30340;&#20010;&#25968;&#12290;&#25509;&#19979;&#26469;&#30340; T &#34892;&#65292;&#27599;&#34892;&#19968;&#20010;&#27491;&#25972;&#25968; n&#12290;

    2
    10
    20

&#36755;&#20986;

    &#23545;&#27599;&#20010; n&#65292;&#27599;&#34892;&#36755;&#20986; n! &#30340;&#20301;&#25968;

    7
    19</code></pre>
<p>&#26368;&#31616;&#21333;&#30340;&#21150;&#27861;&#65292;&#26159;&#32769;&#32769;&#23454;&#23454;&#35745;&#31639;&#20986; n!&#65292;&#28982;&#21518;&#23601;&#30693;&#36947;&#23427;&#30340;&#20301;&#25968;&#20102;&#12290;&#20294;&#36825;&#20010;&#26041;&#27861;&#24456;&#24930;&#65292;&#20250;&#36229;&#26102; (TLE)&#12290;</p>
<p>&#32452;&#21512;&#25968;&#23398;&#37324;&#26377;&#20010; Stirling &#20844;&#24335; (<a href="http://en.wikipedia.org/wiki/Stirling&#39;s_approximation">Stirling&#8217;s formula</a>)</p>
<p>&#21487;&#20197;&#29992;&#36825;&#20010;&#20844;&#24335;&#26469;&#35745;&#31639; n! &#30340;&#20301;&#25968;&#65292;&#23427;&#31561;&#20110;</p>
<pre><code>                              n!
     lim        -----------------------------       =             1
                   sqrt(2*pi*n) * (n/e)^n
    n-&gt;inf


    n! &#30340;&#20301;&#25968;          =    n * log(n/e) + 1/2 * log(2*pi*n)   +  1

        100            -&gt;   log(100) +1 = 2+1 = 3
        1000           -&gt;   log(1000)+1 = 3+1 = 4</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;</span>

<span class="dt">int</span> factorial_digits( <span class="dt">unsigned</span> <span class="dt">int</span> n ) {
    <span class="dt">const</span> <span class="dt">static</span> <span class="dt">double</span> PI = <span class="fl">3.14159265358979323846</span>;
    <span class="dt">const</span> <span class="dt">static</span> <span class="dt">double</span> E = <span class="fl">2.7182818284590452354</span>;
    <span class="kw">if</span>( n == <span class="dv">0</span> ) { <span class="kw">return</span> <span class="dv">1</span>; }
    <span class="kw">return</span> <span class="dv">1</span> + (<span class="dt">int</span>)( n*log10(n/E) + <span class="fl">0.5</span>*log10(<span class="dv">2</span>*PI*n) );
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    <span class="kw">while</span>( <span class="dv">1</span> == scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T) ) {
        <span class="dt">int</span> n;
        <span class="kw">while</span>( T-- ) {
            scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n );
            printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, factorial_digits(n) );
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
<dt>&#22823;&#25968;&#38454;&#20056; <code class="fold">@</code></dt>
<dd><pre><code>&#36755;&#20837;

    &#27599;&#34892;&#19968;&#20010;&#25972;&#25968; n

    1
    2
    3
    6
    18
    108

&#36755;&#20986;

    &#23545;&#27599;&#20010; n&#65292;&#27599;&#34892;&#36755;&#20986; n!

    1
    2
    6
    720
    6402373705728000
    1324641819451828974499891837121832599810209360673358065686551152497461815091591578895743130235002378688844343005686404521144382704205360039762937774080000000000000000000000000</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="ot">#define BIGINT_RADIX 10000</span>
<span class="ot">#define RADIX_LEN 4</span>
<span class="ot">#define MAX_LEN (35660/RADIX_LEN+1)         </span><span class="co">// 10000! &#26377; 35660 &#20301;</span>

<span class="dt">int</span>     x[MAX_LEN + <span class="dv">1</span>];

<span class="dt">void</span> bigint_print( <span class="dt">const</span> <span class="dt">int</span> x[], <span class="dt">const</span> <span class="dt">int</span> n ) {
    <span class="dt">bool</span> start_output = <span class="kw">false</span>;              <span class="co">// &#29992;&#20110;&#36339;&#36807;&#21069;&#23548; 0</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = n - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; --i ) {
        <span class="kw">if</span>( start_output ) {                <span class="co">// &#22914;&#26524;&#22810;&#20313;&#30340; 0 &#24050;&#32463;&#37117;&#36339;&#36807;&#65292;&#21017;&#36755;&#20986;</span>
            printf( <span class="st">&quot;</span><span class="ch">%04d</span><span class="st">&quot;</span>, x[i] );
            <span class="kw">continue</span>;
        }
        <span class="kw">if</span>( x[i] &gt; <span class="dv">0</span> ) {
            printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, x[i] );           <span class="co">// &#26412;&#39064;&#36755;&#20986;&#27604;&#36739;&#22353;&#29241;&#65292;&#26368;&#39640;&#20301;&#25968;&#23383;&#26377;&#21069;&#23548; 0</span>
            start_output = <span class="kw">true</span>;            <span class="co">// &#30896;&#21040;&#31532;&#19968;&#20010;&#38750; 0 &#30340;&#20540;&#65292;&#23601;&#35828;&#26126;&#22810;&#20313;&#30340; 0 &#24050;&#32463;&#37117;&#36339;&#36807;</span>
        }
    }
    <span class="kw">if</span> ( !start_output ) { printf(<span class="st">&quot;0&quot;</span>); }   <span class="co">// &#24403; x &#20840;&#20026; 0 &#26102;</span>
}

<span class="co">// &#22823;&#25972;&#25968;&#20056;&#27861;, x = x*y.</span>
<span class="dt">void</span> bigint_mul( <span class="dt">int</span> x[], <span class="dt">const</span> <span class="dt">int</span> y ) {
    <span class="dt">int</span> c = <span class="dv">0</span>;                              <span class="co">// carry</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; MAX_LEN; ++i ) {    <span class="co">// &#29992; y&#65292;&#21435;&#20056;&#20197; x &#30340;&#21508;&#20301;</span>
        <span class="dt">int</span> tmp = x[i] * y + c;
        x[i] = tmp % BIGINT_RADIX;
        c    = tmp / BIGINT_RADIX;
    }
}

<span class="dt">void</span> bigint_factorial( <span class="dt">int</span> n, <span class="dt">int</span> x[] ) {
    memset( x, <span class="dv">0</span>, <span class="kw">sizeof</span>(<span class="dt">int</span>)*(MAX_LEN<span class="dv">+1</span>) );
    x[<span class="dv">0</span>] = <span class="dv">1</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= n; ++i ) {
        bigint_mul( x, i );
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    <span class="kw">while</span> ( <span class="dv">1</span> == scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) ) {
        bigint_factorial( n, x );
        bigint_print( x, MAX_LEN + <span class="dv">1</span> ); printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>5.4 Selected Problems <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>Unix ls <code class="fold">@</code></dt>
<dd><p>&#20687; <code>ls</code> &#19968;&#26679;&#26684;&#24335;&#21270;&#25171;&#21360;&#65288;&#20027;&#35201;&#22788;&#29702; column &#23545;&#40784;&#38382;&#39064;&#65289;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxcol    = <span class="dv">60</span>;
<span class="dt">const</span> <span class="dt">int</span> maxn      = <span class="dv">100+5</span>;
string filenames[maxn];

<span class="dt">void</span> print( <span class="dt">const</span> string &amp;s, <span class="dt">int</span> len, <span class="dt">char</span> extra ) {
    cout&lt;&lt; s;
    <span class="kw">if</span>( len &lt; <span class="dv">0</span> ) { <span class="kw">return</span>; }
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len-s.length(); ++i ) {
        cout &lt;&lt; extra;
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    <span class="kw">while</span>( cin &gt;&gt; n ) {
        <span class="dt">int</span> M = <span class="dv">0</span>;
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
            cin &gt;&gt; filenames[i];
            M = max( M, (<span class="dt">int</span>)filenames[i].length() );
        }
        <span class="dt">int</span> cols = (maxcol-M)/(M<span class="dv">+2</span>) + <span class="dv">1</span>, rows = (n<span class="dv">-1</span>)/cols + <span class="dv">1</span>;
        print( <span class="st">&quot;&quot;</span>, <span class="dv">60</span>, <span class="st">&#39;-&#39;</span> );
        cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
        sort( filenames, filenames+n );
        <span class="kw">for</span>( <span class="dt">int</span> r = <span class="dv">0</span>; r &lt; rows; ++r ) {
            <span class="kw">for</span>( <span class="dt">int</span> c = <span class="dv">0</span>; c &lt; cols; ++c ) {
                <span class="dt">int</span> idx = c * rows + r;
                <span class="kw">if</span>( idx &lt; n ) {
                    print( filenames[idx],
                           c == cols<span class="dv">-1</span>? M : M<span class="dv">+2</span>,
                           <span class="st">&#39; &#39;</span> );
                }
            }
            cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>run it:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">(echo</span> <span class="st">&quot;</span><span class="kw">`ls|wc</span> -l<span class="kw">`</span><span class="st"> </span><span class="kw">`ls`</span><span class="st">&quot;</span><span class="kw">)</span> <span class="kw">|</span> <span class="kw">path/to/our/own/ls</span>
<span class="kw">------------------------------------------------------------</span>
<span class="kw">LICENSE.txt</span>  envs         lib          ssl
<span class="kw">bin</span>          etc          pkgs         var
<span class="kw">conda-meta</span>   include      share</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>database <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1592 Database</span>
<span class="co">// Rujia Liu</span>
<span class="co">// &#26412;&#31243;&#24207;&#21482;&#26159;&#20026;&#20102;&#28436;&#31034; STL &#21508;&#31181;&#29992;&#27861;&#65292;&#25928;&#29575;&#36739;&#20302;&#12290;&#23454;&#36341;&#20013;&#19968;&#33324;&#29992; C &#23383;&#31526;&#20018;&#21644;&#21704;&#24076;&#34920;&#26469;&#23454;&#29616;&#12290;</span>

<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;string&gt;</span>
<span class="ot">#include&lt;map&gt;</span>
<span class="ot">#include&lt;sstream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; PII;

<span class="dt">const</span> <span class="dt">int</span> maxr = <span class="dv">10000</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> maxc = <span class="dv">10</span> + <span class="dv">5</span>;

<span class="dt">int</span> m, n, db[maxr][maxc], cnt;

map&lt;string, <span class="dt">int</span>&gt; id;
<span class="dt">int</span> ID(<span class="dt">const</span> string&amp; s) {
    <span class="kw">if</span>(!id.count(s)) {
        id[s] = ++cnt;
    }
    <span class="kw">return</span> id[s];
}

<span class="dt">void</span> find() {
    <span class="kw">for</span>(<span class="dt">int</span> c1 = <span class="dv">0</span>; c1 &lt; m; c1++)
        <span class="kw">for</span>(<span class="dt">int</span> c2 = c1<span class="dv">+1</span>; c2 &lt; m; c2++) {
            map&lt;PII, <span class="dt">int</span>&gt; d;
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
                PII p = make_pair(db[i][c1], db[i][c2]);
                <span class="kw">if</span>(d.count(p)) {
                    printf(<span class="st">&quot;NO</span><span class="ch">\n</span><span class="st">&quot;</span>);
                    printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, d[p]<span class="dv">+1</span>, i<span class="dv">+1</span>);
                    printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, c1<span class="dv">+1</span>, c2<span class="dv">+1</span>);
                    <span class="kw">return</span>;
                }
                d[p] = i;
            }
        }
    printf(<span class="st">&quot;YES</span><span class="ch">\n</span><span class="st">&quot;</span>);
}


<span class="dt">int</span> main() {
    string s;
    <span class="kw">while</span>(getline(cin, s)) {
        stringstream ss(s);
        <span class="kw">if</span>(!(ss &gt;&gt; n &gt;&gt; m)) <span class="kw">break</span>;
        cnt = <span class="dv">0</span>;
        id.clear();
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            getline(cin, s);
            <span class="dt">int</span> lastpos = <span class="dv">-1</span>;
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; m; j++) {
                <span class="dt">int</span> p = s.find(<span class="st">&#39;,&#39;</span>, lastpos<span class="dv">+1</span>);
                <span class="kw">if</span>(p == string::npos) p = s.length();
                db[i][j] = ID(s.substr(lastpos<span class="dv">+1</span>, p - lastpos - <span class="dv">1</span>));
                lastpos = p;
            }
        }
        find();
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>PGA Tour Price Money <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa207 PGA Tour Prize Money</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstdlib&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="ot">#include&lt;cassert&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#define REP(i,n) for(int i = 0; i &lt; (n); i++)</span>

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">144</span>;
<span class="dt">const</span> <span class="dt">int</span> n_cut = <span class="dv">70</span>;

<span class="kw">struct</span> Player {
    <span class="dt">char</span> name;
    <span class="dt">int</span> amateur;
    <span class="dt">int</span> sc;
    <span class="dt">int</span> sc36, sc72, dq;
    <span class="dt">int</span> rnds;
} player[maxn];

<span class="dt">int</span> n;
<span class="dt">double</span> purse, p[n_cut];

<span class="dt">bool</span> cmp1(<span class="dt">const</span> Player&amp; p1, <span class="dt">const</span> Player&amp; p2) {
    <span class="kw">if</span>(p1.sc36 &lt; <span class="dv">0</span> &amp;&amp; p2.sc36 &lt; <span class="dv">0</span>) <span class="kw">return</span> <span class="kw">false</span>; <span class="co">// equal</span>
    <span class="kw">if</span>(p1.sc36 &lt; <span class="dv">0</span>) <span class="kw">return</span> <span class="kw">false</span>; <span class="co">// p2 smaller</span>
    <span class="kw">if</span>(p2.sc36 &lt; <span class="dv">0</span>) <span class="kw">return</span> <span class="kw">true</span>; <span class="co">// p1 smaller</span>
    <span class="kw">return</span> p1.sc36 &lt; p2.sc36;
}

<span class="dt">bool</span> cmp2(<span class="dt">const</span> Player&amp; p1, <span class="dt">const</span> Player&amp; p2) {
    <span class="kw">if</span>(p1.dq &amp;&amp; p2.dq) {
        <span class="kw">if</span>(p1.rnds != p2.rnds) <span class="kw">return</span> p2.rnds &lt; p1.rnds;
        <span class="kw">if</span>(p1.sc72 != p2.sc72) <span class="kw">return</span> p1.sc72 &lt; p2.sc72;
        <span class="kw">return</span> strcmp(p1.name, p2.name) &lt; <span class="dv">0</span>;
    }
    <span class="kw">if</span>(p1.dq) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">if</span>(p2.dq) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">if</span>(p1.sc72 != p2.sc72) <span class="kw">return</span> p1.sc72 &lt; p2.sc72;
    <span class="kw">return</span> strcmp(p1.name, p2.name) &lt; <span class="dv">0</span>;
}

<span class="dt">void</span> print_result() {
    printf(<span class="st">&quot;Player Name          Place     RD1  RD2&quot;</span>);
    printf(<span class="st">&quot;  RD3  RD4  TOTAL     Money Won</span><span class="ch">\n</span><span class="st">&quot;</span>);
    printf(<span class="st">&quot;---------------------------------------&quot;</span>);
    printf(<span class="st">&quot;--------------------------------</span><span class="ch">\n</span><span class="st">&quot;</span>);

    <span class="dt">int</span> i = <span class="dv">0</span>, pos = <span class="dv">0</span>;
    <span class="kw">while</span>(i &lt; n) {
        <span class="kw">if</span>(player[i].dq) {
            printf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">           &quot;</span>,player[i].name);
            REP(j,player[i].rnds) printf(<span class="st">&quot;</span><span class="ch">%-5d</span><span class="st">&quot;</span>, player[i].sc[j]);
            REP(j,<span class="dv">4</span>-player[i].rnds) printf(<span class="st">&quot;     &quot;</span>);
            printf(<span class="st">&quot;DQ</span><span class="ch">\n</span><span class="st">&quot;</span>);
            i++;
            <span class="kw">continue</span>;
        }

        <span class="dt">int</span> j = i;
        <span class="dt">int</span> m = <span class="dv">0</span>; <span class="co">// number of tied players</span>
        <span class="dt">bool</span> have_money = <span class="kw">false</span>;
        <span class="dt">double</span> tot = <span class="fl">0.0</span>; <span class="co">// total pooled money</span>
        <span class="kw">while</span>(j &lt; n &amp;&amp; player[i].sc72 == player[j].sc72) {
            <span class="kw">if</span>(!player[j].amateur) {
                m++;
                <span class="kw">if</span>(pos &lt; n_cut) {
                    have_money = <span class="kw">true</span>; <span class="co">// yeah! they still have money</span>
                    tot += p[pos++];
                }
            }
            j++;
        }

        <span class="co">// print player [i,j) together because they have the same rank</span>
        <span class="dt">int</span> rank = i + <span class="dv">1</span>; <span class="co">// rank of all these m players</span>
        <span class="dt">double</span> amount = purse * tot / m; <span class="co">// if m=0, amount will be nan but we don&#39;t use it in that case :)</span>
        <span class="kw">while</span>(i &lt; j) {
            printf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st"> &quot;</span>, player[i].name);
            <span class="dt">char</span> t;
            sprintf(t, <span class="st">&quot;</span><span class="ch">%d%c</span><span class="st">&quot;</span>, rank, m &gt; <span class="dv">1</span> &amp;&amp; have_money &amp;&amp; !player[i].amateur ? <span class="st">&#39;T&#39;</span> : <span class="st">&#39; &#39;</span>);
            printf(<span class="st">&quot;</span><span class="ch">%-10s</span><span class="st">&quot;</span>, t);
            REP(e,<span class="dv">4</span>) printf(<span class="st">&quot;</span><span class="ch">%-5d</span><span class="st">&quot;</span>, player[i].sc[e]);

            <span class="co">// with prize</span>
            <span class="kw">if</span>(!player[i].amateur &amp;&amp; have_money) {
                printf(<span class="st">&quot;</span><span class="ch">%-10d</span><span class="st">&quot;</span>, player[i].sc72);
                printf(<span class="st">&quot;$</span><span class="ch">%9.2lf\n</span><span class="st">&quot;</span>, amount / <span class="fl">100.0</span>);
            } <span class="kw">else</span>
                printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, player[i].sc72);
            i++;
        }
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    <span class="dt">char</span> s;

    gets(s);
    sscanf(s,<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;T);
    <span class="kw">while</span>(T--) {
        gets(s); <span class="co">// empty line</span>

        <span class="co">// prize</span>
        gets(s);
        sscanf(s,<span class="st">&quot;</span><span class="ch">%lf</span><span class="st">&quot;</span>, &amp;purse);
        REP(i,n_cut) {
            gets(s);
            sscanf(s, <span class="st">&quot;</span><span class="ch">%lf</span><span class="st">&quot;</span>, &amp;p[i]);
        }

        <span class="co">// players</span>
        gets(s);
        sscanf(s, <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        assert(n &lt;= <span class="dv">144</span>);
        REP(k,n) {
            <span class="co">// read a 32-character line</span>
            gets(s);

            <span class="co">// player name</span>
            strncpy(player[k].name, s, <span class="dv">20</span>);
            player[k].name = <span class="dv">0</span>;
            player[k].amateur = <span class="dv">0</span>;
            <span class="kw">if</span>(strchr(player[k].name, <span class="st">&#39;*&#39;</span>)) {
                player[k].amateur = <span class="dv">1</span>;
            }

            <span class="co">// scores</span>
            player[k].sc36 = player[k].sc72 = player[k].dq=<span class="dv">0</span>;
            memset(player[k].sc, <span class="dv">-1</span>, <span class="kw">sizeof</span>(player[k].sc));
            REP(i,<span class="dv">4</span>) {
                <span class="co">// raw score</span>
                <span class="dt">char</span> t;
                REP(j,<span class="dv">3</span>) t[j] = s[<span class="dv">20</span> + i*<span class="dv">3</span> + j]; t = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>;

                <span class="co">// parse</span>
                <span class="kw">if</span>(!sscanf(t,<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;player[k].sc[i])) {
                    <span class="co">// DQ!</span>
                    player[k].rnds = i;
                    player[k].dq = <span class="dv">-1</span>;
                    <span class="kw">if</span>(i &lt; <span class="dv">2</span>) player[k].sc36 = <span class="dv">-1</span>;
                    <span class="kw">break</span>; <span class="co">// skip other rounds (filled with -1, initially)</span>
                } <span class="kw">else</span> {
                    player[k].sc72 += player[k].sc[i];
                    <span class="kw">if</span>(i &lt; <span class="dv">2</span>)
                        player[k].sc36 += player[k].sc[i];
                }
            }
        }

        <span class="co">// round 1</span>
        sort(player, player+n, cmp1);
        assert(player[n_cut<span class="dv">-1</span>].sc36 &gt;= <span class="dv">0</span>);
        <span class="kw">for</span>(<span class="dt">int</span> i = n_cut<span class="dv">-1</span>; i &lt; n; i++)
            <span class="kw">if</span>(i == n<span class="dv">-1</span> || player[i].sc36 != player[i<span class="dv">+1</span>].sc36) { n = i<span class="dv">+1</span>; <span class="kw">break</span>; }

        <span class="co">// round 2</span>
        sort(player, player+n, cmp2);

        <span class="co">// print result</span>
        print_result();

        <span class="kw">if</span>(T) printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>The Letter Crarrier&#8217;s Rounds, ACM/ICPC World Finals <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa814 The Letter Carrier&#39;s Rounds</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;string&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;set&gt;</span>
<span class="ot">#include&lt;map&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">void</span> parse_address(<span class="dt">const</span> string&amp; s, string&amp; user, string&amp; mta) {
    <span class="dt">int</span> k = s.find(<span class="st">&#39;@&#39;</span>);
    user = s.substr(<span class="dv">0</span>, k);
    mta = s.substr(k<span class="dv">+1</span>);
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> k;
    string s, t, user1, mta1, user2, mta2;
    set&lt;string&gt; addr;

    <span class="co">// &#36755;&#20837;&#25152;&#26377; MTA&#65292;&#36716;&#21270;&#20026;&#22320;&#22336;&#21015;&#34920;</span>
    <span class="kw">while</span>(cin &gt;&gt; s &amp;&amp; s != <span class="st">&quot;*&quot;</span>) {
        cin &gt;&gt; s &gt;&gt; k;
        <span class="kw">while</span>(k--) { cin &gt;&gt; t; addr.insert(t + <span class="st">&quot;@&quot;</span> + s); }
    }

    <span class="kw">while</span>(cin &gt;&gt; s &amp;&amp; s != <span class="st">&quot;*&quot;</span>) {
        parse_address(s, user1, mta1); <span class="co">// &#22788;&#29702;&#21457;&#20214;&#20154;&#22320;&#22336;</span>

        vector&lt;string&gt; mta; <span class="co">// &#25152;&#26377;&#38656;&#35201;&#36830;&#25509;&#30340;mta&#65292;&#25353;&#29031;&#36755;&#20837;&#39034;&#24207;</span>
        map&lt;string, vector&lt;string&gt; &gt; dest; <span class="co">// &#27599;&#20010;mta&#38656;&#35201;&#21457;&#36865;&#30340;&#29992;&#25143;</span>
        set&lt;string&gt; vis;
        <span class="kw">while</span>(cin &gt;&gt; t &amp;&amp; t != <span class="st">&quot;*&quot;</span>) {
            parse_address(t, user2, mta2); <span class="co">// &#22788;&#29702;&#25910;&#20214;&#20154;&#22320;&#22336;</span>
            <span class="kw">if</span>(vis.count(t)) <span class="kw">continue</span>;     <span class="co">// &#37325;&#22797;&#30340;&#25910;&#20214;&#20154;</span>
            vis.insert(t);
            <span class="kw">if</span>(!dest.count(mta2)) { mta.push_back(mta2); dest[mta2] = vector&lt;string&gt;(); }
            dest[mta2].push_back(t);
        }
        getline(cin, t); <span class="co">// &#25226;&quot;*&quot;&#36825;&#19968;&#34892;&#30340;&#22238;&#36710;&#21507;&#25481;</span>

        <span class="co">// &#36755;&#20837;&#37038;&#20214;&#27491;&#25991;</span>
        string data;
        <span class="kw">while</span>(getline(cin, t) &amp;&amp; t != <span class="st">&#39;*&#39;</span>) data += <span class="st">&quot;     &quot;</span> + t + <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;

        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; mta.size(); i++) {
            string mta2 = mta[i];
            vector&lt;string&gt; users = dest[mta2];
            cout &lt;&lt; <span class="st">&quot;Connection between &quot;</span> &lt;&lt; mta1 &lt;&lt; <span class="st">&quot; and &quot;</span> &lt;&lt; mta2 &lt;&lt;endl;
            cout &lt;&lt; <span class="st">&quot;     HELO &quot;</span> &lt;&lt; mta1 &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
            cout &lt;&lt; <span class="st">&quot;     250</span><span class="ch">\n</span><span class="st">&quot;</span>;
            cout &lt;&lt; <span class="st">&quot;     MAIL FROM:&lt;&quot;</span> &lt;&lt; s &lt;&lt; <span class="st">&quot;&gt;</span><span class="ch">\n</span><span class="st">&quot;</span>;
            cout &lt;&lt; <span class="st">&quot;     250</span><span class="ch">\n</span><span class="st">&quot;</span>;
            <span class="dt">bool</span> ok = <span class="kw">false</span>;
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; users.size(); i++) {
                cout &lt;&lt; <span class="st">&quot;     RCPT TO:&lt;&quot;</span> &lt;&lt; users[i] &lt;&lt; <span class="st">&quot;&gt;</span><span class="ch">\n</span><span class="st">&quot;</span>;
                <span class="kw">if</span>(addr.count(users[i])) { ok = <span class="kw">true</span>; cout &lt;&lt; <span class="st">&quot;     250</span><span class="ch">\n</span><span class="st">&quot;</span>; }
                <span class="kw">else</span> cout &lt;&lt; <span class="st">&quot;     550</span><span class="ch">\n</span><span class="st">&quot;</span>;
            }
            <span class="kw">if</span>(ok) {
                cout &lt;&lt; <span class="st">&quot;     DATA</span><span class="ch">\n</span><span class="st">&quot;</span>;
                cout &lt;&lt; <span class="st">&quot;     354</span><span class="ch">\n</span><span class="st">&quot;</span>;
                cout &lt;&lt; data;
                cout &lt;&lt; <span class="st">&quot;     .</span><span class="ch">\n</span><span class="st">&quot;</span>;
                cout &lt;&lt; <span class="st">&quot;     250</span><span class="ch">\n</span><span class="st">&quot;</span>;
            }
            cout &lt;&lt; <span class="st">&quot;     QUIT</span><span class="ch">\n</span><span class="st">&quot;</span>;
            cout &lt;&lt; <span class="st">&quot;     221</span><span class="ch">\n</span><span class="st">&quot;</span>;
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Urban Elevations, 1992 World Finals <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa221 Urban Elevations</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span> + <span class="dv">5</span>;

<span class="kw">struct</span> Building {
    <span class="dt">int</span> id;
    <span class="dt">double</span> x, y, w, d, h;
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Building&amp; rhs) <span class="dt">const</span> {
        <span class="kw">return</span> x &lt; rhs.x || (x == rhs.x &amp;&amp; y &lt; rhs.y);
    }
} b[maxn];

<span class="dt">int</span> n;
<span class="dt">double</span> x[maxn*<span class="dv">2</span>];

<span class="dt">bool</span> cover(<span class="dt">int</span> i, <span class="dt">double</span> mx) {
    <span class="kw">return</span> b[i].x &lt;= mx &amp;&amp; b[i].x+b[i].w &gt;= mx;
}

<span class="co">// &#21028;&#26029;&#24314;&#31569;&#29289; i &#22312; x=mx &#22788;&#21542;&#21487;&#35265;</span>
<span class="dt">bool</span> visible(<span class="dt">int</span> i, <span class="dt">double</span> mx) {
    <span class="kw">if</span>(!cover(i, mx)) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; k++)
        <span class="kw">if</span>(b[k].y &lt; b[i].y &amp;&amp; b[k].h &gt;= b[i].h &amp;&amp; cover(k, mx)) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> kase = <span class="dv">0</span>;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span> &amp;&amp; n) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%lf%lf%lf%lf%lf</span><span class="st">&quot;</span>, &amp;b[i].x, &amp;b[i].y, &amp;b[i].w, &amp;b[i].d, &amp;b[i].h);
            x[i*<span class="dv">2</span>] = b[i].x; x[i*<span class="dv">2+1</span>] = b[i].x + b[i].w;
            b[i].id = i<span class="dv">+1</span>;
        }
        sort(b, b+n);
        sort(x, x+n*<span class="dv">2</span>);
        <span class="dt">int</span> m = unique(x, x+n*<span class="dv">2</span>) - x; <span class="co">// x &#22352;&#26631;&#25490;&#24207;&#21518;&#21435;&#37325;&#65292;&#24471;&#21040; m &#20010;&#22352;&#26631;</span>

        <span class="kw">if</span>(kase++) printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
        printf(<span class="st">&quot;For map #</span><span class="ch">%d</span><span class="st">, the visible buildings are numbered as follows:</span><span class="ch">\n%d</span><span class="st">&quot;</span>, kase, b.id);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; n; i++) {
            <span class="dt">bool</span> vis = <span class="kw">false</span>;
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; m<span class="dv">-1</span>; j++)
                <span class="kw">if</span>(visible(i, (x[j] + x[j<span class="dv">+1</span>]) / <span class="dv">2</span>)) { vis = <span class="kw">true</span>; <span class="kw">break</span>; }
            <span class="kw">if</span>(vis) printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>, b[i].id);
        }
        printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li>&#31532;&#20845;&#31456;&#65292;etc&#12290;&#25918;&#21040; bonus &#37027;&#36793;&#20102;&#12290;</li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/08/06 &#19978;&#21320; 9:30:00 2. &#20108;&#20998;&#25628;&#32034; Binary Search <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>binary search <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#22914;&#26524;&#25214;&#21040; x&#65292;&#21017;&#36820;&#22238;&#20854;&#19979;&#26631;&#12290; &#22914;&#26524;&#25214;&#19981;&#21040; x &#19988; x &#23567;&#20110; array</span>
<span class="co">// &#20013;&#30340;&#19968;&#20010;&#25110;&#22810;&#20010;&#20803;&#32032;&#65292;&#21017;&#20026;&#19968;&#20010;&#36127;&#25968;&#65292;&#35813;&#36127;&#25968;&#26159;&#22823;&#20110; x &#30340;&#31532;&#19968;</span>
<span class="co">// &#20010;&#20803;&#32032;&#30340;&#32034;&#24341;&#30340;&#25353;&#20301;&#27714;&#34917;&#12290; &#22914;&#26524;&#25214;&#19981;&#21040; x &#19988; x &#22823;&#20110; array &#20013;</span>
<span class="co">// &#30340;&#20219;&#20309;&#20803;&#32032;&#65292;&#21017;&#20026;&#19968;&#20010;&#36127;&#25968;&#65292;&#35813;&#36127;&#25968;&#26159;&#65288;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;&#30340;&#32034;&#24341;&#21152; 1&#65289;&#30340;&#25353;&#20301;&#27714;&#34917;&#12290;</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> binary_search( <span class="dt">const</span> <span class="dt">int</span> A[], <span class="dt">const</span> <span class="dt">int</span> n, <span class="dt">const</span> <span class="dt">int</span> x ) {
    <span class="dt">int</span> left = <span class="dv">0</span>, right = n<span class="dv">-1</span>, mid;
    <span class="kw">while</span>( left &lt;= right ) {
        mid = left + (right - left) / <span class="dv">2</span>;
        <span class="kw">if</span>( x &gt; A[mid] ) {
            left = mid + <span class="dv">1</span>;
        } <span class="kw">else</span> <span class="kw">if</span>(x &lt; A[mid]) {
            right = mid - <span class="dv">1</span>;
        } <span class="kw">else</span> {
            <span class="kw">return</span> mid;
        }
    }
    <span class="kw">return</span> -(left<span class="dv">+1</span>);           <span class="co">// instead of returning -1</span>
}
<span class="co">// -(left+1) == ~left == ~(~(~left))&#65292;&#21487;&#20197;&#30475;&#21040;&#36825;&#20010;&#8220;&#32534;&#30721;&#8221; effective&#65292;&#32780;&#19988;&#30452;&#35266;&#12290;</span>

<span class="dt">int</span> main() {
    <span class="dt">int</span> A[] = { <span class="dv">1</span>,  <span class="dv">5</span>,  <span class="dv">6</span>,  <span class="dv">9</span>,  <span class="dv">12</span>,    <span class="dv">18</span>,    <span class="dv">25</span>,    <span class="dv">73</span>  };
    <span class="dt">int</span> x;
    <span class="kw">while</span>( scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;x) == <span class="dv">1</span> ) {
        <span class="dt">int</span> pos = binary_search( A, <span class="kw">sizeof</span>(A)/<span class="kw">sizeof</span>(A[<span class="dv">0</span>]), x );
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="kw">sizeof</span>(A)/<span class="kw">sizeof</span>(A[<span class="dv">0</span>]); ++i ) {
            printf( <span class="st">&quot;[</span><span class="ch">%3d</span><span class="st">]&quot;</span>, A[i] );
        }
        printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
        <span class="kw">if</span>( pos &gt;= <span class="dv">0</span> ) {
            printf( <span class="st">&quot;</span><span class="ch">%*s</span><span class="st">  ^  hit, pos=</span><span class="ch">%d\n</span><span class="st">&quot;</span>, pos*<span class="dv">5</span>, <span class="st">&quot;&quot;</span>, pos );
        } <span class="kw">else</span> {
            printf( <span class="st">&quot;</span><span class="ch">%*s</span><span class="st">  |  insert before, pos=</span><span class="ch">%d\n</span><span class="st">&quot;</span>, (-pos<span class="dv">-1</span>)*<span class="dv">5</span>, <span class="st">&quot;&quot;</span>, pos );
        }
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">./a.out</span>

        <span class="kw">7</span>
                  <span class="kw">right</span> left
       <span class="kw"> [</span>  1][  5][  6][  9][ 12][ 18][ 25][ 73]
                         |  insert before, pos=-4

        9
                     left/right
        [  1][  5][  6][  9][ 12][ 18][ 25][ 73]
                         ^  hit, pos=3

        1
        left/right
        [  1][  5][  6][  9][ 12][ 18][ 25][ 73]
          ^  hit, pos=0

        73
                                         left/right
        [  1][  5][  6][  9][ 12][ 18][ 25][ 73]
                                             ^  hit, pos=7

        98
                                           right  left
        [  1][  5][  6][  9][ 12][ 18][ 25][ 73]
                                                  |  insert before, pos=-9

        0

  right  left
        [  1][  5][  6][  9][ 12][ 18][ 25][ 73]
          |  insert before, pos=-1</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#23398;&#20064; Binary Search &#30340;&#36890;&#29992;&#27169;&#26495;&#65292;&#19981;&#20877;&#27515;&#24490;&#29615; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> binary_search( <span class="dt">int</span> array[], <span class="dt">int</span> length, <span class="dt">int</span> value )
{
    <span class="co">// &#36825;&#20004;&#20010;&#21028;&#26029;&#19981;&#24517;&#35201;</span>
    <span class="co">// if( length &lt;= 0 ) { return -1; }</span>
    <span class="co">// if( length == 1 ) { return array == value ? 0: -1; }</span>

    <span class="dt">int</span> low = <span class="dv">0</span>;
    <span class="dt">int</span> high = length<span class="dv">-1</span>;
    <span class="dt">int</span> mid;
    <span class="kw">while</span>( low &lt;= high ) {
        mid = (low+high)/<span class="dv">2</span>;
        <span class="kw">if</span>( array[mid] == value ) {
            <span class="kw">return</span> mid;
        } <span class="kw">else</span> <span class="kw">if</span>( array[mid] &gt; value ) {
            high = mid<span class="dv">-1</span>;
        } <span class="kw">else</span> {
            low  = mid<span class="dv">+1</span>;
        }
    }
    <span class="kw">return</span> <span class="dv">-1</span>;
}</code></pre></div>
<p>&#20160;&#20040;&#24773;&#20917;&#19979;&#65292;mid-1 &#21644; mid+1 &#19981;&#36234;&#30028;&#65311;length &gt; 1&#12290;&#20294;&#36824;&#22909;&#26377; left &lt;= right &#30340;&#21028;&#26029;&#65292;&#25152;&#20197;&#36234;&#30028;&#21518;&#65292;while &#36827;&#19981;&#21435;&#12290;</p>
<dl>
<dt>&#24863;&#21463;&#19968;&#19979; mid &#30340;&#20301;&#32622; <code class="fold">@</code></dt>
<dd><pre><code>&#20013;&#38388;&#26377;&#22855;&#25968;&#20010;&#25968;&#23383;
[   0,  1,  2,  3,  4,  ... ]
    ^       *       ^

[   0,  1,  2,  3,  4,  5,  ... ]
        ^       *       ^

&#20013;&#38388;&#26377;&#20598;&#25968;&#20010;&#25968;&#23383;
[   0,  1,  2,  3,  4,  5,  ... ]
    ^       *           ^

[   0,  1,  2,  3,  4,  5,  6,  ... ]
        ^       *           ^

&#20013;&#38388;&#21861;&#37117;&#27809;&#26377;
[   0,  1,  ... ]
    ^   ^
    *

[   0,  ... ]
    ^
    ^
    *</code></pre>
<p>&#24635;&#20043;&#22240;&#20026; (left+right)/2 &#26159;&#21521;&#19979; round&#65288;floor&#65289;&#12290;</p>
<p>&#38656;&#35201;&#27880;&#24847;&#30340;&#26159; -3/2 = -1.5 = -1&#65292;-1/2 = -0.5 = 0&#65307;&#21487;&#35265;&#26159;&#21521; 0 round &#30340;&#12290;</p>
<pre><code>&#22914;&#26524;&#26377;&#36127;&#30340; index
[      -1,  0,  ... ]
        ^   ^
            *

[  -2, -1,  0,  ... ]
    ^   ^
        *

+-----------------------------------------------------------------------------------------------+
|   -2, 1 -&gt;    (left+right)/2          = -1/2 = -0.5               = 0,    round to zero       |
|               left + (right-left)/2   = -2 + (1-(-2))/2 = -2+1.5  = -1,   more to the left    |
+-----------------------------------------------------------------------------------------------+</code></pre>
<p>&#20294;&#20854;&#23454;&#8230;&#8230;&#24590;&#20040; round &#26159;&#26080;&#25152;&#35859;&#30340;&#12290;&#25105;&#36825;&#37324;&#21482;&#26159;&#35753;&#33258;&#24049;&#24863;&#21463;&#19968;&#19979; mid &#30340;&#20301;&#32622;&#12290;&#38754;&#35797;&#30340;&#26102;&#20505;&#21487;&#20197;&#24555;&#36895;&#30340;&#25214;&#21040;&#20013;&#28857;&#65288;&#32780;&#19981;&#26159;&#29992; index &#31639;&#65289;&#12290;</p>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>&#35762;&#35299; Search in Rotated Sorted Array &#31561; 5-7 &#36947;&#39640;&#39057;&#20108;&#20998;&#25628;&#32034;&#39064; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>Search in Rotated Sorted Array <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://whudoc.qiniudn.com/2016/20141025161730953.png" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> search(vector&lt;<span class="dt">int</span>&gt;&amp; nums, <span class="dt">int</span> target) {
        <span class="kw">return</span> search( nums, <span class="dv">0</span>, nums.size(), target );
    }
    <span class="dt">int</span> search( vector&lt;<span class="dt">int</span>&gt; &amp;nums, <span class="dt">int</span> left, <span class="dt">int</span> right, <span class="dt">int</span> target, <span class="dt">int</span> binarysearch = <span class="dv">0</span> ) {
        <span class="kw">if</span>( binarysearch == <span class="dv">1</span> ) {
            <span class="dt">int</span> mid;
            <span class="kw">while</span>( left &lt;= right ) {
                mid = (left+right)/<span class="dv">2</span>;
                <span class="kw">if</span>( target == nums[mid] ) {
                    <span class="kw">return</span> mid;
                } <span class="kw">else</span> <span class="kw">if</span>( target &lt; nums[mid] ) {
                    right = mid<span class="dv">-1</span>;
                } <span class="kw">else</span> {
                    left = mid<span class="dv">+1</span>;
                }
            }
            <span class="kw">return</span> <span class="dv">-1</span>;
        }
        <span class="kw">if</span>( left &gt; right ) { <span class="kw">return</span> <span class="dv">-1</span>; }
        <span class="kw">if</span>( left &lt; <span class="dv">0</span> ) { left = <span class="dv">0</span>; }
        <span class="kw">if</span>( right &gt;= nums.size() ) { right = nums.size()<span class="dv">-1</span>; }

        <span class="dt">int</span> mid = (left+right)/<span class="dv">2</span>;
        <span class="kw">if</span>( target == nums[left] ) { <span class="kw">return</span> left; }
        <span class="kw">if</span>( target == nums[right] ) { <span class="kw">return</span> right; }
        <span class="kw">if</span>( target == nums[mid] ) { <span class="kw">return</span> mid; }

        <span class="kw">if</span>( nums[left] &lt; nums[right] ) {
            <span class="co">//          case 1</span>
            <span class="co">//</span>
            <span class="co">//              /</span>
            <span class="co">//             /</span>
            <span class="co">//            /</span>
            <span class="co">//           /</span>
            <span class="co">//          /</span>
            <span class="co">//</span>
            <span class="kw">if</span>( target &lt; nums[left] || target &gt; nums[right] ) { <span class="kw">return</span> <span class="dv">-1</span>; }
            <span class="kw">if</span>( target &lt; nums[mid] ) {
                <span class="kw">return</span> search( nums, left,  mid<span class="dv">-1</span>, target, <span class="dv">1</span> ); <span class="co">// ordinary binary search</span>
            } <span class="kw">else</span> {
                <span class="kw">return</span> search( nums, mid<span class="dv">+1</span>, right, target, <span class="dv">1</span> ); <span class="co">// ordinary binary search</span>
            }
        } <span class="kw">else</span> <span class="kw">if</span>( nums[left] &lt; nums[mid] <span class="co">/* &amp;&amp; nums[left] &gt; nums[right] */</span> ) {
            <span class="co">//          case 2</span>
            <span class="co">//</span>
            <span class="co">//            /</span>
            <span class="co">//           /</span>
            <span class="co">//          /</span>
            <span class="co">//              /</span>
            <span class="co">//             /</span>
            <span class="co">//</span>
            <span class="kw">if</span>( nums[left] &lt; target &amp;&amp; target &lt; nums[mid] ) {
                <span class="kw">return</span> search( nums,  left, mid<span class="dv">-1</span>, target, <span class="dv">1</span> ); <span class="co">// ordinary binary search</span>
            } <span class="kw">else</span> {
                <span class="kw">return</span> search( nums, mid<span class="dv">+1</span>, right, target );
            }
        } <span class="kw">else</span> <span class="kw">if</span>( nums[right] &gt; nums[mid] <span class="co">/* nums[left] &gt; nums[right] */</span> ) {
            <span class="co">//          case 3</span>
            <span class="co">//</span>
            <span class="co">//           /</span>
            <span class="co">//          /</span>
            <span class="co">//              /</span>
            <span class="co">//             /</span>
            <span class="co">//            /</span>
            <span class="co">//</span>
            <span class="kw">if</span>( nums[mid] &lt; target &amp;&amp; target &lt; nums[right] ) {
                <span class="kw">return</span> search( nums, mid<span class="dv">+1</span>, right, target, <span class="dv">1</span> ); <span class="co">// ordinary binary search</span>
            } <span class="kw">else</span> {
                <span class="kw">return</span> search( nums,  left, mid<span class="dv">-1</span>, target );
            }
        } <span class="kw">else</span> {
            <span class="co">//cout &lt;&lt; &quot;what...?!\n&quot;;</span>
            <span class="kw">return</span> <span class="dv">-1</span>;
        }
    }
};</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://blog.csdn.net/ljiabin/article/details/40453607">&#12304;LeetCode&#12305;Search in Rotated Sorted Array&#35299;&#39064;&#25253;&#21578; - &#36339;&#20986;&#28201;&#27700;&#30340;&#38738;&#34521; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a>&#12290;</li>
<li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array | LeetCode OJ</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Search in Rotated Sorted Array II <code class="fold">@</code></dt>
<dd><p>Follow up for &#8220;Search in Rotated Sorted Array&#8221;:</p>
<ul>
<li>What if duplicates are allowed?</li>
<li>Would this affect the run-time complexity? How and why?</li>
<li>Write a function to determine if a given target is in the array.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">bool</span> search(vector&lt;<span class="dt">int</span>&gt;&amp; nums, <span class="dt">int</span> target) {
        <span class="dt">int</span> low = <span class="dv">0</span>;
        <span class="dt">int</span> high = nums.size()<span class="dv">-1</span>;
        <span class="dt">int</span> mid;
        <span class="kw">while</span>( low &lt;= high ) {
            <span class="kw">if</span>( nums[low] &lt; nums[high] &amp;&amp; (target&lt;nums[low]||nums[high]&lt;target) ) {
                <span class="kw">return</span> <span class="kw">false</span>;
            }
            <span class="co">// if dupilicates, remove the duplication</span>
            <span class="kw">while</span> ( low &lt; high &amp;&amp; nums[low] == nums[high] ) {
                ++low;
            }
            mid = (low+high)/<span class="dv">2</span>;
            <span class="kw">if</span> ( nums[mid] == target || nums[low] == target || nums[high] == target ) {
                <span class="kw">return</span> <span class="kw">true</span>;
            }
            <span class="co">// left, not rotated</span>
            <span class="kw">if</span> ( nums[low] &lt; target &amp;&amp; target &lt; nums[mid] ) {
                high = mid<span class="dv">-1</span>;
                <span class="kw">continue</span>;
            }
            <span class="co">// right, not rotated</span>
            <span class="kw">if</span> ( nums[mid] &lt; target &amp;&amp; target &lt; nums[high] ) {
                low = mid<span class="dv">+1</span>;
                <span class="kw">continue</span>;
            }
            <span class="co">// rotated</span>
            <span class="kw">if</span>  ( nums[low]  &gt; nums[mid] ){ high = mid<span class="dv">-1</span>; <span class="kw">continue</span>; }
            <span class="kw">if</span>  ( nums[high] &lt; nums[mid] ){ low  = mid<span class="dv">+1</span>; <span class="kw">continue</span>; }
            ++low;
        }
        <span class="kw">return</span> <span class="kw">false</span>;
    }
};</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/">81. Search in Rotated Sorted Array II | LeetCode OJ</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Find Minimum in Rotated Sorted Array <code class="fold">@</code></dt>
<dd><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> findMin(vector&lt;<span class="dt">int</span>&gt;&amp; nums) {
        <span class="kw">return</span> findMin( nums, <span class="dv">0</span>, nums.size()<span class="dv">-1</span> );
    }
    <span class="dt">int</span> findMin( vector&lt;<span class="dt">int</span>&gt;&amp; nums, <span class="dt">int</span> low, <span class="dt">int</span> high ) {
        <span class="dt">int</span> mid = (low+high)/<span class="dv">2</span>;
        <span class="kw">if</span>( mid == low || mid == high ) { <span class="kw">return</span> min( nums[low], nums[high] ); }
        <span class="kw">if</span>( nums[low] &lt; nums[high] ) {
            <span class="kw">return</span> nums[low];
        } <span class="kw">else</span> {
            <span class="kw">if</span>( nums[low] &lt; nums[mid] ) {
                <span class="kw">return</span> min( findMin( nums, mid<span class="dv">+1</span>, high ), nums[low] );
            } <span class="kw">else</span> {
                <span class="kw">return</span> min( findMin( nums, low, mid<span class="dv">-1</span> ), nums[mid] );
            }
        }
    }
};</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">153. Find Minimum in Rotated Sorted Array | LeetCode OJ</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Find Minimum in Rotated Sorted Array II <code class="fold">@</code></dt>
<dd><p>The array may contain duplicates.</p>
<p>&#27809;&#26377;&#36890;&#36807; ==</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> findMin(vector&lt;<span class="dt">int</span>&gt;&amp; nums) {
        <span class="kw">return</span> findMin( nums, <span class="dv">0</span>, nums.size()<span class="dv">-1</span> );
    }
    <span class="dt">int</span> findMin( vector&lt;<span class="dt">int</span>&gt;&amp; nums, <span class="dt">int</span> low, <span class="dt">int</span> high ) {
        <span class="kw">if</span>( low &gt; high ) { <span class="kw">return</span> INT_MAX; }
        <span class="dt">int</span> mid = (low+high)/<span class="dv">2</span>;
        <span class="kw">if</span>( mid == low || mid == high ) { <span class="kw">return</span> min( nums[low], nums[high] ); }
        <span class="kw">if</span>( nums[low] &lt; nums[high] ) {
            <span class="kw">return</span> nums[low];
        } <span class="kw">else</span> {
            <span class="kw">while</span> ( low &lt; high &amp;&amp; nums[low] == nums[high] ) {
                ++low;
            }
            mid = (low+high)/<span class="dv">2</span>;
            <span class="kw">if</span>( mid == low || mid == high ) { <span class="kw">return</span> min( nums[low], nums[high] ); }
            <span class="kw">if</span>( nums[low] &lt; nums[mid] ) {
                <span class="kw">return</span> min( findMin( nums, mid<span class="dv">+1</span>, high ), nums[low] );
            } <span class="kw">else</span> {
                <span class="kw">return</span> min( findMin( nums, low, mid<span class="dv">-1</span> ), nums[mid] );
            }
        }
    }
};</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Convert Sorted Array to Binary Search Tree <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/**</span>
 * Definition <span class="kw">for</span> a binary tree node.
 * <span class="kw">struct</span> TreeNode {
 *     <span class="dt">int</span> val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(<span class="dt">int</span> x) : val(x), left(NULL), right(NULL) {}
 * };
 */
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    TreeNode* sortedArrayToBST(vector&lt;<span class="dt">int</span>&gt;&amp; nums) {

        <span class="kw">if</span>(nums.size()==<span class="dv">0</span>){
            <span class="kw">return</span> NULL;
        }
        <span class="kw">if</span>(nums.size()==<span class="dv">1</span>){
            <span class="kw">return</span> <span class="kw">new</span> TreeNode(nums);
        }
        <span class="dt">int</span> mid = nums.size()/<span class="dv">2</span>;

        TreeNode *node = <span class="kw">new</span> TreeNode(nums[mid]);

        vector&lt;<span class="dt">int</span>&gt;::const_iterator first = nums.begin();
        vector&lt;<span class="dt">int</span>&gt;::const_iterator last  = nums.begin()+mid;

        vector&lt;<span class="dt">int</span>&gt; v(first, last);
        node-&gt;left = sortedArrayToBST(v);

        <span class="kw">if</span> (mid==nums.size()<span class="dv">-1</span>){
            node-&gt;right = NULL;
        } <span class="kw">else</span> {
            first = nums.begin()+mid<span class="dv">+1</span>;
            last = nums.end();
            vector&lt;<span class="dt">int</span>&gt; v(first, last);
            node-&gt;right = sortedArrayToBST(v);
        }
        <span class="kw">return</span> node;
    }
};</code></pre></div>
<p><em>Convert Sorted List to Binary Search Tree</em> &#21644;&#36825;&#20010;&#31867;&#20284;&#65292;&#25105;&#21152;&#20102;&#19968;&#23618;&#36716;&#25442;&#23601; pass &#20102;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">TreeNode* sortedListToBST(ListNode* head) {
    vector&lt;<span class="dt">int</span>&gt; nums;
    <span class="kw">while</span>( head ) {
        nums.push_back( head-&gt;val );
        head = head-&gt;next;
    }
    <span class="kw">return</span> sortedArrayToBST( nums );
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. Find Minimum in Rotated Sorted Array II | LeetCode OJ</a></li>
<li><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">108. Convert Sorted Array to Binary Search Tree | LeetCode OJ</a></li>
<li><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">109. Convert Sorted List to Binary Search Tree | LeetCode OJ</a></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">Binary search algorithm - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/08/07 &#19978;&#21320; 9:30:00 3. &#20108;&#21449;&#26641;&#38382;&#39064;&#19982;&#20998;&#27835;&#31639;&#27861; Binary Tree &amp; Divide Conquer <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#20108;&#21449;&#26641;&#30340;&#33410;&#28857;&#23450;&#20041; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> TreeNode {
    <span class="dt">int</span> val;
    TreeNode *left;
    TreeNode *right;
    TreeNode( <span class="dt">int</span> x ) : val(x), left(<span class="kw">nullptr</span>), right(<span class="kw">nullptr</span>) { }
}</code></pre></div>
<dl>
<dt>&#36882;&#24402;&#29256;&#30340;&#37117;&#24456;&#23481;&#26131; <code class="fold">@</code></dt>
<dd><p>&#65288;Recursive solution is trivial <code>['tr&#618;v&#618;&#601;l]</code>, could you do it iteratively <code>['it&#601;,reitivli]</code>?&#65289;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> traversal( TreeNode *root, vector&lt;<span class="dt">int</span>&gt; &amp;result ) {
    <span class="kw">if</span>( !root ) { <span class="kw">return</span>; }
    <span class="co">// &#22914;&#26524;&#20808;&#24207;&#65288;&#20013;&#24207;&#21644;&#21518;&#24207;&#21482;&#26159;&#35843;&#25972;&#19968;&#19979;&#20301;&#32622;&#65289;</span>
    result.push_back( root-&gt;val );
    traversal( root-&gt;left,  result );
    traversal( root-&gt;right, result );
}</code></pre></div>
</dd>
<dt>Iterative &#31639;&#27861;&#20266;&#30721; <code class="fold">@</code></dt>
<dd><pre><code>&#12304;&#20174;&#32500;&#22522;&#30334;&#31185;&#26597;&#21040;&#30340; iterative &#26041;&#27861;&#30340;&#31639;&#27861;&#20266;&#30721;&#12305;

DPS: Depth-first search
BPS: Breath-first search
--------------------------------------------
iterativePreorder(node)
    if (node = null)
        return
    s &#8592; empty stack
    s.push(node)
    while (not s.isEmpty())
        node &#8592; s.pop()
        visit(node)
        if (node.right &#8800; null)
            s.push(node.right)
        if (node.left &#8800; null)
            s.push(node.left)
--------------------------------------------
iterativeInorder(node)
   s &#8592; empty stack

   while (not s.isEmpty() or node &#8800; null)
       if (node &#8800; null)
           s.push(node)
           node &#8592; node.left
       else
           node &#8592; s.pop()
           visit(node)
           node &#8592; node.right
--------------------------------------------
iterativePostorder(node)
    s &#8592; empty stack                                               O  1      X-&gt; go left/down
    lastNodeVisited &#8592; null                                       /          X-&gt; go right?
    while (not s.isEmpty() or node &#8800; null)                   2  O           X-&gt; go up.
        if (node &#8800; null)                                       / \
            s.push(node)                                   3  X-&gt; O  4
            node &#8592; node.left                                     / \
        else                                                5  O    O  7
            peekNode &#8592; s.peek()                              /     /
            // if right child exists and traversing node    X 6   X 8
            // from left child, then move right
            if (peekNode.right &#8800; null and lastNodeVisited &#8800; peekNode.right)
                node &#8592; peekNode.right
            else
                visit(peekNode)
                lastNodeVisited &#8592; s.pop()
--------------------------------------------
levelorder(root)
    q &#8592; empty queue
    q.enqueue(root)
    while (not q.isEmpty())
        node &#8592; q.dequeue()
        visit(node)
        if (node.left &#8800; null)
            q.enqueue(node.left)
        if (node.right &#8800; null)
            q.enqueue(node.right)</code></pre>
</dd>
<dt>Code Template <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;stack&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#define nullptr 0</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> TreeNode {
    <span class="dt">int</span> val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(<span class="dt">int</span> x = <span class="dv">-1</span> ) : val(x), left(NULL), right(NULL) {}  <span class="co">// added default ctor</span>
};
<span class="dt">void</span> link( TreeNode &amp;root, TreeNode * left, TreeNode *right ) {
    root.left  = left;
    root.right = right;
}

<span class="kw">class</span> Solution {
    <span class="kw">public</span>:
    vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; levelOrder( TreeNode *root );
    ...
};

<span class="dt">int</span> main() {
    TreeNode node;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; ++i ) { node[i].val = i; }
    printf( <span class="st">&quot;         0               </span><span class="ch">\n</span><span class="st">&quot;</span>
            <span class="st">&quot;        / </span><span class="ch">\\</span><span class="st">             </span><span class="ch">\n</span><span class="st">&quot;</span>
            <span class="st">&quot;       /   </span><span class="ch">\\</span><span class="st">            </span><span class="ch">\n</span><span class="st">&quot;</span>
            <span class="st">&quot;      1     2            </span><span class="ch">\n</span><span class="st">&quot;</span>
            <span class="st">&quot;    /  </span><span class="ch">\\</span><span class="st">     </span><span class="ch">\\</span><span class="st">         </span><span class="ch">\n</span><span class="st">&quot;</span>
            <span class="st">&quot;   3    4     5          </span><span class="ch">\n</span><span class="st">&quot;</span>
            <span class="st">&quot;   </span><span class="ch">\\</span><span class="st">    /    / </span><span class="ch">\\</span><span class="st">       </span><span class="ch">\n</span><span class="st">&quot;</span>
            <span class="st">&quot;    6  7    8   9        </span><span class="ch">\n</span><span class="st">&quot;</span>   );
    link(   node,     &amp;node,      &amp;node     );
    link(   node,     &amp;node,      &amp;node     );
    link(   node,         <span class="dv">0</span>,      &amp;node     );
    link(   node,         <span class="dv">0</span>,      &amp;node     );
    link(   node,     &amp;node,          <span class="dv">0</span>     );
    link(   node,     &amp;node,      &amp;node     );
    link(   node,         <span class="dv">0</span>,          <span class="dv">0</span>     );
    link(   node,         <span class="dv">0</span>,          <span class="dv">0</span>     );
    link(   node,         <span class="dv">0</span>,          <span class="dv">0</span>     );
    link(   node,         <span class="dv">0</span>,          <span class="dv">0</span>     );

    Solution sol;
    vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; ret = sol.levelOrder( &amp;node );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; ret.size(); ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; ret[i].size(); ++j ) {
            cout &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; ret[i][j];
        }
        cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Tree_traversal">Tree traversal - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/">Binary Tree Preorder Traversal | LeetCode OJ</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">Binary Tree Inorder Traversal | LeetCode OJ</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/">Binary Tree Postorder Traversal | LeetCode OJ</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">Binary Tree Level Order Traversal | LeetCode OJ</a></li>
<li><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#20108;&#21449;&#26641;&#30340;&#28145;&#24230;&#20248;&#20808;&#36941;&#21382; Binary Tree DFS Traversal <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#20808;&#24207; / &#20013;&#24207; / &#21518;&#24207; Preorder / inorder / postorder <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#20808;&#24207;&#36941;&#21382; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#29992;&#26632; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Time: O(n), Space: O(n)</span>
vector&lt;<span class="dt">int</span>&gt; preorderTravesal( TreeNode *root ) {
    vector&lt;<span class="dt">int</span>&gt; result;
    stack&lt;TreeNode *&gt; s;
    <span class="kw">if</span>( root ) { s.push(root); }                <span class="co">// nullptr &#19968;&#23450;&#19981;&#35201; push&#65281;</span>
    <span class="kw">while</span>( !s.empty() ) {
        root = s.top(); s.pop();
        result.push_back( root-&gt;val );
        <span class="kw">if</span>( root-&gt;right ) { s.push( root-&gt;right); }   <span class="co">// &#36825;&#37324;&#19981;&#35201;&#30095;&#24573;&#20102;</span>
        <span class="kw">if</span>( root-&gt;left  ) { s.push( root-&gt;left ); }
    }
    <span class="kw">return</span> result;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Morris &#20808;&#24207;&#36941;&#21382; <code class="fold">@</code></dt>
<dd><p>&#21442;&#32771; <a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html">Morris Traversal&#26041;&#27861;&#36941;&#21382;&#20108;&#21449;&#26641;&#65288;&#38750;&#36882;&#24402;&#65292;&#19981;&#29992;&#26632;&#65292;<code>O(1)</code> &#31354;&#38388;&#65289; - AnnieKim - &#21338;&#23458;&#22253;</a>&#12290;</p>
<p>&#35201;&#20351;&#29992; O(1) &#31354;&#38388;&#36827;&#34892;&#36941;&#21382;&#65292;&#26368;&#22823;&#30340;&#38590;&#28857;&#22312;&#20110;&#65292;&#36941;&#21382;&#21040;&#23376;&#33410;&#28857;&#30340;&#26102;&#20505;&#24590;&#26679;&#37325;&#26032;&#36820;&#22238;&#21040;&#29238;&#33410;&#28857;&#65288;&#20551;&#35774;&#33410;&#28857;&#20013;&#27809;&#26377;&#25351;&#21521;&#29238;&#33410;&#28857;&#30340; p &#25351;&#38024;&#65289;&#65292;&#30001;&#20110;&#19981;&#33021;&#29992;&#26632;&#20316;&#20026;&#36741;&#21161;&#31354;&#38388;&#12290;&#20026;&#20102;&#35299;&#20915;&#36825;&#20010;&#38382;&#39064;&#65292;Morris &#26041;&#27861;&#29992;&#21040;&#20102;&#32447;&#32034;&#20108;&#21449;&#26641;&#65288;threaded binary tree&#65289;&#30340;&#27010;&#24565;&#12290;&#22312; Morris &#26041;&#27861;&#20013;&#19981;&#38656;&#35201;&#20026;&#27599;&#20010;&#33410;&#28857;&#39069;&#22806;&#20998;&#37197;&#25351;&#38024;&#25351;&#21521;&#20854;&#21069;&#39537;&#65288;predecessor&#65289;&#21644;&#21518;&#32487;&#33410;&#28857;&#65288;successor&#65289;&#65292;&#21482;&#38656;&#35201;&#21033;&#29992;&#21494;&#23376;&#33410;&#28857;&#20013;&#30340;&#24038;&#21491;&#31354;&#25351;&#38024;&#25351;&#21521;&#26576;&#31181;&#39034;&#24207;&#36941;&#21382;&#19979;&#30340;&#21069;&#39537;&#33410;&#28857;&#25110;&#21518;&#32487;&#33410;&#28857;&#23601;&#21487;&#20197;&#20102;&#12290;</p>
<div class="figure">
<img src="http://images.cnitblog.com/blog/300640/201306/14221458-aa5f9e92cce743ccacbc735048133058.jpg" alt="moris preorder" />
<p class="caption">moris preorder</p>
</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Time: O(n), Space: O(1)</span>
vector&lt;<span class="dt">int</span>&gt; preorderTraversal( TreeNode *root ) {
    vector&lt;<span class="dt">int</span>&gt; result;
    TreeNode *cur = root; *prev = <span class="kw">nullptr</span>;

    <span class="kw">while</span>( cur ) {
        <span class="kw">if</span>( cur-&gt;left ) {
            result.push_back( cur-&gt;val );
            prev    = cur;
            cur     = cur-&gt;right;
        } <span class="kw">else</span> {
            <span class="co">// &#26597;&#25214;&#21069;&#39537;</span>
            TreeNode *node = cur-&gt;left;
            <span class="kw">while</span>( node-&gt;right &amp;&amp; node-&gt;right != cur ) {
                node = node-&gt;right;
            }
            <span class="kw">if</span>( !node-&gt;right ) {
                result.push_back( cur-&gt;val );
                node-&gt;right = cur;
                prev        = cur;
                cur         = cur-&gt;left;
            } <span class="kw">else</span> {
                node-&gt;right = <span class="kw">nullptr</span>;
                cur = cur-&gt;right;
            }
        }
    }
    <span class="kw">return</span> result;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#20013;&#24207;&#65288;inorder&#65289;&#36941;&#21382; &#10084;&#65039; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#29992;&#26632; <code class="fold">@</code></dt>
<dd><pre><code>    =while { if / else }=

     down to left loop
     +-------&gt;-------+
     |              \|/
     |               V
   +-----+       +---|---------------+
   |while|       |  i f  --&gt;-- else  |
   +-^---+       +---|---------- ----+
     |               V          | go to right subtree
     +-------&lt;-------+--&lt;-------+

    +--+                           +----+
    |if|                           |else|
    +--+                           +----+
                X
               /                           i.  pop
              X                            ii. visit
             /                             iii. go right
            ?</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">int</span>&gt; inorderTraveral( TreeNode *root ) {
    vector&lt;<span class="dt">int</span>&gt; result;
    stack&lt;TreeNode *&gt; s;
    <span class="kw">while</span>( !s.empty() || root ) {
        <span class="kw">if</span>( root ) {
            s.push( root );                 <span class="co">// &#35745;&#21010;&#22788;&#29702; root&#65288;&#24403;&#21069;&#65289;</span>
            root = root-&gt;left;              <span class="co">// &#20294;&#20808;&#22788;&#29702;&#24038;&#33410;&#28857;</span>
        } <span class="kw">else</span> {
            root = s.top(); s.pop();        <span class="co">// &#22788;&#29702; root&#65288;&#24403;&#21069;&#65289;&#65292;&#23427;&#30340;&#24038;&#23376;&#26641;&#24050;&#32463;&#22788;&#29702;&#23436;&#20102;~</span>
            result.push_back( root-&gt;val );
            root = root-&gt;right;             <span class="co">// &#28982;&#21518;&#31227;&#21040;&#21491;&#36793;</span>
        }
    }
    <span class="kw">return</span> result;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Moris <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">TODO</code></pre></div>
<div class="figure">
<img src="http://images.cnitblog.com/blog/300640/201306/15150628-5285f29bab234750a62e2309394b6e14.jpg" alt="&#32418;&#33394;&#26159;&#20026;&#20102;&#23450;&#20301;&#21040;&#26576;&#20010;&#33410;&#28857;&#65292;&#40657;&#33394;&#32447;&#26159;&#20026;&#20102;&#25214;&#21040;&#21069;&#39537;&#33410;&#28857;&#12290;" />
<p class="caption">&#32418;&#33394;&#26159;&#20026;&#20102;&#23450;&#20301;&#21040;&#26576;&#20010;&#33410;&#28857;&#65292;&#40657;&#33394;&#32447;&#26159;&#20026;&#20102;&#25214;&#21040;&#21069;&#39537;&#33410;&#28857;&#12290;</p>
</div>
<div class="figure">
<img src="http://images.cnitblog.com/blog/300640/201306/14214057-7cc645706e7741e3b5ed62b320000354.jpg" alt="moris inorder" />
<p class="caption">moris inorder</p>
</div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#21518;&#24207;&#36941;&#21382; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#29992;&#26632; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">int</span>&gt; postorderTraversal( TreeNode *root ) {
    vector&lt;<span class="dt">int</span>&gt; ret;
    stack&lt;TreeNode *&gt; s;
    TreeNode *pre = <span class="kw">nullptr</span>;
    <span class="kw">while</span>( !s.empty() || root ) {
        <span class="kw">if</span>( root ) {                                    <span class="co">// keep going the left</span>
            s.push( root );
            root = root-&gt;left;
        } <span class="kw">else</span> {
            TreeNode *root = s.top();
            <span class="kw">if</span>( root-&gt;right &amp;&amp; root-&gt;right != pre ) {   <span class="co">// left way is finsised, keep going to the right way</span>
                root = root-&gt;right;
            } <span class="kw">else</span> {
                ret.push_back( root-&gt;val );             <span class="co">// both left and right has been accessed.</span>
                pre = root; s.pop();                    <span class="co">// root == s.top();</span>
            }
        }
    }
    <span class="kw">return</span> ret;
}</code></pre></div>
<dl>
<dt>Another idea, by Chenhao. <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">int</span>&gt; postorderTraversal( TreeNode *root ) {
    vector&lt;<span class="dt">int</span>&gt; ret;
    stack&lt;TreeNode *&gt; s;
    <span class="kw">if</span>( root ) { s.push( root ); }
    <span class="kw">while</span>( !s.empty() ) {
        root = s.top(); s.pop();
        ret.push_back( root-&gt;val );
        <span class="kw">if</span>( root-&gt;left  ) { s.push( root-&gt;left ); }     <span class="co">// &#21644;&#20808;&#24207;&#36941;&#21382;&#20960;&#20046;&#19968;&#27169;&#19968;&#26679;!!! &#21482;&#26159;&#35843;&#25442;&#20102;&#39034;&#24207;.</span>
        <span class="kw">if</span>( root-&gt;right ){ s.push( root-&gt;right ); }
    }
    std::reverse( ret.begin(), ret.end() );             <span class="co">// the trick</span>
    <span class="kw">return</span> ret;
}</code></pre></div>
<pre><code>    A                   postorder:  DFEBCA
   / \
  B   C
 / \
D   E
   /
  F

stack       vector      action
-----       ---------   -------------
||          []
|A|         []          push root
|BC|        [A]         not empty, pop A, log A, push B, C
|B|         [AC]        not empty, pop C, log C, no push
|DE|        [ACB]       not empty, pop B, log B, push D, E
|DF|        [ACBE]      not empty, pop E, log E, push F
|D|         [ACBEF]     not empty, pop F, log F, no push
||          [ACBEFD]    not empty, pop D, log D, no push
||          [DFEBCA]    empty, reverse vec, return</code></pre>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>Morris <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
    <span class="dt">void</span> reverse_right_chain(TreeNode *x, TreeNode *y) {
        TreeNode *p = x, *q = x-&gt;right, *right;
        <span class="kw">while</span> (p != y) {
            right = q-&gt;right;
            q-&gt;right = p;
            p = q;
            q = right;
        }
    }
<span class="kw">public</span>:
    vector&lt;<span class="dt">int</span>&gt; postorderTraversal(TreeNode* root) {
        vector&lt;<span class="dt">int</span>&gt; ret;
        TreeNode aux(<span class="dv">0</span>), *p = &amp;aux;
        aux.left = root;
        aux.right = NULL;
        <span class="kw">while</span> (p) {
            TreeNode *q = p-&gt;left;
            <span class="kw">if</span> (q) {
                <span class="kw">while</span> (q-&gt;right &amp;&amp; q-&gt;right != p) q = q-&gt;right;
                <span class="kw">if</span> (q-&gt;right == p) {
                    reverse_right_chain(p-&gt;left, q);
                    <span class="kw">for</span> (TreeNode *r = q; ; r = r-&gt;right) {
                        ret.push_back(r-&gt;val);
                        <span class="kw">if</span> (r == p-&gt;left) <span class="kw">break</span>;
                    }
                    reverse_right_chain(q, p-&gt;left);
                    q-&gt;right = NULL;
                } <span class="kw">else</span> {
                    q-&gt;right = p;
                    p = p-&gt;left;
                    <span class="kw">continue</span>;
                }
            }
            p = p-&gt;right;
        }
        <span class="kw">return</span> ret;
    }
};</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>threaded tree <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stddef.h&gt;                             </span><span class="co">// for NULL</span>
<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="kw">typedef</span> <span class="dt">int</span> elem_t;
<span class="kw">typedef</span> <span class="kw">struct</span> tbt_node_t {
    <span class="dt">int</span> ltag;                                   <span class="co">// 0 for child, 1 for thread</span>
    <span class="dt">int</span> rtag;
    <span class="kw">struct</span> tbt_node_t *left;                    <span class="co">// left child, or pre</span>
    <span class="kw">struct</span> tbt_node_t *right;                   <span class="co">// right child , or succ</span>
    elem_t elem;                                <span class="co">// node</span>
} tbt_node_t;

<span class="dt">static</span> <span class="dt">void</span> in_thread(tbt_node_t *p, tbt_node_t **pre);
<span class="dt">static</span> tbt_node_t *first(tbt_node_t *p);
<span class="dt">static</span> tbt_node_t *next(<span class="dt">const</span> tbt_node_t *p);

<span class="dt">void</span> create_in_thread(tbt_node_t *root) {
    tbt_node_t *pre=NULL;
    <span class="kw">if</span>( !root ) {                   <span class="co">// &#38750;&#31354;&#20108;&#21449;&#26641;&#65292;&#32447;&#32034;&#21270;</span>
        in_thread( root, &amp;pre );    <span class="co">// threaded in_order traversal</span>
        pre-&gt;right = NULL;          <span class="co">// the only last work to do</span>
        pre-&gt;rtag = <span class="dv">1</span>;
    }
}

<span class="dt">void</span> in_order( tbt_node_t *root, <span class="dt">int</span>(*visit)(tbt_node_t*) ) {
    <span class="kw">for</span>( tbt_node_t *p = first(root); p; p = next(p) ) { visit(p); }
}</code></pre></div>
<pre><code>self-&gt;left -&gt; pre
                            B (pre)
                          .^ \
                         .    \
                         .     \
                           . . .D (p)
                               /
                              /
                            ~~~~ no left child, make it point to it&#39;s pre
pre-&gt;right -&gt; self
                              A (p)
                             /^
                            /   .
                           /      .
                          B        .
                           \      .
                            D.. . (pre)
                             \
                            ~~~~ no right child, make it point to it&#39;s succ</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">static</span> <span class="dt">void</span> in_thread( tbt_node_t *p, tbt_node_t **pre ) {
    <span class="kw">if</span>( p ) {
        in_thread( p-&gt;left, pre );
        <span class="kw">if</span>( !p-&gt;left ) {                        <span class="co">// left child point to pre</span>
            p-&gt;left = *pre;
            p-&gt;ltag = <span class="dv">1</span>;
        }
        <span class="co">/* &#24314;&#31435;&#21069;&#39537;&#32467;&#28857;&#30340;&#21518;&#32487;&#32447;&#32034; */</span>

        <span class="kw">if</span>( (*pre) &amp;&amp; !(*pre)-&gt;right ) {        <span class="co">// pre&#39;s right child point to self</span>
            (*pre)-&gt;right = p;
            (*pre)-&gt;rtag = <span class="dv">1</span>;
        }
        *pre = p;
        in_thread( p-&gt;right, pre );
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">// &#23547;&#25214;&#32447;&#32034;&#20108;&#21449;&#26641;&#30340;&#20013;&#24207;&#19979;&#30340;&#31532;&#19968;&#20010;&#32467;&#28857;.</span>
<span class="co">// p &#32447;&#32034;&#20108;&#21449;&#26641;&#20013;&#30340;&#20219;&#24847;&#19968;&#20010;&#32467;&#28857;</span>
<span class="co">// return &#27492;&#32447;&#32034;&#20108;&#21449;&#26641;&#30340;&#31532;&#19968;&#20010;&#32467;&#28857;</span>
<span class="dt">static</span> tbt_node_t *first(tbt_node_t *p) {
    <span class="kw">if</span>( !p ) { <span class="kw">return</span> NULL; }
    <span class="kw">while</span>( p-&gt;ltag == <span class="dv">0</span> ) {
        p = p-&gt;left;            <span class="co">// left-most node, (may not be leaf, (it may has right child))</span>
    }
    <span class="kw">return</span> p;
}

<span class="dt">static</span> tbt_node_t *next( <span class="dt">const</span> tbt_node_t *p ) {
    assert( p );
    <span class="kw">if</span>( p-&gt;rtag == <span class="dv">0</span> ) {
        <span class="kw">return</span> first(p-&gt;right);
    } <span class="kw">else</span> {
        <span class="kw">return</span> p-&gt;right;        <span class="co">// succ</span>
    }
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>rebuild tree &#9829;&#65039; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#21407;&#29702;&#20197;&#21450;&#20154;&#24037;&#25512;&#28436; <code class="fold">@</code></dt>
<dd><pre><code>                      +---------------------------------------------+
                      |                                             |
                      v                                             |
{pre}       =   [    pre,+---+  {leftpre},      {rightpre}  ];      |
{in}        =   [ {leftin},  +-----&gt;in,&lt;-----+  {rightin}   ];      |
{post}      =   [ {leftpost},   {rightpost}, +-+post        ];      |
                                                   ^                |
                                                   |                |
                                                   +----------------+</code></pre>
<p>&#25163;&#24037;&#25512;&#28436;&#19968;&#19979;&#65306;</p>
<pre><code>pre = &quot;ABDGCEF&quot;;
in  = &quot;DGBAECF&quot;;

    DGBAECF(ABDGCEF)    -&gt;          A               -&gt;          A
        / \                                                    / \
       /   \                                                  /   \
  DGB(BDG) ECF(CEF)     -&gt;      B       C                    B     C
                            DG(DG)  E       F               D     E F
                                                             G</code></pre>
</dd>
</dl></li>
<li><dl>
<dt>&#20808;&#24207;&#12289;&#20013;&#24207;&#23383;&#31526;&#20018;&#21040;&#21518;&#24207;&#23383;&#31526;&#20018; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="dt">void</span> build_post( <span class="dt">const</span> <span class="dt">char</span> * pre, <span class="dt">const</span> <span class="dt">char</span> *in, <span class="dt">const</span> <span class="dt">int</span> n, <span class="dt">char</span> *post ) {
    <span class="kw">if</span>(n &lt;= <span class="dv">0</span>) { <span class="kw">return</span>; }
    <span class="dt">int</span> left_len = strchr(in, pre[<span class="dv">0</span>]) - in;
    post[n - <span class="dv">1</span>] = pre[<span class="dv">0</span>];                   <span class="co">// you can put this line before/after recursion.</span>
    build_post( pre<span class="dv">+1</span>,          in,             left_len,       post );
    build_post( pre+left_len<span class="dv">+1</span>, in+left_len<span class="dv">+1</span>,  n-left_len<span class="dv">-1</span>,   post+left_len );
}

<span class="dt">int</span> main() {
    puts(
    <span class="st">&quot; tree:                        </span><span class="ch">\n</span><span class="st">&quot;</span>
    <span class="st">&quot;            A                 </span><span class="ch">\n</span><span class="st">&quot;</span>
    <span class="st">&quot;           / </span><span class="ch">\\</span><span class="st">               </span><span class="ch">\n</span><span class="st">&quot;</span>
    <span class="st">&quot;          /   </span><span class="ch">\\</span><span class="st">              </span><span class="ch">\n</span><span class="st">&quot;</span>
    <span class="st">&quot;         B     C              </span><span class="ch">\n</span><span class="st">&quot;</span>
    <span class="st">&quot;        /     / </span><span class="ch">\\</span><span class="st">            </span><span class="ch">\n</span><span class="st">&quot;</span>
    <span class="st">&quot;       D     E   F            </span><span class="ch">\n</span><span class="st">&quot;</span>
    <span class="st">&quot;        </span><span class="ch">\\</span><span class="st">                    </span><span class="ch">\n</span><span class="st">&quot;</span>
    <span class="st">&quot;         G                    </span><span class="ch">\n</span><span class="st">&quot;</span> );
    <span class="dt">const</span> <span class="dt">char</span> *pre     = <span class="st">&quot;ABDGCEF&quot;</span>;
    <span class="dt">const</span> <span class="dt">char</span> *in      = <span class="st">&quot;DGBAECF&quot;</span>;
    <span class="dt">char</span>        post[<span class="dv">8</span>] = { <span class="dv">0</span>     };
    <span class="co">//                    &quot;GDBEFCA&quot;;</span>
    build_post( pre, in, strlen(pre), post  );
    printf( <span class="st">&quot;pre:  </span><span class="ch">%s\n</span><span class="st">&quot;</span>, pre               );
    printf( <span class="st">&quot;in:   </span><span class="ch">%s\n</span><span class="st">&quot;</span>, in                );
    printf( <span class="st">&quot;post: </span><span class="ch">%s\n</span><span class="st">&quot;</span>, post              );
}</code></pre></div>
<p>output:</p>
<pre><code> tree:
            A
           / \
          /   \
         B     C
        /     / \
       D     E   F
        \
         G

pre:  ABDGCEF
in:   DGBAECF
post: GDBEFCA</code></pre>
</dd>
</dl></li>
<li><dl>
<dt>&#29983;&#25104;&#26641;&#65292;105. Construct Binary Tree from Preorder and Inorder Traversal &#9829;&#65039; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rebuild( <span class="dt">const</span> <span class="dt">char</span> *pre, <span class="dt">const</span> <span class="dt">char</span> *in, <span class="dt">int</span> n, bt_node_t **root ) {
    <span class="kw">if</span>( n &lt;= <span class="dv">0</span> || !pre || !in ) {                                       <span class="co">// &#26816;&#26597;&#32456;&#27490;&#26465;&#20214;</span>
        <span class="kw">return</span>;
    }

    *root = (bt_node_t*) malloc(<span class="kw">sizeof</span>(bt_node_t));                     <span class="co">// &#33719;&#24471;&#21069;&#24207;&#36941;&#21382;&#30340;&#31532;&#19968;&#20010;&#32467;&#28857;</span>
    (*root)-&gt;elem = *pre;
    (*root)-&gt;left = NULL;
    (*root)-&gt;right = NULL;

    <span class="dt">int</span> left_len = strchr( in, pre ) - in;
    rebuild( pre + <span class="dv">1</span>, in,                                               <span class="co">// &#37325;&#24314;&#24038;&#23376;&#26641;</span>
             left_len,          &amp;((*root)-&gt;left) );
    rebuild( pre + left_len + <span class="dv">1</span>, in + left_len + <span class="dv">1</span>,                     <span class="co">// &#37325;&#24314;&#21491;&#23376;&#26641;</span>
             n - left_len - <span class="dv">1</span>,  &amp;((*root)-&gt;right) );
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Construct Binary Tree from Preorder and Inorder Traversal</span>

<span class="co">// iterative</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    TreeNode *buildTree(vector&lt;<span class="dt">int</span>&gt; &amp;preorder, vector&lt;<span class="dt">int</span>&gt; &amp;inorder) {
        <span class="kw">if</span> (preorder.empty()) <span class="kw">return</span> <span class="kw">nullptr</span>;
        <span class="kw">auto</span> i = preorder.begin(), j = inorder.begin();
        <span class="kw">auto</span> root = <span class="kw">new</span> TreeNode(*i++);
        stack&lt;TreeNode *&gt; s;
        s.push(root);
        <span class="kw">while</span> (i != preorder.end()) {
            <span class="kw">auto</span> x = s.top();
            <span class="kw">if</span> (x-&gt;val != *j) {
                x-&gt;left = <span class="kw">new</span> TreeNode(*i++);
                x = x-&gt;left;
                s.push(x);
            } <span class="kw">else</span> {
                s.pop();
                ++j;
                <span class="kw">if</span> (s.empty() || s.top()-&gt;val != *j) {
                    x-&gt;right = <span class="kw">new</span> TreeNode(*i++);
                    x = x-&gt;right;
                    s.push(x);
                }
            }
        }
        <span class="kw">return</span> root;
    }
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// recursive</span>
<span class="ot">#define FOR(i, a, b) for (decltype(b) i = (a); i &lt; (b); i++)</span>
<span class="ot">#define REP(i, n) FOR(i, 0, n)</span>

<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    TreeNode *buildTree(vector&lt;<span class="dt">int</span>&gt; &amp;preorder, vector&lt;<span class="dt">int</span>&gt; &amp;inorder) {
        <span class="kw">return</span> f(&amp;preorder[<span class="dv">0</span>], &amp;*preorder.end(), &amp;inorder[<span class="dv">0</span>], &amp;*inorder.end());
    }
    TreeNode *f(<span class="dt">int</span> *l, <span class="dt">int</span> *h, <span class="dt">int</span> *ll, <span class="dt">int</span> *hh) {
        <span class="kw">if</span> (l == h)
            <span class="kw">return</span> NULL;
        <span class="kw">auto</span> r = <span class="kw">new</span> TreeNode(*l);
        <span class="dt">int</span> *m = find(ll, hh, *l);
        r-&gt;left = f(l<span class="dv">+1</span>, l<span class="dv">+1</span>+(m-ll), ll, m);
        r-&gt;right = f(l<span class="dv">+1</span>+(m-ll), h, m<span class="dv">+1</span>, hh);
        <span class="kw">return</span> r;
    }
};</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">Construct Binary Tree from Preorder and Inorder Traversal | LeetCode OJ</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#21452;&#20146;&#34920;&#31034;&#27861; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;sstream&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>
<span class="ot">#include &lt;assert.h&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxv = <span class="dv">100</span> + <span class="dv">10</span>;
<span class="dt">int</span> in_order    [   maxv    ];
<span class="dt">int</span> post_order  [   maxv    ];
<span class="dt">int</span> lch         [   maxv    ];
<span class="dt">int</span> rch         [   maxv    ];

<span class="dt">int</span> n;

<span class="dt">bool</span> read_list( <span class="dt">int</span> *a ) {
    string line;
    <span class="kw">if</span>( !getline( cin, line ) ) { <span class="kw">return</span> <span class="kw">false</span>; }
    stringstream ss( line );
    n = <span class="dv">0</span>;
    <span class="dt">int</span> x;
    <span class="kw">while</span>( ss &gt;&gt; x ) { a[n++] = x; }
    <span class="kw">return</span> n &gt; <span class="dv">0</span>;
}

<span class="co">//  in_order[L1..R1] &#21644; post_order[L2..R2] &#24314;&#25104;&#19968;&#39063;&#26641;&#65292;&#36820;&#22238;&#26641;&#26681;</span>
<span class="dt">int</span> build( <span class="dt">int</span> L1, <span class="dt">int</span> R1, <span class="dt">int</span> L2, <span class="dt">int</span> R2 ) {
    <span class="kw">if</span>( L1 &gt; R1 ) { <span class="kw">return</span> <span class="dv">0</span>; }
    <span class="dt">int</span> root = post_order[ R2 ];
    <span class="dt">int</span> p = L1;
    <span class="kw">while</span>( in_order[p] != root ) { ++p; }
    <span class="dt">int</span> cnt = p-L1;
    lch[ root ] = build( L1, p<span class="dv">-1</span>, L2, L2+cnt<span class="dv">-1</span> );
    rch[ root ] = build( p<span class="dv">+1</span>, R1, L2+cnt, R2<span class="dv">-1</span> );
    <span class="kw">return</span> root;
}

string print( <span class="dt">int</span> root, string pad ) {
    <span class="kw">if</span>( root == <span class="dv">0</span> ) { <span class="kw">return</span> pad; }
    <span class="dt">const</span> <span class="dt">static</span> string space = <span class="st">&quot;        &quot;</span>;
    <span class="dt">char</span> buf;
    sprintf( buf, <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, root );
    string result = pad + space + string(buf);
    result += <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    result += print( lch[root], pad );
    result += print( rch[root], pad+space+space );
    <span class="kw">return</span> result;
}

<span class="dt">int</span> best, best_sum;

<span class="co">//          u -&gt; root</span>
<span class="dt">void</span> dfs( <span class="dt">int</span> u, <span class="dt">int</span> sum ) {
    sum += u;
    <span class="kw">if</span>( !lch[u] &amp;&amp; !rch[u] ) { <span class="co">// leaf</span>
        <span class="kw">if</span>( sum &lt; best_sum || (sum == best_sum &amp;&amp; u &lt; best) ) {
            best = u;
            best_sum = sum;
        }
    }
    <span class="kw">if</span>( lch[u] ) { dfs( lch[u], sum ); }
    <span class="kw">if</span>( rch[u] ) { dfs( rch[u], sum ); }
}

<span class="dt">int</span> main() {
    <span class="kw">while</span>( read_list( in_order ) ) {
        read_list( post_order );
        build( <span class="dv">0</span>, n<span class="dv">-1</span>, <span class="dv">0</span>, n<span class="dv">-1</span> );
        best_sum = <span class="dv">-1</span>;
        dfs( post_order[n<span class="dv">-1</span>], <span class="dv">0</span> );
        cout &lt;&lt; best &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
        cout &lt;&lt; print( post_order[n<span class="dv">-1</span>], <span class="st">&quot;&quot;</span> );
        copy( lch, lch+n, ostream_iterator&lt;<span class="dt">int</span>&gt;(cout, <span class="st">&quot; &quot;</span>) );
        cout &lt;&lt;<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
        copy( rch, rch+n, ostream_iterator&lt;<span class="dt">int</span>&gt;(cout, <span class="st">&quot; &quot;</span>) );
        cout &lt;&lt;<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#20108;&#21449;&#26641;&#30340;&#23485;&#24230;&#20248;&#20808;&#36941;&#21382; Binary Tree BFS Traversal <code class="fold">@</code></dt>
<dd><p>&#23601;&#26159;&#23618;&#24207;&#36941;&#21382;&#65288;level order traversal&#65289;</p>
<ul>
<li><dl>
<dt>&#36882;&#24402;&#29256;&#26412; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Time: O(n), Space: O(n)</span>
vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; levelOrder( TreeNode *root ) {
    vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; result;
    traverse( root, <span class="dv">1</span>, result );
    <span class="kw">return</span> result;
}

<span class="co">// level is IMPORTANT!</span>
<span class="dt">void</span> traverse( TreeNode *root, size_t level, vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; &amp;result ) {
    <span class="kw">if</span>( !root ) { <span class="kw">return</span>; }
    <span class="kw">if</span>( level - <span class="dv">1</span> &gt;= result.size() ) {
        result.push_back( vector&lt;<span class="dt">int</span>&gt;() );                  <span class="co">// &#20063;&#21487;&#20197;&#29992; resize( level );</span>
    }
    result[level<span class="dv">-1</span>].push_back( root-&gt;val );
    traverse( root-&gt;left,   level<span class="dv">+1</span>, result );
    traverse( root-&gt;right,  level<span class="dv">+1</span>, result );
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#36845;&#20195;&#29256;&#26412; 1 <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Time: O(n), Space: O(1)</span>
vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; levelOrder( TreeNode *root ) {
    vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; ret;
    <span class="kw">if</span>( !root ) { <span class="kw">return</span> ret; };
    queue&lt;TreeNode *&gt; cur, next;
    cur.push( root );
    <span class="kw">while</span>( !cur.empty() ) {
        vector&lt;<span class="dt">int</span>&gt; level;
        <span class="kw">while</span>( !cur.empty() ) {
            root = cur.front(); cur.pop();
            level.push_back( root-&gt;val );
            <span class="kw">if</span>( root-&gt;left  ) { next.push( root-&gt;left  ); }
            <span class="kw">if</span>( root-&gt;right ) { next.push( root-&gt;right ); }
        }
        ret.push_back( level );
        swap( cur, next );
    }
    <span class="kw">return</span> ret;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#36845;&#20195;&#29256;&#26412; 2 <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; levelOrder( TreeNode *root ) {
    vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; ret;
    <span class="kw">if</span>( !root ) { <span class="kw">return</span> ret; }
    queue&lt;TreeNode *&gt; q;
    q.push( root );
    q.push( <span class="kw">nullptr</span> );                          <span class="co">// indicate end of cur level</span>
    vector&lt;<span class="dt">int</span>&gt; cur;
    <span class="kw">while</span>( !q.empty() ) {
        root = q.front(); q.pop();
        <span class="kw">if</span>( root ) {
            cur.push_back( root-&gt;val );
            <span class="kw">if</span> ( root-&gt;left  ) { q.push( root-&gt;left  ); }
            <span class="kw">if</span> ( root-&gt;right ) { q.push( root-&gt;right ); }
        } <span class="kw">else</span> <span class="kw">if</span>( !q.empty() ) {
            <span class="kw">if</span>( !cur.empty() ) {
                ret.push_back( cur );
                cur.clear();
            }
            q.push( <span class="kw">nullptr</span> );                  <span class="co">// indicate end of cur level</span>
        }
    }
    <span class="kw">if</span>( !cur.empty() ) { ret.push_back( cur ); }
    <span class="kw">return</span> ret;
}</code></pre></div>
</dd>
</dl></li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/aix/library/au-aix-stack-tree-traversal/index.html">Stack-based breadth-first search tree traversal</a></li>
<li><a href="http://www.cnblogs.com/miloyip/archive/2010/05/12/binary_tree_traversal.html">&#12298;&#32534;&#31243;&#20043;&#32654;&#65306;&#20998;&#23618;&#36941;&#21382;&#20108;&#21449;&#26641;&#12299;&#30340;&#21478;&#22806;&#20004;&#20010;&#23454;&#29616; - Milo Yip - &#21338;&#23458;&#22253;</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#20108;&#21449;&#25628;&#32034;&#26641; Binary Search Tree <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>What is BST (wikipedia) <code class="fold">@</code></dt>
<dd><p>In computer science, binary search trees (BST), sometimes called ordered or sorted binary trees, are a particular type of containers: data structures that store &#8220;items&#8221; (such as numbers, names etc.) in memory. They allow fast lookup, addition and removal of items, and can be used to implement either dynamic sets of items, or lookup tables that allow finding an item by its key (e.g., finding the phone number of a person by name).</p>
<p>The major advantage of binary search trees over other data structures is that <strong>the related sorting algorithms and search algorithms such as in-order traversal can be very efficient</strong>; they are also easy to code.</p>
<p>Binary search trees are a fundamental data structure used to construct more abstract data structures such as sets, multisets, and associative arrays. Some of their disadvantages are as follows:</p>
<ul>
<li>The shape of the binary search tree depends entirely on the order of insertions and deletions, and can become <strong>degenerate</strong>. &#26641;&#30340;&#32467;&#26500;&#36319;&#25968;&#25454;&#25554;&#20837;&#21024;&#38500;&#39034;&#24207;&#30456;&#20851;&#65292;&#21487;&#33021;&#36864;&#21270;&#12290;&#35299;&#20915;&#26041;&#26696;&#26159;&#24179;&#34913;&#20108;&#21449;&#26641;&#12290;</li>
<li>When inserting or searching for an element in a binary search tree, the key of each visited node has to be compared with the key of the element to be inserted or found. <strong>&#19981;&#26159;&#38543;&#26426;&#35775;&#38382;&#12290;</strong></li>
<li>The keys in the binary search tree may be long and the run time may increase. &#22914;&#26524; key &#30340;&#27604;&#36739;&#24456;&#32791;&#26102;&#65292;&#37027;&#23601;&#24456;&#31967;&#12290;</li>
<li>After a long intermixed sequence of random insertion and deletion, the expected height of the tree approaches square root of the number of keys, &#8730;n, which grows much faster than log n. <strong>&#28145;&#24230;&#30340;&#39044;&#26399;&#26159; sqrt(n) &#27604; &#26368;&#22909;&#30340; log(n) &#24046;&#24456;&#22810;&#12290;</strong>&#19981;&#36807;&#36825;&#19968;&#28857;&#22909;&#20687;&#36824;&#26159;&#22312;&#35828; degenerate&#8230;&#8230;</li>
</ul>
<p>&#21024;&#38500;&#25805;&#20316;&#27604;&#36739;&#40635;&#28902;&#65292;&#20998;&#19977;&#31181;&#24773;&#20917;&#65306;</p>
<ul>
<li>Deleting a node with no children: simply remove the node from the tree.</li>
<li>Deleting a node with one child: remove the node and replace it with its child.</li>
<li>Deleting a node with two children: call the node to be deleted N. Do not delete N. Instead, choose either its in-order successor node or its in-order predecessor node, R. Copy the value of R to N, then recursively call delete on R until reaching one of the first two cases. If you choose in-order successor of a node, as right sub tree is not NIL (Our present case is node has 2 children), then its in-order successor is node with least value in its right sub tree, which will have at a maximum of 1 sub tree, so deleting it would fall in one of the first 2 cases.</li>
</ul>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Binary_search_tree_delete.svg/960px-Binary_search_tree_delete.svg.png" alt="Deleting a node with two children from a binary search tree. First the rightmost node in the left subtree, the inorder predecessor 6, is identified. Its value is copied into the node being deleted. The inorder predecessor can then be easily deleted because it has at most one child. The same method works symmetrically using the inorder successor labelled 9. &#36825;&#20854;&#23454;&#26159;&#22312;&#25214;&#19968;&#20010;&#27604;&#21024;&#25481;&#33410;&#28857;&#65288;7&#65289;&#23567;&#65288;&#24403;&#28982;&#26159;&#23567;&#65289;&#20294;&#32463;&#21487;&#33021;&#22823;&#30340;&#33021;&#22815;&#25509;&#26367; 7 &#30340;&#24037;&#20316;&#30340;&#33410;&#28857;&#12290;&#36825;&#20010;&#33410;&#28857;&#22312;&#24038;&#36793;&#26368;&#21491;&#12290;&#36825;&#26159;&#22914;&#22270;&#25152;&#31034;&#12290;" />
<p class="caption">Deleting a node with two children from a binary search tree. First the rightmost node in the left subtree, the inorder predecessor 6, is identified. Its value is copied into the node being deleted. The inorder predecessor can then be easily deleted because it has at most one child. The same method works symmetrically using the inorder successor labelled 9. &#36825;&#20854;&#23454;&#26159;&#22312;&#25214;&#19968;&#20010;&#27604;&#21024;&#25481;&#33410;&#28857;&#65288;7&#65289;&#23567;&#65288;&#24403;&#28982;&#26159;&#23567;&#65289;&#20294;&#32463;&#21487;&#33021;&#22823;&#30340;&#33021;&#22815;&#25509;&#26367; 7 &#30340;&#24037;&#20316;&#30340;&#33410;&#28857;&#12290;&#36825;&#20010;&#33410;&#28857;&#22312;&#24038;&#36793;&#26368;&#21491;&#12290;&#36825;&#26159;&#22914;&#22270;&#25152;&#31034;&#12290;</p>
</div>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/43/BinaryTreeRotations.svg/450px-BinaryTreeRotations.svg.png" alt="Tree rotations are very common internal operations in binary trees to keep perfect, or near-to-perfect, internal balance in the tree." />
<p class="caption">Tree rotations are very common internal operations in binary trees to keep perfect, or near-to-perfect, internal balance in the tree.</p>
</div>
</dd>
</dl></li>
<li><dl>
<dt>Unique Binary Search Trees&#65292;&#22810;&#23569;&#20010;&#21464;&#24418;&#65311; <code class="fold">@</code></dt>
<dd><p>Given n, how many structurally unique BST&#8217;s (binary search trees) that store values 1&#8230;n?</p>
<p>For example, Given n = 3, there are a total of 5 unique BST&#8217;s.</p>
<pre><code>   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3</code></pre>
<pre><code>&#12304;&#25968;&#32452;&#20026; 1, 2, ... &#20197; i &#20026;&#26681;&#33410;&#28857;&#30340;&#26641;&#65292;&#24038;&#23376;&#26641;&#30001; `[i, i-1]` &#26500;&#25104;&#65292;&#21491;&#23376;&#26641;&#20026; `[i+1, n]` &#26500;&#25104;&#12290;&#12305;

&#22914;&#26524; n &#20026; 1&#65306;
                    1

&#22914;&#26524; n &#20026; 2&#65306;
                    1               &#25110;&#32773;        2
                     \                         /
                      2                       1

f(2) =  f(0) * f(1),    1 &#20026;&#26681;&#30340;&#24773;&#20917;
     +  f(1) * f(0),    2 &#20026;&#26681;

f(3) =  f(0) * f(2),    1 &#20026;&#26681;
     +  f(1) * f(1),    2 &#20026;&#26681;
     +  f(2) * f(0),    3 &#20026;&#26681;</code></pre>
<p>&#36882;&#25512;&#20844;&#24335;&#20026; <code>f(i) = sum{ f(k-1)*f(i-k) } for k = 1..i</code>&#65292;&#36825;&#26159;&#19968;&#20010;&#19968;&#32500;&#21160;&#24577;&#35268;&#21010;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> numTrees( <span class="dt">int</span> n ) {
    vector&lt;<span class="dt">int</span>&gt; f( n<span class="dv">+1</span>, <span class="dv">0</span> );
    f[<span class="dv">0</span>] = f[<span class="dv">1</span>] = <span class="dv">1</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= n; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> k = <span class="dv">1</span>; k &lt;= n; ++k ) {
            f[i] += f[k<span class="dv">-1</span>] * f[i-k];
        }
    }
    <span class="kw">return</span> f[n];
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/unique-binary-search-trees/">Unique Binary Search Trees | LeetCode OJ</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Validate Binary Search Tree <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> isValidBST( TreeNode *root ) {
    <span class="co">// leetcode &#30340; test case &#37324;&#26377; 0xFFFFFFFF &#21644; 0x7FFFFFFF&#65292;</span>
    <span class="co">// &#31616;&#21333;&#32771;&#34385;&#65292;&#30452;&#25509;&#21464;&#25104; long long &#20877;&#27604;&#36739;</span>
    <span class="kw">return</span> isValidBST( root, LLONG_MIN, LLONG_MAX );
}

<span class="co">// &#30475;&#26159;&#21542;&#22312;&#12304;&#30028;&#23450;&#12305;&#20043;&#20869;</span>
<span class="dt">bool</span> isValidBST( TreeNode *root, <span class="dt">long</span> <span class="dt">long</span> min, <span class="dt">long</span> <span class="dt">long</span> max ) {
    <span class="kw">if</span>( !root ) { <span class="kw">return</span> <span class="kw">true</span>; }
    <span class="dt">long</span> <span class="dt">long</span> val = root-&gt;val;
    <span class="kw">return</span> val &gt; min &amp;&amp; val &lt; max &amp;&amp;
           isValidBST( root-&gt;left,          min,  root-&gt;val ) &amp;&amp;
           isValidBST( root-&gt;right,   root-&gt;val,        max );
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/validate-binary-search-tree/">Validate Binary Search Tree | LeetCode OJ</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Convert Sorted Array to Binary Search Tree <code class="fold">@</code></dt>
<dd><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>dup problem, same idea. (&#24605;&#36335;&#26159;&#19968;&#26679;&#30340;&#65292;&#19981;&#36807;&#37027;&#36793;&#26356;&#30452;&#30333;&#12290;) &#39318;&#20808;&#35201;&#26126;&#30830;&#65292;<strong>&#36825;&#20010; BST &#19981;&#21807;&#19968;</strong>&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">TreeNode * sortedArrayToBST( vector&lt;<span class="dt">int</span>&gt; &amp;nums ) {
    <span class="kw">return</span> sortedArrayToBST( nums.begin(), nums.end() );
}
<span class="kw">template</span>&lt;<span class="kw">typename</span> RandomAccessIterator&gt;
TreeNode * sortedArrayToBST( RandomAccessIterator first, RandomAccessIterator last ) {
    <span class="kw">if</span>( length &lt;= <span class="dv">0</span> ) { <span class="kw">return</span> <span class="kw">nullptr</span>; }
    <span class="dt">const</span> <span class="kw">auto</span> length = distance( first, last );
    RandomAccessIterator mid = first + length/<span class="dv">2</span>;
    TreeNode *root = <span class="kw">new</span> TreeNode( *mid );
    root-&gt;left  = sortedArrayToBST( first, mid  );
    root-&gt;right = sortedArrayToBST( mid<span class="dv">+1</span>, last );
    <span class="kw">return</span> root;
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://articles.leetcode.com/convert-sorted-array-into-balanced">Convert Sorted Array to Balanced Binary Search Tree (BST) &#8211; LeetCode</a></li>
<li><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">Convert Sorted Array to Binary Search Tree | LeetCode OJ</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Convert Sorted List to Binary Search Tree <code class="fold">@</code></dt>
<dd><p>&#36825;&#37324;&#21644;&#19978;&#38754;&#19981;&#21516;&#30340;&#26159;&#65292;list &#19981;&#33021;&#38543;&#26426;&#23384;&#21462;&#12290;&#26368;&#30465;&#21147;&#30340;&#26041;&#27861;&#26159;&#65292;&#20808;&#25226; list &#36716;&#25104; array&#8230;&#8230;</p>
<p>&#19981;&#29992;&#36825;&#31181;&#21270;&#24402;&#30340;&#20599;&#25042;&#31574;&#30053;&#65292;&#26377;&#20004;&#31181;&#24605;&#36335;&#65306;</p>
<ul>
<li><dl>
<dt>&#20998;&#27835;&#27861;&#65292;&#33258;&#39030;&#21521;&#19979; O(n<sup>2</sup>)&#65292;O(logn) <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#20998;&#27835;&#27861;&#65292;&#31867;&#20284;&#20110; Convert Sorted Array to Binary Search Tree&#65292;</span>
<span class="co">// &#33258;&#39030;&#21521;&#19979;&#65292;&#26102;&#38388;&#22797;&#26434;&#24230;O(n^2)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230;O(logn)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    TreeNode *sortedListToBST( ListNode *head ) {
        <span class="kw">return</span> sortedListToBST( head, listLength(head) );
    }

    TreeNode *sortedListToBST( ListNode *head, <span class="dt">int</span> len ) {
        <span class="kw">if</span> (len == <span class="dv">0</span>) { <span class="kw">return</span> <span class="kw">nullptr</span>; }
        <span class="kw">if</span> (len == <span class="dv">1</span>) { <span class="kw">return</span> <span class="kw">new</span> TreeNode(head-&gt;val); }
        TreeNode *root = <span class="kw">new</span> TreeNode( nth_node (head, len / <span class="dv">2</span> + <span class="dv">1</span>)-&gt;val );
        root-&gt;left  = sortedListToBST( head,                         len / <span class="dv">2</span>     );
        root-&gt;right = sortedListToBST( nth_node(head, len / <span class="dv">2</span> + <span class="dv">2</span>), (len - <span class="dv">1</span>) / <span class="dv">2</span>);
        <span class="kw">return</span> root;
    }

    <span class="dt">int</span> listLength( ListNode *node ) {
        <span class="dt">int</span> n = <span class="dv">0</span>;
        <span class="kw">while</span>( node ) {
            node = node-&gt;next;
            ++n;
        }
        <span class="kw">return</span> n;
    }

    ListNode *nth_node( ListNode *node, <span class="dt">int</span> n ) {
        <span class="kw">while</span>( --n ) { node = node-&gt;next; }
        <span class="kw">return</span> node;
    }
};</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#33258;&#24213;&#21521;&#19978; O(n)&#65292;O(logn) &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>As usual, the best solution requires you <strong>to think from another perspective</strong>. In other words, we no longer create nodes in the tree using the top-down approach. We create nodes bottom-up, and &#12304;assign them to its parents&#12305;. The bottom-up approach enables us to access the list in its order while creating nodes.</p>
<p>Isn&#8217;t the bottom-up approach neat? Each time you are stucked with the top-down approach, give bottom-up a try. Although bottom-up approach is not the most natural way we think, it is extremely helpful in some cases. However, you should prefer top-down instead of bottom-up in general, since the latter is more difficult to verify in correctness.</p>
<p>Below is the code for converting a singly linked list to a balanced BST. Please note that the algorithm requires the list&#8217;s length to be passed in as the function&#8217;s parameters. The list&#8217;s length could be found in O(N) time by traversing the entire list&#8217;s once. The recursive calls traverse the list and create tree&#8217;s nodes by the list&#8217;s order, which also takes O(N) time. Therefore, the overall run time complexity is still O(N).</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">BinaryTree* sortedListToBST(ListNode *&amp; list, <span class="dt">int</span> start, <span class="dt">int</span> end) {
    <span class="kw">if</span> (start &gt; end) <span class="kw">return</span> NULL;
    <span class="dt">int</span> mid = start + (end - start) / <span class="dv">2</span>;        <span class="co">// same as (start+end)/2, avoids overflow</span>
    BinaryTree *leftChild = sortedListToBST(list, start, mid<span class="dv">-1</span>);
    BinaryTree *parent = <span class="kw">new</span> BinaryTree(list-&gt;data);
    parent-&gt;left = leftChild;
    list = list-&gt;next;
    parent-&gt;right = sortedListToBST(list, mid<span class="dv">+1</span>, end);
    <span class="kw">return</span> parent;
}

BinaryTree* sortedListToBST(ListNode *head, <span class="dt">int</span> n) {
    <span class="kw">return</span> sortedListToBST(head, <span class="dv">0</span>, n<span class="dv">-1</span>);
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#36825;&#26159;&#20160;&#20040;&#35299;&#27861;&#21602;&#65311; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Convert Sorted List to Binary Search Tree</span>
<span class="kw">class</span> Solution {
    ListNode *l;
    TreeNode *f(<span class="dt">int</span> n) {
        <span class="kw">if</span> (! n) <span class="kw">return</span> <span class="dv">0</span>;
        <span class="kw">auto</span> x = <span class="kw">new</span> TreeNode(<span class="dv">0</span>);
        x-&gt;left = f(n/<span class="dv">2</span>);
        x-&gt;val = l-&gt;val;
        l = l-&gt;next;
        x-&gt;right = f(n-n/<span class="dv">2-1</span>);
        <span class="kw">return</span> x;
    }
<span class="kw">public</span>:
    TreeNode *sortedListToBST(ListNode *head) {
        l = head;
        <span class="dt">int</span> n = <span class="dv">0</span>;
        <span class="kw">while</span> (head) {
            head = head-&gt;next;
            n++;
        }
        <span class="kw">return</span> f(n);
    }
};</code></pre></div>
</dd>
</dl></li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">Convert Sorted List to Binary Search Tree | LeetCode OJ</a></li>
<li><a href="http://articles.leetcode.com/convert-sorted-list-to-balanced-binary">Convert Sorted List to Balanced Binary Search Tree (BST) &#8211; LeetCode</a></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#20998;&#27835; Divide &amp; Conquer <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>pow(x, n) <code class="fold">@</code></dt>
<dd><p>&#23454;&#29616; power(x, n) &#21363; x<sup>n</sup></p>
<p>&#24605;&#36335;&#65306;</p>
<ul>
<li>n &#20026;&#22855;&#25968;&#65292;x<sup>n</sup> = x * x<sup>n-1</sup></li>
<li>n &#20026;&#20598;&#25968;&#65292;x<sup>n</sup> = x<sup>n/2</sup> * x<sup>n/2</sup></li>
</ul>
<p>&#25110;&#32773; x<sup>n</sup> = x<sup>n/2</sup> * x<sup>n/2</sup> * x<sup>n%2</sup></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Time: O(logn), Space: O(1)</span>
<span class="dt">double</span> pow( <span class="dt">double</span> x, <span class="dt">int</span> n ) {
    <span class="kw">if</span>( n &lt; <span class="dv">0</span>  ) { <span class="kw">return</span> <span class="fl">1.0</span> / pow( x, -n); }
    <span class="kw">if</span>( n == <span class="dv">0</span> ) { <span class="kw">return</span> <span class="fl">1.0</span>; }
    <span class="dt">double</span> v = pow( x, n/<span class="dv">2</span> );
    <span class="kw">if</span>( n%<span class="dv">2</span> == <span class="dv">0</span> ) {                    <span class="co">// divide &amp; conquer</span>
        <span class="kw">return</span> v * v;
    } <span class="kw">else</span> {
        <span class="kw">return</span> v * v * x;
    }
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>sqrt(x) <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> sqrt( <span class="dt">int</span> x ) {
    <span class="dt">int</span> left = <span class="dv">1</span>, right = x / <span class="dv">2</span> + <span class="dv">1</span>, mid;
    <span class="kw">if</span>( x &lt; <span class="dv">2</span> ) { <span class="kw">return</span> x; }                   <span class="co">// ?&lt;0-&gt;..., 0-&gt;0, 1-&gt;1</span>
    <span class="kw">while</span>( left &lt;= right ) {
        mid = (left+right)/<span class="dv">2</span>;
        <span class="kw">if</span>( x / mid &gt; mid ) {
            left = mid<span class="dv">+1</span>;
        } <span class="kw">else</span> <span class="kw">if</span> ( x / mid &lt; mid) {
            right = mid<span class="dv">-1</span>;
        } <span class="kw">else</span> {
            <span class="co">// 9/3 == 3, 10/3 == 3, 15/3 &gt; 3, so sqrt(15) = 4</span>
            <span class="kw">break</span>; <span class="co">// return mid;</span>
        }
    }
    <span class="kw">return</span> mid;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>chess covering <code class="fold">@</code></dt>
<dd><p>dup?</p>
<pre><code>input:

    3
    1
    2
    3

output:

    1
    5
    21</code></pre>
<p>&#26412;&#39064;&#30340;&#26827;&#30424;&#26159; 2<sup>k</sup> x 2<sup>k</sup>&#65292;&#24456;&#23481;&#26131;&#24819;&#21040;&#29992;&#20998;&#27835;&#27861;&#12290;&#25226;&#26827;&#30424;&#20999;&#25104; 4 &#22359;&#65292;&#21017;&#27599;&#19968;&#22359;&#37117;&#26159; 2<sup>k-1</sup> x 2<sup>k-1</sup> &#30340;&#12290;&#26377;&#40657;&#26684;&#30340;&#37027;&#19968;&#22359;&#21487;&#20197;&#36882;&#24402;&#35299;&#20915;&#65292;&#20294;&#20854;&#20182; 3 &#22359;&#24182;&#27809;&#26377;&#40657;&#26684;&#23376;&#65292;&#24212;&#35813;&#24590;&#20040;&#21150;&#21602;&#65311;&#21487;&#20197;&#26500;&#36896;&#20986;&#19968;&#20010;&#40657;&#26684;&#23376;&#65292;&#22312;&#20013;&#24515;&#25918;&#19968;&#20010; L &#22411;&#29260;&#65292;&#20854;&#23427; 3 &#22359;&#20063;&#21464;&#25104;&#20102;&#23376;&#38382;&#39064;&#12290;&#36882;&#24402;&#36793;&#30028;&#19981;&#38590;&#24471;&#20986;&#65292;&#24403; k=1 &#26102; 1 &#22359; L &#22411;&#29260;&#23601;&#22815;&#20102;&#12290;</p>
<p>&#26412;&#39064;&#21482;&#38656;&#35201;&#27714;&#24635;&#25968;&#65292;&#19981;&#38656;&#35201;&#27714;&#20855;&#20307;&#24590;&#20040;&#25670;&#25918;&#65292;&#22240;&#27492;&#31616;&#21270;&#24456;&#22810;&#12290;&#26681;&#25454;&#19978;&#38754;&#30340;&#24605;&#36335;&#65292;&#35774; f(k) &#34920;&#31034;&#26827;&#30424;&#26159; 2<sup>k</sup> x 2<sup>k</sup> &#26102;&#25152;&#38656; L &#22411;&#29260;&#30340;&#24635;&#25968;&#65292;&#21487;&#24471;&#36882;&#25512;&#20844;&#24335; f(k) = 4f(k-1)+1&#12290;</p>
<p>&#27880;&#24847;&#65292;2<sup>100</sup> &#26159;&#19968;&#20010;&#24456;&#22823;&#30340;&#25968;&#65292;&#26412;&#39064;&#38656;&#35201;&#22788;&#29702;&#22823;&#25968;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>schedule &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#26377; 2<sup>k</sup> &#20010;&#36816;&#21160;&#21592;&#21442;&#21152;&#24490;&#29615;&#27604;&#36187;&#65292;&#38656;&#35201;&#35774;&#35745;&#27604;&#36187;&#26085;&#31243;&#34920;&#12290;&#35201;&#27714;&#22914;&#19979;&#65306;</p>
<ul>
<li>&#27599;&#20010;&#36873;&#25163;&#24517;&#39035;&#19982;&#20854;&#20182; n-1 &#20010;&#36873;&#25163;&#21508;&#36187;&#19968;&#27425;</li>
<li>&#27599;&#20010;&#36873;&#25163;&#19968;&#22825;&#21482;&#33021;&#36187;&#19968;&#27425;</li>
<li>&#27604;&#36187;&#19968;&#20849;&#36827;&#34892; n-1 &#22825;</li>
</ul>
<p>&#25353;&#27492;&#35201;&#27714;&#35774;&#35745;&#19968;&#24352;&#27604;&#36187;&#26085;&#31243;&#34920;&#65292;&#23427;&#26377; n &#34892;&#21644; n-1 &#21015;&#65292;&#31532; i &#34892;&#31532; j &#21015;&#20026;&#31532; i &#20010;&#36873;&#25163;&#31532; j &#22825;&#36935;&#21040;&#30340;&#23545;&#25163;&#12290;</p>
<pre><code>input:

    &#21482;&#26377;&#19968;&#20010;&#25968; k&#65292;0 &lt; k &lt; 9&#65292;&#19988; k &#20026;&#33258;&#28982;&#25968;&#12290;

    1

output:

    &#19968;&#24352;&#27604;&#36187;&#26085;&#31243;&#34920;&#65292;&#23427;&#26377; n &#34892;&#21644; n-1 &#21015;
    &#65288;&#19981;&#31639;&#31532;&#19968;&#21015;&#65292;&#31532;&#19968;&#21015;&#34920;&#31034;&#36873;&#25163;&#30340;&#32534;&#21495;&#65289;&#65292;&#31532; i &#34892;&#31532;j &#21015;&#20026;
    &#31532; i &#20010;&#36873;&#25163;&#31532; j &#22825;&#36935;&#21040;&#30340;&#23545;&#25163;&#12290;&#30456;&#37051;&#30340;&#20004;&#20010;&#25972;&#25968;&#29992;&#31354;&#26684;&#38548;&#24320;&#12290;

    1 2
    2 1</code></pre>
<p>&#20998;&#26512;</p>
<p>&#26681;&#25454;&#20998;&#32780;&#27835;&#20043;&#30340;&#24605;&#24819;&#65292;&#21487;&#20174;&#20854;&#20013;&#19968;&#21322;&#36873;&#25163; (2<sup>k-1</sup> &#20301;) &#30340;&#27604;&#36187;&#26085;&#31243;&#65292;&#25512;&#23548;&#20986;&#20840;&#20307;&#36873;&#25163;&#30340;&#26085;&#31243;&#65292;&#26368;&#32456;&#32454;&#20998;&#21040;&#21482;&#26377;&#20004;&#20301;&#36873;&#25163;&#30340;&#27604;&#36187;&#26085;&#31243;&#12290;</p>
<p>&#25152;&#31034;&#26159; k=3 &#26102;&#30340;&#19968;&#20010;&#21487;&#34892;&#35299;&#65292;&#23427;&#26159;&#30001; 4 &#22359;&#25340;&#36215;&#26469;&#30340;&#12290;&#24038;&#19978;&#35282;&#26159; k=2 &#26102;&#30340;&#19968;&#32452;&#35299;&#65292;&#24038;&#19979;&#35282;&#26159;&#30001;&#24038;&#19978;&#35282;&#27599;&#20010;&#25968;&#21152; 4 &#24471;&#21040;&#65292;&#32780;&#21491;&#19978;&#35282;&#12289;&#21491;&#19979;&#35282;&#20998;&#21035;&#30001;&#24038;&#19979;&#35282;&#12289;&#24038;&#19978;&#35282;&#22797;&#21046;&#24471;&#21040;&#12290;</p>
<pre><code>1   2   3   4 | 5   6   7   8
2   1   4   3 | 6   5   8   7
3   4   1   2 | 7   8   5   6
4   3   2   1 | 8   7   6   5
--------------+--------------
5   6   7   8 | 1   2   3   4
6   5   8   7 | 2   1   4   3
7   8   5   6 | 3   4   1   2
8   7   6   5 | 4   3   2   1</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;stdio.h&gt;</span>
<span class="ot">#include&lt;stdlib.h&gt;</span>

<span class="ot">#define MAXN 512                    </span><span class="co">// N=2^k, 0&lt;k&lt;9</span>
<span class="dt">short</span> schedule[MAXN][MAXN];

<span class="dt">void</span> dc(<span class="dt">const</span> <span class="dt">int</span> k) {
    <span class="dt">int</span> i, j, t;
    <span class="dt">int</span> n, n2; <span class="co">/* &#24403;&#21069;&#30340;n&#65292;&#21363;&#23558;&#25193;&#23637;&#30340;n */</span>

    <span class="co">/* k=1&#65292;&#21363;&#20004;&#20010;&#20154;&#26102;&#65292;&#26085;&#31243;&#34920;&#21487;&#20197;&#30452;&#25509;&#20889;&#20986; */</span>
    n=<span class="dv">2</span>;
    schedule[<span class="dv">0</span>][<span class="dv">0</span>]=<span class="dv">1</span>; schedule[<span class="dv">0</span>][<span class="dv">1</span>]=<span class="dv">2</span>;
    schedule[<span class="dv">1</span>][<span class="dv">0</span>]=<span class="dv">2</span>; schedule[<span class="dv">1</span>][<span class="dv">1</span>]=<span class="dv">1</span>;

    <span class="co">// &#36845;&#20195;&#22788;&#29702;&#65292;&#20381;&#27425;&#22788;&#29702;2^2....2^k&#20010;&#36873;&#25163;&#30340;&#27604;&#36187;&#26085;&#31243;</span>
    <span class="kw">for</span>(t = <span class="dv">1</span>; t &lt; k; t++, n *= <span class="dv">2</span>) {
        n2 = n * <span class="dv">2</span>;
        <span class="co">//&#22635;&#24038;&#19979;&#35282;&#20803;&#32032;</span>
        <span class="kw">for</span>(i = n; i &lt; n2; i++)
            <span class="kw">for</span>(j = <span class="dv">0</span>; j &lt; n; j++)
                schedule[i][j] = schedule[i-n][j] + n;

        <span class="co">//&#23558;&#24038;&#19979;&#35282;&#20803;&#32032;&#25220;&#21040;&#21491;&#19978;&#35282;</span>
        <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; n; i++)
            <span class="kw">for</span>(j = n; j &lt; n2; j++)
                schedule[i][j] = schedule[i+n][j-n];

        <span class="co">//&#23558;&#24038;&#19978;&#35282;&#20803;&#32032;&#25220;&#21040;&#21491;&#19979;&#35282;</span>
        <span class="kw">for</span>(i = n; i &lt; n2; i++)
            <span class="kw">for</span>(j = n;j &lt; n2; j++)
                schedule[i][j] = schedule[i-n][j-n];
    }
}

<span class="co">/* &#21478;&#19968;&#20010;&#29256;&#26412; */</span>
<span class="dt">void</span> dc2(<span class="dt">const</span> <span class="dt">int</span> k) {
    <span class="dt">int</span> i, j, r;
    <span class="dt">int</span> n;
    <span class="dt">const</span> <span class="dt">int</span> N = <span class="dv">1</span> &lt;&lt; k;

    <span class="co">/* &#31532;&#19968;&#21015;&#26159;&#36873;&#25163;&#30340;&#32534;&#21495; */</span>
    <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; N; i++) schedule[i][<span class="dv">0</span>] = i + <span class="dv">1</span>;
    schedule[<span class="dv">0</span>][<span class="dv">1</span>] = <span class="dv">1</span>;  <span class="co">/* &#24403; k=0&#26102;&#65292;&#21482;&#26377;&#19968;&#20010;&#20154; */</span>

    <span class="kw">for</span> (n = <span class="dv">2</span>; n &lt;= N; n *= <span class="dv">2</span>) {  <span class="co">/* &#26041;&#22359;&#22823;&#23567;, 2, 4, 8 */</span>
        <span class="dt">const</span> <span class="dt">int</span> half = n / <span class="dv">2</span>;
        <span class="kw">for</span> (r = <span class="dv">0</span>; r &lt; N; r += n) { <span class="co">/* &#26041;&#22359;&#25152;&#22312;&#34892; */</span>
            <span class="kw">for</span> (i = r; i &lt;= r + half <span class="dv">-1</span>; i++) {  <span class="co">/* &#24038;&#19978;&#35282;&#23567;&#26041;&#22359;&#30340;&#25152;&#26377;&#34892; */</span>
                <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; half; j++) {  <span class="co">/* &#24038;&#19978;&#35282;&#23567;&#26041;&#22359;&#30340;&#25152;&#26377;&#34892; */</span>
                    <span class="co">/* &#21491;&#19979;&#35282; &lt;-- &#24038;&#19978;&#35282; */</span>
                    schedule[i + half][j + half] = schedule[i][j];
                    <span class="co">/* &#21491;&#19978;&#35282; &lt;-- &#24038;&#19979;&#35282; */</span>
                    schedule[i][j + half] = schedule[i + half][j];
                }
            }
        }
    }
}

<span class="dt">int</span> main(){
    <span class="dt">int</span> k, N;
    <span class="dt">int</span> i,j;

    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;k);
    N = <span class="dv">1</span> &lt;&lt; k;

    dc(k);
    <span class="co">// dc2(k);</span>

    <span class="co">// &#36755;&#20986;&#26085;&#31243;&#34920;</span>
    <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; N; i++) {
        <span class="kw">for</span>(j = <span class="dv">0</span>; j &lt; N; j++) printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, schedule[i][j]);
        printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="http://cslibrary.stanford.edu/110/BinaryTrees.html">Binary Trees</a></li>
<li><a href="https://en.wikipedia.org/wiki/Binary_search_tree">Binary search tree - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms">Divide and conquer algorithms - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/00/00 &#19978;&#21320; 9:30:00 0. Sortings <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>util: print.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>

<span class="dt">void</span> print( <span class="dt">int</span> A[], <span class="dt">int</span> n, <span class="dt">const</span> <span class="dt">char</span> *msg = <span class="dv">0</span> ) {
    <span class="kw">using</span> <span class="kw">namespace</span> std;
    <span class="dt">int</span> h = *max_element(A, A+n);
    <span class="kw">if</span>( h &gt;= <span class="dv">10</span> ) { <span class="kw">return</span>; }
    <span class="kw">if</span>( msg ) { printf( <span class="st">&quot;==== </span><span class="ch">%s</span><span class="st"> ====</span><span class="ch">\n</span><span class="st">&quot;</span>, msg ); }
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n<span class="dv">+1</span>; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; h; ++j ) {
            <span class="kw">if</span>( i + A[j] == h<span class="dv">+1</span> ) {
                printf( <span class="st">&quot; |</span><span class="ch">%d</span><span class="st">| &quot;</span>, A[j] );
            } <span class="kw">else</span> <span class="kw">if</span>( i+A[j] &lt; h<span class="dv">+1</span> ) {
                printf( <span class="st">&quot;     &quot;</span> );
            } <span class="kw">else</span> {
                printf( <span class="st">&quot; |X| &quot;</span> );
            }
        }
        printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
    }
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) { printf( <span class="st">&quot;-----&quot;</span> ); }     printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) { printf( <span class="st">&quot;  </span><span class="ch">%d</span><span class="st">  &quot;</span>, i ); } printf( <span class="st">&quot;</span><span class="ch">\t</span><span class="st">(index)</span><span class="ch">\n\n\n</span><span class="st">&quot;</span> );
}</code></pre></div>
<p>effect</p>
<pre><code>                            |9|
                            |X|                 |8|
                            |X|                 |X|  |7|
                       |6|  |X|                 |X|  |X|
                       |X|  |X|  |5|            |X|  |X|
                       |X|  |X|  |X|       |4|  |X|  |X|
                  |3|  |X|  |X|  |X|       |X|  |X|  |X|
             |2|  |X|  |X|  |X|  |X|       |X|  |X|  |X|
             |X|  |X|  |X|  |X|  |X|  |1|  |X|  |X|  |X|
            ---------------------------------------------
              0    1    2    3    4    5    6    7    8     (index)</code></pre>
</dd>
</dl></li>
<li><dl>
<dt>insertion sort <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>straight insertion sort <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-22-49-insert.gif" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &quot;print.cpp&quot;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">void</span> straight_insertion_sort( <span class="dt">int</span> A[], <span class="dt">const</span> <span class="dt">int</span> start, <span class="dt">const</span> <span class="dt">int</span> end ) {
    <span class="dt">int</span> tmp;
    <span class="dt">int</span> i, j;

    <span class="co">// insert ith element</span>
    <span class="kw">for</span> (i = start + <span class="dv">1</span>; i &lt; end; i++) {
        tmp = A[i];
        <span class="kw">for</span> (j = i - <span class="dv">1</span>; j &gt;= start &amp;&amp; tmp &lt; A[j]; j--) {    <span class="co">// to the left</span>
            A[j + <span class="dv">1</span>] = A[j];                                <span class="co">// j-&gt;j+1</span>
        }
        A[j + <span class="dv">1</span>] = tmp;
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> A[] = { <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">9</span>, <span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">8</span>, <span class="dv">7</span>  };
    <span class="dt">int</span> n = <span class="kw">sizeof</span>(A)/<span class="kw">sizeof</span>(A[<span class="dv">0</span>]);
    straight_insertion_sort( A, <span class="dv">0</span>, n );
}</code></pre></div>
<p>which is better, why?</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span>( <span class="dt">int</span> j = i - <span class="dv">1</span>; j &gt;= start &amp;&amp; tmp &lt; A[j]; --j ) {   <span class="co">// good</span>
    A[j + <span class="dv">1</span>] = A[j];
}

<span class="kw">for</span>( <span class="dt">int</span> j = i - <span class="dv">1</span>; j &gt;= start &amp;&amp; tmp &lt; A[j]; ) {
    A[j + <span class="dv">1</span>] = A[j];
    --j;                                                <span class="co">// better in some aspect</span>
}</code></pre></div>
<dl>
<dt>pretty output <code class="fold">@</code></dt>
<dd><pre><code>==== before sorting ====

                |9|
                |X|                 |8|
                |X|                 |X|  |7|
           |6|  |X|                 |X|  |X|
           |X|  |X|  |5|            |X|  |X|
           |X|  |X|  |X|       |4|  |X|  |X|
 |3|       |X|  |X|  |X|       |X|  |X|  |X|
 |X|  |2|  |X|  |X|  |X|       |X|  |X|  |X|
 |X|  |X|  |X|  |X|  |X|  |1|  |X|  |X|  |X|
---------------------------------------------
  0    1    2    3    4    5    6    7    8     (index)

==== i: 1, j+1: 0 ====

                |9|
                |X|                 |8|
                |X|                 |X|  |7|
           |6|  |X|                 |X|  |X|
           |X|  |X|  |5|            |X|  |X|
           |X|  |X|  |X|       |4|  |X|  |X|
      |3|  |X|  |X|  |X|       |X|  |X|  |X|
 |2|  |X|  |X|  |X|  |X|       |X|  |X|  |X|
 |X|  |X|  |X|  |X|  |X|  |1|  |X|  |X|  |X|
---------------------------------------------
  0    1    2    3    4    5    6    7    8     (index)

==== i: 2, j+1: 2 ====

                |9|
                |X|                 |8|
                |X|                 |X|  |7|
           |6|  |X|                 |X|  |X|
           |X|  |X|  |5|            |X|  |X|
           |X|  |X|  |X|       |4|  |X|  |X|
      |3|  |X|  |X|  |X|       |X|  |X|  |X|
 |2|  |X|  |X|  |X|  |X|       |X|  |X|  |X|
 |X|  |X|  |X|  |X|  |X|  |1|  |X|  |X|  |X|
---------------------------------------------
  0    1    2    3    4    5    6    7    8     (index)

==== i: 3, j+1: 3 ====

                |9|
                |X|                 |8|
                |X|                 |X|  |7|
           |6|  |X|                 |X|  |X|
           |X|  |X|  |5|            |X|  |X|
           |X|  |X|  |X|       |4|  |X|  |X|
      |3|  |X|  |X|  |X|       |X|  |X|  |X|
 |2|  |X|  |X|  |X|  |X|       |X|  |X|  |X|
 |X|  |X|  |X|  |X|  |X|  |1|  |X|  |X|  |X|
---------------------------------------------
  0    1    2    3    4    5    6    7    8     (index)

==== i: 4, j+1: 2 ====

                     |9|
                     |X|            |8|
                     |X|            |X|  |7|
                |6|  |X|            |X|  |X|
           |5|  |X|  |X|            |X|  |X|
           |X|  |X|  |X|       |4|  |X|  |X|
      |3|  |X|  |X|  |X|       |X|  |X|  |X|
 |2|  |X|  |X|  |X|  |X|       |X|  |X|  |X|
 |X|  |X|  |X|  |X|  |X|  |1|  |X|  |X|  |X|
---------------------------------------------
  0    1    2    3    4    5    6    7    8     (index)

==== i: 5, j+1: 0 ====

                          |9|
                          |X|       |8|
                          |X|       |X|  |7|
                     |6|  |X|       |X|  |X|
                |5|  |X|  |X|       |X|  |X|
                |X|  |X|  |X|  |4|  |X|  |X|
           |3|  |X|  |X|  |X|  |X|  |X|  |X|
      |2|  |X|  |X|  |X|  |X|  |X|  |X|  |X|
 |1|  |X|  |X|  |X|  |X|  |X|  |X|  |X|  |X|
---------------------------------------------
  0    1    2    3    4    5    6    7    8     (index)

==== i: 6, j+1: 3 ====

                               |9|
                               |X|  |8|
                               |X|  |X|  |7|
                          |6|  |X|  |X|  |X|
                     |5|  |X|  |X|  |X|  |X|
                |4|  |X|  |X|  |X|  |X|  |X|
           |3|  |X|  |X|  |X|  |X|  |X|  |X|
      |2|  |X|  |X|  |X|  |X|  |X|  |X|  |X|
 |1|  |X|  |X|  |X|  |X|  |X|  |X|  |X|  |X|
---------------------------------------------
  0    1    2    3    4    5    6    7    8     (index)

==== i: 7, j+1: 6 ====

                                    |9|
                               |8|  |X|
                               |X|  |X|  |7|
                          |6|  |X|  |X|  |X|
                     |5|  |X|  |X|  |X|  |X|
                |4|  |X|  |X|  |X|  |X|  |X|
           |3|  |X|  |X|  |X|  |X|  |X|  |X|
      |2|  |X|  |X|  |X|  |X|  |X|  |X|  |X|
 |1|  |X|  |X|  |X|  |X|  |X|  |X|  |X|  |X|
---------------------------------------------
  0    1    2    3    4    5    6    7    8     (index)

==== i: 8, j+1: 6 ====

                                         |9|
                                    |8|  |X|
                               |7|  |X|  |X|
                          |6|  |X|  |X|  |X|
                     |5|  |X|  |X|  |X|  |X|
                |4|  |X|  |X|  |X|  |X|  |X|
           |3|  |X|  |X|  |X|  |X|  |X|  |X|
      |2|  |X|  |X|  |X|  |X|  |X|  |X|  |X|
 |1|  |X|  |X|  |X|  |X|  |X|  |X|  |X|  |X|
---------------------------------------------
  0    1    2    3    4    5    6    7    8     (index)

==== after sorting ====

                                         |9|
                                    |8|  |X|
                               |7|  |X|  |X|
                          |6|  |X|  |X|  |X|
                     |5|  |X|  |X|  |X|  |X|
                |4|  |X|  |X|  |X|  |X|  |X|
           |3|  |X|  |X|  |X|  |X|  |X|  |X|
      |2|  |X|  |X|  |X|  |X|  |X|  |X|  |X|
 |1|  |X|  |X|  |X|  |X|  |X|  |X|  |X|  |X|
---------------------------------------------
  0    1    2    3    4    5    6    7    8     (index)</code></pre>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>binary insertion sort <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> straight_insertion_sort( <span class="dt">int</span> A[], <span class="dt">const</span> <span class="dt">int</span> start, <span class="dt">const</span> <span class="dt">int</span> end ) {
    <span class="dt">int</span> tmp;
    <span class="dt">int</span> i, j;
    <span class="kw">for</span> (i = start + <span class="dv">1</span>; i &lt; end; i++) {
        tmp = A[i];
        <span class="dt">int</span> left = start, right = i<span class="dv">-1</span>, mid;
        <span class="kw">while</span>( left &lt;= right ) {
            mid = (left+right)/<span class="dv">2</span>;
            <span class="kw">if</span>( tmp &lt; A[mid] ) {
                right = mid - <span class="dv">1</span>;
            } <span class="kw">else</span> {
                left = mid + <span class="dv">1</span>;     <span class="co">// &#22823;&#20110;&#25110;&#32773;&#31561;&#20110;&#65292;&#37117;&#21521;&#21491;&#20542;&#26012;</span>
            }
        }
        <span class="kw">for</span>( j = i - <span class="dv">1</span>; j &gt;= left; --j ) {
            A[j + <span class="dv">1</span>] = A[j];
        }
        A[left] = tmp;
    }
}</code></pre></div>
<pre><code>+-------------------------------+
|   find 4                      |
|                       R   L   |
|   0   1   2   4   4   4   6   |
|                           ^   |
+-------------------------------+

L=0, R=6        -&gt;      M=3

L           M           R
0   1   2   4   4   4   6

                L   M   R               target &gt;= a[M], L=M+1
0   1   2   4   4   4   6

                        L
                        M
                        R               target &lt;  a[M], R=M-1
0   1   2   4   4   4   6

                    R   L               a[R] == 4
0   1   2   4   4   4   6</code></pre>
</dd>
</dl></li>
<li><dl>
<dt>shell insertion sort <code class="fold">@</code></dt>
<dd><p>&#20174;&#23545;&#30452;&#25509;&#25554;&#20837;&#25490;&#24207;&#30340;&#20998;&#26512;&#24471;&#30693;&#65292;&#20854;&#31639;&#27861;&#26102;&#38388;&#22797;&#26434;&#24230;&#20026; <code>O(n^2^)</code>&#65292;&#20294;&#26159;&#65292;&#33509;&#24453;&#25490;&#24207;&#35760;&#24405;&#24207;&#21015;&#20026;&#8220;&#27491;&#24207;&#8221;&#26102;&#65292;&#20854;&#26102;&#38388;&#22797;&#26434;&#24230;&#21487;&#25552;&#39640;&#33267; O(n)&#12290;</p>
<pre><code>&#30001;&#27492;&#21487;&#35774;&#24819;&#65292;&#33509;&#24453;&#25490;&#24207;&#35760;&#24405;&#24207;&#21015;&#25353;&#20851;&#38190;&#23383;&#8220;&#22522;&#26412;&#26377;&#24207;&#8221;&#65292;
&#21363;&#24207;&#21015;&#20013;&#20855;&#26377;&#19979;&#21015;&#29305;&#24615; `R~i~.key &lt; max{ R~j~.key }`, j&lt;i &#30340;
&#35760;&#24405;&#36739;&#23569;&#26102;&#65292;&#30452;&#25509;&#25554;&#20837;&#25490;&#24207;&#30340;&#25928;&#29575;&#23601;&#21487;&#22823;&#22823;&#25552;&#39640;&#12290;

&#20174;&#21478;&#19968;&#26041;&#38754; &#26469;&#30475;&#65292;&#30001;&#20110;&#30452;&#25509;&#25554;&#20837;&#25490;&#24207;&#31639;&#27861;&#31616;&#21333;&#65292;&#21017;&#22312; n &#20540;&#24456;&#23567;&#26102;&#25928;&#29575;&#20063;&#27604;
&#36739;&#39640;&#12290;&#24076;&#23572;&#25490;&#24207;&#27491;&#26159;&#20174;&#36825;&#20004;&#28857;&#20998;&#26512;&#20986;&#21457;&#23545;&#30452;&#25509;&#25554;&#20837;&#25490;&#24207;&#36827;&#34892;&#25913;
&#36827;&#24471;&#21040;&#30340;&#19968;&#31181;&#25554;&#20837;&#25490;&#24207;&#26041;&#27861;&#12290;

&#24076;&#23572;&#25490;&#24207; (Shell Sort) &#30340;&#22522;&#26412;&#24605;&#24819;&#26159;&#65306;&#35774;&#24453;&#25490;&#24207;&#20803;&#32032;&#24207;
&#21015;&#26377; n &#20010;&#20803;&#32032;&#65292;&#39318;&#20808;&#21462;&#19968;&#20010;&#25972;&#25968; gap = n/3+1 &#20316;&#20026;&#38388;&#38548;&#65292;
&#23558;&#20840;&#37096;&#20803;&#32032;&#20998;&#20026; gap &#20010;&#23376;&#24207;&#21015;&#65292;&#25152;&#26377;&#36317;&#31163;&#20026; gap &#30340;&#20803;&#32032;&#25918;&#22312;
&#21516;&#19968;&#20010;&#23376;&#24207;&#21015;&#20013;&#65292;&#22312;&#27599;&#19968;&#20010;&#23376;&#24207;&#21015;&#20013;&#20998;&#21035;&#26045;&#34892;&#30452;&#25509;&#25554;&#20837;&#25490;
&#24207;&#12290;&#28982;&#21518;&#32553;&#23567;&#38388;&#38548; gap&#65292;&#21462; gap = n/3+1, &#37325;&#22797;&#19978;&#36848;&#30340;&#23376;&#24207;&#21015;
&#21010;&#20998;&#21644;&#25490;&#24207;&#24037;&#20316;&#65292;&#30452;&#21040;&#26368;&#21518;&#21462; gap = 1&#65292;&#23558;&#25152;&#26377;&#20803;&#32032;&#25918;&#22312;&#21516;&#19968;
&#20010;&#24207;&#21015;&#20013;&#25490;&#24207;&#20026;&#27490;&#12290;

```cpp
// &#21644;&#19968;&#36255;&#30452;&#25509;&#25554;&#20837;&#25490;&#24207;&#30456;&#27604;&#65292;&#20165;&#26377;&#19968;&#28857;&#19981;&#21516;&#65292;&#23601;&#26159;&#21069;&#21518;&#20803;&#32032;&#30340;&#38388;&#36317;&#26159; gap &#32780;&#19981;&#26159; 1
// [start, end)
// gap &#38388;&#38548;
static void shell_insert( int A[], const int start, const int end, const int gap ) {
    int tmp;
    int i, j;
    for( int i = start + gap; i &lt; end; ++i ) {
        tmp = A[i];
        for( int j = i - gap; j&gt;=start &amp;&amp; A[j] &gt; tmp; j -= gap ) {
            A[j + gap] = A[j];
        }
        A[j + gap] = tmp;
    }
}

void shell_sort( int A[], const int start, const int end ) {
    int gap = end - start;
    while( gap &gt; 1 ) {
        gap = gap / 3 + 1;
        shell_insert( A, start, end, gap );
    }
}
```

if `gap &lt;- gap/3+1 &gt; 1`, then it&#39;s buggy.

```
gap: 4 2 1
gap: 5 2 1
gap: 7 3 2 1
gap: 8 3 2 1
gap: 9 4 2 1
```</code></pre>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>exchange sort <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>bubble sort <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> bubble_sort( <span class="dt">int</span> A[], <span class="dt">const</span> <span class="dt">int</span> start, <span class="dt">const</span> <span class="dt">int</span> end ) {
    <span class="dt">int</span> exchange;
    <span class="dt">int</span> tmp;
    <span class="co">// i is the element to set, in this loop</span>
    <span class="kw">for</span> ( <span class="dt">int</span> i = start; i &lt; end - <span class="dv">1</span>; i++) {
        exchange = <span class="dv">0</span>;
        <span class="kw">for</span> ( <span class="dt">int</span> j = end - <span class="dv">1</span>; j &gt; i; j--) {        <span class="co">// &#21457;&#29983;&#36870;&#24207;&#65292;&#20132;&#25442;</span>
            <span class="kw">if</span> (A[j - <span class="dv">1</span>] &gt; A[j]) {
                tmp = A[j - <span class="dv">1</span>];
                A[j - <span class="dv">1</span>] = A[j];
                A[j] = tmp;
                exchange = <span class="dv">1</span>;
            }
        }
        <span class="kw">if</span>( exchange == <span class="dv">0</span> ) { <span class="kw">return</span>; }             <span class="co">// &#26412;&#36255;&#26080;&#36870;&#24207;&#65292;&#20572;&#27490;&#22788;&#29702;</span>
    }
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>quick sort <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-25-47-quick.gif" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> quick_sort( <span class="dt">int</span> A[], <span class="dt">const</span> <span class="dt">int</span> start, <span class="dt">const</span> <span class="dt">int</span> end ) {
    <span class="kw">if</span>( start &lt; end - <span class="dv">1</span> ) {                                     <span class="co">// &#33267;&#23569;&#20004;&#20010;&#20803;&#32032;</span>
        <span class="dt">const</span> <span class="dt">int</span> pivot_pos = partition( A, start, end );
        quick_sort( A, start, pivot_pos );
        quick_sort( A, pivot_pos + <span class="dv">1</span>, end );
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> partition( <span class="dt">int</span> A[], <span class="dt">const</span> <span class="dt">int</span> start, <span class="dt">const</span> <span class="dt">int</span> end ) {
    <span class="dt">int</span> i = start;
    <span class="dt">int</span> j = end - <span class="dv">1</span>;
    <span class="dt">const</span> <span class="dt">int</span> pivot = A[i];

    <span class="kw">while</span>( i &lt; j ) {
        <span class="kw">while</span>( j &gt; i &amp;&amp; A[j] &gt;= pivot ) { j--; }    <span class="co">// no need to move to left</span>
        A[i] = A[j];                                <span class="co">// move</span>
        <span class="kw">while</span>( i &lt; j &amp;&amp; A[i] &lt;= pivot ) { i++; }    <span class="co">// no need to move to right</span>
        A[j] = A[i];                                <span class="co">// move to right</span>
    }
    A[i] = pivot;
    <span class="kw">return</span> i;
}</code></pre></div>
<pre><code>log:
            -------------------------------------
            p0:  3  2   6   9   5   1   4   8   7
            p1:  1  2   3   9   5   6   4   8   7
            ------------+------------------------
            p0:  1  2   |
            p1:  1  2   |
            ------------+------------------------
            p0:         |   9   5   6   4   8   7
            p1:         |   7   5   6   4   8   9
            ------------+-----------------------+
            p0:             7   5   6   4   8   |
            p1:             4   5   6   7   8   |
            ----------------------------+-------+
            p0:             4   5   6   |
            p1:             4   5   6   |
            ----------------+-----------+--------
            p0:             |   5   6
            p1:             |   5   6
            ----------------+--------------------

analysis

    pivot = 3
    ---------

            3   2   6   9   5   1   4   8   7
            i=0                             j=8         --j
                                        j=7             --j
                                    j=6                 --j
                                j=5
            1   2   6   9   5   1   4   8   7           A[i=0]  =   A[j=5]  = 1
            i=0                                         ++i
                i=1                                     ++i
                    i=2
            1   2   6   9   5   6   4   8   7           A[j=5]  =   A[i=2]  = 6
                    i=2         j=5                     i &lt; j   -&gt;  true, loop, --j
                            j=4                         --j
                        j=3                             --j
                    j=2                                 A[i=2]  =   A[j=2]  = 6
            1   2   6   9   5   6   4   8   7           i &lt; j   -&gt; false, loop end
            1   2   3   9   5   6   4   8   7           A[i]    =   pivot

    pivot = 1
    ---------

            1   2
            i=0 j=1                                     --j
            j=0
            1   2                                       A[i=0]  =   A[j=0]
            1   2                                       A[i=0]  =   A[j=0]
            1   2                                       i &lt; j   -&gt;  false
            1   2                                       A[i=0]  =   pivot

    pivot = 9
    ---------

            9   5   6   4   8   7
            i=0                 j=5
            7   5   6   4   8   7                       A[i=0]  =   A[j=5]  = 7
            i=0                                         ++i
                i=1                                     ++i
                    i=2                                 ++i
                        i=3                             ++i
                            i=4                         ++i
                                i=5
            7   5   6   4   8   7
                                i=5
                                j=5                     i &lt; j   -&gt;  false
            7   5   6   4   8   9                       A[i=5]  =   pivot   = 9

    p1:  7 5 6 4 8 9

    p0:  7 5 6 4 8
    p1:  4 5 6 7 8

    p0:  4 5 6
    p1:  4 5 6

    p0:  5 6
    p1:  5 6</code></pre>
<p>refs and see also</p>
<ul>
<li><a href="http://www.cnblogs.com/morewindows/archive/2011/08/13/2137415.html">&#30333;&#35805;&#32463;&#20856;&#31639;&#27861;&#31995;&#21015;&#20043;&#20845; &#24555;&#36895;&#25490;&#24207; &#24555;&#36895;&#25630;&#23450; - MoreWindows - &#21338;&#23458;&#22253;</a></li>
<li><a href="https://github.com/soulmachine/acm-cheat-sheet/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">&#24555;&#36895;&#25490;&#24207; &#183; soulmachine/acm-cheat-sheet Wiki &#183; GitHub</a></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>selection sort <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>simple selection sort <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-19-47-select.gif" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> simple_selection_sort( <span class="dt">int</span> A[], <span class="dt">int</span> start, <span class="dt">int</span> end ) {
    <span class="dt">int</span> tmp;

    <span class="co">// A[i] will be put at right position</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = start; i &lt; end; ++i ) {
        <span class="dt">int</span> k = i;
        <span class="kw">for</span>( <span class="dt">int</span> j = i + <span class="dv">1</span>; j &lt; end; ++j ) {
            <span class="kw">if</span>( A[j] &lt; A[k] ) { k = j; }          <span class="co">// &#22312; a[i] &#21040; a[end-1] &#20013;&#23547;&#25214;&#26368;&#23567;&#20803;&#32032;</span>
        }
        <span class="kw">if</span>( k != i ) {
            tmp = A[i]; A[i] = A[k]; A[k]= tmp;
        }
    }
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>heap sort <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-52-11-heap-sort.gif" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &quot;heap.c&quot;</span>

<span class="dt">int</span> cmp( <span class="dt">const</span> <span class="dt">int</span> *x, <span class="dt">const</span> <span class="dt">int</span> *y ) {
    <span class="dt">int</span> sub = *x - *y;
    <span class="kw">return</span> sub &lt; <span class="dv">0</span> ? <span class="dv">1</span> : sub &gt; <span class="dv">0</span> ? <span class="dv">-1</span> : <span class="dv">0</span>;
}

<span class="dt">void</span> heap_sort( <span class="dt">int</span> *a, <span class="dt">const</span> <span class="dt">int</span> n, <span class="dt">int</span> (*cmp)(<span class="dt">const</span> <span class="dt">int</span> *, <span class="dt">const</span> <span class="dt">int</span> *) ) {
    heap_t h;
    h.cmp = cmp;
    h.elems = a;
    h.size = h.capacity = n;

    <span class="dt">int</span> i = (h.size - <span class="dv">2</span>)/<span class="dv">2</span>;             <span class="co">// &#25214;&#26368;&#21021;&#35843;&#25972;&#20301;&#32622;&#65306;&#26368;&#21518;&#20998;&#25903;&#32467;&#28857;</span>
    <span class="kw">while</span>( i &gt;= <span class="dv">0</span> ) {                   <span class="co">// &#33258;&#24213;&#21521;&#19978;&#36880;&#27493;&#25193;&#22823;&#24418;&#25104;&#22534;</span>
        heap_sift_down( &amp;h, i );
        --i;
    }

    <span class="dt">int</span> tmp;
    <span class="kw">for</span>( <span class="dt">int</span> i = h.size - <span class="dv">1</span>; i &gt; <span class="dv">0</span>; --i ) {
        tmp = h.elems[i]; h.elems[i] = h.elems; h.elems = tmp;
        h.size = i;                     <span class="co">// &#30456;&#24403;&#20110; --h.size</span>
        heap_sift_down( &amp;h, <span class="dv">0</span> );
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> A[] = { <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">9</span>, <span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">8</span>, <span class="dv">7</span>  };
    <span class="dt">int</span> n = <span class="kw">sizeof</span>(A)/<span class="kw">sizeof</span>(A[<span class="dv">0</span>]);
    heap_sort( A, n, &amp;cmp );
}</code></pre></div>
<pre><code> 3 2 6 9 5 1 4 8 7
before sift at 3
 3 2 6 9 5 1 4 8 7
 3 2 6 9 5 1 4 8 7
before sift at 2
 3 2 6 9 5 1 4 8 7
 3 2 6 9 5 1 4 8 7
before sift at 1
 3 2 6 9 5 1 4 8 7
 3 9 6 8 5 1 4 2 7
before sift at 0
 3 9 6 8 5 1 4 2 7
 9 8 6 7 5 1 4 2 3
before sift at 0
 3 8 6 7 5 1 4 2
 8 7 6 3 5 1 4 2
before sift at 0
 2 7 6 3 5 1 4
 7 5 6 3 2 1 4
before sift at 0
 4 5 6 3 2 1
 6 5 4 3 2 1
before sift at 0
 1 5 4 3 2
 5 3 4 1 2
before sift at 0
 2 3 4 1
 4 3 2 1
before sift at 0
 1 3 2
 3 1 2
before sift at 0
 2 1
 2 1
before sift at 0
 1
 1
 1 2 3 4 5 6 7 8 9</code></pre>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>merge sort <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//  input: tmp[i/j]</span>
<span class="co">//                         start       mid         end</span>
<span class="co">//                           ^          ^</span>
<span class="co">//                          [i]        [j]</span>
<span class="co">//                            \        /</span>
<span class="co">//                              \     /</span>
<span class="co">//                                \ /</span>
<span class="co">//                                 +</span>
<span class="co">//  output:  A[i/j]                |</span>
<span class="co">//                         start   |   mid         end</span>
<span class="co">//                           ^     |</span>
<span class="co">//                           |     |</span>
<span class="co">//                          [k]--&lt;-+</span>
<span class="co">//</span>
<span class="dt">static</span> <span class="dt">void</span> merge( <span class="dt">int</span> A[], <span class="dt">int</span> tmp[],
                   <span class="dt">const</span> <span class="dt">int</span> start,
                   <span class="dt">const</span> <span class="dt">int</span> mid,
                   <span class="dt">const</span> <span class="dt">int</span> end )
{
    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; end; ++i ) {
        tmp[i] = A[i];
    }

    <span class="dt">int</span> i, j, k;
    <span class="kw">for</span>( i = start, j = mid, k = start; i &lt; mid &amp;&amp; j &lt; end; k++ ) {
        <span class="kw">if</span> (tmp[i] &lt; tmp[j]) {
            A[k] = tmp[i++];
        } <span class="kw">else</span> {
            A[k] = tmp[j++];
        }
    }
    <span class="kw">while</span> (i &lt; mid) { A[k++] = tmp[i++]; }
    <span class="kw">while</span> (j &lt; end) { A[k++] = tmp[j++]; }
}

<span class="dt">void</span> merge_sort( <span class="dt">int</span> A[], <span class="dt">int</span> tmp[], <span class="dt">const</span> <span class="dt">int</span> start, <span class="dt">const</span> <span class="dt">int</span> end ) {
    <span class="co">//  first   last</span>
    <span class="kw">if</span>( start &lt; end<span class="dv">-1</span> ) {                       <span class="co">// more than one element</span>
        <span class="dt">const</span> <span class="dt">int</span> mid = (start + end) / <span class="dv">2</span>;
        merge_sort( A, tmp, start, mid );
        merge_sort( A, tmp, mid, end );
        merge( A, tmp, start, mid, end );
    }
}</code></pre></div>
<pre><code>merging: 0, 1, 2
merging: 2, 3, 4
merging: 0, 2, 4
merging: 4, 5, 6
merging: 7, 8, 9
merging: 6, 7, 9
merging: 4, 6, 9
merging: 0, 4, 9

    ==== before sorting ====

                    |9|
                    |X|                 |8|
                    |X|                 |X|  |7|
               |6|  |X|                 |X|  |X|
               |X|  |X|  |5|            |X|  |X|
               |X|  |X|  |X|       |4|  |X|  |X|
     |3|       |X|  |X|  |X|       |X|  |X|  |X|
     |X|  |2|  |X|  |X|  |X|       |X|  |X|  |X|
     |X|  |X|  |X|  |X|  |X|  |1|  |X|  |X|  |X|
    ---------------------------------------------
      0    1    2    3    4    5    6    7    8     (index)

    ==== start: 0, mid: 1, end: 2 ====

                    |9|
                    |X|                 |8|
                    |X|                 |X|  |7|
               |6|  |X|                 |X|  |X|
               |X|  |X|  |5|            |X|  |X|
               |X|  |X|  |X|       |4|  |X|  |X|
          |3|  |X|  |X|  |X|       |X|  |X|  |X|
     |2|  |X|  |X|  |X|  |X|       |X|  |X|  |X|
     |X|  |X|  |X|  |X|  |X|  |1|  |X|  |X|  |X|
    ---------------------------------------------
      0    1    2    3    4    5    6    7    8     (index)
      ^----^----^

    ==== start: 2, mid: 3, end: 4 ====

                    |9|
                    |X|                 |8|
                    |X|                 |X|  |7|
               |6|  |X|                 |X|  |X|
               |X|  |X|  |5|            |X|  |X|
               |X|  |X|  |X|       |4|  |X|  |X|
          |3|  |X|  |X|  |X|       |X|  |X|  |X|
     |2|  |X|  |X|  |X|  |X|       |X|  |X|  |X|
     |X|  |X|  |X|  |X|  |X|  |1|  |X|  |X|  |X|
    ---------------------------------------------
      0    1    2    3    4    5    6    7    8     (index)
                ^----^----^

    ==== start: 0, mid: 2, end: 4 ====

                    |9|
                    |X|                 |8|
                    |X|                 |X|  |7|
               |6|  |X|                 |X|  |X|
               |X|  |X|  |5|            |X|  |X|
               |X|  |X|  |X|       |4|  |X|  |X|
          |3|  |X|  |X|  |X|       |X|  |X|  |X|
     |2|  |X|  |X|  |X|  |X|       |X|  |X|  |X|
     |X|  |X|  |X|  |X|  |X|  |1|  |X|  |X|  |X|
    ---------------------------------------------
      0    1    2    3    4    5    6    7    8     (index)
      ^---------^---------^

    ==== start: 4, mid: 5, end: 6 ====

                    |9|
                    |X|                 |8|
                    |X|                 |X|  |7|
               |6|  |X|                 |X|  |X|
               |X|  |X|       |5|       |X|  |X|
               |X|  |X|       |X|  |4|  |X|  |X|
          |3|  |X|  |X|       |X|  |X|  |X|  |X|
     |2|  |X|  |X|  |X|       |X|  |X|  |X|  |X|
     |X|  |X|  |X|  |X|  |1|  |X|  |X|  |X|  |X|
    ---------------------------------------------
      0    1    2    3    4    5    6    7    8     (index)
                          ^----^----^

    ==== start: 7, mid: 8, end: 9 ====

                    |9|
                    |X|                      |8|
                    |X|                 |7|  |X|
               |6|  |X|                 |X|  |X|
               |X|  |X|       |5|       |X|  |X|
               |X|  |X|       |X|  |4|  |X|  |X|
          |3|  |X|  |X|       |X|  |X|  |X|  |X|
     |2|  |X|  |X|  |X|       |X|  |X|  |X|  |X|
     |X|  |X|  |X|  |X|  |1|  |X|  |X|  |X|  |X|
    ---------------------------------------------
      0    1    2    3    4    5    6    7    8     (index)
                                         ^----^----^

    ==== start: 6, mid: 7, end: 9 ====

                    |9|
                    |X|                      |8|
                    |X|                 |7|  |X|
               |6|  |X|                 |X|  |X|
               |X|  |X|       |5|       |X|  |X|
               |X|  |X|       |X|  |4|  |X|  |X|
          |3|  |X|  |X|       |X|  |X|  |X|  |X|
     |2|  |X|  |X|  |X|       |X|  |X|  |X|  |X|
     |X|  |X|  |X|  |X|  |1|  |X|  |X|  |X|  |X|
    ---------------------------------------------
      0    1    2    3    4    5    6    7    8     (index)
                                    ^----^---------^

    ==== start: 4, mid: 6, end: 9 ====

                    |9|
                    |X|                      |8|
                    |X|                 |7|  |X|
               |6|  |X|                 |X|  |X|
               |X|  |X|            |5|  |X|  |X|
               |X|  |X|       |4|  |X|  |X|  |X|
          |3|  |X|  |X|       |X|  |X|  |X|  |X|
     |2|  |X|  |X|  |X|       |X|  |X|  |X|  |X|
     |X|  |X|  |X|  |X|  |1|  |X|  |X|  |X|  |X|
    ---------------------------------------------
      0    1    2    3    4    5    6    7    8     (index)
                          ^---------^--------------^

    ==== start: 0, mid: 4, end: 9 ====

                                             |9|
                                        |8|  |X|
                                   |7|  |X|  |X|
                              |6|  |X|  |X|  |X|
                         |5|  |X|  |X|  |X|  |X|
                    |4|  |X|  |X|  |X|  |X|  |X|
               |3|  |X|  |X|  |X|  |X|  |X|  |X|
          |2|  |X|  |X|  |X|  |X|  |X|  |X|  |X|
     |1|  |X|  |X|  |X|  |X|  |X|  |X|  |X|  |X|
    ---------------------------------------------
      0    1    2    3    4    5    6    7    8     (index)
      ^-------------------^------------------------^

    ==== after sorting ====

                                             |9|
                                        |8|  |X|
                                   |7|  |X|  |X|
                              |6|  |X|  |X|  |X|
                         |5|  |X|  |X|  |X|  |X|
                    |4|  |X|  |X|  |X|  |X|  |X|
               |3|  |X|  |X|  |X|  |X|  |X|  |X|
          |2|  |X|  |X|  |X|  |X|  |X|  |X|  |X|
     |1|  |X|  |X|  |X|  |X|  |X|  |X|  |X|  |X|
    ---------------------------------------------
      0    1    2    3    4    5    6    7    8     (index)
</code></pre>
</dd>
</dl></li>
<li><dl>
<dt>radix sort <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>conclusion <code class="fold">@</code></dt>
<dd><table style="width:90%;">
<colgroup>
<col width="22%" />
<col width="22%" />
<col width="16%" />
<col width="16%" />
<col width="12%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">&#25490;&#24207;&#26041;&#27861;</th>
<th align="left">&#24179;&#22343;&#26102;&#38388;</th>
<th align="left">&#26368;&#22351;&#24773;&#20917;</th>
<th align="left">&#36741;&#21161;&#23384;&#20648;</th>
<th align="left">&#26159;&#21542;&#31283;&#23450;</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">&#30452;&#25509;&#25554;&#20837;&#25490;&#24207;</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(1)</td>
<td align="left">&#26159;</td>
</tr>
<tr class="even">
<td align="left">&#25240;&#21322;&#25554;&#20837;&#25490;&#24207;</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(1)</td>
<td align="left">&#26159;</td>
</tr>
<tr class="odd">
<td align="left">&#24076;&#23572;&#25490;&#24207;</td>
<td align="left">N/A</td>
<td align="left">N/A</td>
<td align="left">O(1)</td>
<td align="left">&#21542;</td>
</tr>
<tr class="even">
<td align="left">&#20882;&#27873;&#25490;&#24207;</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(1)</td>
<td align="left">&#26159;</td>
</tr>
<tr class="odd">
<td align="left">&#24555;&#36895;&#25490;&#24207;</td>
<td align="left">O(nlogn)</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(logn)</td>
<td align="left">&#21542;</td>
</tr>
<tr class="even">
<td align="left">&#31616;&#21333;&#36873;&#25321;&#25490;&#24207;</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(n<sup>2</sup>)</td>
<td align="left">O(1)</td>
<td align="left">&#21542;</td>
</tr>
<tr class="odd">
<td align="left">&#22534;&#25490;&#24207;</td>
<td align="left">O(nlogn)</td>
<td align="left">O(nlogn)</td>
<td align="left">O(1)</td>
<td align="left">&#21542;</td>
</tr>
<tr class="even">
<td align="left">&#20108;&#36335;&#24402;&#24182;</td>
<td align="left">O(nlogn)</td>
<td align="left">O(nlogn)</td>
<td align="left">O(n)</td>
<td align="left">&#26159;</td>
</tr>
<tr class="odd">
<td align="left">&#22522;&#25968;&#25490;&#24207;</td>
<td align="left">O(d*(n+R))</td>
<td align="left">O(d*(n+R))</td>
<td align="left">O(R)</td>
<td align="left">&#26159;</td>
</tr>
</tbody>
</table>
</dd>
</dl></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/00/00 &#19978;&#21320; 9:30:00 0. Brute Force <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>Brute-force search <code class="fold">@</code></dt>
<dd><p>In computer science, <strong>brute-force search</strong> or <strong>exhaustive search</strong>, also known as <strong>generate and test</strong>, is a very general problem-solving technique that consists of systematically enumerating all possible candidates for the solution and checking whether each candidate satisfies the problem&#8217;s statement.</p>
<p>Brute-force search is also useful <strong>as a baseline method when benchmarking other algorithms or metaheuristics.</strong> Indeed, brute-force search can be viewed as the simplest metaheuristic. Brute force search should not be confused with backtracking, where large sets of solutions can be discarded without being explicitly enumerated (as in the textbook computer solution to the eight queens problem above). The brute-force method for finding an item in a table &#8212; namely, check all entries of the latter, sequentially &#8212; is called linear search.</p>
<p>In order to apply brute-force search to a specific class of problems, one must implement <strong>four procedures</strong>, <code>first</code>, <code>next</code>, <code>valid</code>, and <code>output</code>. These procedures should take as a parameter the data P for the particular instance of the problem that is to be solved, and should do the following:</p>
<ul>
<li><strong><code>first (P)</code></strong>: generate a first candidate solution for P.</li>
<li><strong><code>next (P, c)</code></strong>: generate the next candidate for P after the current one c.</li>
<li><strong><code>valid (P, c)</code></strong>: check whether candidate c is a solution for P.</li>
<li><strong><code>output (P, c)</code></strong>: use the solution c of P as appropriate to the application.</li>
</ul>
<pre><code>c &#8592; first(P)
while c &#8800; &#923; do
    if valid(P,c) then output(P, c)
    c &#8592; next(P,c)
end while</code></pre>
<p>Combinatorial explosion, or the curse of dimensionality.</p>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Brute-force_search">Brute-force search - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#31616;&#21333;&#26522;&#20030; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>Division, abcde/fghij = n, a~j -&gt; 0~9, n = 2..79 <code class="fold">@</code></dt>
<dd><p>fghij &#215; {2, 3, 4, &#8230; } = {xxxxx, &#8230;}, then test 0~9</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;utility&gt; </span><span class="co">// pair</span>
<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">bool</span> five( <span class="dt">int</span> n ) {
    <span class="kw">if</span>( n &lt; <span class="dv">1234</span> || n &gt; <span class="dv">98765</span>   ) { <span class="kw">return</span> <span class="kw">false</span>;   }
    <span class="dt">int</span> numpad = { <span class="dv">0</span> };
    <span class="kw">if</span>( n &lt; <span class="dv">9876</span>                ) { ++numpad;    }
    <span class="kw">while</span>( n ) {
        <span class="kw">if</span>( ++numpad[n%<span class="dv">10</span>] &gt;= <span class="dv">2</span> ) { <span class="kw">return</span> <span class="kw">false</span>; }
        n /= <span class="dv">10</span>;
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="dt">bool</span> ten( <span class="dt">int</span> n1, <span class="dt">int</span> n2, <span class="dt">int</span> buf[] ) {
    <span class="kw">if</span>( !five(n1) || !five(n2) ) { <span class="kw">return</span> <span class="kw">false</span>; }
    <span class="dt">int</span> numpad = { <span class="dv">0</span> };
    <span class="kw">while</span>( n1 ) {
        <span class="kw">if</span>( ++numpad[n1%<span class="dv">10</span>] &gt;= <span class="dv">2</span> ) { <span class="kw">return</span> <span class="kw">false</span>; }
        n1 /= <span class="dv">10</span>;
    }
    <span class="kw">while</span>( n2 ) {
        <span class="kw">if</span>( ++numpad[n2%<span class="dv">10</span>] &gt;= <span class="dv">2</span> ) { <span class="kw">return</span> <span class="kw">false</span>; }
        n2 /= <span class="dv">10</span>;
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="dt">int</span> main() {

    vector&lt;pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; &gt; result;

    <span class="dt">int</span> fghij = <span class="dv">1234</span>;                               <span class="co">// 01234, but careful, not octal!</span>
    <span class="kw">for</span>( <span class="dt">int</span> f = fghij; f &lt;= <span class="dv">98765</span>/<span class="dv">2</span>; ++f ) {
        <span class="kw">if</span>( !five(f) ) { <span class="kw">continue</span>; }
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">2</span>; j &lt;= <span class="dv">79</span>; ++j ) {
            <span class="dt">int</span> a = f * j;
            <span class="kw">if</span>( a &gt; <span class="dv">98765</span> ) { <span class="kw">break</span>; }
            <span class="kw">if</span>( !five(a) ) {
                <span class="kw">continue</span>;
            } <span class="kw">else</span> {
                <span class="dt">int</span> buf = { <span class="dv">0</span> };
                <span class="kw">if</span>( ten(f, a, buf) ) {
                    printf( <span class="st">&quot;hit </span><span class="ch">%05d</span><span class="st">/</span><span class="ch">%05d</span><span class="st"> = </span><span class="ch">%d\n</span><span class="st">&quot;</span>, a, f, j );
                    result.push_back( pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt;(a, f) );
                }
            }
        }
    }
    cout &lt;&lt; <span class="st">&quot;size: &quot;</span> &lt;&lt; result.size() &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
}</code></pre></div>
<pre><code>hit 76508/01234 = 62
hit 08659/01237 = 7
hit 86590/01237 = 70
hit 89064/01237 = 72
hit 65879/01243 = 53
...
hit 93702/46851 = 2
hit 96270/48135 = 2
hit 96702/48351 = 2
hit 97026/48513 = 2
hit 97032/48516 = 2
hit 97062/48531 = 2
hit 97230/48615 = 2
hit 97302/48651 = 2
size: 763</code></pre>
<p>&#21407;&#31572;&#26696;&#20284;&#20046;&#31616;&#27905;&#24456;&#22810;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, kase = <span class="dv">0</span>;
    <span class="dt">char</span> buf;
    <span class="kw">while</span>( scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n ) == <span class="dv">1</span> &amp;&amp; n ) {
        <span class="dt">int</span> cnt = <span class="dv">0</span>;
        <span class="kw">if</span>( kase++ ) { printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> ); }
        <span class="kw">for</span>( <span class="dt">int</span> fghij = <span class="dv">1234</span>; ; fghij++ ) {
            <span class="dt">int</span> abcde = fghij * n;
            sprintf( buf, <span class="st">&quot;</span><span class="ch">%05d%05d</span><span class="st">&quot;</span>, abcde, fghij );
            <span class="kw">if</span>( strlen( buf ) &gt; <span class="dv">10</span> ) { <span class="kw">break</span>; }
            sort( buf, buf<span class="dv">+10</span> );
            <span class="dt">int</span> ok = <span class="dv">1</span>;
            <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++ ) {
                <span class="kw">if</span>( buf[i] != <span class="st">&#39;0&#39;</span> + i ) { ok = <span class="dv">0</span>; <span class="kw">break</span>; }
            }
            <span class="kw">if</span>( ok ) {
                cnt++;
                printf( <span class="st">&quot;</span><span class="ch">%05d</span><span class="st"> / </span><span class="ch">%05d</span><span class="st"> = </span><span class="ch">%d\n</span><span class="st">&quot;</span>, abcde, fghij, n );
            }
        }
        <span class="kw">if</span>( !cnt ) { printf( <span class="st">&quot;There are no solutions for </span><span class="ch">%d</span><span class="st">.</span><span class="ch">\n</span><span class="st">&quot;</span>, n ); }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#26368;&#22823;&#20056;&#31215; <code class="fold">@</code></dt>
<dd><p>&#36825;&#20010;&#23384;&#31929;&#26159;&#26292;&#21147;&#20102;&#36215;&#28857;&#21644;&#32456;&#28857;&#65292;&#28982;&#21518;&#30475;&#26159;&#21542;&#8220;&#27700;&#20301;&#26356;&#39640;&#8221;&#12290;</p>
<p>&#36755;&#20837; n &#20010;&#20803;&#32032;&#32452;&#25104;&#30340;&#24207;&#21015; S&#65292;&#25214;&#19968;&#20010;&#20056;&#31215;&#26368;&#22823;&#30340;&#36830;&#32493;&#23376;&#24207;&#21015;&#12290;&#22914;&#26524;&#26368;&#22823;&#20026;&#36127;&#65292;&#36755;&#20986; 0&#12290;1 &lt;= n &lt;= 18&#65292;-10 &lt;= S<sub>i</sub> &lt;= 10&#12290;</p>
<pre><code>input:

    3
    2   4  -3
    5
    2   5  -1   2  -1

output:

    8
    20</code></pre>
<p><strong>&#22240;&#20026; n &#21644; S<sub>i</sub> &#30340;&#20540;&#22495;&#65292;&#26368;&#22823;&#20056;&#31215;&#19981;&#20250;&#36229;&#36807; 10<sup>18</sup>&#65292;&#21487;&#20197;&#29992; long long &#34920;&#31034;&#12290;</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11059 Maximum Product</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main() {
    <span class="dt">int</span> S, kase = <span class="dv">0</span>, n;
    <span class="kw">while</span>( cin &gt;&gt; n &amp;&amp; n ) {
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++ ) { cin &gt;&gt; S[i]; }
        <span class="dt">long</span> <span class="dt">long</span> ans = <span class="dv">0</span>;
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++ ) {
            <span class="dt">long</span> <span class="dt">long</span> v = <span class="dv">1</span>;
            <span class="kw">for</span>( <span class="dt">int</span> j = i; j &lt; n; j++ ) {
                v *= S[j];
                <span class="kw">if</span>( v &gt; ans ) { ans = v; }
            }
        }
        cout &lt;&lt; <span class="st">&quot;Case #&quot;</span> &lt;&lt; ++kase
             &lt;&lt; <span class="st">&quot;: The maximum product is &quot;</span> &lt;&lt; ans &lt;&lt; <span class="st">&quot;.</span><span class="ch">\n\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#20998;&#25968;&#25286;&#20998;&#65292;Fractual Again? &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#26292;&#21147;&#21069;&#20998;&#26512;&#20102;&#21462;&#20540;&#33539;&#22260;&#12290;</p>
<p>&#36755;&#20837;&#27491;&#25972;&#25968; k&#65292;&#25214;&#21040;&#25152;&#26377;&#30340;&#27491;&#25972;&#25968; x &gt;= y&#65292;&#20351;&#24471; 1/k = 1/x + 1/y&#12290;</p>
<pre><code>input:

    2
    12

output:

    2
    1/2 = 1/6 + 1/3
    1/2 = 1/4 + 1/4
    8
    1/12 = 1/156 + 1/13
    1/12 = 1/84 + 1/14
    1/12 = 1/60 + 1/15
    1/12 = 1/48 + 1/16
    1/12 = 1/36 + 1/18
    1/12 = 1/30 + 1/20
    1/12 = 1/28 + 1/21
    1/12 = 1/24 + 1/24</code></pre>
<p>&#20998;&#26512;&#65306;</p>
<ul>
<li>1/k = 1/x + 1/y</li>
<li><code>x &gt;= y</code> -&gt; <code>1/x &lt;= 1/y</code> -&gt; <code>1/k &lt;= 2/y</code> -&gt; <code>y &lt;= 2k</code></li>
<li><code>x &gt; 0</code> -&gt; <code>y &gt; k</code></li>
</ul>
<p>&#25152;&#20197;&#22312; <code>y~(k, 2k]</code> &#26522;&#20030;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10976 Fractions Again?!</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main() {
    <span class="dt">int</span> k;
    <span class="kw">while</span>( scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;k ) == <span class="dv">1</span> &amp;&amp; k ) {
        vector&lt;<span class="dt">int</span>&gt; X, Y;
        <span class="kw">for</span>( <span class="dt">int</span> y = k<span class="dv">+1</span>; y &lt;= k*<span class="dv">2</span>; ++y ) {
            <span class="kw">if</span>( k*y%( y-k ) == <span class="dv">0</span> ) {                <span class="co">// 1/k = 1/x + 1/y =&gt; x = ky/(y-k)</span>
                X.push_back(k*y/(y-k)); Y.push_back(y);
            }
        }
        printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, X.size() );
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; X.size(); i++ ) {
            printf( <span class="st">&quot;1/</span><span class="ch">%d</span><span class="st"> = 1/</span><span class="ch">%d</span><span class="st"> + 1/</span><span class="ch">%d\n</span><span class="st">&quot;</span>, k, X[i], Y[i] );
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#26522;&#20030;&#25490;&#21015; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>next_permutation &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#19979;&#38754;&#32771;&#34385;&#29992; C &#35821;&#35328;&#23454;&#29616;&#12290;&#19981;&#38590;&#24819;&#21040;&#29992;&#25968;&#32452;&#34920;&#31034; P &#21644; S&#12290;&#30001;&#20110; P &#21644; S &#26159;&#20114;&#34917;&#30340;&#65292;&#23427;&#20204;&#20108;&#32773;&#30693;&#36947;&#20854;&#20013;&#32473;&#19968;&#20010;&#65292;&#21478;&#19968;&#20010;&#23601;&#23436;&#20840;&#30830;&#23450;&#20102;&#65292;&#22240;&#27492;&#19981;&#29992;&#20445;&#23384; P&#12290;</p>
<pre><code>P    P    P    P    ...     P[cur]  ...     P[n-1]
|-------- used -------------------------|-----not used--------|</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// permutation P, set S</span>
<span class="dt">static</span> <span class="dt">void</span> print_permutation_r( <span class="dt">int</span> n, <span class="dt">int</span> cur, <span class="dt">int</span> P[] ) {
    <span class="kw">if</span>( cur == n ) {                                            <span class="co">// &#25910;&#25947;&#26465;&#20214;</span>
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) { printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, P[i] ); }
        printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
    }

    <span class="co">// &#25193;&#23637;&#29366;&#24577;&#65292;&#23581;&#35797;&#22312; A[cur] &#20013;&#22635;&#21508;&#31181;&#25972;&#25968; i&#65292;&#25353;&#20174;&#23567;&#21040;&#22823;&#30340;&#39034;&#24207;</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++ ) {
        <span class="dt">int</span> used = <span class="dv">0</span>;
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; cur; j++ ) {
            <span class="kw">if</span>( P[j] == i ) { used = <span class="dv">1</span>; <span class="kw">break</span>; }                <span class="co">// &#22914;&#26524; i &#24050;&#32463;&#22312; A~A[cur-1] &#20986;&#29616;&#36807;&#65292;&#21017;&#19981;&#33021;&#20877;&#36873;</span>
        }
        <span class="kw">if</span>( !used ) {
            P[cur] = i;
            print_permutation_r( n, cur + <span class="dv">1</span>, P );               <span class="co">// &#36882;&#24402;&#35843;&#29992;</span>
        }
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    vector&lt;<span class="dt">int</span>&gt; P;
    <span class="kw">while</span>( scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n ) &amp;&amp; n ) {
        P.resize(n);
        print_permutation_r( n, <span class="dv">0</span>, &amp;P[<span class="dv">0</span>] );
    }
}</code></pre></div>
<p>&#30495;&#30340;&#24456;&#20687;&#20843;&#30343;&#21518;&#12290;</p>
<p>&#22914;&#26524;&#30830;&#23450;&#20102; n &#30340;&#33539;&#22260;&#65292;&#27604;&#22914; n &lt;= 100&#65292;&#21487;&#20197;&#29992;&#20840;&#23616; A&#65292;&#36991;&#20813;&#21160;&#24577;&#20869;&#23384;&#20998;&#37197;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>Leetcode: Next Permutation <code class="fold">@</code></dt>
<dd><pre><code>&#22788;&#29702;&#27493;&#39588;&#65306;
                            ^ increase
                             \
                              \
                               \
        &lt;-----------------------\
            i   j   *   *   *   *

Example

            6   8   7   4   3   2
step 1     [6]  8   7   4   3   2
step 2      6   8  [7]  4   3   2
step 3      7   8   6   4   3   2
step 4      7  [8   6   4   3   2]
            7   2   2   4   6   8

1.  from right to left, find the first digit which violate the increase&#65292;&#36825;&#37324;&#26159; 6&#65292;&#31216;&#20043;&#20026; PartitionNumber
2.  from right to left, find the first digit which large than PartitionNumber&#65288;6&#65289;,
    call it ChangeNumber&#65292;&#36825;&#37324;&#26159; 7&#12290;
3.  swap the PartitionNumber and ChangeNumber&#65307;
4.  Reverse all the digit on the right of partition index&#12290;</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#36825;&#37324;&#30340; ROF &#26159; for &#20498;&#36807;&#26469;&#65292;&#24847;&#24605;&#23601;&#26159; i &#20174; b &#21040; a&#12290;</span>
<span class="ot">#define ROF(i, a, b) for (int i = (b); --i &gt;= (a); )</span>

<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">void</span> nextPermutation(vector&lt;<span class="dt">int</span>&gt; &amp;num) {
        <span class="kw">if</span> (num.size() &lt;= <span class="dv">1</span>) <span class="kw">return</span>;
        <span class="co">// ROF(i, 0, num.size()-1) {</span>
        <span class="kw">for</span>( <span class="dt">int</span> i = num.size()<span class="dv">-2</span>; i &gt;= <span class="dv">0</span>; --i ) {
            <span class="kw">if</span> ( i<span class="dv">+1</span> &lt; num.size() &amp;&amp; num[i] &lt; num[i<span class="dv">+1</span>] ) {
                <span class="dt">int</span> j = num.size();
                <span class="kw">while</span> (! (num[i] &lt; num[--j]));  <span class="co">// num[i] &lt; num[j]</span>
                swap(num[i], num[j]);
                reverse(num.begin()+i<span class="dv">+1</span>, num.end());
                <span class="kw">return</span>;
            }
        }
        reverse(num.begin(), num.end());
    }
};</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/next-permutation/">Next Permutation | LeetCode OJ</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Leetcode: Permutation Sequence <code class="fold">@</code></dt>
<dd><p>The set <code>[1,2,3,&#8230;,n]</code> contains a total of n! unique permutations. &#36755;&#20837; n &#21644; k&#65292;&#36820;&#22238;&#31532; k &#20010;&#24207;&#21015;&#12290;</p>
<p>&#26368;&#26080;&#36182;&#30340;&#35299;&#27861;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    string getPermutation(<span class="dt">int</span> n, <span class="dt">int</span> k) {
        string s(n, <span class="st">&#39;0&#39;</span>);
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i)
            s[i] += i<span class="dv">+1</span>;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; k<span class="dv">-1</span>; ++i)
            next_permutation(s.begin(), s.end());
        <span class="kw">return</span> s;
    }
};</code></pre></div>
<p>&#36825;&#20010;&#26041;&#27861;&#21487;&#20197;&#24471;&#21040;&#31572;&#26696;&#65292;&#20294;&#26159;&#8230;&#8230;Status: Time Limit Exceeded&#8230;&#8230;</p>
<dl>
<dt>&#24247;&#25176;&#23637;&#24320;, Cantor expansion <code class="fold">@</code></dt>
<dd><p><code>X=a[n]*(n-1)!+a[n-1]*(n-2)!+...+a[i]*(i-1)!+...+a[1]*0!</code>&#65292;&#20854;&#20013; <code>a[i]</code> &#20026;&#24403;&#21069;&#26410;&#20986;&#29616;&#30340;&#20803;&#32032;&#20013;&#26159;&#25490;&#22312;&#31532;&#20960;&#20010;&#65288;&#20174; 0&#24320;&#22987;&#65289;&#12290;&#36825;&#23601;&#26159;&#24247;&#25176;&#23637;&#24320;&#12290;&#24247;&#25176;&#23637;&#24320;&#21487;&#29992;&#20195;&#30721;&#23454;&#29616;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://baike.baidu.com/link?url=UTLtFkZMM5RzyijXFpFAkwFSJ3PeZcsBj_48119xF7LgI0cr9jW92Y2vGkdPY9ibPxD53oPbG5YS1ZLenghvOK">&#24247;&#25176;&#23637;&#24320;_&#30334;&#24230;&#30334;&#31185;</a></li>
<li><a href="http://blog.csdn.net/synapse7/article/details/16901489">&#20840;&#25490;&#21015;&#30340;&#32534;&#30721;&#19982;&#35299;&#30721;&#8212;&#8212;&#24247;&#25176;&#23637;&#24320; (&#38468;&#23436;&#25972;&#20195;&#30721;) - AC&#65292;&#8721;ndless - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
</ul>
</dd>
</dl>
<p>&#21033;&#29992;&#24247;&#25176;&#32534;&#30721;&#30340;&#24605;&#36335;&#65292;&#20551;&#35774;&#26377; n &#20010;&#19981;&#37325;&#22797;&#30340;&#20803;&#32032;&#65292;&#31532; k &#20010;&#25490;&#21015;&#26159; a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, &#8230;, a<sub>n</sub>&#65292;&#37027;&#20040; a<sub>1</sub> &#26159;&#21738;&#19968;&#20010;&#20301;&#32622;&#21602;&#65311;&#25105;&#20204;&#25226; a<sub>1</sub>&#21435;&#25481;&#65292;&#37027;&#20040;&#21097;&#19979;&#30340;&#25490;&#21015;&#20026; a<sub>2</sub>, a<sub>3</sub>, &#8230;, a<sub>n</sub>, &#20849;&#35745; n-1 &#20010;&#20803;&#32032;&#65292;n-1 &#20010;&#20803;&#32032;&#20849;&#26377; (n-1)! &#20010;&#25490;&#21015;&#65292;&#20110;&#26159;&#23601;&#21487;&#20197;&#30693;&#36947; a<sub>1</sub> = k / (n-1)!&#12290;</p>
<p>&#21516;&#29702;&#65292;a<sub>2</sub>, a<sub>3</sub>, &#8230;, a<sub>n</sub> &#30340;&#20540;&#25512;&#23548;&#22914;&#19979;&#65306;</p>
<ul>
<li>k<sub>2</sub> = k%(n-1)!</li>
<li>a<sub>2</sub> = k<sub>2</sub>/(n-2)!</li>
<li>&#8230;</li>
<li>k<sub>n-1</sub> = k<sub>n-2</sub>%2!</li>
<li>a<sub>n-1</sub> = k<sub>n-1</sub>%1!</li>
<li>a<sub>n</sub> = 0</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#24247;&#25176;&#32534;&#30721;&#65292;&#26102;&#38388;&#22797;&#26434;&#24230; O(n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(1)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    string getPermutation(<span class="dt">int</span> n, <span class="dt">int</span> k) {
        string s(n, <span class="st">&#39;0&#39;</span>);
        string result;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i)
            s[i] += i + <span class="dv">1</span>;
        <span class="kw">return</span> kth_permutation(s, k);
    }
<span class="kw">private</span>:
    <span class="dt">int</span> factorial(<span class="dt">int</span> n) {
        <span class="dt">int</span> result = <span class="dv">1</span>;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i)
            result *= i;
        <span class="kw">return</span> result;
    }

    <span class="kw">template</span>&lt;<span class="kw">typename</span> Sequence&gt;                                     <span class="co">// seq &#24050;&#25490;&#22909;&#24207;&#65292;&#26159;&#31532;&#19968;&#20010;&#25490;&#21015;</span>
    Sequence kth_permutation(<span class="dt">const</span> Sequence &amp;seq, <span class="dt">int</span> k) {
        <span class="dt">const</span> <span class="dt">int</span> n = seq.size();
        Sequence S(seq), result;
        result.reserve( n );

        <span class="dt">int</span> base = factorial(n - <span class="dv">1</span>);
        --k;                                                        <span class="co">// &#24247;&#25176;&#32534;&#30721;&#20174; 0 &#24320;&#22987;</span>

        <span class="kw">for</span> (<span class="dt">int</span> i = n - <span class="dv">1</span>; i &gt; <span class="dv">0</span>; k %= base, base /= i, --i ) {    <span class="co">// base/=i &#23454;&#22312;&#22826;&#24039;&#22937;</span>
            <span class="kw">auto</span> a = next(S.begin(), k / base);
            result.push_back(*a);
            S.erase(a);                                             <span class="co">// &#35760;&#24471; erase &#25481;&#65281;</span>
        }

        result.push_back(S[<span class="dv">0</span>]);                                     <span class="co">// &#26368;&#21518;&#19968;&#20010;</span>
        <span class="kw">return</span> result;
    }
};</code></pre></div>
<p>&#19978;&#38754;&#37027;&#20010;&#31572;&#26696;&#36890;&#36807;&#20102;&#12290;&#19979;&#38754;&#26377;&#20010;&#26356;&#31616;&#27905;&#30340;&#12290;&#20063;&#36890;&#36807;&#20102;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define ROF(i, a, b) for (int i = (b); --i &gt;= (a); )</span>

<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    string getPermutation(<span class="dt">int</span> n, <span class="dt">int</span> k) {
        <span class="co">// factorial:   0     1   2   3    4      5       6        7        8</span>
        <span class="dt">int</span> f[] =     { <span class="dv">1</span>,    <span class="dv">1</span>,  <span class="dv">2</span>,  <span class="dv">6</span>,  <span class="dv">24</span>,   <span class="dv">120</span>,    <span class="dv">720</span>,    <span class="dv">5040</span>,   <span class="dv">40320</span>   };
        vector&lt;<span class="dt">bool</span>&gt; a(n, <span class="kw">true</span>);
        string r;
        k--;
        ROF(i, <span class="dv">0</span>, n) {
            <span class="dt">int</span> t = k/f[i], j = <span class="dv">0</span>;
            k %= f[i];
            <span class="kw">while</span> (!a[j]) j++;
            <span class="kw">while</span> (t--)
                <span class="kw">while</span> (! a[++j]);
            a[j] = <span class="kw">false</span>;
            r += <span class="st">&#39;1&#39;</span>+j;
        }
        <span class="kw">return</span> r;
    }
};</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/permutation-sequence/">Permutation Sequence | LeetCode OJ</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#29983;&#25104;&#21487;&#37325;&#38598;&#30340;&#25490;&#21015; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#30452;&#25509;&#29992; STL &#37324;&#38754;&#30340; next_permutation <code class="fold">@</code></dt>
<dd><dl>
<dt>std::next_permutation &#25509;&#21475; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt; <span class="kw">class</span> BidirIt &gt;
<span class="dt">bool</span> next_permutation( BidirIt first, BidirIt last );

<span class="kw">template</span>&lt; <span class="kw">class</span> BidirIt, <span class="kw">class</span> Compare &gt;
<span class="dt">bool</span> next_permutation( BidirIt first, BidirIt last, Compare comp );</code></pre></div>
<dl>
<dt>Possible implementation &#9829;&#65039; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> BidirIt&gt;
<span class="dt">bool</span> next_permutation(BidirIt first, BidirIt last)
{
    <span class="kw">if</span> (first == last) <span class="kw">return</span> <span class="kw">false</span>;                <span class="co">// no element</span>
    BidirIt i = last;
    <span class="kw">if</span> (first == --i) <span class="kw">return</span> <span class="kw">false</span>;                 <span class="co">// only one element</span>

    <span class="kw">while</span> (<span class="kw">true</span>) {
        BidirIt i1, i2;

        i1 = i;
        <span class="kw">if</span> (*--i &lt; *i1) {
            i2 = last;
            <span class="kw">while</span> (!(*i &lt; *--i2))
                ;
            std::iter_swap(i, i2);                  <span class="co">// iter_swap?? TODO</span>
            std::reverse(i1, last);
            <span class="kw">return</span> <span class="kw">true</span>;
        }
        <span class="kw">if</span> (i == first) {
            std::reverse(first, last);
            <span class="kw">return</span> <span class="kw">false</span>;                           <span class="co">// great! termination.</span>
        }
    }
}</code></pre></div>
</dd>
</dl>
</dd>
</dl>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, p;
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++ ) { scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;p[i] ); }
    sort( p, p+n );                                                 <span class="co">// &#25490;&#24207;&#65292;&#24471;&#21040; p &#30340;&#26368;&#23567;&#25490;&#21015;</span>
    <span class="kw">do</span> {
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++ ) { printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, p[i] ); }     <span class="co">// &#36755;&#20986;&#25490;&#21015; p</span>
        printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
    } <span class="kw">while</span>(  next_permutation( p, p+n )  );                        <span class="co">// &#27714;&#19979;&#19968;&#20010;&#25490;&#21015;</span>
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">echo</span> <span class="st">&quot;4 5 2 2 4&quot;</span> <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">2</span> 2 4 5
<span class="kw">2</span> 2 5 4
<span class="kw">2</span> 4 2 5
<span class="kw">2</span> 4 5 2
<span class="kw">2</span> 5 2 4
<span class="kw">2</span> 5 4 2
<span class="kw">4</span> 2 2 5
<span class="kw">4</span> 2 5 2
<span class="kw">4</span> 5 2 2
<span class="kw">5</span> 2 2 4
<span class="kw">5</span> 2 4 2
<span class="kw">5</span> 4 2 2</code></pre></div>
</dd>
<dt>&#24403;&#28982;&#65292;&#33258;&#24049;&#20889;&#20063;&#26159;&#21487;&#20197;&#24471;&#12290;&#12304;&#36825;&#20010;&#20195;&#30721;&#21313;&#20998;&#37325;&#35201;&#65281;&#65281;&#65281;&#12305;&#9829;&#65039; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">50</span>;
<span class="dt">int</span> P[maxn], A[maxn];

<span class="co">// &#36755;&#20986;&#25968;&#32452; P &#20013;&#20803;&#32032;&#30340;&#20840;&#25490;&#21015;&#12290;&#25968;&#32452; P &#20013;&#21487;&#33021;&#26377;&#37325;&#22797;&#20803;&#32032;</span>
<span class="dt">void</span> print_permutation( <span class="dt">int</span> n, <span class="dt">int</span> *P, <span class="dt">int</span> *A, <span class="dt">int</span> cur ) {
    <span class="kw">if</span>( cur == n ) {
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++ ) { printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, A[i] ); } printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
    } <span class="kw">else</span> {
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++ ) {
            <span class="kw">if</span>( i == <span class="dv">0</span> || P[i] != P[i<span class="dv">-1</span>] ) {
                <span class="dt">int</span> c1 = <span class="dv">0</span>, c2 = <span class="dv">0</span>;
                <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; cur; j++ ) { <span class="kw">if</span>( A[j] == P[i] ) { c1++; } }
                <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt;   n; j++ ) { <span class="kw">if</span>( P[i] == P[j] ) { c2++; } }
                <span class="kw">if</span>( c1 &lt; c2 ) {
                    A[cur] = P[i];
                    print_permutation( n, P, A, cur<span class="dv">+1</span> );
                }
            }
        }
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> i, n;
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n );
    <span class="kw">for</span>( i = <span class="dv">0</span>; i &lt; n; i++ ) {
        scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;P[i] );
    }
    sort( P, P+n );
    print_permutation( n, P, A, <span class="dv">0</span> );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">echo</span> 4 2 3 1 1 <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">1</span> 1 2 3
<span class="kw">1</span> 1 3 2
<span class="kw">1</span> 2 1 3
<span class="kw">1</span> 2 3 1
<span class="kw">1</span> 3 1 2
<span class="kw">1</span> 3 2 1
<span class="kw">2</span> 1 1 3
<span class="kw">2</span> 1 3 1
<span class="kw">2</span> 3 1 1
<span class="kw">3</span> 1 1 2
<span class="kw">3</span> 1 2 1
<span class="kw">3</span> 2 1 1</code></pre></div>
<p>&#25152;&#20197;&#21834;&#65292;&#26522;&#20030;&#25490;&#21015;&#35201;&#19981;&#33258;&#24049;&#36882;&#24402;&#26522;&#20030;&#65292;&#35201;&#19981;&#23601;&#29992; stl &#30340; next_permutation&#12290;</p>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>&#35299;&#31572;&#26641; <code class="fold">@</code></dt>
<dd><pre><code>                                                            (*,*,*,*)
                                                                |
              .--------------------------------+----------------+---------------+-------------------------------.
              |                                |                                |                               |
          (1,*,*,*)                        (2,*,*,*)                        (3,*,*,*)                       (4,*,*,*)
         /    |    \                      /    |    \                      /    |    \                     /    |    \
(1,2,*,*) (1,3,*,*) (1,4,*,*)    (2,1,*,*) (2,3,*,*) (2,4,*,*)    (3,1,*,*) (3,2,*,*) (3,4,*,*)   (4,1,*,*) (4,2,*,*) (4,3,*,*)</code></pre>
<p>&#31532; 0 &#23618;&#26377; n &#20010;&#20799;&#23376;&#65292;&#31532;&#19968;&#23618;&#21508;&#33410;&#28857;&#21508;&#26377; n-1 &#20010;&#20799;&#23376;&#65292;&#31532;&#20108;&#23618;&#21508;&#26377; n-2 &#20010;&#20799;&#23376;&#65292;&#31532; n &#23618;&#33410;&#28857;&#27809;&#26377;&#20799;&#23376;&#12290;&#27599;&#20010;&#21494;&#23376;&#23545;&#24212;&#19968;&#20010;&#25490;&#21015;&#65292;&#20849;&#26377; n! &#20010;&#21494;&#23376;&#12290;&#36825;&#26869;&#26641;&#23637;&#31034;&#30340;&#26159;&#65306; &#20174;&#20160;&#20040;&#37117;&#27809;&#20570;&#21040;&#36880;&#27493;&#29983;&#25104;&#23436;&#25972;&#35299;&#30340;&#36807;&#31243;&#12290;</p>
<p>&#35299;&#31572;&#26641;&#29305;&#28857;: &#22810;&#27493;&#39588;&#65292;&#22810;&#36873;&#25321;&#65292;&#29992;&#36882;&#24402;</p>
<p>0 &#23618;&#65306;<code>1</code> &#20010;&#33410;&#28857;&#65292;1 &#23618;&#65306;<code>n</code> &#20010;&#33410;&#28857;&#65292;2 &#23618;&#65306;<code>n*(n-1)</code>&#65292;&#31532; 3 &#23618;&#65306;<code>n*(n-1)*(n-2)</code>&#65292;&#31532; n &#23618;&#65306;<code>n*(n-1)*(n-2)*(n-3)*...*1 = n!</code> &#20010;&#33410;&#28857;&#12290;&#20840;&#37096;&#21152;&#36215;&#26469;&#12290;&#26368;&#21518;&#23621;&#28982;&#22797;&#26434;&#24230;&#26159; O(n!)&#12288;TODO&#65288;&#25226;&#20844;&#24335;&#20889;&#23436;&#25972;&#65289;</p>
<p>&#22810;&#25968;&#24773;&#20917;&#19979;: &#35299;&#31572;&#26641;&#19978;&#25152;&#26377;&#33410;&#28857;&#26469;&#28304;&#20110;&#26368;&#21518;&#19968;&#20004;&#23618;</p>
<p>1 + 1/2 + 1/3 + &#8230; = e&#65292;&#27888;&#21202;&#20844;&#24335;&#12290;</p>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#23376;&#38598;&#29983;&#25104; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#22686;&#37327;&#26500;&#36896;&#27861; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// {0~n-1} &#30340;&#25152;&#26377;&#23376;&#38598;&#65306;&#22686;&#37327;&#26500;&#36896;&#27861;</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">void</span> print_subset( <span class="dt">int</span> n, <span class="dt">int</span>* A, <span class="dt">int</span> cur ) {
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; cur; i++ ) { printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, A[i] ); }   <span class="co">// &#25171;&#21360;&#24403;&#21069;&#38598;&#21512;</span>
    printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
    <span class="dt">int</span> s = cur != <span class="dv">0</span> ? A[cur<span class="dv">-1</span>]<span class="dv">+1</span> : <span class="dv">0</span>;                          <span class="co">// &#30830;&#23450;&#24403;&#21069;&#20803;&#32032;&#30340;&#26368;&#23567;&#21487;&#33021;&#20540;</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = s; i &lt; n; i++ ) {
        A[cur] = i;
        print_subset( n, A, cur<span class="dv">+1</span> );                            <span class="co">// &#36882;&#24402;&#26500;&#36896;&#23376;&#38598;</span>
    }
}

<span class="dt">int</span> A;
<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n );
    print_subset( n, A, <span class="dv">0</span> );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>output</p>
<pre><code>0
0 1
0 1 2
0 2
1
1 2
2</code></pre>
</dd>
</dl></li>
<li><dl>
<dt>&#20301;&#21521;&#37327;&#27861; <code class="fold">@</code></dt>
<dd><p>&#19981;&#30452;&#25509;&#26500;&#36896; A&#65292;&#21462;&#32780;&#20195;&#20043;&#26500;&#36896; B&#12290;</p>
<p>&#24320;&#19968;&#20010;&#20301;&#21521;&#37327; B&#65292;<code>B[i]=1</code> &#34920;&#31034;&#36873;&#25321; <code>S[i]</code>, <code>B[i]=0</code> &#34920;&#31034;&#19981;&#36873;&#25321;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// {0~n-1} &#30340;&#25152;&#26377;&#23376;&#38598;&#65306;&#20301;&#21521;&#37327;&#27861;</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">void</span> print_subset( <span class="dt">int</span> n, <span class="dt">int</span>* B, <span class="dt">int</span> cur ) {
    <span class="kw">if</span>( cur == n ) {
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; cur; i++ ) {
            <span class="kw">if</span>( B[i] ) { printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, i ); }      <span class="co">// &#25171;&#21360;&#24403;&#21069;&#38598;&#21512;</span>
        }
        printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
        <span class="kw">return</span>;
    }
    B[cur] = <span class="dv">1</span>;                                     <span class="co">// &#36873;&#31532; cur &#20010;&#20803;&#32032;</span>
    print_subset( n, B, cur<span class="dv">+1</span> );
    B[cur] = <span class="dv">0</span>;                                     <span class="co">// &#19981;&#36873;&#31532; cur &#20010;&#20803;&#32032;</span>
    print_subset( n, B, cur<span class="dv">+1</span> );
}

<span class="dt">int</span> B;
<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) { scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;B[i]); }
    print_subset( n, B, <span class="dv">0</span> );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#20108;&#36827;&#21046;&#27861; <code class="fold">@</code></dt>
<dd><p>&#21069;&#25552;&#65306;&#38598;&#21512;&#30340;&#20803;&#32032;&#19981;&#36229;&#36807; int &#20301;&#25968;&#12290;&#29992;&#19968;&#20010; int &#25972;&#25968;&#34920;&#31034;&#20301;&#21521;&#37327;&#65292;&#31532; i &#20301;&#20026; 1&#65292;&#21017;&#34920;&#31034;&#36873;&#25321; S[i]&#65292;&#20026; 0 &#21017;&#19981;&#36873;&#25321;&#12290;&#20363;&#22914; S={A,B,C,D}&#65292;&#21017; 0110=6 &#34920;&#31034;&#23376;&#38598; {B,C}&#12290;</p>
<p>&#36825;&#31181;&#26041;&#27861;&#26368;&#24039;&#22937;&#12290;&#22240;&#20026;&#23427;&#19981;&#20165;&#33021;&#29983;&#25104;&#23376;&#38598;&#65292;&#36824;&#33021;&#26041;&#20415;&#30340;&#34920;&#31034;&#38598;&#21512;&#30340;&#24182;&#12289;&#20132;&#12289;&#24046;&#31561;&#38598;&#21512;&#36816;&#31639;&#12290;&#35774;&#20004;&#20010;&#38598;&#21512;&#30340;&#20301;&#21521;&#37327;&#20998;&#21035;&#20026; B1 &#21644; B2&#65292;&#21017; B1|B2, B1&amp;B2, B1^B2 &#20998;&#21035;&#23545;&#24212;&#38598;&#21512;&#30340;&#24182;&#12289;&#20132;&#12289;&#23545;&#31216;&#24046;&#12290;</p>
<pre><code>15  14  13  12  11  10  9   8   7   6   5   4   3   2   1   0
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
0   1   0   0   0   1   1   0   0   0   1   1   0   1   1   1
    ^               ^   ^               ^   ^       ^   ^   ^
    |               |   |               |   |       |   |   |
    +---------------+---+---------------+---+-------+---+---+
                        |
                        |
                        V
           { 14, 10, 9, 5, 4, 2, 1, 0 }</code></pre>
<p>XOR &#26368;&#37325;&#35201;&#30340;&#24615;&#36136;&#26159;&#8220;&#24320;&#20851;&#24615;&#8221; &#8212; XOR &#20004;&#27425;&#31561;&#20110;&#27809;&#26377; XOR&#65306;A<sup>B</sup>B = A&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// {0~n-1}&#30340;&#25152;&#26377;&#23376;&#38598;&#65306;&#20108;&#36827;&#21046;&#27861;</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">void</span> print_subset( <span class="dt">int</span> n, <span class="dt">int</span> s ) {             <span class="co">// &#25171;&#21360; {0, 1, 2, ..., n-1} &#30340;&#23376;&#38598; S</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++ ) {
        <span class="kw">if</span>( s&amp;(<span class="dv">1</span>&lt;&lt;i) ) { printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, i); }    <span class="co">// &#36825;&#37324;&#21033;&#29992;&#20102; C &#35821;&#35328;&#8220;&#38750; 0 &#20540;&#37117;&#20026;&#30495;&#8221;&#30340;&#35268;&#23450;</span>
    }
    printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; ( <span class="dv">1</span>&lt;&lt;n ); i++ ) {       <span class="co">// &#26522;&#20030;&#21508;&#23376;&#38598;&#25152;&#23545;&#24212;&#30340;&#32534;&#30721; 0, 1, 2, ..., 2^n-1</span>
        print_subset( n, i );
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">echo</span> 3 <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">0</span>
<span class="kw">1</span>
<span class="kw">0</span> 1
<span class="kw">2</span>
<span class="kw">0</span> 2
<span class="kw">1</span> 2
<span class="kw">0</span> 1 2</code></pre></div>
<p><code>ALL_BITS = (1&lt;&lt;n) -1</code>&#65292;A &#30340;&#34917;&#38598;&#23601;&#26159; <code>A^ALL_BITS</code>&#12290;</p>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#22238;&#28335;&#27861; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#22238;&#28335;&#27861;&#29702;&#35770; TODO <code class="fold">@</code></dt>
<dd><p>&#20043;&#21069;&#20004;&#31181;&#24605;&#36335;&#26159;&#65306;&#36882;&#24402;&#26500;&#36896;&#12289;&#30452;&#25509;&#26522;&#20030;&#65288;generate&#65292;&#28982;&#21518; test&#65289;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>n &#30343;&#21518;&#38382;&#39064; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#38382;&#39064;&#25551;&#36848; <code class="fold">@</code></dt>
<dd><p>The eight queens puzzle is the problem of <strong>placing eight chess queens</strong> on an 8&#215;8 chessboard so that no two queens <strong>threaten each other</strong>. Thus, a solution requires that no two queens share the same row, column, or diagonal. The eight queens puzzle is an example of the more general n queens problem of placing n non-attacking queens on an n&#215;n chessboard, for which solutions exist for all natural numbers n with the exception of n=2 and n=3.</p>
<p>The eight queens puzzle has <strong>92 distinct solutions</strong>. If solutions that differ only by symmetry operations (rotations and reflections) of the board are counted as one, the puzzle has <strong>12 fundamental solutions</strong>.</p>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle">Eight queens puzzle - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#29983;&#25104; - &#27979;&#35797;&#27861; <code class="fold">@</code></dt>
<dd><p>generate-test&#65292;&#20063;&#23601;&#26159;&#30452;&#25509;&#26522;&#20030;&#27861;&#65288;&#26292;&#21147;&#27861;&#65289;&#12290;</p>
<p>These brute-force algorithms to count the number of solutions are computationally manageable for n = 8, but would be intractable for problems of n &#8805; 20, as 20! = 2.433 x 10<sup>18</sup>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// n &#30343;&#21518;&#38382;&#39064;&#65306;&#29983;&#25104;-&#27979;&#35797;&#27861;</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> C, tot = <span class="dv">0</span>, n = <span class="dv">8</span>, nc = <span class="dv">0</span>;

<span class="dt">void</span> search( <span class="dt">int</span> cur ) {
    <span class="dt">int</span> i, j;
    nc++;
    <span class="kw">if</span>( cur == n ) {
        <span class="kw">for</span>( i = <span class="dv">0</span>; i &lt; n; i++ ) {      <span class="co">// &#21040;&#26368;&#21518;&#20877;&#21028;&#26029;&#21679;&#12290;&#26159;&#21542; valid</span>
            <span class="kw">for</span>(j = i<span class="dv">+1</span>; j &lt; n; j++) {
                <span class="kw">if</span>( C[i] == C[j] || i-C[i] == j-C[j] || i+C[i] == j+C[j] ) { <span class="kw">return</span>; }
            }
        }
        tot++;
    } <span class="kw">else</span> <span class="kw">for</span>( i = <span class="dv">0</span>; i &lt; n; i++ ) {
        C[cur] = i;                     <span class="co">// &#30452;&#25509;&#26292;&#21147;&#24456;&#22810;&#24773;&#20917;&#65292;&#24456;&#22810;&#37117;&#26159;&#19981;&#21487;&#34892;&#30340;</span>
        search( cur<span class="dv">+1</span> );
    }
}

<span class="dt">int</span> main() {
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n );
    search( <span class="dv">0</span> );
    printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, tot );
    printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, nc );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">echo</span> 8 <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">92</span>
<span class="kw">19173961</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#26222;&#36890;&#22238;&#28335;&#27861; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// n &#30343;&#21518;&#38382;&#39064;&#65306;&#26222;&#36890;&#22238;&#28335;&#27861;</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> C, tot = <span class="dv">0</span>, n = <span class="dv">8</span>, nc = <span class="dv">0</span>;

<span class="dt">void</span> search( <span class="dt">int</span> cur ) {
    <span class="dt">int</span> i, j;
    nc++;
    <span class="kw">if</span>( cur == n ) {
        tot++;
    } <span class="kw">else</span> <span class="kw">for</span>( i = <span class="dv">0</span>; i &lt; n; i++ ) {
        <span class="dt">int</span> ok = <span class="dv">1</span>;
        C[cur] = i;
        <span class="kw">for</span>( j = <span class="dv">0</span>; j &lt; cur; j++ ) {        <span class="co">// &#22312;&#36827;&#20837;&#19968;&#31181;&#21487;&#33021;&#24615;&#30340;&#26102;&#20505;&#23601;&#21028;&#26029;&#26159;&#21542;&#21487;&#33021;&#12290;</span>
            <span class="dt">int</span> dx = cur - j, dy = C[cur] - C[j];
            <span class="kw">if</span>( C[cur] == C[j] || dx == dy || dy == -dy ) {
                ok = <span class="dv">0</span>;
                <span class="kw">break</span>;
            }
        }
        <span class="kw">if</span>( ok ) { search( cur<span class="dv">+1</span> ); }
    }
}

<span class="dt">int</span> main() {
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n );
    search( <span class="dv">0</span> );
    printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, tot );
    printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, nc );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">echo</span> 8 <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">92</span>
<span class="kw">2057</span>        <span class="co"># &#23545;&#27604;&#30452;&#25509;&#26292;&#21147;&#27861;&#30340; 19173961</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#20248;&#21270;&#20102;&#30340;&#22238;&#28335;&#27861; <code class="fold">@</code></dt>
<dd><p>&#36890;&#36807;&#35774;&#32622;&#26631;&#24535;&#20301;&#26469;&#36991;&#20813;&#36890;&#36807;&#24490;&#29615;&#26469;&#21028;&#26029;&#26159;&#21542; valid&#12290;</p>
<pre><code>  y - x    ?dx == dy                                y + x    ? dx == -dy (dx+dy==0)
      +----------------------------------&gt; y            +-----------------------------------&gt; y
      |  0   1   2   3   4   5   6   7                  |  0   1   2   3   4   5   6   7
      | -1   0   1   2   3   4   5   6                  |  1   2   3   4   5   6   7   8
      | -2  -1   0   1   2   3   4   5                  |  2   3   4   5   6   7   8   9
      | -3  -2  -1   0   1   2   3   4                  |  3   4   5   6   7   8   9  10
      | -4  -3  -2  -1   0   1   2   3                  |  4   5   6   7   8   9  10  11
      | -5  -4  -3  -2  -1   0   1   2                  |  5   6   7   8   9  10  11  12
    x | -6  -5  -4  -3  -2  -1   0   1               x  |  6   7   8   9  10  11  12  13
      | -7  -6  -5  -4  -3  -2  -1   0                  |  7   8   9  10  11  12  13  14
      V                                                 V</code></pre>
<p>&#26631;&#24535;&#20301;&#30340;&#32534;&#30721;&#26080;&#25152;&#35859;&#65292;&#21482;&#35201;&#33021;&#26816;&#27979;&#26631;&#24535;&#12289;&#35774;&#32622;&#26631;&#24535;&#12289;&#31227;&#38500;&#26631;&#24535;&#65292;&#21363;&#21487;&#12290;</p>
<dl>
<dt>&#36825;&#20010;&#22312;&#25105;&#30340;&#19968;&#20010;&#31616;&#21382;&#25237;&#36882;&#37324;&#35828;&#24471;&#36824;&#35814;&#32454;&#28857;&#65306;<a href="../misc/yotouch.html">&#24212;&#32856;&#31616;&#31572; for &#21019;&#19994;&#20844;&#21496;&#27714; Java &#24320;&#21457;&#24037;&#31243;&#24072;&#65292;&#22522;&#20110;&#24494;&#20449;&#24179;&#21488;</a>&#12290; <code class="fold">@</code></dt>
<dd><p>&#39318;&#20808;&#19981;&#33021;&#21516;&#34892;&#65292;&#37027;&#23601;&#30452;&#25509;&#29992; <code>C[i]</code>&#65288;<code>i=[0,7)</code>&#65292;&#27599;&#20010; i &#37117;&#19981;&#19968;&#26679;&#65289;&#26469;&#23384;&#20648;&#27599;&#19968;&#34892;&#30340;&#21015;&#30340;&#20301;&#32622;&#12290;&#27604;&#22914; <code>C[2]=5</code> &#20195;&#34920;&#30343;&#21518;&#28857;&#20301;&#20026; <code>(3, 6)</code>&#12290;</p>
<p>&#19981;&#33021;&#21516;&#21015;&#65292;&#21487;&#20197;&#29992;&#24490;&#29615;&#26816;&#27979;&#26159;&#21542;&#21644;&#20854;&#20182;&#30343;&#21518;&#20914;&#31361;&#12290;</p>
<p>&#19981;&#33021;&#21516;&#26012;&#32447;&#65292;&#21487;&#20197;&#29992;&#24490;&#29615;&#26816;&#27979;&#26159;&#21542;&#21644;&#20854;&#20182;&#30343;&#21518;&#20914;&#31361;&#12290;&#20004;&#31181;&#24773;&#20917;&#65306;</p>
<ul>
<li><code>dx ==  dy</code></li>
<li><code>dx == -dy</code></li>
</ul>
<p>&#20248;&#21270; 1&#65306;&#25226; 8 &#30343;&#21518;&#30340;&#25918;&#32622;&#30475;&#25104;&#19968;&#20010;&#36807;&#31243;&#65292;&#31532;&#19968;&#20010;&#30343;&#21518;&#65292;&#38543;&#24847;&#25918;&#65292;&#31532;&#20108;&#20010;&#30343;&#21518;&#65292;&#21482;&#35201;&#21644;&#31532;&#19968;&#20010;&#30343;&#21518;&#19981;&#20914;&#31361;&#65292;&#38543;&#24847;&#25918;&#65292;&#20197;&#27492;&#65292;&#20843;&#20010;&#30343;&#21518;&#37117;&#25918;&#19978;&#20102;&#65292;&#23601;&#26159;&#19968;&#20010; valid &#30340;&#24773;&#20917;&#12290;</p>
<p>&#36825;&#26679;&#20914;&#31361;&#30340;&#21028;&#26029;&#19981;&#24517;&#35201;&#21644;<strong>&#20840;&#37096;</strong>&#20854;&#20182;&#30343;&#21518;&#26816;&#27979;&#65292;&#21482;&#38656;&#35201;&#30475;<strong>&#20043;&#21069;</strong>&#30340;&#30343;&#21518;&#12290;</p>
<p>&#20248;&#21270; 2&#65306;&#21015;&#12289;&#20027;&#23545;&#35282;&#32447;&#12289;&#21103;&#23545;&#35282;&#32447;&#32534;&#30721;&#65292;&#23384;&#36215;&#26469;&#65292;&#21344;&#20102;&#19968;&#20010;&#22353;&#65292;&#23601;&#25226;&#37027;&#20010;&#22353;&#26631;&#35760;&#22909;&#12290;</p>
<p>&#36825;&#26679;&#65292;&#23601;&#19981;&#29992;&#36890;&#36807;&#24490;&#29615;&#26469;&#21028;&#26029;&#26159;&#21542;&#20914;&#31361;&#20102;&#12290;&#21482;&#35201;&#26816;&#27979;&#19968;&#20010;&#26631;&#24535;&#20301;&#12290;</p>
<p>&#36825;&#20010;&#26631;&#24535;&#20301;&#35774;&#35745;&#26041;&#26696;&#24590;&#20040;&#37117;&#21487;&#20197;&#65292;&#27604;&#22914;&#20687;&#36825;&#26679;&#65306;</p>
<pre><code>    &#20027;&#23545;&#35282;&#32447;                                            &#21103;&#23545;&#35282;&#32447;

  y - x    ?dx == dy                                y + x    ? dx == -dy (dx+dy==0)
      +----------------------------------&gt; y            +-----------------------------------&gt; y
      |  0   1   2   3   4   5   6   7                  |  0   1   2   3   4   5   6   7
      | -1   0   1   2   3   4   5   6                  |  1   2   3   4   5   6   7   8
      | -2  -1   0   1   2   3   4   5                  |  2   3   4   5   6   7   8   9
      | -3  -2  -1   0   1   2   3   4                  |  3   4   5   6   7   8   9  10
      | -4  -3  -2  -1   0   1   2   3                  |  4   5   6   7   8   9  10  11
      | -5  -4  -3  -2  -1   0   1   2                  |  5   6   7   8   9  10  11  12
    x | -6  -5  -4  -3  -2  -1   0   1               x  |  6   7   8   9  10  11  12  13
      | -7  -6  -5  -4  -3  -2  -1   0                  |  7   8   9  10  11  12  13  14
      V                                                 V</code></pre>
<p>&#20195;&#30721;&#22914;&#19979;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> search( <span class="dt">int</span> cur ) {
    <span class="kw">if</span>( cur == n ) {
        ++tot;
        <span class="co">// &#25171;&#21360;&#32467;&#26524;&#30340;&#20195;&#30721;&#25918;&#22312;&#36825;&#37324;</span>
    } <span class="kw">else</span> {
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
            <span class="co">// vis: visited, vis[0] -&gt; col, vis[1] -&gt; minor diag, vis[2] -&gt; major diag</span>
            <span class="kw">if</span>( !vis[<span class="dv">0</span>][i] &amp;&amp; !vis[<span class="dv">1</span>][cur+i] &amp;&amp; !vis[<span class="dv">2</span>][cur-i+n] ) {
                C[cur] = i;
                <span class="co">// col         y-x=0           y+x=0</span>
                vis[<span class="dv">0</span>][i] = vis[<span class="dv">1</span>][cur+i] = vis[<span class="dv">2</span>][cur-i+n] = <span class="dv">1</span>;
                search( cur<span class="dv">+1</span> );
                vis[<span class="dv">0</span>][i] = vis[<span class="dv">1</span>][cur+i] = vis[<span class="dv">2</span>][cur-i+n] = <span class="dv">0</span>;    <span class="co">// &#25913;&#22238;&#26469;</span>
            }
        }
    }
}</code></pre></div>
<p>&#20854;&#20013; vis &#26159;&#19968;&#20010;&#20108;&#32500;&#25968;&#32452;&#65292;<code>vis[0][i]</code> &#34920;&#31034;&#31532; i &#21015;&#26159;&#21542;&#34987;&#21344;&#22353;&#65288;1 &#26159;&#26377;&#20154;&#65292;0 &#26159;&#27809;&#20154;&#65289;&#65292; <code>vis[1][i]</code> &#34920;&#31034;&#21103;&#23545;&#35282;&#32447;&#65288;&#19978;&#38754;&#21491;&#22270;&#65289;&#65292; <code>vis[2][i]</code> &#34920;&#31034;&#20027;&#23545;&#35282;&#32447;&#65288;&#19978;&#38754;&#24038;&#22270;&#65292;&#22240;&#20026; cur-i &#21487;&#33021;&#20026;&#36127;&#65288;&#22270;&#20013;&#19979;&#19977;&#35282;&#37096;&#20998;&#65289;&#65292;&#25152;&#20197;&#65292;&#35201;&#21152;&#19978; n=8 &#65289;&#12290;</p>
<p>&#22914;&#26524;&#24819;&#30475;&#30475;&#27599;&#20010;&#21487;&#33021;&#24773;&#20917;&#30340;&#25918;&#32622;&#65292;&#22312;&#19978;&#38754; <code>// &#25171;&#21360;&#32467;&#26524;&#30340;&#20195;&#30721;&#25918;&#22312;&#36825;&#37324;</code> &#22788;&#21152;&#19978;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">printf( <span class="st">&quot;solve #</span><span class="ch">%d</span><span class="st">:&quot;</span>, tot );
<span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
    printf( <span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>, C[i] );
}
printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );</code></pre></div>
<p>&#36755;&#20986;&#22914;&#19979;&#65306;</p>
<pre><code>solve #1: 0 4 7 5 2 6 1 3
solve #2: 0 5 7 2 6 3 1 4
solve #3: 0 6 3 5 7 1 4 2
solve #4: 0 6 4 7 1 3 5 2
...
solve #89: 7 1 3 0 6 4 2 5
solve #90: 7 1 4 2 0 6 3 5
solve #91: 7 2 0 5 1 4 6 3
solve #92: 7 3 0 2 5 1 6 4</code></pre>
<p>&#25110;&#32773;&#65292;&#20320;&#35201;&#19968;&#20010;&#35270;&#35273;&#21270;&#30340;&#34920;&#31034;&#65292;&#19978;&#38754;&#30340;&#20195;&#30721;&#21487;&#20197;&#36825;&#20040;&#26469;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">printf( <span class="st">&quot;-- Solve #</span><span class="ch">%03d</span><span class="st"> --</span><span class="ch">\n</span><span class="st">&quot;</span>, tot );
<span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
    printf( <span class="st">&quot;+-+-+-+-+-+-+-+-+</span><span class="ch">\n</span><span class="st">&quot;</span> );
    <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j ) {
        printf( <span class="st">&quot;|</span><span class="ch">%c</span><span class="st">&quot;</span>, C[i] == j ? <span class="st">&#39;X&#39;</span> : <span class="st">&#39; &#39;</span> );
    }
    printf( <span class="st">&quot;|</span><span class="ch">\n</span><span class="st">&quot;</span> );
}
printf( <span class="st">&quot;-----------------</span><span class="ch">\n\n</span><span class="st">&quot;</span> );</code></pre></div>
<p>&#25171;&#21360;&#20986;&#26469;&#23601;&#26159;&#36825;&#26679;&#65306;&#65288;&#22914;&#26524;&#30475;&#24471;&#19981;&#22815;&#8220;&#26041;&#8221;&#65292;&#37027;&#26159;&#23383;&#23485;&#21644;&#34892;&#39640;&#30340;&#38382;&#39064;&#65292;&#23601;&#24618;&#19981;&#24471;&#25105;&#20102;&#65289;</p>
<pre><code>-- Solve #092 --
+-+-+-+-+-+-+-+-+
| | | | | | | |X|
+-+-+-+-+-+-+-+-+
| | | |X| | | | |
+-+-+-+-+-+-+-+-+
|X| | | | | | | |
+-+-+-+-+-+-+-+-+
| | |X| | | | | |
+-+-+-+-+-+-+-+-+
| | | | | |X| | |
+-+-+-+-+-+-+-+-+
| |X| | | | | | |
+-+-+-+-+-+-+-+-+
| | | | | | |X| |
+-+-+-+-+-+-+-+-+
| | | | |X| | | |
-----------------</code></pre>
</dd>
</dl>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> vis, C, tot = <span class="dv">0</span>, n = <span class="dv">8</span>, nc = <span class="dv">0</span>;

<span class="dt">void</span> search( <span class="dt">int</span> cur ) {
    ++nc;
    <span class="kw">if</span>( cur == n ) {
        ++tot;
    } <span class="kw">else</span> {
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
            <span class="co">// vis: visited, vis -&gt; col, vis -&gt; minor diag, vis -&gt; major diag</span>
            <span class="kw">if</span>( !vis[i] &amp;&amp; !vis[cur+i] &amp;&amp; !vis[cur-i+n] ) {
                C[cur] = i;
                <span class="co">// col          x+y                 y-x</span>
                vis[i] = vis[cur+i] = vis[cur-i+n] = <span class="dv">1</span>;
                search( cur<span class="dv">+1</span> );
                vis[i] = vis[cur+i] = vis[cur-i+n] = <span class="dv">0</span>;    <span class="co">// &#25913;&#22238;&#26469;</span>
            }
        }
    }
}

<span class="dt">int</span> main() {
    memset( vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis) );
    search( <span class="dv">0</span> );
    printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, tot );
    printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, nc );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>output:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">92</span>
<span class="kw">2057</span></code></pre></div>
<p>print the result:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">++tot;
<span class="co">// add several lines here</span>
printf( <span class="st">&quot;solve #</span><span class="ch">%d</span><span class="st">:&quot;</span>, tot );
<span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
    printf( <span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>, C[i] );
}
printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );</code></pre></div>
<dl>
<dt>see all the 92 solves. <code class="fold">@</code></dt>
<dd><pre><code>solve #1: 0 4 7 5 2 6 1 3
solve #2: 0 5 7 2 6 3 1 4
solve #3: 0 6 3 5 7 1 4 2
solve #4: 0 6 4 7 1 3 5 2
solve #5: 1 3 5 7 2 0 6 4
solve #6: 1 4 6 0 2 7 5 3
solve #7: 1 4 6 3 0 7 5 2
solve #8: 1 5 0 6 3 7 2 4
solve #9: 1 5 7 2 0 3 6 4
solve #10: 1 6 2 5 7 4 0 3
solve #11: 1 6 4 7 0 3 5 2
solve #12: 1 7 5 0 2 4 6 3
solve #13: 2 0 6 4 7 1 3 5
solve #14: 2 4 1 7 0 6 3 5
solve #15: 2 4 1 7 5 3 6 0
solve #16: 2 4 6 0 3 1 7 5
solve #17: 2 4 7 3 0 6 1 5
solve #18: 2 5 1 4 7 0 6 3
solve #19: 2 5 1 6 0 3 7 4
solve #20: 2 5 1 6 4 0 7 3
solve #21: 2 5 3 0 7 4 6 1
solve #22: 2 5 3 1 7 4 6 0
solve #23: 2 5 7 0 3 6 4 1
solve #24: 2 5 7 0 4 6 1 3
solve #25: 2 5 7 1 3 0 6 4
solve #26: 2 6 1 7 4 0 3 5
solve #27: 2 6 1 7 5 3 0 4
solve #28: 2 7 3 6 0 5 1 4
solve #29: 3 0 4 7 1 6 2 5
solve #30: 3 0 4 7 5 2 6 1
solve #31: 3 1 4 7 5 0 2 6
solve #32: 3 1 6 2 5 7 0 4
solve #33: 3 1 6 2 5 7 4 0
solve #34: 3 1 6 4 0 7 5 2
solve #35: 3 1 7 4 6 0 2 5
solve #36: 3 1 7 5 0 2 4 6
solve #37: 3 5 0 4 1 7 2 6
solve #38: 3 5 7 1 6 0 2 4
solve #39: 3 5 7 2 0 6 4 1
solve #40: 3 6 0 7 4 1 5 2
solve #41: 3 6 2 7 1 4 0 5
solve #42: 3 6 4 1 5 0 2 7
solve #43: 3 6 4 2 0 5 7 1
solve #44: 3 7 0 2 5 1 6 4
solve #45: 3 7 0 4 6 1 5 2
solve #46: 3 7 4 2 0 6 1 5
solve #47: 4 0 3 5 7 1 6 2
solve #48: 4 0 7 3 1 6 2 5
solve #49: 4 0 7 5 2 6 1 3
solve #50: 4 1 3 5 7 2 0 6
solve #51: 4 1 3 6 2 7 5 0
solve #52: 4 1 5 0 6 3 7 2
solve #53: 4 1 7 0 3 6 2 5
solve #54: 4 2 0 5 7 1 3 6
solve #55: 4 2 0 6 1 7 5 3
solve #56: 4 2 7 3 6 0 5 1
solve #57: 4 6 0 2 7 5 3 1
solve #58: 4 6 0 3 1 7 5 2
solve #59: 4 6 1 3 7 0 2 5
solve #60: 4 6 1 5 2 0 3 7
solve #61: 4 6 1 5 2 0 7 3
solve #62: 4 6 3 0 2 7 5 1
solve #63: 4 7 3 0 2 5 1 6
solve #64: 4 7 3 0 6 1 5 2
solve #65: 5 0 4 1 7 2 6 3
solve #66: 5 1 6 0 2 4 7 3
solve #67: 5 1 6 0 3 7 4 2
solve #68: 5 2 0 6 4 7 1 3
solve #69: 5 2 0 7 3 1 6 4
solve #70: 5 2 0 7 4 1 3 6
solve #71: 5 2 4 6 0 3 1 7
solve #72: 5 2 4 7 0 3 1 6
solve #73: 5 2 6 1 3 7 0 4
solve #74: 5 2 6 1 7 4 0 3
solve #75: 5 2 6 3 0 7 1 4
solve #76: 5 3 0 4 7 1 6 2
solve #77: 5 3 1 7 4 6 0 2
solve #78: 5 3 6 0 2 4 1 7
solve #79: 5 3 6 0 7 1 4 2
solve #80: 5 7 1 3 0 6 4 2
solve #81: 6 0 2 7 5 3 1 4
solve #82: 6 1 3 0 7 4 2 5
solve #83: 6 1 5 2 0 3 7 4
solve #84: 6 2 0 5 7 4 1 3
solve #85: 6 2 7 1 4 0 5 3
solve #86: 6 3 1 4 7 0 2 5
solve #87: 6 3 1 7 5 0 2 4
solve #88: 6 4 2 0 5 7 1 3
solve #89: 7 1 3 0 6 4 2 5
solve #90: 7 1 4 2 0 6 3 5
solve #91: 7 2 0 5 1 4 6 3
solve #92: 7 3 0 2 5 1 6 4
92</code></pre>
</dd>
</dl>
<p>we can also print out the details:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">printf( <span class="st">&quot;-- Solve #</span><span class="ch">%03d</span><span class="st"> --</span><span class="ch">\n</span><span class="st">&quot;</span>, tot );
<span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
    printf( <span class="st">&quot;+-+-+-+-+-+-+-+-+</span><span class="ch">\n</span><span class="st">&quot;</span> );
    <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j ) {
        printf( <span class="st">&quot;|</span><span class="ch">%c</span><span class="st">&quot;</span>, C[i] == j ? <span class="st">&#39;X&#39;</span> : <span class="st">&#39; &#39;</span> );
    }
    printf( <span class="st">&quot;|</span><span class="ch">\n</span><span class="st">&quot;</span> );
}
printf( <span class="st">&quot;-----------------</span><span class="ch">\n\n</span><span class="st">&quot;</span> );</code></pre></div>
<p>which yields to:</p>
<pre><code>-- Solve #092 --
+-+-+-+-+-+-+-+-+
| | | | | | | |X|
+-+-+-+-+-+-+-+-+
| | | |X| | | | |
+-+-+-+-+-+-+-+-+
|X| | | | | | | |
+-+-+-+-+-+-+-+-+
| | |X| | | | | |
+-+-+-+-+-+-+-+-+
| | | | | |X| | |
+-+-+-+-+-+-+-+-+
| |X| | | | | | |
+-+-+-+-+-+-+-+-+
| | | | | | |X| |
+-+-+-+-+-+-+-+-+
| | | | |X| | | |
-----------------</code></pre>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>prime ring <code class="fold">@</code></dt>
<dd><p>&#36755;&#20837;&#27491;&#25972;&#25968; n&#65292;&#25226;&#25972;&#25968; 1&#65292;2&#65292;&#8230;&#65292;n &#32452;&#25104;&#19968;&#20010;&#29615;&#65292;&#20351;&#24471;&#30456;&#37051;&#20004;&#20010;&#25972;&#25968;&#30340;&#21644;&#22343;&#20026;&#32032;&#25968;&#12290;&#36755;&#20986;&#26102;&#20174;&#25972;&#25968; 1 &#24320;&#22987;&#36870;&#26102;&#38024;&#25490;&#21015;&#12290;&#21516;&#19968;&#20010;&#29615;&#24212;&#24688;&#22909;&#36755;&#20986;&#19968;&#27425;&#12290;n &lt;= 16&#12290;</p>
<pre><code>input:

    6

output:

    1   4   3   2   5   6
    1   6   5   2   3   4</code></pre>
<dl>
<dt>&#22914;&#26524;&#30452;&#25509;&#26292;&#21147;&#12290;&#25490;&#21015;&#24635;&#25968;&#39640;&#36798; 16! = 2x10<sup>13</sup> <code class="fold">@</code></dt>
<dd><p>&#30452;&#25509;&#26292;&#21147;&#8211;&#29983;&#25104;&#27979;&#35797;&#27861;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= n*<span class="dv">2</span>; ++i ) { isp[i] = is_prime( i ); }
<span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) { A[i] = i<span class="dv">+1</span>; }
<span class="kw">do</span>  {
    <span class="dt">int</span> ok = <span class="dv">1</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
        <span class="kw">if</span>( !isp[A[i]+A[(i<span class="dv">+1</span>)%n]] ) { ok = <span class="dv">0</span>; <span class="kw">break</span>; }
    }
    <span class="kw">if</span>( ok ) {
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) { printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, A[i] ); }
        printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
    }
} <span class="kw">while</span>( next_permutation(A<span class="dv">+1</span>, A+n) );</code></pre></div>
<p>&#24403; n = 12 &#23601;&#30456;&#24403;&#24930;&#20102;&#12290;</p>
</dd>
<dt>&#29983;&#25104;&#8211;&#27979;&#35797;&#27861;&#22826;&#24930;&#65292;&#29616;&#22312;&#29992;&#22238;&#28335;&#27861; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> is_prime( <span class="dt">int</span> x ) {
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">2</span>; i*i &lt;= x; i++ ) {
        <span class="kw">if</span>( x % i == <span class="dv">0</span> ) { <span class="kw">return</span> <span class="dv">0</span>; }
    }
    <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">50</span>;
<span class="dt">int</span> n, A[maxn], isp[maxn], vis[maxn];
<span class="dt">void</span> dfs( <span class="dt">int</span> cur ) {
    <span class="kw">if</span>( cur == n &amp;&amp; isp[A[<span class="dv">0</span>]+A[n<span class="dv">-1</span>]] ) {                <span class="co">// &#24050;&#32463;&#22788;&#29702;&#20102;&#25152;&#26377;&#65292;&#38500;&#20102;&#31532;&#19968;&#20010;&#21644;&#26368;&#21518;&#19968;&#20010;&#65288;&#38381;&#29615;&#65289;</span>
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++ ) {
            <span class="kw">if</span>( i != <span class="dv">0</span> ) { printf( <span class="st">&quot; &quot;</span> ); }
            printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, A[i] );
        }
        printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
    } <span class="kw">else</span> {
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= n; i++ ) {
            <span class="kw">if</span>( !vis[i] &amp;&amp; isp[i+A[cur<span class="dv">-1</span>]] ) {          <span class="co">// &#36825;&#27425;&#25105;&#36873; i&#65292;&#35774;&#32622; cur &#30340;&#20301;&#32622;</span>
                A[cur] = i;
                vis[i] = <span class="dv">1</span>;                             <span class="co">// visited</span>
                dfs( cur<span class="dv">+1</span> );                           <span class="co">// &#36882;&#24402;&#65292;&#22788;&#29702; cur+1 &#30340;&#20301;&#32622;</span>
                vis[i] = <span class="dv">0</span>;                             <span class="co">// change back</span>
            }
        }
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> kase = <span class="dv">0</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; maxn; ++i ) { isp[i] = is_prime( i ); }
    <span class="kw">while</span>( scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n ) == <span class="dv">1</span> &amp;&amp; n &gt; <span class="dv">0</span> ) {
        <span class="kw">if</span>( kase &gt; <span class="dv">0</span> ) { printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> ); }
        printf( <span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">:</span><span class="ch">\n</span><span class="st">&quot;</span>, ++kase );
        memset( vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis) );
        A[<span class="dv">0</span>] = <span class="dv">1</span>;
        dfs( <span class="dv">1</span> );   <span class="co">// put A[1]</span>
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">echo</span> 6 <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">Case</span> 1:
<span class="kw">1</span> 4 3 2 5 6
<span class="kw">1</span> 6 5 2 3 4</code></pre></div>
<p>&#22240;&#20026;&#26159;&#19968;&#20010;&#29615;&#65292;&#25152;&#20197;&#22266;&#23450;&#20102;&#31532;&#19968;&#20010;&#26159; 1&#12290;&#36825;&#26679;&#20415;&#27809;&#26377;&#37325;&#22797;&#36755;&#20986;&#12290;&#37324;&#38754;&#30340; i &#20063;&#26159;&#20174; 2 &#24320;&#22987;&#24490;&#29615;&#65292;&#25152;&#20197;&#19981;&#29992;&#25285;&#24515; <code>vis[1]</code> &#27809;&#26377;&#35774;&#23450;&#20102;&#12290;</p>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>&#22256;&#38590;&#30340;&#20018; Krypton Factor :???: <code class="fold">@</code></dt>
<dd><p>&#21253;&#21547;&#20004;&#20010;&#30456;&#37051;&#30340;&#37325;&#22797;&#23376;&#20018;&#65292;&#31216;&#20043;&#20026;&#8220;&#23481;&#26131;&#30340;&#20018;&#8221;&#65292;&#21542;&#21017;&#65292;&#8220;&#22256;&#38590;&#30340;&#20018;&#8221;&#12290;&#20363;&#22914;&#65292;&#8220;BB&#8221;&#12289;&#8220;ABCDACABCAB&#8221;&#12289;&#8220;ABCDABCD&#8221;&#37117;&#26159;&#23481;&#26131;&#30340;&#65292;&#32780;&#8220;D&#8221;&#12289;&#8220;DC&#8221;&#12289;&#8220;ABDAB&#8221;&#12289;&#8220;CBABCBA&#8221;&#37117;&#26159;&#22256;&#38590;&#30340;&#20018;&#12290;</p>
<p>&#36755;&#20837;&#27491;&#25972;&#25968; n &#21644; L&#65292;&#36755;&#20986;&#30001;&#38065; L &#20010;&#23383;&#31526;&#32452;&#25104;&#30340;&#12289;&#23383;&#20856;&#24207;&#31532; k &#23567;&#30340;&#22256;&#38590;&#30340;&#20018;&#12290;</p>
<pre><code>input:

    7   3
    30  3

output:

    ABAC ABA
    ABAC ABCA CBAB CABA CABC ACBA CABA</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa129 Krypton Factor</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="dt">int</span> n, L, cnt;
<span class="dt">int</span> S;

<span class="dt">int</span> dfs( <span class="dt">int</span> cur ) {                                                <span class="co">// &#36820;&#22238; 0 &#34920;&#31034;&#24050;&#32463;&#24471;&#21040;&#35299;&#65292;&#26080;&#39035;&#32487;&#32493;&#25628;&#32034;</span>
    <span class="kw">if</span>( cnt++ == n ) {
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; cur; i++ ) {
            <span class="kw">if</span>( i % <span class="dv">64</span> == <span class="dv">0</span> &amp;&amp; i &gt; <span class="dv">0</span> ) {
                printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
            } <span class="kw">else</span> <span class="kw">if</span>( i % <span class="dv">4</span> == <span class="dv">0</span> &amp;&amp; i &gt; <span class="dv">0</span> ) {
                printf( <span class="st">&quot; &quot;</span> );
            }
            printf( <span class="st">&quot;</span><span class="ch">%c</span><span class="st">&quot;</span>, <span class="st">&#39;A&#39;</span>+S[i] );                               <span class="co">// &#36755;&#20986;&#26041;&#26696;</span>
        }
        printf( <span class="st">&quot;</span><span class="ch">\n%d\n</span><span class="st">&quot;</span>, cur );
        <span class="kw">return</span> <span class="dv">0</span>;
    }
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; L; i++ ) {
        S[cur] = i;
        <span class="dt">int</span> ok = <span class="dv">1</span>;
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">1</span>; j*<span class="dv">2</span> &lt;= cur<span class="dv">+1</span>; j++ ) {                       <span class="co">// &#23581;&#35797;&#38271;&#24230;&#20026; j*2 &#30340;&#21518;&#32512;</span>
            <span class="dt">int</span> equal = <span class="dv">1</span>;
            <span class="kw">for</span>( <span class="dt">int</span> k = <span class="dv">0</span>; k &lt; j; k++ ) {                          <span class="co">// &#26816;&#26597;&#21518;&#19968;&#21322;&#26159;&#21542;&#31561;&#20110;&#21069;&#19968;&#21322;</span>
                <span class="kw">if</span>( S[cur-k] != S[cur-k-j] ) { equal = <span class="dv">0</span>; <span class="kw">break</span>; }
            }
            <span class="kw">if</span>( equal ) { ok = <span class="dv">0</span>; <span class="kw">break</span>; }                          <span class="co">// &#21518;&#19968;&#21322;&#31561;&#20110;&#21069;&#19968;&#21322;&#65292;&#26041;&#26696;&#19981;&#21512;&#27861;</span>
        }
        <span class="kw">if</span>( ok ) <span class="kw">if</span>( !dfs(cur<span class="dv">+1</span>) ) { <span class="kw">return</span> <span class="dv">0</span>; }                    <span class="co">// &#36882;&#24402;&#25628;&#32034;&#12290;&#22914;&#26524;&#24050;&#32463;&#25214;&#21040;&#35299;&#65292;&#21017;&#30452;&#25509;&#36864;&#20986;</span>
    }
    <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="dt">int</span> main() {
    <span class="kw">while</span>( scanf( <span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;L ) == <span class="dv">2</span> &amp;&amp; n &gt; <span class="dv">0</span> ) {
        cnt = <span class="dv">0</span>;
        dfs( <span class="dv">0</span> );
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">echo</span> 7 3 <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">ABAC</span> ABA
<span class="kw">7</span></code></pre></div>
<p>&#22238;&#28335;&#27861;&#35201;&#27880;&#24847;&#24573;&#30053;&#19981;&#24517;&#35201;&#30340;&#21028;&#26029;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#24102;&#23485;&#65292;Bandwith &#9829;&#65039; <code class="fold">@</code></dt>
<dd><blockquote>
<p>&#26368;&#20248;&#24615;&#21098;&#32440;</p>
</blockquote>
<p>&#32473;&#20986;&#19968;&#20010; n&#65288;n&lt;=8&#65289;&#20010;&#33410;&#28857;&#30340;&#22270; G &#21644;&#19968;&#20010;&#33410;&#28857;&#30340;&#25490;&#21015;&#12290;&#23450;&#20041;&#33410;&#28857; i &#30340;&#24102;&#23485; b(i) &#20026; i &#21644;&#30456;&#37051;&#32467;&#28857;&#22312;&#25490;&#21015;&#20013;&#30340;&#26368;&#36828;&#36317;&#31163;&#65292;&#32780;&#25152;&#26377; b(i) &#30340;&#26368;&#22823;&#20540;&#23601;&#26159;&#25972;&#20010;&#22270;&#30340;&#24102;&#23485;&#12290;&#32473;&#23450;&#22270; G&#65292;&#27714;&#20986;&#35753;&#24102;&#23485;&#26368;&#23567;&#30340;&#33410;&#28857;&#25490;&#21015;&#65292;&#22914;&#22270; 7-7 &#25152;&#31034;&#12290;</p>
<pre><code>            A ------------- F
           /               /|
          /               / |
         /               /  H
        B ------------- G   |
        |               |   E
        |               |  /
        |               | /
        C-------------- D

            &#22270; G</code></pre>
<p>&#19979;&#38754;&#20004;&#20010;&#25490;&#21015;&#30340;&#24102;&#23485;&#20998;&#21035;&#20026; 6 &#21644; 5&#12290;&#20855;&#20307;&#35828;&#65292;&#19979;&#38754;&#24038;&#22270;&#30340;&#21508;&#20010;&#32467;&#28857;&#30340;&#24102;&#23485;&#20998;&#21035;&#20026; 6&#65292;6&#65292;1&#65292;4&#65292;1&#65292;1&#65292;6&#65292;6&#65292;&#21491;&#22270;&#30340;&#21508;&#20010;&#32467;&#28857;&#30340;&#24102;&#23485;&#20998;&#21035;&#20026; 5&#65292;3&#65292;1&#65292;4&#65292;3&#65292;5&#65292;1&#65292;4&#12290;</p>
<pre><code>    +-----------------------+         +-------------------+
    |                       |         |                   |
+-----------------------+   |         |   +-----------+   |
|   |                   |   |         |   |           |   |
|   |                   |   |         |   |           |   |
A   B   C   D   E   H   F   G         A   B   C   D   G   F   H   E
            |               |                     |               |
            |               |                     |               |
            +---------------+                     +---------------+

            (a)                                 (b)</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa140 Bandwidth</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">10</span>;
<span class="dt">int</span> id, letter[maxn];

<span class="dt">int</span> main() {
    <span class="dt">char</span> input;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, input) == <span class="dv">1</span> &amp;&amp; input != <span class="st">&#39;#&#39;</span>) {
        <span class="co">// &#35745;&#31639;&#32467;&#28857;&#20010;&#25968;&#24182;&#32473;&#23383;&#27597;&#32534;&#21495;</span>
        <span class="dt">int</span> n = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">char</span> ch = <span class="st">&#39;A&#39;</span>; ch &lt;= <span class="st">&#39;Z&#39;</span>; ch++)
            <span class="kw">if</span>(strchr(input, ch) != NULL) {
                id[ch] = n++;
                letter[id[ch]] = ch;
            }

        <span class="co">// &#22788;&#29702;&#36755;&#20837;</span>
        <span class="dt">int</span> len = strlen(input), p = <span class="dv">0</span>, q = <span class="dv">0</span>;
        vector&lt;<span class="dt">int</span>&gt; u, v;
        <span class="kw">for</span>(;;) {
            <span class="kw">while</span>(p &lt; len &amp;&amp; input[p] != <span class="st">&#39;:&#39;</span>) p++;
            <span class="kw">if</span>(p == len) <span class="kw">break</span>;
            <span class="kw">while</span>(q &lt; len &amp;&amp; input[q] != <span class="st">&#39;;&#39;</span>) q++;
            <span class="kw">for</span>(<span class="dt">int</span> i = p<span class="dv">+1</span>; i &lt; q; i++) {
                u.push_back(id[input[p<span class="dv">-1</span>]]);
                v.push_back(id[input[i]]);
            }
            p++; q++;
        }

        <span class="co">// &#26522;&#20030;&#20840;&#25490;&#21015;</span>
        <span class="dt">int</span> P[maxn], bestP[maxn], pos[maxn], ans = n;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) P[i] = i;
        <span class="kw">do</span> {
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) pos[P[i]] = i; <span class="co">// &#27599;&#20010;&#23383;&#27597;&#30340;&#20301;&#32622;</span>
            <span class="dt">int</span> bandwidth = <span class="dv">0</span>;
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; u.size(); i++)
                bandwidth = max(bandwidth, abs(pos[u[i]] - pos[v[i]])); <span class="co">// &#35745;&#31639;&#24102;&#23485;</span>
            <span class="kw">if</span>(bandwidth &lt; ans) {
                ans = bandwidth;
                memcpy(bestP, P, <span class="kw">sizeof</span>(P));
            }
        } <span class="kw">while</span>(next_permutation(P, P+n));

        <span class="co">// &#36755;&#20986;</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) printf(<span class="st">&quot;</span><span class="ch">%c</span><span class="st"> &quot;</span>, letter[bestP[i]]);
        printf(<span class="st">&quot;-&gt; </span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#22825;&#24179;&#38590;&#39064;&#65292;Mobile Computing <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1354 Mobile Computing</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> Tree {
    <span class="dt">double</span> L, R; <span class="co">// distance from the root to the leftmost/rightmost point</span>
    Tree():L(<span class="dv">0</span>),R(<span class="dv">0</span>) {}
};

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">6</span>;

<span class="dt">int</span> n, vis[<span class="dv">1</span>&lt;&lt;maxn];
<span class="dt">double</span> r, w[maxn], sum[<span class="dv">1</span>&lt;&lt;maxn];
vector&lt;Tree&gt; tree[<span class="dv">1</span>&lt;&lt;maxn];

<span class="dt">void</span> dfs(<span class="dt">int</span> subset) {
    <span class="kw">if</span>(vis[subset]) <span class="kw">return</span>;
    vis[subset] = <span class="kw">true</span>;

    <span class="dt">bool</span> have_children = <span class="kw">false</span>;
    <span class="kw">for</span>(<span class="dt">int</span> left = (subset<span class="dv">-1</span>)&amp;subset; left; left = (left<span class="dv">-1</span>)&amp;subset) {
        have_children = <span class="kw">true</span>;

        <span class="dt">int</span> right = subset^left;
        <span class="dt">double</span> d1 = sum[right] / sum[subset];
        <span class="dt">double</span> d2 = sum[left] / sum[subset];

        dfs(left); dfs(right);

        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; tree[left].size(); i++)
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; tree[right].size(); j++) {
                Tree t;
                t.L = max(tree[left][i].L + d1, tree[right][j].L - d2);
                t.R = max(tree[right][j].R + d2, tree[left][i].R - d1);
                <span class="kw">if</span>(t.L + t.R &lt; r) tree[subset].push_back(t);
            }
    }

    <span class="kw">if</span>(!have_children) tree[subset].push_back(Tree());
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%lf%d</span><span class="st">&quot;</span>, &amp;r, &amp;n);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) scanf(<span class="st">&quot;</span><span class="ch">%lf</span><span class="st">&quot;</span>, &amp;w[i]);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; (<span class="dv">1</span>&lt;&lt;n); i++) {
            sum[i] = <span class="dv">0</span>;
            tree[i].clear();
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)
                <span class="kw">if</span>(i &amp; (<span class="dv">1</span>&lt;&lt;j)) sum[i] += w[j];
        }

        <span class="dt">int</span> root = (<span class="dv">1</span>&lt;&lt;n)<span class="dv">-1</span>;
        memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
        dfs(root);

        <span class="dt">double</span> ans = <span class="dv">-1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; tree[root].size(); i++)
            ans = max(ans, tree[root][i].L + tree[root][i].R);
        printf(<span class="st">&quot;</span><span class="ch">%.10lf\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#36335;&#24452;&#23547;&#25214;&#38382;&#39064; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#20843;&#25968;&#30721;&#38382;&#39064; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><pre><code>+---+---+---+        +---+---+---+
| 2 | 6 | 4 |        | 8 | 1 | 5 |
+---+---+---+        +---+---+---+
| 1 | 3 | 7 |        | 7 | 3 | 6 |
+---+---+---+        +---+---+---+
|   | 5 | 8 |        | 4 |   | 2 |
+---+---+---+        +---+---+---+

input: (current, goal)

    2   6   4   1   3   7   0   5   8
    8   1   5   7   3   6   4   0   2

output: (#steps)

    31</code></pre>
<p>&#19977;&#31181;&#32534;&#30721;&#26041;&#24335;&#65306;</p>
<ul>
<li>&#23436;&#32654;&#21704;&#24076;&#65306;&#25226; 0~8 &#30340;&#20840;&#25490;&#21015;&#21644; 0~362879 &#23545;&#24212;&#36215;&#26469;&#12290;</li>
<li>hash &#34920;&#65306;&#20914;&#31361;&#36234;&#22810;&#25928;&#29575;&#36234;&#20302;&#65292;&#36866;&#29992;&#36820;&#22238;&#24191;&#12290;</li>
<li>STL &#37324;&#30340; set&#65306;<code>set.insert( item )</code>&#65292;<code>set.count( item )</code>&#65292;<code>set.clear()</code></li>
</ul>
<p>&#21487;&#20197;&#20808;&#29992; set &#25226;&#36923;&#36753;&#35843;&#36890;&#65292;&#28982;&#21518;&#25442;&#25928;&#29575;&#26356;&#39640;&#30340; hash&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;algorithm&gt;                                    </span><span class="co">// next_permutation</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;math.h&gt;                                       </span><span class="co">// sqrt</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> <span class="dt">int</span> State;
<span class="dt">const</span> <span class="dt">int</span> maxstate = <span class="dv">100000</span>;

State st[maxstate], goal;
<span class="co">// int goal;</span>
<span class="dt">int</span> dist[maxstate];

<span class="dt">const</span> <span class="dt">int</span> dx[] = {  <span class="dv">-1</span>,  <span class="dv">1</span>,  <span class="dv">0</span>,  <span class="dv">0</span>  };
<span class="dt">const</span> <span class="dt">int</span> dy[] = {   <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">-1</span>,  <span class="dv">1</span>  };

<span class="dt">int</span> vis, fact;
<span class="dt">void</span> init_lookup_table() {                              <span class="co">// fact[i] = i!</span>
    fact = <span class="dv">1</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="dv">9</span>; ++i ) {
        fact[i] = fact[i<span class="dv">-1</span>] * i;
    }
}

<span class="dt">int</span> try_to_insert( <span class="dt">int</span> s ) {
    <span class="dt">int</span> code = <span class="dv">0</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">9</span>; ++i ) {
        <span class="dt">int</span> cnt = <span class="dv">0</span>;
        <span class="kw">for</span>( <span class="dt">int</span> j = i<span class="dv">+1</span>; j &lt; <span class="dv">9</span>; ++j ) {
            <span class="kw">if</span>( st[s][j] &lt; st[s][i] ) {
                ++cnt;
            }
        }
        code += fact[<span class="dv">8</span>-i] * cnt;
    }
    <span class="kw">if</span>( vis[code] ) {
        <span class="kw">return</span> <span class="dv">0</span>;
    } <span class="kw">else</span> {
        <span class="kw">return</span> vis[code] = <span class="dv">1</span>;
    }
}

<span class="dt">int</span> bfs() {
    init_lookup_table();
    <span class="dt">int</span> front = <span class="dv">1</span>, rear = <span class="dv">2</span>;                                    <span class="co">// &#19981;&#36866;&#29992;&#19979;&#26631; 0&#65292;0 is &#39;not exist&#39;</span>
    <span class="kw">while</span>( front &lt; rear ) {
        State &amp;s = st[front];
        <span class="kw">if</span>( memcmp( goal, s, <span class="kw">sizeof</span>(s) ) == <span class="dv">0</span> ) {
            <span class="kw">return</span> front;                                       <span class="co">// gotcha</span>
        }
        <span class="dt">int</span> z;
        <span class="kw">for</span>( z = <span class="dv">0</span>; z &lt; <span class="dv">9</span>; ++z ) { <span class="kw">if</span>( !s[z] ) { <span class="kw">break</span>; } }     <span class="co">// get &#39;0&#39;</span>
        <span class="dt">int</span> x = z/<span class="dv">3</span>, y = z%<span class="dv">3</span>;
        <span class="kw">for</span>( <span class="dt">int</span> d = <span class="dv">0</span>; d &lt; <span class="dv">4</span>; ++d ) {
            <span class="dt">int</span> newx = x + dx[d];
            <span class="dt">int</span> newy = y + dy[d];
            <span class="dt">int</span> newz = newx * <span class="dv">3</span> + newy;
            <span class="kw">if</span>( newx &gt;= <span class="dv">0</span> &amp;&amp; newx &lt; <span class="dv">3</span> &amp;&amp; newy &gt;= <span class="dv">0</span> &amp;&amp; newy &lt; <span class="dv">3</span> ) {
                State &amp;t = st[rear];
                <span class="co">// seems, both `&amp;t&#39; or `t&#39; will work</span>
                memcpy( t, s, <span class="kw">sizeof</span>(s) );                      <span class="co">// type of t, s: int is actually a int *</span>
                t[newz] = s[z];
                t[z] = s[newz];
                dist[rear] = dist[front] + <span class="dv">1</span>;
                <span class="kw">if</span>( try_to_insert(rear) ) {
                    ++rear;
                }
            }
        }
        ++front;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> main() {
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">9</span>; ++i ) { scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;st[i] ); }
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">9</span>; ++i ) { scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;goal[i] ); }
    <span class="dt">int</span> ans = bfs();
    <span class="kw">if</span>( ans &gt; <span class="dv">0</span> ) {
        printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, dist[ans] );
    } <span class="kw">else</span> {
        printf( <span class="st">&quot;-1</span><span class="ch">\n</span><span class="st">&quot;</span> );
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>input.txt</p>
<pre><code>2   6   4   1   3   7   0   5   8
8   1   5   7   3   6   4   0   2</code></pre>
<p>run it:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">g++</span> source.cpp -o source
$ <span class="kw">cat</span> input.txt <span class="kw">|</span> <span class="kw">./source</span>
<span class="kw">1</span>   2   3   4   5   6   7   8   0
<span class="kw">1</span>   2   3   4   5   6   8   7   0</code></pre></div>
<p>&#23436;&#32654;&#21704;&#24076;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>7-8 &#20498;&#27700;&#38382;&#39064;&#65292;fill :???: <code class="fold">@</code></dt>
<dd><p>&#19977;&#20010;&#26479;&#23376;&#23481;&#37327;&#20026; a&#65292;b&#65292;c&#65288;1&lt;=a,b,c&lt;=200&#65289;&#12290;</p>
<p>&#29366;&#24577;&#65306;&#31532; 1&#12289;2&#12289;3 &#26479;&#23376;&#23545;&#24212;&#30340;&#27700;&#26377; (v0, v1, v2)&#12290;</p>
<p>&#29366;&#24577;&#21644;&#23427;&#30340;&#36716;&#31227;&#65306;&#29366;&#24577;&#22270;&#65288;state graph&#65289;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10603 Fill</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;queue&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> Node {
    <span class="dt">int</span> v[<span class="dv">3</span>], dist;
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Node&amp; rhs) <span class="dt">const</span> {
        <span class="kw">return</span> dist &gt; rhs.dist;
    }
};

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">200</span> + <span class="dv">5</span>;
<span class="dt">int</span> mark[maxn][maxn], dist[maxn][maxn], cap[<span class="dv">3</span>], ans[maxn];

<span class="dt">void</span> update_ans(<span class="dt">const</span> Node&amp; u) {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i++) {
        <span class="dt">int</span> d = u.v[i];
        <span class="kw">if</span>(ans[d] &lt; <span class="dv">0</span> || u.dist &lt; ans[d]) ans[d] = u.dist;
    }
}

<span class="dt">void</span> solve(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> c, <span class="dt">int</span> d) {
    cap[<span class="dv">0</span>] = a; cap[<span class="dv">1</span>] = b; cap[<span class="dv">2</span>] = c;
    memset(ans, <span class="dv">-1</span>, <span class="kw">sizeof</span>(ans));
    memset(mark, <span class="dv">0</span>, <span class="kw">sizeof</span>(mark));
    memset(dist, <span class="dv">-1</span>, <span class="kw">sizeof</span>(dist));
    priority_queue&lt;Node&gt; q;

    Node start;
    start.dist = <span class="dv">0</span>;
    start.v[<span class="dv">0</span>] = <span class="dv">0</span>; start.v[<span class="dv">1</span>] = <span class="dv">0</span>; start.v[<span class="dv">2</span>] = c;
    q.push(start);

    dist = <span class="dv">0</span>;
    <span class="kw">while</span>(!q.empty()) {
        Node u = q.top(); q.pop();
        <span class="kw">if</span>(mark[u.v][u.v]) <span class="kw">continue</span>;
        mark[u.v][u.v] = <span class="dv">1</span>;
        update_ans(u);
        <span class="kw">if</span>(ans[d] &gt;= <span class="dv">0</span>) <span class="kw">break</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i++)
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">3</span>; j++) <span class="kw">if</span>(i != j) {
                <span class="kw">if</span>(u.v[i] == <span class="dv">0</span> || u.v[j] == cap[j]) <span class="kw">continue</span>;
                <span class="dt">int</span> amount = min(cap[j], u.v[i] + u.v[j]) - u.v[j];
                Node u2;
                memcpy(&amp;u2, &amp;u, <span class="kw">sizeof</span>(u));
                u2.dist = u.dist + amount;
                u2.v[i] -= amount;
                u2.v[j] += amount;
                <span class="dt">int</span>&amp; D = dist[u2.v][u2.v];
                <span class="kw">if</span>(D &lt; <span class="dv">0</span> || u2.dist &lt; D){
                    D = u2.dist;
                    q.push(u2);
                }
            }
    }
    <span class="kw">while</span>(d &gt;= <span class="dv">0</span>) {
        <span class="kw">if</span>(ans[d] &gt;= <span class="dv">0</span>) {
            printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans[d], d);
            <span class="kw">return</span>;
        }
        d--;
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T, a, b, c, d;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d%d%d%d</span><span class="st">&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);
        solve(a, b, c, d);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>7-9 UVa1601 &#19975;&#22307;&#33410;&#30340;&#26089;&#19978;&#65292;The Morning after Halloween &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p><code>w*h</code>&#65288;w,h &lt;= 16&#65289;&#32593;&#26684;&#19978;&#26377; n&#65288;n &lt;= 3&#65289;&#20010;&#23567;&#20889;&#23383;&#27597;&#65288;&#20195;&#34920;&#39740;&#65289;&#65292;&#35201;&#27714;&#25226;&#23427;&#20204;&#31227;&#21040;&#23545;&#24212;&#30340;&#22823;&#20889;&#23383;&#27597;&#37324;&#12290;&#27599;&#27493;&#21487;&#20197;&#21516;&#26102;&#31227;&#21160;&#22810;&#20010;&#39740;&#12290;&#20294;&#31227;&#21160;&#21518;&#19981;&#33021;&#20004;&#20010;&#39740;&#21344;&#29992;&#21516;&#19968;&#20010;&#20301;&#32622;&#65292;&#20063;&#19981;&#33021;&#20877;&#19968;&#27493;&#20043;&#20869;&#20132;&#25442;&#20301;&#32622;&#12290;</p>
<pre><code>####                        ####        ####        ####        ####
 ab#                         ab#        a b#        acb#        ab #
#c##                        #c##        #c##        # ##        #c##
####                        ####        ####        ####        ####

&#29366;&#24577;&#25968;&#65306;(16^2)^3
&#27599;&#27425;&#36716;&#31227;&#65306;5^3&#65292;&#19978;&#19979;&#24038;&#21491;&#20197;&#21450;&#19981;&#21160;</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1601 The Morning after Halloween</span>
<span class="co">// This code implements the simpliest yet efficient-enough algorithm I&#39;m aware of</span>
<span class="co">// Readers are encouraged to experiment on other algorithms (especially for better efficiency!)</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;cctype&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxs = <span class="dv">20</span>;
<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">150</span>;                                   <span class="co">// 75% cells plus 2 fake nodes</span>
<span class="dt">const</span> <span class="dt">int</span> dx[] = { <span class="dv">1</span>,<span class="dv">-1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span> };                        <span class="co">// 4 moves, plus &quot;no move&quot;</span>
<span class="dt">const</span> <span class="dt">int</span> dy[] = { <span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">-1</span>,<span class="dv">0</span> };

<span class="kw">inline</span> <span class="dt">int</span> ID( <span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> c ) {
    <span class="kw">return</span> (a&lt;&lt;<span class="dv">16</span>)|(b&lt;&lt;<span class="dv">8</span>)|c;
}

<span class="dt">int</span> s, t;                                         <span class="co">// starting/ending position of each ghost</span>

<span class="dt">int</span> deg[maxn], G[maxn];                              <span class="co">// target cells for each move (including &quot;no move&quot;)</span>

<span class="kw">inline</span> <span class="dt">bool</span> conflict( <span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> a2, <span class="dt">int</span> b2 ) {
    <span class="kw">return</span> a2 == b2 || (a2 == b &amp;&amp; b2 == a);
}

<span class="dt">int</span> d[maxn][maxn][maxn];                                <span class="co">// distance from starting state</span>
<span class="dt">int</span> bfs() {
    queue&lt;<span class="dt">int</span>&gt; q;
    memset( d, <span class="dv">-1</span>, <span class="kw">sizeof</span>(d) );
    q.push( ID( s, s, s ) );                   <span class="co">// starting node</span>
    d[s][s][s] = <span class="dv">0</span>;
    <span class="kw">while</span>( !q.empty(  ) ) {
        <span class="dt">int</span> u = q.front(); q.pop();
        <span class="dt">int</span> a = (u&gt;&gt;<span class="dv">16</span>)&amp;<span class="bn">0xff</span>, b = (u&gt;&gt;<span class="dv">8</span>)&amp;<span class="bn">0xff</span>, c = u&amp;<span class="bn">0xff</span>;
        <span class="kw">if</span>( a == t &amp;&amp; b == t &amp;&amp; c == t ) {     <span class="co">// solution found</span>
            <span class="kw">return</span> d[a][b][c];
        }
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; deg[a]; i++ ) {
            <span class="dt">int</span> a2 = G[a][i];
            <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; deg[b]; j++ ) {
                <span class="dt">int</span> b2 = G[b][j];
                <span class="kw">if</span>( conflict( a, b, a2, b2 ) ) { <span class="kw">continue</span>; }
                <span class="kw">for</span>( <span class="dt">int</span> k = <span class="dv">0</span>; k &lt; deg[c]; k++ ) {
                    <span class="dt">int</span> c2 = G[c][k];
                    <span class="kw">if</span>( conflict( a, c, a2, c2 ) ) { <span class="kw">continue</span>; }
                    <span class="kw">if</span>( conflict( b, c, b2, c2 ) ) { <span class="kw">continue</span>; }
                    <span class="kw">if</span>( d[a2][b2][c2] != <span class="dv">-1</span>      ) { <span class="kw">continue</span>; }
                    d[a2][b2][c2] = d[a][b][c]<span class="dv">+1</span>;
                    q.push( ID( a2, b2, c2 ) );
                }
            }
        }
    }
    <span class="kw">return</span> <span class="dv">-1</span>;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> w, h, n;

    <span class="kw">while</span>( scanf( <span class="st">&quot;</span><span class="ch">%d%d%d\n</span><span class="st">&quot;</span>, &amp;w, &amp;h, &amp;n ) == <span class="dv">3</span> &amp;&amp; n ) {
        <span class="dt">char</span> maze;
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; h; i++ ) {
            fgets(maze[i], <span class="dv">20</span>, stdin);
        }

        <span class="co">// extract empty cells</span>
        <span class="dt">int</span> cnt, x[maxn], y[maxn], id[maxs][maxs];      <span class="co">// cnt is the number of empty cells</span>
        cnt = <span class="dv">0</span>;
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; h; i++ ) {
            <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; w; j++ ) {
                <span class="kw">if</span>( maze[i][j] != <span class="st">&#39;#&#39;</span> ) {
                    x[cnt] = i; y[cnt] = j; id[i][j] = cnt;
                    <span class="kw">if</span>( islower( maze[i][j] ) ) {
                        s[maze[i][j] - <span class="st">&#39;a&#39;</span>] = cnt;
                    } <span class="kw">else</span> <span class="kw">if</span>( isupper( maze[i][j] ) ) {
                        t[maze[i][j] - <span class="st">&#39;A&#39;</span>] = cnt;
                    }
                    cnt++;
                }
            }
        }

        <span class="co">// build a graph of empty cells</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; cnt; i++) {
            deg[i] = <span class="dv">0</span>;
            <span class="kw">for</span>( <span class="dt">int</span> dir = <span class="dv">0</span>; dir &lt; <span class="dv">5</span>; dir++ ) {
                <span class="dt">int</span> nx = x[i]+dx[dir], ny = y[i]+dy[dir];
                <span class="co">// &quot;Outermost cells of a map are walls&quot; means we don&#39;t need to check out-of-bound</span>
                <span class="kw">if</span>( maze[nx][ny] != <span class="st">&#39;#&#39;</span> ) {
                    G[i][deg[i]++] = id[nx][ny];
                }
            }
        }

        <span class="co">// add fakes nodes so that in each case we have 3 ghosts. this makes the code shorter</span>
        <span class="kw">if</span>( n &lt;= <span class="dv">2</span> ) { deg[cnt] = <span class="dv">1</span>; G[cnt] = cnt; s = t = cnt++; }
        <span class="kw">if</span>( n &lt;= <span class="dv">1</span> ) { deg[cnt] = <span class="dv">1</span>; G[cnt] = cnt; s = t = cnt++; }

        printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, bfs() );
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#36845;&#20195;&#21152;&#28145;&#25628;&#32034; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#22467;&#21450;&#20998;&#25968;&#38382;&#39064; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>2/3 = 1/2 + 1/6&#65292;&#20294;&#26159;&#19981;&#33021;&#26377; 2/3 = 1/3 + 1/3&#12290;&#21152;&#25968;&#36234;&#23569;&#36234;&#22909;&#12290;&#20854;&#20013;&#26368;&#23567;&#20998;&#25968;&#36234;&#22823;&#36234;&#22909;&#12290;</p>
<p>&#35299;&#31572;&#26641;&#22826;&#22840;&#24352;&#12290;&#28145;&#24230;&#19981;&#35265;&#24213;&#65292;&#23485;&#24230;&#20063;&#27809;&#26377;&#36793;&#30028;&#12290;&#29992; BFS &#19968;&#23618;&#37117;&#25628;&#19981;&#23436;&#12290;</p>
<p>&#29992;&#36845;&#20195;&#21152;&#28145;&#25628;&#32034;&#65288;iterative deepening&#65289;&#12290;</p>
<p>&#31532; i &#23618;&#65292;sum of before: c/d&#65292;&#31532; i &#20010;&#20301; 1/e&#65292;&#21017;&#36824;&#38656;&#35201;&#33267;&#23569; (a/b-c/d)/(1/e) &#20010;&#20998;&#25968;&#65292;&#24635;&#21644;&#25165;&#33021;&#36798;&#21040; a/b&#12290;</p>
<p>&#20363;&#22914;&#65306;19/45 = 1/5 + 1/100 + &#8230;&#65292;&#33267;&#23569;&#38656;&#35201; (19/45-1/5)/(1/101) = 23 &#39033;&#12290;</p>
<p><strong>&#20272;&#35745;&#33267;&#23569;&#36824;&#35201;&#22810;&#23569;&#27493;&#25165;&#33021;&#20986;&#35299;&#12290;</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#22467;&#21450;&#20998;&#25968;&#38382;&#39064;</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;cassert&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> a, b, maxd;

<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL;

LL gcd( LL a, LL b ) {
    <span class="kw">return</span> b == <span class="dv">0</span> ? a : gcd( b, a%b );
}

<span class="co">// &#36820;&#22238;&#28385;&#36275; 1/c &lt;= a/b &#30340;&#26368;&#23567; c</span>
<span class="kw">inline</span> <span class="dt">int</span> get_first( LL a, LL b ) {
    <span class="kw">return</span> b/a<span class="dv">+1</span>;
}

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span> + <span class="dv">5</span>;
LL v[maxn], ans[maxn];

<span class="co">// &#22914;&#26524;&#24403;&#21069;&#35299; v &#27604;&#30446;&#21069;&#26368;&#20248;&#35299; ans &#26356;&#20248;&#65292;&#26356;&#26032; ans</span>
<span class="dt">bool</span> better( <span class="dt">int</span> d ) {
    <span class="kw">for</span>( <span class="dt">int</span> i = d; i &gt;= <span class="dv">0</span>; i-- ) {
        <span class="kw">if</span>( v[i] != ans[i] ) {
            <span class="kw">return</span> ans[i] == <span class="dv">-1</span> || v[i] &lt; ans[i];
        }
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="co">// &#24403;&#21069;&#28145;&#24230;&#20026; d&#65292;&#20998;&#27597;&#19981;&#33021;&#23567;&#20110; from&#65292;&#20998;&#25968;&#20043;&#21644;&#24688;&#22909;&#20026; aa/bb</span>
<span class="dt">bool</span> dfs( <span class="dt">int</span> d, <span class="dt">int</span> from, LL aa, LL bb ) {
    <span class="kw">if</span>( d == maxd ) {
        <span class="kw">if</span>( bb % aa ) { <span class="kw">return</span> <span class="kw">false</span>; }                         <span class="co">// aa/bb &#24517;&#39035;&#26159;&#22467;&#21450;&#20998;&#25968;</span>
        v[d] = bb/aa;
        <span class="kw">if</span>( better( d ) ) {
            memcpy( ans, v, <span class="kw">sizeof</span>( LL ) * ( d<span class="dv">+1</span> ) );           <span class="co">// 0..d</span>
        }
        <span class="kw">return</span> <span class="kw">true</span>;
    }
    <span class="dt">int</span> ok = <span class="dv">0</span>;
    from = max( from, get_first( aa, bb ) );                    <span class="co">// &#26522;&#20030;&#30340;&#36215;&#28857;</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = from; ; i++ ) {
        <span class="kw">if</span>( bb *(maxd<span class="dv">+1</span>-d) &lt;= i*aa ) { <span class="kw">break</span>; }                 <span class="co">// &#21098;&#26525;&#65306;&#22914;&#26524;&#21097;&#19979;&#30340; maxd+1-d &#20010;&#20998;&#25968;&#20840;&#37096;&#37117;&#26159; 1/i&#65292;&#21152;&#36215;&#26469;&#20173;&#28982;&#19981;&#36229;&#36807; aa/bb&#65292;&#21017;&#26080;&#35299;</span>
        v[d] = i;
        LL b2 = bb*i;                                           <span class="co">// &#35745;&#31639; aa/bb - 1/i&#65292;&#35774;&#32467;&#26524;&#20026; a2/b2</span>
        LL a2 = aa*i - bb;
        LL g = gcd( a2, b2 );                                   <span class="co">// &#20197;&#20415;&#32422;&#20998;</span>
        <span class="kw">if</span>( dfs( d<span class="dv">+1</span>, i<span class="dv">+1</span>, a2/g, b2/g ) ) { ok = <span class="kw">true</span>; }
    }
    <span class="kw">return</span> ok;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> kase = <span class="dv">0</span>;
    <span class="kw">while</span>( cin &gt;&gt; a &gt;&gt; b ) {
        <span class="dt">int</span> ok = <span class="dv">0</span>;
        <span class="kw">for</span>( maxd = <span class="dv">1</span>; maxd &lt;= <span class="dv">100</span>; maxd++ ) {
            memset( ans, <span class="dv">-1</span>, <span class="kw">sizeof</span>(ans) );
            <span class="kw">if</span>( dfs( <span class="dv">0</span>, get_first( a, b ), a, b ) ) { ok = <span class="dv">1</span>; <span class="kw">break</span>; }
        }
        cout &lt;&lt; <span class="st">&quot;Case &quot;</span> &lt;&lt; ++kase &lt;&lt; <span class="st">&quot;: &quot;</span>;
        <span class="kw">if</span>( ok ) {
            cout &lt;&lt; a &lt;&lt; <span class="st">&quot;/&quot;</span> &lt;&lt; b &lt;&lt; <span class="st">&quot;=&quot;</span>;
            <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; maxd; i++ ) {
                cout &lt;&lt; <span class="st">&quot;1/&quot;</span> &lt;&lt; ans[i] &lt;&lt; <span class="st">&quot;+&quot;</span>;
            }
            cout &lt;&lt; <span class="st">&quot;1/&quot;</span> &lt;&lt; ans[maxd] &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
        } <span class="kw">else</span> {
            cout &lt;&lt; <span class="st">&quot;No solution.</span><span class="ch">\n</span><span class="st">&quot;</span>;
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">echo</span> 495 499 <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">Case</span> 1: 495/499=1/2+1/5+1/6+1/8+1/3992+1/14970</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>7-10 UVa11212 &#32534;&#36753;&#20070;&#31295;&#65292;Editing a Book <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11212 Editing a Book</span>
<span class="co">// Rujia Liu</span>
<span class="co">// This implementation is not very fast, but easy to understand</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">9</span>;
<span class="dt">int</span> n, a[maxn];

<span class="dt">bool</span> is_sorted() {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n<span class="dv">-1</span>; i++)
        <span class="kw">if</span>(a[i] &gt;= a[i<span class="dv">+1</span>]) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="co">// the number of integers with incorrect successor</span>
<span class="dt">int</span> h() {
    <span class="dt">int</span> cnt = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n<span class="dv">-1</span>; i++)
        <span class="kw">if</span>(a[i]<span class="dv">+1</span> != a[i<span class="dv">+1</span>]) cnt++;
    <span class="kw">if</span>(a[n<span class="dv">-1</span>] != n) cnt++;
    <span class="kw">return</span> cnt;
}

<span class="dt">bool</span> dfs(<span class="dt">int</span> d, <span class="dt">int</span> maxd) {
    <span class="kw">if</span>(d*<span class="dv">3</span> + h() &gt; maxd*<span class="dv">3</span>) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">if</span>(is_sorted()) <span class="kw">return</span> <span class="kw">true</span>;

    <span class="dt">int</span> b[maxn], olda[maxn];
    memcpy(olda, a, <span class="kw">sizeof</span>(a));
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
        <span class="kw">for</span>(<span class="dt">int</span> j = i; j &lt; n; j++) {
            <span class="co">// cut</span>
            <span class="dt">int</span> cnt = <span class="dv">0</span>;
            <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; k++)
                <span class="kw">if</span>(k &lt; i || k &gt; j) b[cnt++] = a[k];

            <span class="co">// insert before position k</span>
            <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt;= cnt; k++) {
                <span class="dt">int</span> cnt2 = <span class="dv">0</span>;
                <span class="kw">for</span>(<span class="dt">int</span> p = <span class="dv">0</span>; p &lt; k; p++) a[cnt2++] = b[p];
                <span class="kw">for</span>(<span class="dt">int</span> p = i; p &lt;= j; p++) a[cnt2++] = olda[p];
                <span class="kw">for</span>(<span class="dt">int</span> p = k; p &lt; cnt; p++) a[cnt2++] = b[p];

                <span class="kw">if</span>(dfs(d<span class="dv">+1</span>, maxd)) <span class="kw">return</span> <span class="kw">true</span>;
                memcpy(a, olda, <span class="kw">sizeof</span>(a));
            }
        }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">int</span> solve() {
    <span class="kw">if</span>(is_sorted()) <span class="kw">return</span> <span class="dv">0</span>;
    <span class="dt">int</span> max_ans = <span class="dv">5</span>; <span class="co">// after experiments, we found ans &lt;= 5 for n &lt;= 9</span>
    <span class="kw">for</span>(<span class="dt">int</span> maxd = <span class="dv">1</span>; maxd &lt; max_ans; maxd++)
        <span class="kw">if</span>(dfs(<span class="dv">0</span>, maxd)) <span class="kw">return</span> maxd;
    <span class="kw">return</span> max_ans;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> kase = <span class="dv">0</span>;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span> &amp;&amp; n) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;a[i]);
        printf(<span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">: </span><span class="ch">%d\n</span><span class="st">&quot;</span>, ++kase, solve());
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#23567;&#32467; <code class="fold">@</code></dt>
<dd><ul>
<li><p><strong>&#30452;&#25509;&#26522;&#20030;</strong>&#65306;&#25928;&#29575;&#19981;&#39640;&#12290;</p></li>
<li><p><strong>&#26522;&#20030;&#23376;&#38598;&#21644;&#25490;&#21015;</strong>&#65306;n &#20010;&#20803;&#32032;&#30340;&#23376;&#38598;&#26377; 2<sup>n</sup> &#20010;&#65292;&#21487;&#29992;&#36882;&#24402;&#30340;&#26041;&#27861;&#26522;&#20030;&#65288;&#22686;&#37327;&#27861;&#21644;&#20301;&#21521;&#37327;&#27861;&#65289;&#65292;&#20063;&#21487;&#20197;&#29992;&#20108;&#36827;&#21046;&#27861;&#26522;&#20030;&#12290;&#36882;&#24402;&#27861;&#25928;&#29575;&#39640;&#65292;&#26041;&#20415;&#21098;&#26525;&#65292;&#32570;&#28857;&#22312;&#20110;&#20195;&#30721;&#27604;&#36739;&#38271;&#12290;&#24403; n &lt;= 15 &#26102;&#65292;&#19968;&#33324;&#29992;&#20108;&#36827;&#21046;&#26522;&#20030;&#12290;</p>
<p>n &#20010;&#19981;&#21516;&#20803;&#32032;&#30340;&#20840;&#25490;&#21015;&#26377; n! &#20010;&#12290;&#38500;&#20102;&#29992;&#36882;&#24402;&#30340;&#26041;&#27861;&#26522;&#20030;&#65292;&#36824;&#21487;&#20197;&#29992; STL &#30340; <code>next_permutation</code>&#65292;&#23427;&#21487;&#20197;&#22788;&#29702;&#37325;&#22797;&#20803;&#32032;&#30340;&#24773;&#20917;&#12290;</p></li>
<li><p><strong>&#22238;&#28335;&#27861;</strong>&#65292;&#22238;&#28335;&#23601;&#26159;&#36882;&#24402;&#26522;&#20030;&#65292;&#21482;&#19981;&#36807;&#21487;&#20197;&#25552;&#21069;&#32456;&#27490;&#36882;&#24402;&#65292;&#21363;&#22238;&#28335;&#65288;backtracking&#65289;&#12290;</p></li>
<li><p><strong>&#29366;&#24577;&#31354;&#38388;&#30340;&#25628;&#32034;</strong>&#65306;&#26412;&#36136;&#19978;&#65292;&#29366;&#24577;&#31354;&#38388;&#25628;&#32034;&#21644;&#22270;&#31639;&#27861;&#30456;&#20284;&#24230;&#27604;&#36739;&#22823;&#12290;</p>
<p>&#26368;&#22909;&#25484;&#25569; <code>Dijkstra</code>&#12289;<code>A*</code> &#20197;&#21450; <code>&#21452;&#21521;&#24191;&#24230;&#20248;&#20808;&#25628;&#32034;</code>&#12290;</p></li>
<li><p>&#36845;&#20195;&#21152;&#28145;&#25628;&#32034;&#65292;&#22467;&#21450;&#20998;&#25968;&#21644;&#32534;&#36753;&#20070;&#31295;&#37117;&#26159;&#32463;&#20856;&#39064;&#12290;</p></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#31454;&#36187;&#39064;&#30446;&#36873;&#35762; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>7-11 UVa12325 Zombie&#8217;s Treasure Chest UVa12325.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12325 Zombie&#39;s Treasure Chest</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL;

<span class="dt">int</span> main(){
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">for</span>(<span class="dt">int</span> kase = <span class="dv">1</span>; kase &lt;= T; kase++) {
        <span class="dt">int</span> n, s1, v1, s2, v2;
        scanf(<span class="st">&quot;</span><span class="ch">%d%d%d%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;s1, &amp;v1, &amp;s2, &amp;v2);
        <span class="kw">if</span>(s1 &gt; s2){
            swap(s1, s2);
            swap(v1, v2);
        }
        LL ans = <span class="dv">0</span>;
        <span class="kw">if</span>(n / s2 &gt;= <span class="dv">65536</span>){ <span class="co">// both s1 and s2 are small</span>
            <span class="kw">for</span>(LL i = <span class="dv">0</span>; i &lt;= s1; i++){
                ans = max(ans, v2*i + (n-s2*i)/s1*v1);
            }
            <span class="kw">for</span>(LL i = <span class="dv">0</span>; i &lt;= s2; i++){
                ans = max(ans, v1*i + (n-s1*i)/s2*v2);
            }
        }<span class="kw">else</span>{ <span class="co">// s2 is large</span>
            <span class="kw">for</span>(LL i = <span class="dv">0</span>; s2*i &lt;= n; i++)
                ans = max(ans, v2*i + (n-s2*i)/s1*v1);
        }
        printf(<span class="st">&quot;Case #</span><span class="ch">%d</span><span class="st">: </span><span class="ch">%lld\n</span><span class="st">&quot;</span>, kase, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>7-12 UVa1343 The Rotation Game UVa1343.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1343 The Rotation Game</span>
<span class="co">// Rujia Liu</span>
<span class="co">// This solutions uses IDA* instead of BFS described in the book, because it&#39;s shorter 8-)</span>
<span class="co">// It&#39;s shorter because no need for lookup tables and &quot;automatically&quot; lexicographically smallest solution.</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">/*</span>
<span class="co">   00    01</span>
<span class="co">   02    03</span>
<span class="co">   04 05 06 07 08 09 10</span>
<span class="co">   11    12</span>
<span class="co">   13 14 15 16 17 18 19</span>
<span class="co">   20    21</span>
<span class="co">   22    23</span>
<span class="co">   */</span>

<span class="co">// lines E~H are computed with the help of rev[]</span>
<span class="dt">int</span> line={
    { <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">6</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">20</span>,<span class="dv">22</span>}, <span class="co">// A</span>
    { <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">8</span>,<span class="dv">12</span>,<span class="dv">17</span>,<span class="dv">21</span>,<span class="dv">23</span>}, <span class="co">// B</span>
    {<span class="dv">10</span>, <span class="dv">9</span>, <span class="dv">8</span>, <span class="dv">7</span>, <span class="dv">6</span>, <span class="dv">5</span>, <span class="dv">4</span>}, <span class="co">// C</span>
    {<span class="dv">19</span>,<span class="dv">18</span>,<span class="dv">17</span>,<span class="dv">16</span>,<span class="dv">15</span>,<span class="dv">14</span>,<span class="dv">13</span>}, <span class="co">// D</span>
};

<span class="dt">const</span> <span class="dt">int</span> rev = {<span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">6</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">2</span>}; <span class="co">// reverse lines of each line</span>

<span class="co">// center squares</span>
<span class="dt">const</span> <span class="dt">int</span> center = {<span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">15</span>, <span class="dv">16</span>, <span class="dv">17</span>};

<span class="dt">int</span> a;
<span class="dt">char</span> ans;

<span class="dt">bool</span> is_final() {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">8</span>; i++)
        <span class="kw">if</span> (a[center[i]] != a[center]) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="dt">int</span> diff(<span class="dt">int</span> target) {
    <span class="dt">int</span> ans = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">8</span>; i++)
        <span class="kw">if</span>(a[center[i]] != target) ans++;
    <span class="kw">return</span> ans;
}

<span class="kw">inline</span> <span class="dt">int</span> h() {
    <span class="kw">return</span> min(min(diff(<span class="dv">1</span>), diff(<span class="dv">2</span>)), diff(<span class="dv">3</span>));
}

<span class="kw">inline</span> <span class="dt">void</span> move(<span class="dt">int</span> i) {
    <span class="dt">int</span> tmp = a[line[i]];
    <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">6</span>; j++) a[line[i][j]] = a[line[i][j<span class="dv">+1</span>]];
    a[line[i]] = tmp;
}

<span class="dt">bool</span> dfs(<span class="dt">int</span> d, <span class="dt">int</span> maxd) {
    <span class="kw">if</span>(is_final()) {
        ans[d] = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>;
        printf(<span class="st">&quot;</span><span class="ch">%s\n</span><span class="st">&quot;</span>, ans);
        <span class="kw">return</span> <span class="kw">true</span>;
    }
    <span class="kw">if</span>(d + h() &gt; maxd) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">8</span>; i++) {
        ans[d] = <span class="st">&#39;A&#39;</span> + i;
        move(i);
        <span class="kw">if</span>(dfs(d<span class="dv">+1</span>, maxd)) <span class="kw">return</span> <span class="kw">true</span>;
        move(rev[i]);
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">int</span> main() {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">4</span>; i &lt; <span class="dv">8</span>; i++)
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">7</span>; j++) line[i][j] = line[rev[i]][<span class="dv">6</span>-j];

    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;a) == <span class="dv">1</span> &amp;&amp; a) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="dv">24</span>; i++) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;a[i]);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">24</span>; i++) <span class="kw">if</span>(!a[i]) <span class="kw">return</span> <span class="dv">0</span>;
        <span class="kw">if</span>(is_final()) {
            printf(<span class="st">&quot;No moves needed</span><span class="ch">\n</span><span class="st">&quot;</span>);
        } <span class="kw">else</span> {
            <span class="kw">for</span>(<span class="dt">int</span> maxd = <span class="dv">1</span>; ; maxd++)
                <span class="kw">if</span>(dfs(<span class="dv">0</span>, maxd)) <span class="kw">break</span>;
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, a);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>7-13 UVa1374 Power Calculus UVa1374.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1374 Power Calculus</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxans = <span class="dv">13</span>; <span class="co">// we got it by experimenting</span>

<span class="dt">int</span> n, a[maxans<span class="dv">+1</span>];

<span class="dt">bool</span> dfs(<span class="dt">int</span> d, <span class="dt">int</span> maxd) {
    <span class="kw">if</span>(a[d] == n) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">if</span>(d == maxd) <span class="kw">return</span> <span class="kw">false</span>;

    <span class="dt">int</span> maxv = a;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= d; i++) maxv = max(maxv, a[i]);
    <span class="kw">if</span>((maxv &lt;&lt; (maxd-d)) &lt; n) <span class="kw">return</span> <span class="kw">false</span>;

    <span class="co">// Always use the last value.</span>
    <span class="co">// I can&#39;t prove it, but we haven&#39;t found a counter-example for n &lt;= 1000</span>
    <span class="kw">for</span>(<span class="dt">int</span> i = d; i &gt;= <span class="dv">0</span>; i--) {
        a[d<span class="dv">+1</span>] = a[d] + a[i];
        <span class="kw">if</span>(dfs(d<span class="dv">+1</span>, maxd)) <span class="kw">return</span> <span class="kw">true</span>;
        a[d<span class="dv">+1</span>] = a[d] - a[i];
        <span class="kw">if</span>(dfs(d<span class="dv">+1</span>, maxd)) <span class="kw">return</span> <span class="kw">true</span>;
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">int</span> solve(<span class="dt">int</span> n) {
    <span class="kw">if</span>(n == <span class="dv">1</span>) <span class="kw">return</span> <span class="dv">0</span>;
    a = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> maxd = <span class="dv">1</span>; maxd &lt; maxans; maxd++) {
        <span class="kw">if</span>(dfs(<span class="dv">0</span>, maxd)) <span class="kw">return</span> maxd;
    }
    <span class="kw">return</span> maxans;
}

<span class="dt">int</span> main() {
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span> &amp;&amp; n) {
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, solve(n));
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>7-14 UVa1602 &#32593;&#26684;&#21160;&#29289;&#65292;Lattice Animals <code class="fold">@</code></dt>
<dd><p>&#36755;&#20837; n&#12289;w&#12289;h&#65288;1&lt;=n&lt;=10&#65292;1&lt;=w,h&lt;=n&#65289;&#65292;&#27714;&#33021;&#25918;&#22312; <code>w*h</code> &#32593;&#26684;&#20869;&#37324;&#30340;&#19981;&#21516;&#30340; n &#36830;&#22359;&#30340;&#20010;&#25968;&#12290;</p>
<pre><code>2x4 &#37324;&#38754;&#30340; 5 &#36830;&#22359;&#65306;

        --      --      --      --      --
    1|  ##      #        #      ##       #
    2|  ##      #       ##       #      ##
    3|   #      #       #       ##       #
    4|          ##      #                #

3x3 &#37324;&#38754;&#30340; 8 &#36830;&#22359;&#65306;

        ---     ---     ---
    1|  ###     ###     ###
    2|  ###     ###     # #
    3|   ##     # #     ###</code></pre>
<p>&#22914;&#26524;&#29992;&#22238;&#28335;&#27861;&#65292;&#21644;&#26377;&#24456;&#22810;&#37325;&#22797;&#26522;&#20030;&#65306;</p>
<pre><code>            ##
             #

             |
 +-------+---+--+------+
 |       |      |      |

 X                X
 ##     X##      ##    ##X
  #       #       #     #</code></pre>
<dl>
<dt>Polyomino <code class="fold">@</code></dt>
<dd><p>A <strong>polyomino <code>[,p&#594;l&#618;'&#594;m&#618;n&#601;&#650;]</code></strong> is a plane geometric figure formed by joining one or more equal squares edge to edge. It is a polyform whose cells are squares. It may be regarded as a finite subset of the regular square tiling with a connected interior.</p>
<p>&#23427;&#20204;&#36824;&#26377;&#33258;&#24049;&#30340;&#21517;&#23383;&#65306;</p>
<table style="width:44%;">
<colgroup>
<col width="38%" />
<col width="5%" />
</colgroup>
<thead>
<tr class="header">
<th>Number of cells</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>monomino</td>
</tr>
<tr class="even">
<td>2</td>
<td>domino</td>
</tr>
<tr class="odd">
<td>3</td>
<td>tromino</td>
</tr>
<tr class="even">
<td>4</td>
<td>tetromino</td>
</tr>
<tr class="odd">
<td>5</td>
<td>pentomino</td>
</tr>
<tr class="even">
<td>6</td>
<td>hexomino</td>
</tr>
<tr class="odd">
<td>7</td>
<td>heptomino</td>
</tr>
<tr class="even">
<td>8</td>
<td>octomino</td>
</tr>
<tr class="odd">
<td>9</td>
<td>nonomino</td>
</tr>
<tr class="even">
<td>10</td>
<td>decomino</td>
</tr>
<tr class="odd">
<td>11</td>
<td>undecomino</td>
</tr>
<tr class="even">
<td>12</td>
<td>dodecomino</td>
</tr>
</tbody>
</table>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/aa/All_18_Pentominoes.svg/330px-All_18_Pentominoes.svg.png" alt="The 18 one-sided pentominoes, including 6 mirrored pairs" />
<p class="caption">The 18 one-sided pentominoes, including 6 mirrored pairs</p>
</div>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/02/All_35_free_hexominoes.svg/330px-All_35_free_hexominoes.svg.png" alt="The 35 free hexominoes, colored according to their symmetry." />
<p class="caption">The 35 free hexominoes, colored according to their symmetry.</p>
</div>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Polyomino">Polyomino - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
</dl>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1602 Lattice Animals</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;set&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> Cell {
    <span class="dt">int</span> x, y;
    Cell( <span class="dt">int</span> x=<span class="dv">0</span>, <span class="dt">int</span> y=<span class="dv">0</span> ) : x(x), y(y) { }
    <span class="dt">bool</span> <span class="kw">operator</span> &lt;( <span class="dt">const</span> Cell&amp; rhs ) <span class="dt">const</span> {
        <span class="kw">return</span> x &lt; rhs.x || (x == rhs.x &amp;&amp; y &lt; rhs.y);
    }
};

<span class="kw">typedef</span> set&lt;Cell&gt; Polyomino;

<span class="ot">#define FOR_CELL(c, p) for( Polyomino::const_iterator c = (p).begin(); c != (p).end(); ++c )</span>

<span class="kw">inline</span> Polyomino normalize( <span class="dt">const</span> Polyomino &amp;p ) {
    <span class="dt">int</span> minX = p.begin()-&gt;x, minY = p.begin()-&gt;y;
    FOR_CELL( c, p ) {
        minX = min(minX, c-&gt;x);
        minY = min(minY, c-&gt;y);
    }
    Polyomino p2;
    FOR_CELL( c, p ) {
        p2.insert( Cell(c-&gt;x-minX, c-&gt;y-minY) );
    }
    <span class="kw">return</span> p2;
}

<span class="kw">inline</span> Polyomino rotate( <span class="dt">const</span> Polyomino &amp;p ) {
    Polyomino p2;
    FOR_CELL( c, p ) {
        p2.insert( Cell(c-&gt;y, -c-&gt;x) );
    }
    <span class="kw">return</span> normalize(p2);
}

<span class="kw">inline</span> Polyomino flip( <span class="dt">const</span> Polyomino &amp;p ) {
    Polyomino p2;
    FOR_CELL( c, p ) {
        p2.insert( Cell(c-&gt;x,-c-&gt;y) );
    }
    <span class="kw">return</span> normalize( p2 );
}

<span class="dt">const</span> <span class="dt">int</span> dx[] = {  <span class="dv">-1</span>,  <span class="dv">1</span>,  <span class="dv">0</span>,  <span class="dv">0</span>  };
<span class="dt">const</span> <span class="dt">int</span> dy[] = {   <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">-1</span>,  <span class="dv">1</span>  };

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">10</span>;
set&lt;Polyomino&gt; poly[maxn<span class="dv">+1</span>];
<span class="dt">int</span> ans[maxn<span class="dv">+1</span>][maxn<span class="dv">+1</span>][maxn<span class="dv">+1</span>];

<span class="co">// add a cell to p0 and check whether it&#39;s new. If so, add to the polyonimo set</span>
<span class="dt">void</span> check_polyomino( <span class="dt">const</span> Polyomino&amp; p0, <span class="dt">const</span> Cell&amp; c ) {
    Polyomino p = p0;
    p.insert(c);
    p = normalize(p);

    <span class="dt">int</span> n = p.size();
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">4</span>; i++ ) {
        <span class="kw">if</span>( poly[n].count(p) ) { <span class="kw">return</span>; }
        p = rotate(p);
    }
    p = flip(p);
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">4</span>; i++ ) {
        <span class="kw">if</span>( poly[n].count( p ) ) { <span class="kw">return</span>; }
        p = rotate(p);
    }
    poly[n].insert(p);
}

<span class="dt">void</span> generate() {
    Polyomino s;
    s.insert( Cell(<span class="dv">0</span>, <span class="dv">0</span>) );
    poly.insert(s);

    <span class="co">// generate</span>
    <span class="kw">for</span>( <span class="dt">int</span> n = <span class="dv">2</span>; n &lt;= maxn; n++ ) {
        <span class="kw">for</span>( set&lt;Polyomino&gt;::iterator p = poly[n<span class="dv">-1</span>].begin(); p != poly[n<span class="dv">-1</span>].end(); ++p ) {
            FOR_CELL( c, *p ) {
                <span class="kw">for</span>( <span class="dt">int</span> dir = <span class="dv">0</span>; dir &lt; <span class="dv">4</span>; dir++ ) {
                    Cell newc(c-&gt;x + dx[dir], c-&gt;y + dy[dir]);
                    <span class="kw">if</span>( p-&gt;count(newc) == <span class="dv">0</span> ) { check_polyomino(*p, newc); }
                }
            }
        }
    }

    <span class="co">// precompute answers</span>
    <span class="kw">for</span>( <span class="dt">int</span> n = <span class="dv">1</span>; n &lt;= maxn; n++ ) {
        <span class="kw">for</span>( <span class="dt">int</span> w = <span class="dv">1</span>; w &lt;= maxn; w++ ) {
            <span class="kw">for</span>( <span class="dt">int</span> h = <span class="dv">1</span>; h &lt;= maxn; h++ ) {
                <span class="dt">int</span> cnt = <span class="dv">0</span>;
                <span class="kw">for</span>( set&lt;Polyomino&gt;::iterator p = poly[n].begin(); p != poly[n].end(); ++p ) {
                    <span class="dt">int</span> maxX = <span class="dv">0</span>, maxY = <span class="dv">0</span>;
                    FOR_CELL(c, *p) {
                        maxX = max( maxX, c-&gt;x );
                        maxY = max( maxY, c-&gt;y );
                    }
                    <span class="kw">if</span>( min( maxX, maxY ) &lt; min( h, w ) &amp;&amp; max( maxX, maxY ) &lt; max( h, w ) ) {
                        ++cnt;
                    }
                }
                ans[n][w][h] = cnt;
            }
        }
    }
}

<span class="dt">int</span> main() {
    generate();

    <span class="dt">int</span> n, w, h;
    <span class="kw">while</span>( scanf( <span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;w, &amp;h ) == <span class="dv">3</span> ) {
        printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans[n][w][h] );
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>7-15 UVa1603 Square Destroyer UVa1603.cpp <code class="fold">@</code></dt>
<dd><p>&#29992;&#36845;&#20195;&#21152;&#28145;&#12290;&#25110;&#32773; DLX &#31639;&#27861;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1603 Square Destroyer</span>
<span class="co">// Rujia Liu</span>
<span class="co">// This code implements a variant of an algorithm presented in a book. It&#39;s simple yet efficient.</span>
<span class="co">// Readers are encouraged to experiment on other algorithms.</span>
<span class="co">// However, it&#39;s still slow for n=5 and m=0 (which is NOT in judge input)</span>
<span class="co">// If you really want an efficient solution, learn DLX (Algorithm X with dancing links)</span>
<span class="co">// DLX is well expained (with code) in my other book &lt;&lt;Beginning Algorithm Contests -- Training Guide&gt;&gt;</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;cstdlib&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxs = <span class="dv">60</span>; <span class="co">// number of squares: 25+16+9+4+1=55</span>
<span class="dt">const</span> <span class="dt">int</span> maxm = <span class="dv">60</span>; <span class="co">// number of matches: 2*5*(5+1)=60</span>

<span class="dt">int</span> n, exists[maxm]; <span class="co">// matches</span>
<span class="dt">int</span> s, size[maxs], fullsize[maxs], contains[maxs][maxm]; <span class="co">// squares</span>
<span class="dt">int</span> best;

<span class="kw">inline</span> <span class="dt">int</span> row_match(<span class="dt">int</span> x, <span class="dt">int</span> y) {
    <span class="kw">return</span> (<span class="dv">2</span>*n<span class="dv">+1</span>)*x+y;
}

<span class="kw">inline</span> <span class="dt">int</span> col_match(<span class="dt">int</span> x, <span class="dt">int</span> y) {
    <span class="kw">return</span> (<span class="dv">2</span>*n<span class="dv">+1</span>)*x+n+y;
}

<span class="co">// number of matches in a full n*n grid</span>
<span class="kw">inline</span> <span class="dt">int</span> match_count(<span class="dt">int</span> n) {
    <span class="kw">return</span> <span class="dv">2</span>*n*(n<span class="dv">+1</span>);
}

<span class="dt">void</span> init() {
    <span class="dt">int</span> m, v;
    scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m);
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; match_count(n); ++i) exists[i] = <span class="dv">1</span>;
    <span class="kw">while</span>(m--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;v);
        exists[v<span class="dv">-1</span>] = <span class="dv">0</span>;
    }

    <span class="co">// collect full squares</span>
    s = <span class="dv">0</span>;
    memset(contains, <span class="dv">0</span>, <span class="kw">sizeof</span>(contains));
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) <span class="co">// side length</span>
        <span class="kw">for</span>(<span class="dt">int</span> x = <span class="dv">0</span>; x &lt;= n-i; x++)
            <span class="kw">for</span>(<span class="dt">int</span> y = <span class="dv">0</span>; y &lt;= n-i; y++) {
                size[s] = <span class="dv">0</span>;
                fullsize[s] = <span class="dv">4</span>*i; <span class="co">// number of matches in a complete square</span>
                <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; i; j++) {
                    <span class="dt">int</span> a = row_match(x, y+j); <span class="co">// up</span>
                    <span class="dt">int</span> b = row_match(x+i, y+j); <span class="co">// down</span>
                    <span class="dt">int</span> c = col_match(x+j, y); <span class="co">// left</span>
                    <span class="dt">int</span> d = col_match(x+j, y+i); <span class="co">// right</span>
                    contains[s][a] = <span class="dv">1</span>;
                    contains[s][b] = <span class="dv">1</span>;
                    contains[s][c] = <span class="dv">1</span>;
                    contains[s][d] = <span class="dv">1</span>;
                    size[s] += exists[a] + exists[b] + exists[c] + exists[d]; <span class="co">// number of matches now</span>
                }
                ++s;
            }
}

<span class="dt">int</span> find_square() {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; s; i++)
        <span class="kw">if</span>(size[i] == fullsize[i]) <span class="kw">return</span> i;
    <span class="kw">return</span> <span class="dv">-1</span>;
}

<span class="dt">void</span> dfs(<span class="dt">int</span> dep) {
    <span class="kw">if</span>(dep &gt;= best) <span class="kw">return</span>;

    <span class="dt">int</span> k = find_square();
    <span class="kw">if</span>(k == <span class="dv">-1</span>) {
        best = dep;
        <span class="kw">return</span>;
    }

    <span class="co">// remove a match in that square</span>
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; match_count(n); i++)
        <span class="kw">if</span>(contains[k][i]) {
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; s; j++)
                <span class="kw">if</span>(contains[j][i]) size[j]--;
            dfs(dep + <span class="dv">1</span>);
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; s; j++)
                <span class="kw">if</span>(contains[j][i]) size[j]++;
        }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        init();
        best = n*n;
        dfs(<span class="dv">0</span>);
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, best);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/00/00 &#19978;&#21320; 9:30:00 0. &#39640;&#25928;&#31639;&#27861;&#35774;&#35745; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#31639;&#27861;&#20998;&#26512;&#21021;&#27493; <code class="fold">@</code></dt>
<dd><ul>
<li>&#28176;&#36827;&#26102;&#38388;&#22797;&#26434;&#24230;</li>
<li>&#19978;&#30028;&#20998;&#26512;</li>
<li>&#20998;&#27835;&#27861;</li>
<li>&#27491;&#30830;&#23545;&#24453;&#31639;&#27861;&#20998;&#26512;&#32467;&#26524;</li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#20877;&#35848;&#25490;&#24207;&#19982;&#26816;&#32034; <code class="fold">@</code></dt>
<dd><ul>
<li>&#24402;&#24182;&#25490;&#24207;</li>
<li>&#24555;&#36895;&#25490;&#24207;</li>
</ul>
</dd>
</dl></li>
<li><p>&#36882;&#24402;&#19982;&#20998;&#27835;</p></li>
<li><dl>
<dt>&#36138;&#24515;&#27861; <code class="fold">@</code></dt>
<dd><ul>
<li><p>&#32972;&#21253;&#30456;&#20851;&#38382;&#39064;</p></li>
<li><p>&#21306;&#38388;&#30456;&#20851;&#38382;&#39064;</p></li>
<li><dl>
<dt>Huffman &#32534;&#30721; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#32473;&#23450;&#19968;&#20010;&#33521;&#25991;&#23383;&#31526;&#20018;&#65292;&#20351;&#29992; 0 &#21644; 1 &#23545;&#20854;&#36827;&#34892;&#32534;&#30721;&#65292;&#27714;&#26368;&#20248;&#21069;&#32512;&#32534;&#30721;&#65292;&#20351;&#20854;&#25152;&#38656;&#35201;&#30340;&#27604;&#29305;&#25968;&#26368;&#23569;&#12290;</p>
<p>&#21704;&#24343;&#26364;&#32534;&#30721;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#26412;&#39064;&#32771;&#26597;&#21704;&#24343;&#26364;&#32534;&#30721;&#65292;&#20294;&#21482;&#38656;&#35201;&#32479;&#35745;&#21704;&#24343;&#26364;&#32534;&#30721;&#21518;&#30340;&#24635;&#30721;&#38271;&#21363;&#21487;&#65292;</span>
<span class="co">// &#27809;&#24517;&#35201;&#24314;&#21704;&#24343;&#26364;&#26641;&#24471;&#20986;&#21704;&#24343;&#26364;&#32534;&#30721;</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;functional&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main() {
    vector&lt;<span class="dt">int</span>&gt; count( <span class="dv">128</span>, <span class="dv">0</span> );    <span class="co">// count[i] &#35760;&#24405; ASCII &#30721;&#20026; i &#30340;&#23383;&#31526;&#30340;&#20986;&#29616;&#27425;&#25968;</span>

    <span class="dt">int</span> sum;
    priority_queue&lt;<span class="dt">int</span>, vector&lt;<span class="dt">int</span>&gt;, greater&lt;<span class="dt">int</span>&gt; &gt; pq;     <span class="co">// &#23567;&#26681;&#22534;&#65292;&#38431;&#21015;&#22836;&#20026;&#26368;&#23567;&#20803;&#32032;</span>

    string line;
    <span class="kw">while</span> ( getline(cin, line) ) {
        <span class="kw">if</span>( line == <span class="st">&quot;END&quot;</span> ) { <span class="kw">break</span>; }
        sum = <span class="dv">0</span>;                        <span class="co">// &#28165;&#38646;</span>
        <span class="dt">const</span> <span class="dt">int</span> len = line.size();
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len; ++i ) {
            count[line[i]]++;
        }
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">128</span>; ++i ) {
            <span class="kw">if</span> (count[i] &gt; <span class="dv">0</span>) {
                pq.push(count[i]);
                count[i] = <span class="dv">0</span>;
            }
        }
        <span class="kw">while</span>( pq.size() &gt; <span class="dv">1</span> ) {
            <span class="dt">const</span> <span class="dt">int</span> a = pq.top(); pq.pop();
            <span class="dt">const</span> <span class="dt">int</span> b = pq.top(); pq.pop();
            sum += a + b;
            pq.push(a + b);
        }
        <span class="kw">if</span> ( sum == <span class="dv">0</span> ) {               <span class="co">// &#27492;&#26102;pq&#20013;&#21482;&#26377;&#19968;&#20010;&#20803;&#32032;</span>
            sum = len;
        }

        <span class="co">// these is no such thing as `pq.clear()&#39;;</span>
        <span class="kw">while</span>( !pq.empty() ) { pq.pop(); }

        <span class="co">// &#27880;&#24847;&#31934;&#24230;&#35774;&#32622;</span>
        printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">, </span><span class="ch">%d</span><span class="st">, </span><span class="ch">%.1f\n</span><span class="st">&quot;</span>, <span class="dv">8</span> * len, sum, ((<span class="dt">double</span>)<span class="dv">8</span> * len) / sum );
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#31639;&#27861;&#35774;&#35745;&#19982;&#20248;&#21270;&#31574;&#30053; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>8-1 UVa120 Stacks of Flapjacks UVa120.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa120 Stacks of Flapjacks</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;sstream&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">30</span> + <span class="dv">5</span>;
<span class="dt">int</span> n, a[maxn];

<span class="co">// &#32763;&#36716;a[0..p]</span>
<span class="dt">void</span> flip(<span class="dt">int</span> p) {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; p-i; i++)
        swap(a[i], a[p-i]);
    printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, n-p);
}

<span class="dt">int</span> main() {
    string s;
    <span class="kw">while</span>(getline(cin, s)) {
        cout &lt;&lt; s &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
        stringstream ss(s);
        n = <span class="dv">0</span>;
        <span class="kw">while</span>(ss &gt;&gt; a[n]) n++;
        <span class="kw">for</span>(<span class="dt">int</span> i = n<span class="dv">-1</span>; i &gt; <span class="dv">0</span>; i--) {
            <span class="dt">int</span> p = max_element(a, a+i<span class="dv">+1</span>) - a; <span class="co">// &#20803;&#32032;a[0..i]&#20013;&#30340;&#26368;&#22823;&#20803;&#32032;</span>
            <span class="kw">if</span>(p == i) <span class="kw">continue</span>;
            <span class="kw">if</span>(p &gt; <span class="dv">0</span>) flip(p); <span class="co">// flip(0)&#27809;&#21861;&#24847;&#24605;&#65292;&#26159;&#19981;&#65311;</span>
            flip(i);
        }
        printf(<span class="st">&quot;0</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-2 UVa1605 Building for UN UVa1605.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1605 Building for UN</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">char</span> country(<span class="dt">int</span> i) {
    <span class="kw">if</span>(i &lt; <span class="dv">26</span>) <span class="kw">return</span> <span class="st">&#39;A&#39;</span> + i;
    <span class="kw">return</span> <span class="st">&#39;a&#39;</span> + i - <span class="dv">26</span>;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span>) {
        printf(<span class="st">&quot;2 </span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, n, n);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++) printf(<span class="st">&quot;</span><span class="ch">%c</span><span class="st">&quot;</span>, country(i));
            printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
        }
        printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++) printf(<span class="st">&quot;</span><span class="ch">%c</span><span class="st">&quot;</span>, country(j));
            printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-3 UVa1152 4 Values Whose Sum is Zero UVa1152.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1152 4 Values Whose Sum is Zero</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">4000</span> + <span class="dv">5</span>;
<span class="dt">int</span> n, c, A[maxn], B[maxn], C[maxn], D[maxn], sums[maxn*maxn];

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
            scanf(<span class="st">&quot;</span><span class="ch">%d%d%d%d</span><span class="st">&quot;</span>, &amp;A[i], &amp;B[i], &amp;C[i], &amp;D[i]);
        c = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)
                sums[c++] = A[i] + B[j];
        sort(sums, sums+c);
        <span class="dt">long</span> <span class="dt">long</span> cnt = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)
                cnt += upper_bound(sums, sums+c, -C[i]-D[j]) - lower_bound(sums, sums+c, -C[i]-D[j]);
        printf(<span class="st">&quot;</span><span class="ch">%lld\n</span><span class="st">&quot;</span>, cnt);
        <span class="kw">if</span>(T) printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-4 UVa11134 Fabled Rooks UVa11134.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11134 Fabled Rooks</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// solve 1-D problem: find c so that a[i] &lt;= c[i] &lt;= b[i] (0 &lt;= i &lt; n)</span>
<span class="dt">bool</span> solve(<span class="dt">int</span> *a, <span class="dt">int</span> *b, <span class="dt">int</span> *c, <span class="dt">int</span> n) {
    fill(c, c+n, <span class="dv">-1</span>);
    <span class="kw">for</span>(<span class="dt">int</span> col = <span class="dv">1</span>; col &lt;= n; col++) {
        <span class="co">// find a rook with smalleset b that is not yet assigned</span>
        <span class="dt">int</span> rook = <span class="dv">-1</span>, minb = n<span class="dv">+1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
            <span class="kw">if</span>(c[i] &lt; <span class="dv">0</span> &amp;&amp; b[i] &lt; minb &amp;&amp; col &gt;= a[i]) { rook = i; minb = b[i]; }
        <span class="kw">if</span>(rook &lt; <span class="dv">0</span> || col &gt; minb) <span class="kw">return</span> <span class="kw">false</span>;
        c[rook] = col;
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">5000</span> + <span class="dv">5</span>;
<span class="dt">int</span> n, x1[maxn], y1[maxn], x2[maxn], y2[maxn], x[maxn], y[maxn];

<span class="dt">int</span> main() {
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span> &amp;&amp; n) {
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
            scanf(<span class="st">&quot;</span><span class="ch">%d%d%d%d</span><span class="st">&quot;</span>, &amp;x1[i], &amp;y1[i], &amp;x2[i], &amp;y2[i]);
        <span class="kw">if</span>(solve(x1, x2, x, n) &amp;&amp; solve(y1, y2, y, n))
            <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, x[i], y[i]);
        <span class="kw">else</span>
            printf(<span class="st">&quot;IMPOSSIBLE</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-5 UVa11054 Wine trading in Gergovia UVa11054.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11054 Wine trading in Gergovia</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    <span class="kw">while</span>(cin &gt;&gt; n &amp;&amp; n) {
        <span class="dt">long</span> <span class="dt">long</span> ans = <span class="dv">0</span>, a, last = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            cin &gt;&gt; a;
            ans += abs(last);
            last += a;
        }
        cout &lt;&lt; ans &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-6 UVa1606 Amphiphilic Carbon Molecules UVa1606.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1606 Amphiphilic Carbon Molecules</span>
<span class="co">// Rujia Liu</span>
<span class="co">// To make life a bit easier, we change each color 1 point into color 0.</span>
<span class="co">// Then we only need to find an angle interval with most points. See code for details.</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1000</span> + <span class="dv">5</span>;

<span class="kw">struct</span> Point {
    <span class="dt">int</span> x, y;
    <span class="dt">double</span> rad; <span class="co">// with respect to current point</span>
    <span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="dt">const</span> Point &amp;rhs) <span class="dt">const</span> {
        <span class="kw">return</span> rad &lt; rhs.rad;
    }
}op[maxn], p[maxn];

<span class="dt">int</span> n, color[maxn];

<span class="co">// from O-A to O-B, is it a left turn?</span>
<span class="dt">bool</span> Left(Point A, Point B) {
    <span class="kw">return</span> A.x * B.y - A.y * B.x &gt;= <span class="dv">0</span>;
}

<span class="dt">int</span> solve() {
    <span class="kw">if</span>(n &lt;= <span class="dv">2</span>) <span class="kw">return</span> <span class="dv">2</span>;
    <span class="dt">int</span> ans = <span class="dv">0</span>;

    <span class="co">// pivot point</span>
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
        <span class="dt">int</span> k = <span class="dv">0</span>;

        <span class="co">// the list of other point, sorted in increasing order of rad</span>
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)
            <span class="kw">if</span>(j != i) {
                p[k].x = op[j].x - op[i].x;
                p[k].y = op[j].y - op[i].y;
                <span class="kw">if</span>(color[j]) { p[k].x = -p[k].x; p[k].y = -p[k].y; }
                p[k].rad = atan2(p[k].y, p[k].x);
                k++;
            }
        sort(p, p+k);

        <span class="co">// sweeping. cnt is the number of points whose rad is between p[L] and p[R]</span>
        <span class="dt">int</span> L = <span class="dv">0</span>, R = <span class="dv">0</span>, cnt = <span class="dv">2</span>;
        <span class="kw">while</span>(L &lt; k) {
            <span class="kw">if</span>(R == L) { R = (R<span class="dv">+1</span>)%k; cnt++; } <span class="co">// empty interval</span>
            <span class="kw">while</span>(R != L &amp;&amp; Left(p[L], p[R])) { R = (R<span class="dv">+1</span>)%k; cnt++; } <span class="co">// stop when [L,R] spans across &gt; 180 degrees</span>
            cnt--;
            L++;
            ans = max(ans, cnt);
        }
    }
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main() {
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span> &amp;&amp; n) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
            scanf(<span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, &amp;op[i].x, &amp;op[i].y, &amp;color[i]);
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, solve());
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-7 UVa11572 Unique snowflakes UVa11572.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11572 Unique snowflakes</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;set&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1000000</span> + <span class="dv">5</span>;
<span class="dt">int</span> A[maxn];

<span class="dt">int</span> main() {
    <span class="dt">int</span> T, n;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;A[i]);

        set&lt;<span class="dt">int</span>&gt; s;
        <span class="dt">int</span> L = <span class="dv">0</span>, R = <span class="dv">0</span>, ans = <span class="dv">0</span>;
        <span class="kw">while</span>(R &lt; n) {
            <span class="kw">while</span>(R &lt; n &amp;&amp; !s.count(A[R])) s.insert(A[R++]);
            ans = max(ans, R - L);
            s.erase(A[L++]);
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11572 Unique snowflakes</span>
<span class="co">// Rujia Liu</span>
<span class="co">// &#31639;&#27861;&#20108;&#65306;&#35760;&#24405;&#20301;&#32622;i&#30340;&#19978;&#20010;&#30456;&#21516;&#20803;&#32032;&#20301;&#32622;last[i]</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;map&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1000000</span> + <span class="dv">5</span>;
<span class="dt">int</span> A[maxn], last[maxn];
map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; cur;

<span class="dt">int</span> main() {
    <span class="dt">int</span> T, n;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        cur.clear();
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;A[i]);
            <span class="kw">if</span>(!cur.count(A[i])) last[i] = <span class="dv">-1</span>;
            <span class="kw">else</span> last[i] = cur[A[i]];
            cur[A[i]] = i;
        }

        <span class="dt">int</span> L = <span class="dv">0</span>, R = <span class="dv">0</span>, ans = <span class="dv">0</span>;
        <span class="kw">while</span>(R &lt; n) {
            <span class="kw">while</span>(R &lt; n &amp;&amp; last[R] &lt; L) R++;
            ans = max(ans, R - L);
            L++;
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11572 Unique snowflakes</span>
<span class="co">// Rujia Liu</span>
<span class="co">// &#31639;&#27861;&#20108;&#65306;&#35760;&#24405;&#20301;&#32622;i&#30340;&#19978;&#20010;&#30456;&#21516;&#20803;&#32032;&#20301;&#32622;last[i]&#12290;&#20351;&#29992;hash_map&#65288;gcc&#25193;&#23637;&#65289;</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;ext/hash_map&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="kw">using</span> <span class="kw">namespace</span> __gnu_cxx; <span class="co">// hash_map</span>

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1000000</span> + <span class="dv">5</span>;
<span class="dt">int</span> A[maxn], last[maxn];
hash_map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; cur;

<span class="dt">int</span> main() {
    <span class="dt">int</span> T, n;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        cur.clear();
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;A[i]);
            <span class="kw">if</span>(!cur.count(A[i])) last[i] = <span class="dv">-1</span>;
            <span class="kw">else</span> last[i] = cur[A[i]];
            cur[A[i]] = i;
        }

        <span class="dt">int</span> L = <span class="dv">0</span>, R = <span class="dv">0</span>, ans = <span class="dv">0</span>;
        <span class="kw">while</span>(R &lt; n) {
            <span class="kw">while</span>(R &lt; n &amp;&amp; last[R] &lt; L) R++;
            ans = max(ans, R - L);
            L++;
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-8 UVa1471 Defense Lines UVa1471.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1471 Defense Lines</span>
<span class="co">// Rujia Liu</span>
<span class="co">// Algorithm 1: use STL set to maintain the candidates.</span>
<span class="co">// This is a little bit more intuitive, but less efficient (than algorithm 2)</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;set&gt;</span>
<span class="ot">#include&lt;cassert&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">200000</span> + <span class="dv">5</span>;
<span class="dt">int</span> n, a[maxn], f[maxn], g[maxn];

<span class="kw">struct</span> Candidate {
    <span class="dt">int</span> a, g;
    Candidate(<span class="dt">int</span> a, <span class="dt">int</span> g):a(a),g(g) {}
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Candidate&amp; rhs) <span class="dt">const</span> {
        <span class="kw">return</span> a &lt; rhs.a;
    }
};

set&lt;Candidate&gt; s;

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;a[i]);
        <span class="kw">if</span>(n == <span class="dv">1</span>) { printf(<span class="st">&quot;1</span><span class="ch">\n</span><span class="st">&quot;</span>); <span class="kw">continue</span>; }

        <span class="co">// g[i] is the length of longest increasing continuous subsequence ending at i</span>
        g = <span class="dv">1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; n; i++)
            <span class="kw">if</span>(a[i<span class="dv">-1</span>] &lt; a[i]) g[i] = g[i<span class="dv">-1</span>] + <span class="dv">1</span>;
            <span class="kw">else</span> g[i] = <span class="dv">1</span>;

        <span class="co">// f[i] is the length of longest increasing continuous subsequence starting from i</span>
        f[n<span class="dv">-1</span>] = <span class="dv">1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = n<span class="dv">-2</span>; i &gt;= <span class="dv">0</span>; i--)
            <span class="kw">if</span>(a[i] &lt; a[i<span class="dv">+1</span>]) f[i] = f[i<span class="dv">+1</span>] + <span class="dv">1</span>;
            <span class="kw">else</span> f[i] = <span class="dv">1</span>;

        s.clear();
        s.insert(Candidate(a, g));
        <span class="dt">int</span> ans = <span class="dv">1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; n; i++) {
            Candidate c(a[i], g[i]);
            set&lt;Candidate&gt;::iterator it = s.lower_bound(c); <span class="co">// first one that is &gt;= c</span>
            <span class="dt">bool</span> keep = <span class="kw">true</span>;
            <span class="kw">if</span>(it != s.begin()) {
                Candidate last = *(--it); <span class="co">// (--it) points to the largest one that is &lt; c</span>
                <span class="dt">int</span> len = f[i] + last.g;
                ans = max(ans, len);
                <span class="kw">if</span>(c.g &lt;= last.g) keep = <span class="kw">false</span>;
            }

            <span class="kw">if</span>(keep) {
                s.erase(c); <span class="co">// if c.a is already present, the old g must be &lt;= c.g</span>
                s.insert(c);
                it = s.find(c); <span class="co">// this is a bit cumbersome and slow but it&#39;s clear</span>
                it++;
                <span class="kw">while</span>(it != s.end() &amp;&amp; it-&gt;a &gt; c.a &amp;&amp; it-&gt;g &lt;= c.g) s.erase(it++);
            }
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-9 UVa1451 Average UVa1451.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1451 Average</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100000</span> + <span class="dv">5</span>;

<span class="dt">int</span> n, L;
<span class="dt">char</span> s[maxn];
<span class="dt">int</span> sum[maxn], p[maxn]; <span class="co">// average of i~j is (sum[j]-sum[i-1])/(j-i+1)</span>

<span class="co">// compare average of x1~x2 and x3~x4</span>
<span class="dt">int</span> compare_average(<span class="dt">int</span> x1, <span class="dt">int</span> x2, <span class="dt">int</span> x3, <span class="dt">int</span> x4) {
    <span class="kw">return</span> (sum[x2]-sum[x1<span class="dv">-1</span>]) * (x4-x3<span class="dv">+1</span>) - (sum[x4]-sum[x3<span class="dv">-1</span>]) * (x2-x1<span class="dv">+1</span>);
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);

    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d%d%s</span><span class="st">&quot;</span>, &amp;n, &amp;L, s<span class="dv">+1</span>);

        sum = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) sum[i] = sum[i<span class="dv">-1</span>] + s[i] - <span class="st">&#39;0&#39;</span>;

        <span class="dt">int</span> ansL = <span class="dv">1</span>, ansR = L;

        <span class="co">// p[i..j) is the sequence of candidate start points</span>
        <span class="dt">int</span> i = <span class="dv">0</span>, j = <span class="dv">0</span>;
        <span class="kw">for</span> (<span class="dt">int</span> t = L; t &lt;= n; t++) { <span class="co">// end point</span>
            <span class="kw">while</span> (j-i &gt; <span class="dv">1</span> &amp;&amp; compare_average(p[j<span class="dv">-2</span>], t-L, p[j<span class="dv">-1</span>], t-L) &gt;= <span class="dv">0</span>) j--; <span class="co">// remove concave points</span>
            p[j++] = t-L<span class="dv">+1</span>; <span class="co">// new candidate</span>

            <span class="kw">while</span> (j-i &gt; <span class="dv">1</span> &amp;&amp; compare_average(p[i], t, p[i<span class="dv">+1</span>], t) &lt;= <span class="dv">0</span>) i++; <span class="co">// update tangent point</span>

            <span class="co">// compare and update solution</span>
            <span class="dt">int</span> c = compare_average(p[i], t, ansL, ansR);
            <span class="kw">if</span> (c &gt; <span class="dv">0</span> || c == <span class="dv">0</span> &amp;&amp; t - p[i] &lt; ansR - ansL) {
                ansL = p[i]; ansR = t;
            }
        }
        printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, ansL, ansR);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-10 UVa714 Copying Books UVa714.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa714 Copying Books</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="dt">const</span> <span class="dt">int</span> maxm = <span class="dv">500</span> + <span class="dv">5</span>;
<span class="dt">int</span> m, k, p[maxm];

<span class="co">// how many scribers needed if each scriber can work on at most maxp pages</span>
<span class="dt">int</span> solve(<span class="dt">long</span> <span class="dt">long</span> maxp) {
    <span class="dt">long</span> <span class="dt">long</span> done = <span class="dv">0</span>;
    <span class="dt">int</span> ans = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++) {
        <span class="kw">if</span>(done + p[i] &lt;= maxp) done += p[i];
        <span class="kw">else</span> { ans++; done = p[i]; }
    }
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> last[maxm]; <span class="co">// last[i] = 1 iff i is the last book assigned to someone</span>
<span class="dt">void</span> print(<span class="dt">long</span> <span class="dt">long</span> ans) {
    <span class="dt">long</span> <span class="dt">long</span> done = <span class="dv">0</span>;
    memset(last, <span class="dv">0</span>, <span class="kw">sizeof</span>(last));
    <span class="dt">int</span> remain = k;
    <span class="kw">for</span>(<span class="dt">int</span> i = m<span class="dv">-1</span>; i &gt;= <span class="dv">0</span>; i--) {
        <span class="kw">if</span>(done + p[i] &gt; ans || i<span class="dv">+1</span> &lt; remain) {
            last[i] = <span class="dv">1</span>; remain--; done = p[i];
        }
        <span class="kw">else</span> {
            done += p[i];
        }
    }
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m<span class="dv">-1</span>; i++) {
        printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, p[i]);
        <span class="kw">if</span>(last[i]) printf(<span class="st">&quot;/ &quot;</span>);
    }
    printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, p[m<span class="dv">-1</span>]);
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;m, &amp;k);
        <span class="dt">long</span> <span class="dt">long</span> tot = <span class="dv">0</span>;
        <span class="dt">int</span> maxp = <span class="dv">-1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;p[i]);
            tot += p[i];
            maxp = max(maxp, p[i]);
        }
        <span class="dt">long</span> <span class="dt">long</span> L = maxp, R = tot;
        <span class="kw">while</span>(L &lt; R) {
            <span class="dt">long</span> <span class="dt">long</span> M = L + (R-L)/<span class="dv">2</span>;
            <span class="kw">if</span>(solve(M) &lt;= k) R = M; <span class="kw">else</span> L = M<span class="dv">+1</span>;
        }
        print(L);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-11 UVa10954 Add All UVa10954.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10954 Add All</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;queue&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, x;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span> &amp;&amp; n) {
        priority_queue&lt;<span class="dt">int</span>, vector&lt;<span class="dt">int</span>&gt;, greater&lt;<span class="dt">int</span>&gt; &gt; q;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) { scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;x); q.push(x); }
        <span class="dt">int</span> ans = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n<span class="dv">-1</span>; i++) {
            <span class="dt">int</span> a = q.top(); q.pop();
            <span class="dt">int</span> b = q.top(); q.pop();
            ans += a+b;
            q.push(a+b);
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-12 UVa12627 Erratic Expansion UVa12627.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12627 Erratic Expansion</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// how many red balloons after k hours</span>
<span class="dt">long</span> <span class="dt">long</span> c(<span class="dt">int</span> i) {
    <span class="kw">return</span> i == <span class="dv">0</span> ? <span class="dv">1</span> : c(i<span class="dv">-1</span>)*<span class="dv">3</span>;
}

<span class="co">// how many red balloons in the first i rows, after k hours</span>
<span class="dt">long</span> <span class="dt">long</span> f(<span class="dt">int</span> k, <span class="dt">int</span> i) {
    <span class="kw">if</span>(i == <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">if</span>(k == <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">1</span>;

    <span class="dt">int</span> k2 = <span class="dv">1</span> &lt;&lt; (k<span class="dv">-1</span>);
    <span class="kw">if</span>(i &gt;= k2) <span class="kw">return</span> f(k<span class="dv">-1</span>, i-k2) + c(k<span class="dv">-1</span>)*<span class="dv">2</span>;
    <span class="kw">else</span> <span class="kw">return</span> f(k<span class="dv">-1</span>, i) * <span class="dv">2</span>;
}

<span class="co">// how many red balloons in the last i rows, after k hours</span>
<span class="dt">long</span> <span class="dt">long</span> g(<span class="dt">int</span> k, <span class="dt">int</span> i) {
    <span class="kw">if</span>(i == <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">if</span>(k == <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">1</span>;

    <span class="dt">int</span> k2 = <span class="dv">1</span> &lt;&lt; (k<span class="dv">-1</span>);
    <span class="kw">if</span>(i &gt;= k2) <span class="kw">return</span> g(k<span class="dv">-1</span>, i-k2) + c(k<span class="dv">-1</span>);
    <span class="kw">else</span> <span class="kw">return</span> g(k<span class="dv">-1</span>,i);
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T, k, a, b;
    cin &gt;&gt; T;
    <span class="kw">for</span>(<span class="dt">int</span> kase = <span class="dv">1</span>; kase &lt;= T; kase++) {
        cin &gt;&gt; k &gt;&gt; a &gt;&gt; b;
        cout &lt;&lt; <span class="st">&quot;Case &quot;</span> &lt;&lt; kase &lt;&lt; <span class="st">&quot;: &quot;</span> &lt;&lt; f(k, b) - f(k, a<span class="dv">-1</span>) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-13 UVa11093 Just Finish it up UVa11093.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11093 Just Finish it up</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100000</span> + <span class="dv">5</span>;
<span class="dt">int</span> n, p[maxn], q[maxn];

<span class="co">// returns s if success</span>
<span class="co">// otherwise, return the station you failed to reach</span>
<span class="co">// if you failed to reach the start, return -1</span>
<span class="dt">int</span> go(<span class="dt">int</span> s) {
    <span class="dt">int</span> fuel = p[s] - q[s];
    <span class="kw">for</span>(<span class="dt">int</span> i = (s<span class="dv">+1</span>)%n; i != s; i = (i<span class="dv">+1</span>)%n) {
        <span class="kw">if</span>(fuel &lt; <span class="dv">0</span>) <span class="kw">return</span> i;
        fuel += p[i] - q[i];
    }
    <span class="kw">if</span>(fuel &lt; <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">-1</span>; <span class="co">// this means sum(p) &lt; sum(q), so this case is impossible</span>
    <span class="kw">return</span> s; <span class="co">// success</span>
}

<span class="dt">int</span> solve() {
    <span class="dt">int</span> start = <span class="dv">0</span>;
    <span class="kw">for</span>(;;) {
        <span class="dt">int</span> finish = go(start);
        <span class="kw">if</span>(finish &lt; start) <span class="kw">return</span> <span class="dv">-1</span>; <span class="co">// wrapped around, or go(start) returns -1</span>
        <span class="kw">if</span>(finish == start) <span class="kw">return</span> start;
        start = finish;
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">for</span>(<span class="dt">int</span> kase = <span class="dv">1</span>; kase &lt;= T; kase++) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;p[i]);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;q[i]);
        <span class="dt">int</span> ans = solve();
        printf(<span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">: &quot;</span>, kase);
        <span class="kw">if</span>(ans &lt; <span class="dv">0</span>) printf(<span class="st">&quot;Not possible</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">else</span> printf(<span class="st">&quot;Possible from station </span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans<span class="dv">+1</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-14 UVa1607 Gates UVa1607.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1607 Gates</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxm = <span class="dv">200000</span> + <span class="dv">5</span>;

<span class="dt">int</span> n, m;

<span class="kw">struct</span> Gates {
    <span class="dt">int</span> a, b, o;
} gates[maxm];

<span class="co">// returns the output of input 000..0111...1 (there are k 0&#39;s)</span>
<span class="dt">int</span> output(<span class="dt">int</span> k) {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= m; i++) {
        <span class="dt">int</span> a = gates[i].a;
        <span class="dt">int</span> b = gates[i].b;
        <span class="dt">int</span> va = a &lt; <span class="dv">0</span> ? -a &gt; k : gates[a].o;
        <span class="dt">int</span> vb = b &lt; <span class="dv">0</span> ? -b &gt; k : gates[b].o;
        gates[i].o = !(va &amp;&amp; vb);
    }
    <span class="kw">return</span> gates[m].o;
}

<span class="co">// returns k such that</span>
<span class="co">// 1. output(k) = output(n)</span>
<span class="co">// 2. output(k-1) = output(0)</span>
<span class="dt">int</span> solve(<span class="dt">int</span> vn) {
    <span class="dt">int</span> L = <span class="dv">1</span>, R = n;
    <span class="kw">while</span>(L &lt; R) {
        <span class="dt">int</span> M = L + (R-L)/<span class="dv">2</span>;
        <span class="kw">if</span>(output(M) == vn) R = M; <span class="kw">else</span> L = M<span class="dv">+1</span>;
    }
    <span class="kw">return</span> L;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m);
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= m; i++)
            scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;gates[i].a, &amp;gates[i].b);
        <span class="dt">int</span> v0 = output(<span class="dv">0</span>);
        <span class="dt">int</span> vn = output(n);
        <span class="kw">if</span>(v0 == vn) {
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) printf(<span class="st">&quot;0&quot;</span>);
        } <span class="kw">else</span> {
            <span class="dt">int</span> x = solve(vn);
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; x; i++) printf(<span class="st">&quot;0&quot;</span>);
            printf(<span class="st">&quot;x&quot;</span>);
            <span class="kw">for</span>(<span class="dt">int</span> i = x<span class="dv">+1</span>; i &lt;= n; i++) printf(<span class="st">&quot;1&quot;</span>);
        }
        printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-15 UVa12174 Shuffle UVa12174.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12174 Shuffle</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100000</span> + <span class="dv">5</span>;
<span class="dt">int</span> s, n, x[maxn*<span class="dv">3</span>], cnt[maxn], ok[maxn*<span class="dv">2</span>];

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    cin &gt;&gt; T;
    <span class="kw">while</span>(T--) {
        cin &gt;&gt; s &gt;&gt; n;

        <span class="co">// add s &quot;-1&quot; to the left/right of orriginal sequence</span>
        <span class="co">// so we don&#39;t have to worry about negative subscript or wrapping round</span>
        fill(x, x+n<span class="dv">+2</span>*s, <span class="dv">-1</span>);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) cin &gt;&gt; x[i+s];

        <span class="dt">int</span> tot = <span class="dv">0</span>; <span class="co">// how many different integers in current sliding window</span>
        fill(cnt<span class="dv">+1</span>, cnt+s<span class="dv">+1</span>, <span class="dv">0</span>); <span class="co">// cnt[i] is the number of occurrence of i in the current sliding window</span>
        fill(ok, ok+n+s<span class="dv">+1</span>, <span class="dv">0</span>);   <span class="co">// ok[i] = 1 iff the i-th sliding window didn&#39;t have duplicate numbers</span>

        <span class="co">// compute &quot;ok&quot; array</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n+s<span class="dv">+1</span>; i++) {
            <span class="kw">if</span> (tot == s) ok[i] = <span class="dv">1</span>;              <span class="co">// complete window</span>
            <span class="kw">if</span> (i &lt; s &amp;&amp; tot == i) ok[i] = <span class="dv">1</span>;     <span class="co">// incomplete windows on the left side</span>
            <span class="kw">if</span> (i &gt; n &amp;&amp; tot == n+s-i) ok[i] = <span class="dv">1</span>; <span class="co">// incomplete windows on the right side</span>

            <span class="co">// update cnt and tot for the next sliding window</span>
            <span class="kw">if</span> (i == n+s) <span class="kw">break</span>; <span class="co">// no more sliding windows, so we stop here</span>
            <span class="kw">if</span> (x[i] != <span class="dv">-1</span> &amp;&amp; --cnt[x[i]]==<span class="dv">0</span>) tot--; <span class="co">// remove the first one</span>
            <span class="kw">if</span> (x[i+s] != <span class="dv">-1</span> &amp;&amp; cnt[x[i+s]]++==<span class="dv">0</span>) tot++; <span class="co">// add the next one</span>
        }

        <span class="co">// check each possible answer</span>
        <span class="dt">int</span> ans = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; s; i++) {
            <span class="dt">int</span> valid = <span class="dv">1</span>;
            <span class="kw">for</span> (<span class="dt">int</span> j = i; j &lt; n+s<span class="dv">+1</span>; j += s)
                <span class="kw">if</span>(!ok[j]) valid = <span class="dv">0</span>;;
            <span class="kw">if</span>(valid) ans++;
        }
        <span class="kw">if</span>(ans == n<span class="dv">+1</span>) ans = s; <span class="co">// special case</span>
        cout &lt;&lt; ans &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-16 UVa1608 Non-boring sequences UVa1608.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1608 Non-boring sequences</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;map&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">200000</span> + <span class="dv">5</span>;
<span class="dt">int</span> A[maxn], prev[maxn], next[maxn];
map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; cur;

<span class="kw">inline</span> <span class="dt">bool</span> unique(<span class="dt">int</span> p, <span class="dt">int</span> L, <span class="dt">int</span> R) {
    <span class="kw">return</span> prev[p] &lt; L &amp;&amp; next[p] &gt; R;
}

<span class="dt">bool</span> check(<span class="dt">int</span> L, <span class="dt">int</span> R) {
    <span class="kw">if</span>(L &gt;= R) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">for</span>(<span class="dt">int</span> d = <span class="dv">0</span>; L+d &lt;= R-d; d++) {
        <span class="kw">if</span>(unique(L+d, L, R))
            <span class="kw">return</span> check(L, L+d<span class="dv">-1</span>) &amp;&amp; check(L+d<span class="dv">+1</span>, R);
        <span class="kw">if</span>(L+d == R-d) <span class="kw">break</span>;
        <span class="kw">if</span>(unique(R-d, L, R))
            <span class="kw">return</span> check(R-d<span class="dv">+1</span>, R) &amp;&amp; check(L, R-d<span class="dv">-1</span>);
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T, n;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        cur.clear();
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;A[i]);
            <span class="kw">if</span>(!cur.count(A[i])) prev[i] = <span class="dv">-1</span>;
            <span class="kw">else</span> prev[i] = cur[A[i]];
            cur[A[i]] = i;
        }
        cur.clear();
        <span class="kw">for</span>(<span class="dt">int</span> i = n<span class="dv">-1</span>; i &gt;= <span class="dv">0</span>; i--) {
            <span class="kw">if</span>(!cur.count(A[i])) next[i] = n;
            <span class="kw">else</span> next[i] = cur[A[i]];
            cur[A[i]] = i;
        }

        <span class="kw">if</span>(check(<span class="dv">0</span>, n<span class="dv">-1</span>)) printf(<span class="st">&quot;non-boring</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">else</span> printf(<span class="st">&quot;boring</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-17 UVa1609 Foul Play UVa1609.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1609  Foul Play</span>
<span class="co">// Rujia Liu</span>

<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1024</span> + <span class="dv">5</span>;
<span class="dt">char</span> table[maxn][maxn];

<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span>) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, table[i]<span class="dv">+1</span>);

        vector&lt;<span class="dt">int</span>&gt; win, lose; <span class="co">// teams that team 1 win/lose against.</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= n; i++)
            <span class="kw">if</span>(table[i] == <span class="st">&#39;1&#39;</span>) win.push_back(i);
            <span class="kw">else</span> lose.push_back(i);

        <span class="dt">int</span> nt = n;
        <span class="kw">while</span>(nt &gt; <span class="dv">1</span>) {
            vector&lt;<span class="dt">int</span>&gt; win2, lose2, <span class="kw">final</span>; <span class="co">// phase 3/4</span>

            <span class="co">// Phase 1</span>
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; lose.size(); i++) {
                <span class="dt">int</span> tlose = lose[i];
                <span class="dt">bool</span> matched = <span class="kw">false</span>;
                <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; win.size(); j++) {
                    <span class="dt">int</span>&amp; twin = win[j];
                    <span class="kw">if</span>(twin &gt; <span class="dv">0</span> &amp;&amp; table[twin][tlose] == <span class="st">&#39;1&#39;</span>) {
                        printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, twin, tlose);
                        win2.push_back(twin); <span class="co">// go to the next round</span>
                        twin = <span class="dv">0</span>; <span class="co">// not available</span>
                        matched = <span class="kw">true</span>;
                        <span class="kw">break</span>;
                    }
                }
                <span class="kw">if</span>(!matched) <span class="kw">final</span>.push_back(tlose); <span class="co">// to phase 3/4</span>
            }

            <span class="co">// Phase 2</span>
            <span class="dt">bool</span> first = <span class="kw">true</span>;
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; win.size(); i++) {
                <span class="dt">int</span> twin = win[i];
                <span class="kw">if</span>(twin &gt; <span class="dv">0</span>) {
                    <span class="kw">if</span>(first) { printf(<span class="st">&quot;1 </span><span class="ch">%d\n</span><span class="st">&quot;</span>, twin); first = <span class="kw">false</span>; }
                    <span class="kw">else</span> <span class="kw">final</span>.push_back(twin);
                }
            }

            <span class="co">// Phase 3/4</span>
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="kw">final</span>.size(); i += <span class="dv">2</span>) {
                printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, <span class="kw">final</span>[i], <span class="kw">final</span>[i<span class="dv">+1</span>]);
                <span class="dt">int</span> keep = <span class="kw">final</span>[i];
                <span class="kw">if</span>(table[<span class="kw">final</span>[i<span class="dv">+1</span>]][keep] == <span class="st">&#39;1&#39;</span>) keep = <span class="kw">final</span>[i<span class="dv">+1</span>];
                <span class="kw">if</span>(table[keep] == <span class="st">&#39;1&#39;</span>) win2.push_back(keep);
                <span class="kw">else</span> lose2.push_back(keep);
            }
            win = win2;
            lose = lose2;
            nt &gt;&gt;= <span class="dv">1</span>;
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-18 UVa1442 Cave uva1442.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1442 Cav</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1000000</span> + <span class="dv">5</span>;
<span class="dt">int</span> n, p[maxn], s[maxn], h[maxn];
<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;p[i]);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;s[i]);

        <span class="dt">int</span> ans = <span class="dv">0</span>, level = s;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            <span class="kw">if</span>(p[i] &gt; level) level = p[i];
            <span class="kw">if</span>(s[i] &lt; level) level = s[i];
            h[i] = level;
        }
        level = s[n<span class="dv">-1</span>];
        <span class="kw">for</span>(<span class="dt">int</span> i = n<span class="dv">-1</span>; i &gt;= <span class="dv">0</span>; i--) {
            <span class="kw">if</span>(p[i] &gt; level) level = p[i];
            <span class="kw">if</span>(s[i] &lt; level) level = s[i];
            ans += min(h[i], level) - p[i];
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>8-19 UVa12265 Selling Land UVa12265.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12265 Selling Land</span>
<span class="co">// Rujia Liu</span>
<span class="co">// This code implements the algorithm described in the book</span>
<span class="co">// Another way is: still use a stack to maintain the &quot;staircase&quot; shape</span>
<span class="co">// But don&#39;t eliminate non-optimal rectangles in the stairecase.</span>
<span class="co">// instead, let maxp[c] be the maximal half-perimeter whose rightmost column is c, which can be calculated with dp.</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1000</span> + <span class="dv">10</span>;

<span class="dt">char</span> s[maxn][maxn];
<span class="dt">int</span> height[maxn], ans[maxn*<span class="dv">2</span>];

<span class="kw">struct</span> Rect {
    <span class="dt">int</span> c, h;
    Rect(<span class="dt">int</span> c=<span class="dv">0</span>, <span class="dt">int</span> h=<span class="dv">0</span>):c(c),h(h){}
};

Rect rect[maxn]; <span class="co">// stack</span>

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, m, T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i ++) scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, s[i]);

        memset(height, <span class="dv">0</span>, <span class="kw">sizeof</span>(height));
        memset(ans, <span class="dv">0</span>, <span class="kw">sizeof</span>(ans));
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i ++) {
            <span class="dt">int</span> top = <span class="dv">-1</span>;
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; m; j ++) {
                <span class="kw">if</span>(s[i][j] == <span class="st">&#39;#&#39;</span>) {
                    height[j] = <span class="dv">0</span>;
                    top = <span class="dv">-1</span>; <span class="co">// clear stack</span>
                } <span class="kw">else</span> {
                    height[j]++;
                    Rect r(j, height[j]);
                    <span class="kw">if</span>(top &lt; <span class="dv">0</span>) rect[++top] = r;
                    <span class="kw">else</span> {
                        <span class="kw">while</span>(top &gt;= <span class="dv">0</span> &amp;&amp; r.h &lt;= rect[top].h) r.c = rect[top--].c;
                        <span class="kw">if</span>(top &lt; <span class="dv">0</span> || r.h - r.c &gt; rect[top].h - rect[top].c) rect[++top] = r;
                    }
                    ans[j-rect[top].c+rect[top].h<span class="dv">+1</span>]++;
                }
            }
        }
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n + m; i++)
            <span class="kw">if</span>(ans[i]) printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> x </span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans[i], i*<span class="dv">2</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/00/00 &#19978;&#21320; 9:30:00 0. more BFS, DFS <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>chap9. BFS <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>maze &#9829;&#65039; <code class="fold">@</code></dt>
<dd><pre><code>input:

    0 1 0 0 0
    0 1 0 1 0
    0 0 0 0 0
    0 1 1 1 0
    0 0 0 1 0

output:

    (0, 0)
    (1, 0)
    (2, 0)
    (2, 1)
    (2, 2)
    (2, 3)
    (2, 4)
    (3, 4)
    (4, 4)</code></pre>
<p>POJ 3984 &#36855;&#23467;&#38382;&#39064;, <a href="http://poj.org/problem?id=3984" class="uri">http://poj.org/problem?id=3984</a></p>
<dl>
<dt>C version <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">char</span> name[] = { <span class="st">&#39;U&#39;</span>, <span class="st">&#39;R&#39;</span>, <span class="st">&#39;D&#39;</span>, <span class="st">&#39;L&#39;</span> };    <span class="co">//      |</span>
<span class="dt">const</span> <span class="dt">int</span> dx[] = { <span class="dv">-1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span> };              <span class="co">//      |</span>
<span class="dt">const</span> <span class="dt">int</span> dy[] = { <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">-1</span> };              <span class="co">//      V  rowsise: x</span>

<span class="kw">typedef</span> <span class="kw">struct</span> state_t {
    <span class="dt">int</span> data;
    <span class="dt">int</span> action;
    <span class="dt">int</span> father;
} state_t;

<span class="dt">const</span> <span class="dt">int</span> MAXN = <span class="dv">5</span>;
<span class="dt">int</span> m = MAXN, n = MAXN;                                 <span class="co">// &#36855;&#23467;&#30340;&#34892;&#25968;&#65292;&#21015;&#25968;</span>
<span class="dt">int</span> map[MAXN][MAXN];                                    <span class="co">// &#36855;&#23467;&#65292;0 &#34920;&#31034;&#31354;&#22320;&#65292;1 &#34920;&#31034;&#38556;&#30861;&#29289;</span>

<span class="dt">const</span> <span class="dt">int</span> STATE_MAX = MAXN * MAXN;                      <span class="co">// &#29366;&#24577;&#24635;&#25968;</span>
state_t nodes[STATE_MAX];
<span class="dt">int</span> state_hash(  <span class="dt">const</span> state_t &amp;s ) {
    <span class="kw">return</span> s.data;
}
<span class="dt">int</span> state_index( <span class="dt">const</span> state_t &amp;s ) {
    <span class="kw">return</span> state_hash(s);
}

<span class="dt">void</span> print_action(<span class="dt">const</span> <span class="dt">int</span> end) {
    <span class="kw">if</span>( nodes[end].father == <span class="dv">-1</span> ) { <span class="kw">return</span>; }           <span class="co">// no father</span>
    print_action( nodes[end].father );
    putchar( name[nodes[end].action] );
}
<span class="dt">void</span> print_path( <span class="dt">const</span> <span class="dt">int</span> end ) {
    <span class="kw">if</span>( nodes[end].father != <span class="dv">-1</span> ) {                     <span class="co">// starting point</span>
        print_path( nodes[end].father );
    }
    printf(<span class="st">&quot;(</span><span class="ch">%d</span><span class="st">, </span><span class="ch">%d</span><span class="st">)</span><span class="ch">\n</span><span class="st">&quot;</span>, end / n, end % n);
}

<span class="dt">const</span> state_t END = { <span class="dv">24</span>, <span class="dv">-1</span>, <span class="dv">-1</span> };                     <span class="co">// (4, 4)</span>
<span class="dt">bool</span> state_is_target( <span class="dt">const</span> state_t &amp;s ) {              <span class="co">// end point</span>
    <span class="kw">return</span> s.data == END.data;
}

<span class="dt">const</span> <span class="dt">int</span> HASH_CAPACITY = STATE_MAX;
<span class="dt">bool</span> visited[HASH_CAPACITY];
<span class="dt">void</span> hashset_init() {
    memset( visited, <span class="dv">0</span>, <span class="kw">sizeof</span>(visited) );
}
<span class="dt">bool</span> hashset_find( <span class="dt">const</span> state_t &amp;s ) {
    <span class="kw">return</span> visited[state_hash(s)] == <span class="kw">true</span>;
}
<span class="dt">void</span> hashset_insert( <span class="dt">const</span> state_t &amp;s ) {
    visited[state_hash(s)] = <span class="kw">true</span>;
}

<span class="dt">int</span> x, y;                                               <span class="co">// &#25193;&#23637;&#28857;&#65292;&#21363;&#24403;&#21069;&#20301;&#32622;</span>
<span class="dt">int</span> action_cur;
<span class="dt">const</span> <span class="dt">int</span> ACTION_BEGIN = <span class="dv">0</span>;
<span class="dt">const</span> <span class="dt">int</span> ACTION_END   = <span class="dv">4</span>;
<span class="dt">void</span> state_extend_init(<span class="dt">const</span> state_t &amp;s) {
    action_cur = ACTION_BEGIN;
    x = s.data / n;
    y = s.data % n;
}

<span class="dt">bool</span> state_extend( <span class="dt">const</span> state_t &amp;s, state_t &amp;next ) {
    <span class="kw">while</span>( action_cur &lt; ACTION_END ) {
        <span class="dt">const</span> <span class="dt">int</span> nx = x + dx[action_cur];
        <span class="dt">const</span> <span class="dt">int</span> ny = y + dy[action_cur];
        <span class="kw">if</span>( <span class="dv">0</span> &lt;= nx &amp;&amp; nx &lt; m &amp;&amp; <span class="dv">0</span> &lt;= ny &amp;&amp; ny &lt; n &amp;&amp; !map[nx][ny] ) {  <span class="co">// in scope, and empty</span>
            next.data = nx * n + ny;
            <span class="kw">if</span>( !hashset_find(next) ) {                                 <span class="co">// &#21028;&#37325;</span>
                next.action = action_cur;                               <span class="co">// &#35760;&#24405;&#36335;&#24452;</span>
                next.father = state_hash(s);
                nodes[state_index(next)] = next;
                ++action_cur;                                           <span class="co">// return &#21069;&#21035;&#24536;&#20102;&#22686; 1</span>
                <span class="kw">return</span> <span class="kw">true</span>;
            }
        }
        ++action_cur;
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">int</span> bfs( state_t &amp;start ) {
    queue&lt;state_t&gt; q;
    hashset_init();

    start.action = <span class="dv">-1</span>;
    start.father = <span class="dv">-1</span>;

    nodes[state_index(start)] = start;
    hashset_insert(start);
    <span class="kw">if</span> ( state_is_target(start) ) {
        <span class="kw">return</span> state_index(start);
    }

    q.push(start);
    <span class="kw">while</span>( !q.empty() ) {
        <span class="dt">const</span> state_t s = q.front(); q.pop();
        state_extend_init( s );
        state_t next;
        <span class="kw">while</span>( state_extend(s, next) ) {
            <span class="kw">if</span>( state_is_target(next) ) {       <span class="co">// the END</span>
                <span class="kw">return</span> state_index(next);
            }
            q.push( next );
            hashset_insert( next );
        }
    }
    <span class="kw">return</span> <span class="dv">-1</span>;
}

<span class="dt">int</span> main(<span class="dt">void</span>) {
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j ) {
            scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;map[i][j] );
        }
    }

    state_t start = { <span class="dv">0</span>, <span class="dv">-1</span>, <span class="dv">-1</span> };                          <span class="co">// &#24038;&#19978;&#35282;&#20026;&#36215;&#28857;</span>
    <span class="dt">int</span> end = bfs( start );
    print_path( end );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
<dt>C++ version <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;stack&gt;</span>
<span class="ot">#include &lt;unordered_set&gt;</span>
<span class="ot">#include &lt;unordered_map&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> Point {
    <span class="dt">int</span> x, y;
    Point( <span class="dt">int</span> x = <span class="dv">0</span>, <span class="dt">int</span> y = <span class="dv">0</span> ) : x(x), y(y) { }
    <span class="dt">bool</span> valid( <span class="dt">const</span> vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; &amp;map ) <span class="dt">const</span> {
        <span class="kw">return</span> <span class="dv">0</span> &lt;= x &amp;&amp; x &lt; map.size() &amp;&amp; <span class="dv">0</span> &lt;= y &amp;&amp; y &lt; map[<span class="dv">0</span>].size() &amp;&amp; map.at(x).at(y) == <span class="dv">0</span>;
    }
    <span class="dt">bool</span> <span class="kw">operator</span>==( <span class="dt">const</span> Point &amp;rhs ) <span class="dt">const</span> {
        <span class="kw">return</span> x == rhs.x &amp;&amp; y == rhs.y;
    }
};

<span class="kw">namespace</span> std {
    <span class="kw">template</span> &lt;&gt; <span class="kw">struct</span> hash&lt;Point&gt; {
        size_t <span class="kw">operator</span>()( <span class="dt">const</span> Point &amp;p ) <span class="dt">const</span> {
            <span class="kw">return</span> p.x * <span class="dv">10</span> + p.y;
        }
    };
}

<span class="dt">bool</span> bfs( <span class="dt">const</span> vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; &amp;map, unordered_map&lt;Point, Point&gt; &amp;father, <span class="dt">const</span> Point &amp;start, <span class="dt">const</span> Point &amp;end ) {
    queue&lt;Point&gt; q;
    q.push( start );
    unordered_set&lt;Point&gt; s;
    s.insert( start );
    <span class="kw">while</span>( !q.empty() ) {
        Point p = q.front(); q.pop();
        <span class="dt">static</span> <span class="dt">int</span> dx[] = { <span class="dv">1</span>, <span class="dv">-1</span>, <span class="dv">0</span>,  <span class="dv">0</span> };
        <span class="dt">static</span> <span class="dt">int</span> dy[] = { <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">-1</span> };
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">4</span>; ++i ) {
            Point pp( p.x+dx[i], p.y+dy[i] );
            <span class="kw">if</span>( !pp.valid(map) || s.count(pp) ) { <span class="kw">continue</span>; }
            s.insert( pp );
            father[pp] = p;
            <span class="kw">if</span>( pp == end ) {
                <span class="kw">return</span> <span class="kw">true</span>;
            }
            q.push( pp );
        }
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">int</span> main() {
    vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; map( <span class="dv">5</span>, vector&lt;<span class="dt">int</span>&gt;(<span class="dv">5</span>) );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">5</span>; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">5</span>; ++j ) {
            scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;map[i][j] );
        }
    }
    Point start( <span class="dv">0</span>, <span class="dv">0</span> );
    Point end  ( <span class="dv">4</span>, <span class="dv">4</span> );
    unordered_map&lt;Point, Point&gt; father;
    <span class="kw">if</span>( bfs(map, father, start, end) ) {
        stack&lt;Point&gt; s;
        <span class="kw">while</span>( father.count(end) ) {
            s.push( end );
            end = father[end];
        }
        s.push( start );
        <span class="kw">while</span>( !s.empty() ) {
            printf(<span class="st">&quot;(</span><span class="ch">%d</span><span class="st">, </span><span class="ch">%d</span><span class="st">)</span><span class="ch">\n</span><span class="st">&quot;</span>, s.top().x, s.top().y );
            s.pop();
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>eight digit <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* POJ 1077 Eight, http://poj.org/problem?id=1077 */</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> DIGITS = <span class="dv">9</span>; <span class="co">// &#26827;&#30424;&#20013;&#25968;&#23383;&#30340;&#20010;&#25968;&#65292;&#20063;&#26159;&#21464;&#36827;&#21046;&#25968;&#38656;&#35201;&#30340;&#20301;&#25968;</span>
<span class="dt">const</span> <span class="dt">int</span> MATRIX_EDGE = <span class="dv">3</span>;       <span class="co">// &#26827;&#30424;&#36793;&#38271;</span>

<span class="co">/***** &#19968;&#20123;&#24120;&#37327; *****/</span>
<span class="dt">const</span> <span class="dt">int</span> SPACE_NUMBER = <span class="dv">0</span>; <span class="co">// &#31354;&#26684;&#23545;&#24212;&#30528;&#25968;&#23383; 0</span>
<span class="co">// &#19978;&#19979;&#24038;&#21491;&#22235;&#20010;&#26041;&#21521;</span>
<span class="dt">const</span> <span class="dt">int</span> dx[] = {<span class="dv">-1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>};
<span class="dt">const</span> <span class="dt">int</span> dy[] = {<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">-1</span>, <span class="dv">1</span>};
<span class="dt">const</span> <span class="dt">char</span> name[] = { <span class="st">&#39;u&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;r&#39;</span> };

<span class="kw">typedef</span> <span class="dt">char</span> <span class="dt">int8_t</span>;

<span class="co">/**</span>
 * <span class="er">@</span>strut &#29366;&#24577;
 */
<span class="kw">typedef</span> <span class="kw">struct</span> state_t {
    <span class="dt">int8_t</span> data[DIGITS];  <span class="co">/** </span>&#29366;&#24577;&#30340;&#25968;&#25454;. */
    <span class="dt">int</span> action; <span class="co">/* &#30001;&#29238;&#29366;&#24577;&#31227;&#21160;&#21040;&#26412;&#29366;&#24577;&#30340;&#21160;&#20316; */</span>
    <span class="dt">int</span> father; <span class="co">/* &#29238;&#29366;&#24577;&#22312; nodes[] &#20013;&#30340;&#19979;&#26631;&#65292;&#20063;&#21363;&#29238;&#29366;&#24577;&#30340;&#21704;&#24076;&#20540; */</span>
<span class="er">    int count;  /** &#25152;&#33457;&#36153;&#30340;&#27493;&#39588;&#25968;&#65288;&#20063;&#21363;&#36335;&#24452;&#38271;&#24230; -1&#65289; */</span>
} state_t;

<span class="co">// 3x3 &#30340;&#26827;&#30424;&#65292;&#29366;&#24577;&#26368;&#22810;&#26377; 9! &#31181;</span>
<span class="dt">const</span> <span class="dt">int</span> STATE_MAX = <span class="dv">362880</span>;  <span class="co">/* &#29366;&#24577;&#24635;&#25968; */</span>

state_t nodes[STATE_MAX<span class="dv">+1</span>];

<span class="dt">int</span> state_hash(<span class="dt">const</span> state_t &amp;s) {
    <span class="kw">return</span> state_hash( &amp;s );
}

<span class="dt">int</span> state_index(<span class="dt">const</span> state_t &amp;s) {
    <span class="kw">return</span> state_hash(s);
}

<span class="co">/**</span>
 * <span class="er">@</span>brief &#25171;&#21360;&#21160;&#20316;&#24207;&#21015;.
 * <span class="er">@</span>param[in] end &#32456;&#28857;&#29366;&#24577;&#30340;&#21704;&#24076;&#20540;
 * <span class="er">@</span>return &#29238;&#29366;&#24577;
 */
<span class="dt">void</span> print_action(<span class="dt">const</span> <span class="dt">int</span> end) {
    <span class="kw">if</span> (nodes[end].father == <span class="dv">-1</span>) <span class="kw">return</span>;

    print_action(nodes[end].father);
    putchar(name[nodes[end].action]);
}

<span class="dt">void</span> hashset_init();

<span class="dt">bool</span> hashset_find(<span class="dt">const</span> state_t *s);

<span class="dt">void</span> hashset_insert(<span class="dt">const</span> state_t *s);

<span class="dt">void</span> state_extend_init(<span class="dt">const</span> state_t *s);

<span class="dt">bool</span> state_extend(<span class="dt">const</span> state_t *s, state_t *next);

<span class="dt">bool</span> state_is_target(<span class="dt">const</span> state_t *s);


<span class="dt">int</span> bfs(state_t *start) {
    queue&lt;state_t&gt; q;
    hashset_init();

    start-&gt;action = <span class="dv">-1</span>;
    start-&gt;father = <span class="dv">-1</span>;
    start-&gt;count = <span class="dv">0</span>;

    nodes[state_index(*start)] = *start;
    hashset_insert(start);
    <span class="kw">if</span> (state_is_target(start))
        <span class="kw">return</span> state_index(*start);
    q.push(*start);

    <span class="kw">while</span> (!q.empty()) {
        <span class="dt">const</span> state_t s = q.front(); q.pop();
        state_t next;

        state_extend_init(&amp;s);
        <span class="kw">while</span> (state_extend(&amp;s, &amp;next)) {
            <span class="kw">if</span> (state_is_target(&amp;next)) {
                <span class="co">// printf(&quot;%d\n&quot;, next.count);</span>
                <span class="kw">return</span> state_index(next);
            }
            q.push(next);
            hashset_insert(&amp;next);
        }
    }
    <span class="kw">return</span> <span class="dv">-1</span>;
}

<span class="co">/**</span>
 * <span class="er">@</span>brief &#36755;&#20837;.
 * <span class="er">@</span>return &#26080;
 */
<span class="dt">void</span> input(state_t *start) {
    <span class="dt">int</span> ch;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; DIGITS; ++i) {
        <span class="kw">do</span> {
            ch = getchar();
        } <span class="kw">while</span> ((ch != EOF) &amp;&amp; ((ch &lt; <span class="st">&#39;1&#39;</span>) || (ch &gt; <span class="st">&#39;8&#39;</span>)) &amp;&amp; (ch != <span class="st">&#39;x&#39;</span>));
        <span class="kw">if</span> (ch == EOF) <span class="kw">return</span>;
        <span class="kw">if</span> (ch == <span class="st">&#39;x&#39;</span>) start-&gt;data[i] = <span class="dv">0</span>; <span class="co">// x &#26144;&#23556;&#25104;&#25968;&#23383; 0</span>
        <span class="kw">else</span>           start-&gt;data[i] = ch - <span class="st">&#39;0&#39;</span>;
    }
}

<span class="co">/** </span><span class="kw">for</span> wikioi <span class="dv">1225</span> */
<span class="dt">void</span> input1(state_t *start) {
    <span class="dt">int</span> n;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span><span class="co">,</span> &amp;n);

    <span class="co">/* &#23558;&#25972;&#25968;&#36716;&#21270;&#20026;&#26827;&#30424; */</span>
    <span class="kw">for</span>(<span class="dt">int</span> i = DIGITS<span class="dv">-1</span>; i &gt;= <span class="dv">0</span>; i--) {
        start-&gt;data[i] = n % <span class="dv">10</span>;
        n /= <span class="dv">10</span>;
    }
}

<span class="dt">int</span> main(<span class="dt">void</span>) {
    state_t start;
    <span class="dt">int</span> end; <span class="co">/* &#30446;&#26631;&#29366;&#24577;&#22312;nodes[]&#20013;&#30340;&#19979;&#26631; */</span>
    input(&amp;start);

    end = bfs(&amp;start);

    print_action(end);
    printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span><span class="co">)</span>;
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="co">/********** functions implement **************/</span>

<span class="co">/********** &#26041;&#26696;1&#65292;&#23436;&#32654;&#21704;&#24076;&#65292;&#20351;&#29992;&#24247;&#25176;&#23637;&#24320; **************/</span>

<span class="co">// 9 &#20301;&#21464;&#36827;&#21046;&#25968;&#65288;&#31354;&#26684;&#65289;&#33021;&#34920;&#31034; 0 &#21040; (9!-1) &#20869;&#30340;&#25152;&#26377;&#33258;&#28982;&#25968;, &#24688;&#22909;&#26377; 9! &#20010;&#65292;</span>
<span class="co">// &#19982;&#29366;&#24577;&#19968;&#19968;&#23545;&#24212;&#65292;&#22240;&#27492;&#21487;&#20197;&#25226;&#29366;&#24577;&#19968;&#19968;&#26144;&#23556;&#21040;&#19968;&#20010; 9 &#20301;&#21464;&#36827;&#21046;&#25968;</span>

<span class="co">// 9 &#20301;&#21464;&#36827;&#21046;&#25968;&#65292;&#27599;&#20010;&#20301;&#25968;&#30340;&#21333;&#20301;&#65292;0!~8!</span>
<span class="dt">const</span> <span class="dt">int</span> fac[] = {<span class="dv">40320</span>, <span class="dv">5040</span>, <span class="dv">720</span>, <span class="dv">120</span>, <span class="dv">24</span>, <span class="dv">6</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>};
<span class="co">/* &#21704;&#24076;&#34920;&#23481;&#37327;&#65292;&#35201;&#22823;&#20110;&#29366;&#24577;&#24635;&#25968;&#65292;&#33509;&#23384;&#22312;&#23436;&#32654;&#21704;&#24076;&#26041;&#26696;&#65292;&#21017;&#31561;&#20110;&#29366;&#24577;&#24635;&#25968; */</span>
<span class="dt">const</span> <span class="dt">int</span> HASH_CAPACITY = STATE_MAX;

<span class="dt">bool</span> visited[HASH_CAPACITY];

<span class="dt">int</span> state_hash(<span class="dt">const</span> state_t *s) {
    <span class="dt">int</span> key = <span class="dv">0</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; DIGITS; i++) {
        <span class="dt">int</span> cnt = <span class="dv">0</span>;  <span class="co">/* &#36870;&#24207;&#25968; */</span>
        <span class="kw">for</span> (<span class="dt">int</span> j = i + <span class="dv">1</span>; j &lt; DIGITS; j++) <span class="kw">if</span> (s-&gt;data[i] &gt; s-&gt;data[j]) cnt++;
        key += fac[i] * cnt;
    }
    <span class="kw">return</span> key;
}

<span class="dt">void</span> hashset_init() {
    memset(visited, <span class="dv">0</span>, <span class="kw">sizeof</span>(visited));
}

<span class="dt">bool</span> hashset_find(<span class="dt">const</span> state_t *s) {
    <span class="kw">return</span> visited[state_hash(s)] == <span class="kw">true</span>;
}

<span class="dt">void</span> hashset_insert(<span class="dt">const</span> state_t *s) {
    visited[state_hash(s)] = <span class="kw">true</span>;
}

<span class="dt">int</span> action_cur;
<span class="ot">#define ACTION_BEGIN 0</span>
<span class="ot">#define ACTION_END 4</span>

<span class="co">/* &#25193;&#23637;&#28857;&#65292;&#21363;0&#30340;&#20301;&#32622; */</span>
<span class="dt">int</span> z;

<span class="dt">void</span> state_extend_init(<span class="dt">const</span> state_t *s) {
    action_cur = ACTION_BEGIN;
    <span class="kw">for</span> (z = <span class="dv">0</span>; z &lt; DIGITS; z++) {
        <span class="kw">if</span> (s-&gt;data[z] == SPACE_NUMBER) {
            <span class="kw">break</span>;  <span class="co">// &#25214; 0 &#30340;&#20301;&#32622;</span>
        }
    }
}

<span class="dt">bool</span> state_extend(<span class="dt">const</span> state_t *s, state_t *next) {
    <span class="dt">const</span> <span class="dt">int</span> x = z / MATRIX_EDGE; <span class="co">// &#34892;</span>
    <span class="dt">const</span> <span class="dt">int</span> y = z % MATRIX_EDGE; <span class="co">// &#21015;</span>

    <span class="kw">while</span> (action_cur &lt; ACTION_END) {
        <span class="dt">const</span> <span class="dt">int</span> newx = x + dx[action_cur];
        <span class="dt">const</span> <span class="dt">int</span> newy = y + dy[action_cur];
        <span class="dt">const</span> <span class="dt">int</span> newz = newx * MATRIX_EDGE + newy;

        <span class="kw">if</span> (newx &gt;= <span class="dv">0</span> &amp;&amp; newx &lt; MATRIX_EDGE &amp;&amp; newy &gt;= <span class="dv">0</span> &amp;&amp;
                newy &lt; MATRIX_EDGE) { <span class="co">// &#27809;&#26377;&#36234;&#30028;</span>
            *next = *s;
            next-&gt;data[newz] = SPACE_NUMBER;
            next-&gt;data[z] = s-&gt;data[newz];
            next-&gt;count = s-&gt;count + <span class="dv">1</span>;
            <span class="kw">if</span> (!hashset_find(next)) { <span class="co">/* &#21028;&#37325; */</span>
                next-&gt;action = action_cur;
                next-&gt;father = state_hash(s);
                <span class="co">/* &#35760;&#24405;&#36335;&#24452; */</span>
                nodes[state_index(*next)] = *next;
                action_cur++; <span class="co">/* return&#21069;&#21035;&#24536;&#20102;&#22686;1 */</span>
                <span class="kw">return</span> <span class="kw">true</span>;
            }
        }
        action_cur++;
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="co">// &#30446;&#26631;&#29366;&#24577;</span>
<span class="dt">const</span> state_t END = {{<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">0</span>}, <span class="dv">-1</span>, <span class="dv">-1</span>};
<span class="co">// for wikioi 1225</span>
<span class="dt">const</span> state_t END1 = {{<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">8</span>, <span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">6</span>, <span class="dv">5</span>}, <span class="dv">-1</span>, <span class="dv">-1</span>};

<span class="dt">bool</span> state_is_target(<span class="dt">const</span> state_t *s) {
    <span class="kw">return</span> memcmp(s-&gt;data, END.data, DIGITS * <span class="kw">sizeof</span>(<span class="dt">int8_t</span>)) == <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>four go <code class="fold">@</code></dt>
<dd><p>&#22312;&#19968;&#20010; 4 x 4 &#30340;&#26827;&#30424;&#19978;&#25670;&#25918;&#20102; 14 &#39063;&#26827;&#23376;&#65292;&#20854;&#20013;&#26377; 7 &#39063;&#30333;&#33394;&#26827;&#23376;&#65292;7 &#39063;&#40657;&#33394;&#26827;&#23376;&#65292;&#26377;&#20004;&#20010;&#31354;&#30333;&#22320;&#24102;&#65292;&#20219;&#20309;&#19968;&#39063;&#40657;&#30333;&#26827;&#23376;&#37117;&#21487;&#20197;&#21521;&#19978;&#19979;&#24038;&#21491;&#22235;&#20010;&#26041;&#21521;&#31227;&#21160;&#21040;&#30456;&#37051;&#30340;&#31354;&#26684;&#65292;&#36825;&#21483;&#34892;&#26827;&#19968;&#27493;&#65292;&#40657;&#30333;&#21452;&#26041;&#20132;&#26367;&#36208;&#26827;&#65292;&#20219;&#24847;&#19968;&#26041;&#21487;&#20197;&#20808;&#36208;&#65292;&#22914;&#26524;&#26576;&#20010;&#26102;&#21051;&#20351;&#24471;&#20219;&#24847;&#19968;&#31181;&#39068;&#33394;&#30340;&#26827;&#23376;&#24418;&#25104;&#22235;&#20010;&#19968;&#32447;&#65288;&#21253;&#25324;&#26012;&#32447;&#65289;&#65292;&#36825;&#26679;&#30340;&#29366;&#24577;&#20026;&#30446;&#26631;&#26827;&#23616;&#12290;</p>
<pre><code>&#36755;&#20837;

    &#19968;&#20010; 4 x 4 &#30340;&#21021;&#22987;&#26827;&#23616;&#65292;
    &#40657;&#26827;&#23376;&#29992; B &#34920;&#31034;&#65292;&#30333;&#26827;&#23376;&#29992; W &#34920;&#31034;&#65292;&#31354;&#26684;&#22320;&#24102;&#29992; O &#34920;&#31034;&#12290;

    BWBO
    WBWB
    BWBW
    WBWO

&#36755;&#20986;

    &#31227;&#21160;&#21040;&#30446;&#26631;&#26827;&#23616;&#30340;&#26368;&#23569;&#27493;&#25968;&#12290;

   5</code></pre>
<dl>
<dt>&#20998;&#26512;</dt>
<dd><p>&#27714;&#26368;&#23569;&#27493;&#25968;&#65292;&#24456;&#33258;&#28982;&#30340;&#24819;&#21040;&#24191;&#25628;&#12290;</p>
<p>&#22914;&#20309;&#34920;&#31034;&#19968;&#20010;&#29366;&#24577;&#65311;&#29992;&#19968;&#20010;&#20108;&#32500;&#25968;&#32452; <code>int board[4][4]</code> &#34920;&#31034;&#65292;&#36824;&#38656;&#35201;&#35760;&#24405;&#35813;&#29366;&#24577;&#26159;&#30001;&#30333;&#23376;&#36824;&#26159;&#40657;&#23376;&#31227;&#21160;&#32780;&#23548;&#33268;&#30340;&#65292;&#36208;&#21040;&#35813;&#29366;&#24577;&#24050;&#32463;&#33457;&#36153;&#30340;&#27493;&#25968;&#12290;</p>
<p>&#22914;&#20309;&#25193;&#23637;&#33410;&#28857;&#65311;&#27599;&#19968;&#27493;&#65292;&#20174;&#38431;&#21015;&#24377;&#20986;&#19968;&#20010;&#29366;&#24577;&#65292;&#20004;&#20010;&#31354;&#26684;&#37117;&#21487;&#20197;&#21521;&#22235;&#20010;&#26041;&#21521;&#25193;&#23637;&#65292;&#25226;&#24471;&#21040;&#30340;&#29366;&#24577;&#20837;&#38431;&#21015;&#12290;</p>
<p>&#22914;&#20309;&#21028;&#37325;&#65311;&#26827;&#30424;&#29992;&#20108;&#32500;&#30697;&#38453;&#23384;&#20648;&#65292;&#29992; 0 &#34920;&#31034;&#31354;&#26684;&#65292;1 &#34920;&#31034;&#40657;&#33394;&#65292;2 &#34920;&#31034;&#30333;&#33394;&#65292;&#25152;&#20197;&#26368;&#21518;&#21487;&#20197;&#30475;&#25104;&#19968;&#20010; 16 &#20301;&#30340;&#19977;&#36827;&#21046;&#25968;&#12290;&#29992;&#36825;&#20010;&#25968;&#20316;&#20026;&#26827;&#30424;&#30340;&#32534;&#30721;&#65292;&#23601;&#21487;&#20197;&#29992;&#26469;&#21028;&#37325;&#20102;&#12290;&#27880;&#24847;&#65292;&#26412;&#39064;&#35201;&#40657;&#30333;&#20132;&#26367;&#36208;&#65292;&#25152;&#20197;&#25105;&#20204;&#35201;&#21306;&#20998;&#29366;&#24577;&#26159;&#30001;&#30333;&#23376;&#36824;&#26159;&#40657;&#23376;&#31227;&#21160;&#32780;&#23548;&#33268;&#30340;&#12290;</p>
<p>&#21028;&#37325;: <code>visited[0]</code> &#35760;&#24405;&#30333;&#23376;&#30340;&#21382;&#21490;&#65292; <code>visited[1]</code> &#35760;&#24405;&#40657;&#23376;&#30340;&#21382;&#21490;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// std::map</span>
map&lt;<span class="dt">int</span>, <span class="dt">bool</span>&gt; visited[<span class="dv">2</span>];

<span class="co">// &#20063;&#21487;&#20197;&#24320;&#19968;&#20010;&#22823;&#25968;&#32452;&#24403;&#20570;&#21704;&#24076;&#34920;&#65292;</span>
<span class="ot">#define HASH_MOD 43036875                       </span><span class="co">// hash&#34920;&#22823;&#23567;</span>
<span class="dt">bool</span> visited[<span class="dv">2</span>][HASH_MOD];</code></pre></div>
</dd>
<dt>C version <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/** </span>wikioi <span class="dv">1004</span> &#22235;&#23376;&#36830;&#26827;  , http:<span class="co">//www.wikioi.com/problem/1004 */</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// &#25193;&#23637;&#30340;&#26102;&#20505;&#65292;&#20808;&#23450;&#31354;&#26684;&#65292;&#20877;&#23450;&#26041;&#21521;</span>
<span class="co">// &#35760;&#24405;&#24403;&#21069;&#26041;&#21521;&#65292;&#20363;&#22914;action_cur[0]&#35760;&#24405;&#20102;&#31532;&#19968;&#20010;&#31354;&#26684;&#65292;&#24403;&#21069;&#22312;&#25193;&#23637;&#21738;&#20010;&#26041;&#21521;</span>
<span class="dt">int</span> action_cur[<span class="dv">2</span>];
<span class="ot">#define ACTION_BEGIN 0</span>
<span class="ot">#define ACTION_END 4</span>

<span class="kw">typedef</span> <span class="kw">struct</span> point_t {
    <span class="dt">int</span> x, y;
} point_t;
<span class="dt">int</span> space_cur;                          <span class="co">// &#35760;&#24405;&#24403;&#21069;&#22312;&#25193;&#23637;&#21738;&#19968;&#20010;&#31354;&#26684;&#65292;&#20540;&#20026;0&#25110;1</span>
point_t extend_pos[<span class="dv">2</span>];                  <span class="co">// &#20004;&#20010;&#31354;&#26684;&#30340;&#20301;&#32622;</span>

<span class="co">// &#21704;&#24076;&#34920;&#23481;&#37327;&#65292;&#35201;&#22823;&#20110;&#29366;&#24577;&#24635;&#25968;&#65292;&#33509;&#23384;&#22312;&#23436;&#32654;&#21704;&#24076;&#26041;&#26696;&#65292;&#21017;&#31561;&#20110;&#29366;&#24577;&#24635;&#25968;</span>
<span class="ot">#define HASH_CAPACITY 43036875</span>

<span class="dt">bool</span> visited[<span class="dv">2</span>][HASH_CAPACITY];
<span class="ot">#define LEN 4                               </span><span class="co">// &#36793;&#38271;</span>
<span class="dt">const</span> <span class="dt">int</span> dx[] = { <span class="dv">1</span>, <span class="dv">-1</span>, <span class="dv">0</span>, <span class="dv">0</span> };           <span class="co">// &#21491;&#65292;&#24038;&#65292;&#19978;&#65292;&#19979;&#65288;&#24038;&#19979;&#35282;&#20026;&#22352;&#26631;&#21407;&#28857;&#65289;</span>
<span class="dt">const</span> <span class="dt">int</span> dy[] = { <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">-1</span> };

<span class="kw">typedef</span> <span class="kw">struct</span> state_t {
    <span class="dt">int</span> board[LEN][LEN];                    <span class="co">// &#26827;&#23616;&#65292;1&#34920;&#31034;&#40657;&#23376;&#65292;2&#34920;&#31034;&#30333;&#23376;&#65292;0&#34920;&#31034;&#31354;&#30333;</span>
    <span class="dt">int</span> color;                              <span class="co">// &#26412;&#29366;&#24577;&#26159;&#30001;&#30333;&#23376;&#36824;&#26159;&#40657;&#23376;&#31227;&#21160;&#32780;&#23548;&#33268;&#30340;</span>
    <span class="dt">int</span> count;                              <span class="co">// &#25152;&#33457;&#36153;&#30340;&#27493;&#39588;&#25968;&#65288;&#20063;&#21363;&#36335;&#24452;&#38271;&#24230;-1&#65289;&#65292;&#27714;&#36335;&#24452;&#38271;&#24230;&#26102;&#38656;&#35201;</span>
} state_t;

<span class="dt">int</span> state_hash(<span class="dt">const</span> state_t &amp;s) {
    <span class="dt">const</span> <span class="dt">static</span> <span class="dt">int</span> RADIX = <span class="dv">3</span>;         <span class="co">// &#19977;&#36827;&#21046;</span>
    <span class="dt">int</span> ret = <span class="dv">0</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; LEN; i++) {
        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; LEN; j++) {
            ret = ret * RADIX + s.board[i][j];
        }
    }
    <span class="kw">return</span> ret;
}

<span class="dt">void</span> hashset_init() {
    fill(visited[<span class="dv">0</span>], visited[<span class="dv">0</span>] + HASH_CAPACITY, <span class="kw">false</span>);
    fill(visited[<span class="dv">1</span>], visited[<span class="dv">1</span>] + HASH_CAPACITY, <span class="kw">false</span>);
}
<span class="dt">bool</span> hashset_find(<span class="dt">const</span> state_t &amp;s) {
    <span class="kw">return</span> visited[s.color - <span class="dv">1</span>][state_hash(s)] == <span class="kw">true</span>;
}
<span class="dt">void</span> hashset_insert(<span class="dt">const</span> state_t &amp;s) {
    visited[s.color - <span class="dv">1</span>][state_hash(s)] = <span class="kw">true</span>;
}
<span class="dt">void</span> state_extend_init(<span class="dt">const</span> state_t &amp;s) {
    action_cur[<span class="dv">0</span>] = ACTION_BEGIN;
    action_cur[<span class="dv">1</span>] = ACTION_BEGIN;
    space_cur = <span class="dv">0</span>;

    <span class="dt">int</span> k = <span class="dv">0</span>;
    <span class="co">// &#23547;&#25214;&#20004;&#20010;&#31354;&#30333;&#30340;&#26684;&#23376;&#30340;&#20301;&#32622;</span>
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; LEN; i++) {
        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; LEN; j++) {
            <span class="kw">if</span> (s.board[i][j] == <span class="dv">0</span>) {
                extend_pos[k].x = i;
                extend_pos[k].y = j;
                k++;
            }
        }
    }
}
<span class="dt">bool</span> state_extend(<span class="dt">const</span> state_t &amp;s, state_t &amp;next) {
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">2</span>; i++) { <span class="co">/* &#20808;&#31532;&#19968;&#20010;&#31354;&#26684;&#65292;&#20877;&#31532;&#20108;&#20010;&#31354;&#26684; */</span>
        <span class="kw">while</span> (action_cur[i] &lt; ACTION_END) {
            <span class="dt">const</span> <span class="dt">int</span> x = extend_pos[i].x;
            <span class="dt">const</span> <span class="dt">int</span> y = extend_pos[i].y;
            <span class="dt">int</span> nextx = x + dx[action_cur[i]];
            <span class="dt">int</span> nexty = y + dy[action_cur[i]];
            next = s;
            next.count = s.count + <span class="dv">1</span>;
            next.color = <span class="dv">3</span> - s.color;

            <span class="kw">if</span> (nextx &gt;= <span class="dv">0</span> &amp;&amp; nextx &lt; LEN &amp;&amp; nexty &gt;= <span class="dv">0</span> &amp;&amp;
                nexty &lt; LEN &amp;&amp; next.color == s.board[nextx][nexty])     <span class="co">// &#24517;&#39035;&#40657;&#30333;&#20132;&#26367;&#36208;</span>
            {
                <span class="co">// swap</span>
                <span class="dt">int</span> temp = next.board[x][y];
                next.board[x][y] = next.board[nextx][nexty];
                next.board[nextx][nexty] = temp;

                <span class="kw">if</span> (!hashset_find(next)) { <span class="co">/* &#21028;&#37325; */</span>
                    action_cur[i]++; <span class="co">/* return&#21069;&#21035;&#24536;&#20102;&#22686;1 */</span>
                    <span class="kw">return</span> <span class="kw">true</span>;
                }
            }
            action_cur[i]++;
        }
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">bool</span> state_is_target(<span class="dt">const</span> state_t &amp;s) {
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; LEN; i++) {  <span class="co">/* &#36880;&#34892;&#26816;&#26597; */</span>
        <span class="dt">int</span> flag = <span class="dv">1</span>;  <span class="co">/* &#26576;&#19968;&#34892;&#20840;&#26159;&#21516;&#19968;&#39068;&#33394; */</span>
        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt; LEN; j++)
            <span class="kw">if</span> (s.board[i][j - <span class="dv">1</span>] != s.board[i][j])
                flag = <span class="dv">0</span>;
        <span class="kw">if</span> (flag)
            <span class="kw">return</span> <span class="dv">1</span>;
    }
    <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; LEN; j++) { <span class="co">//&#36880;&#21015;&#26816;&#26597;</span>
        <span class="dt">int</span> flag = <span class="dv">1</span>;  <span class="co">/* &#26576;&#19968;&#34892;&#20840;&#26159;&#21516;&#19968;&#39068;&#33394; */</span>
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; LEN; i++)
            <span class="kw">if</span> (s.board[i][j] != s.board[i - <span class="dv">1</span>][j]) flag = <span class="dv">0</span>;
        <span class="kw">if</span> (flag) <span class="kw">return</span> <span class="dv">1</span>;
    }
    <span class="co">/* &#26012;&#32447; */</span>
    <span class="kw">if</span> (s.board[<span class="dv">0</span>][<span class="dv">0</span>] == s.board[<span class="dv">1</span>][<span class="dv">1</span>] &amp;&amp; s.board[<span class="dv">1</span>][<span class="dv">1</span>] == s.board[<span class="dv">2</span>][<span class="dv">2</span>]
            &amp;&amp; s.board[<span class="dv">2</span>][<span class="dv">2</span>] == s.board[<span class="dv">3</span>][<span class="dv">3</span>])
        <span class="kw">return</span> <span class="dv">1</span>;
    <span class="kw">if</span> (s.board[<span class="dv">0</span>][<span class="dv">3</span>] == s.board[<span class="dv">1</span>][<span class="dv">2</span>] &amp;&amp; s.board[<span class="dv">1</span>][<span class="dv">2</span>] == s.board[<span class="dv">2</span>][<span class="dv">1</span>]
            &amp;&amp; s.board[<span class="dv">2</span>][<span class="dv">1</span>] == s.board[<span class="dv">3</span>][<span class="dv">0</span>])
        <span class="kw">return</span> <span class="dv">1</span>;
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">void</span> bfs(state_t &amp;start) {
    queue&lt;state_t&gt; q;
    hashset_init();

    start.count = <span class="dv">0</span>;
    start.color = <span class="dv">1</span>;

    hashset_insert(start);
    q.push(start);

    start.color = <span class="dv">2</span>;

    hashset_insert(start); <span class="co">// &#21315;&#19975;&#21035;&#24536;&#35760;&#20102;&#26631;&#35760;&#27492;&#22788;&#30340;&#35775;&#38382;&#35760;&#24405;</span>
    <span class="kw">if</span> (state_is_target(start)) <span class="co">/* &#22914;&#26524;&#36215;&#28857;&#23601;&#26159;&#32456;&#28857;&#65292;&#36820;&#22238; */</span>
        <span class="kw">return</span>;
    q.push(start);

    <span class="kw">while</span> (!q.empty()) {
        <span class="dt">const</span> state_t s = q.front(); q.pop();
        state_t next;

        state_extend_init(s);
        <span class="kw">while</span> (state_extend(s, next)) {
            <span class="kw">if</span> (state_is_target(next)) {
                printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span><span class="co">,</span> next.count);
                <span class="kw">return</span>;
            }
            q.push(next);
            hashset_insert(next);
        }
    }
}

<span class="dt">int</span> main() {
    <span class="dt">char</span> s[LEN + <span class="dv">1</span>];
    state_t start;

    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; LEN; i++) {
        scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span><span class="co">,</span> s);
        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; LEN; j++) {
            <span class="kw">if</span> (s[j] == <span class="st">&#39;B&#39;</span>) start.board[i][j] = <span class="dv">1</span>;
            <span class="kw">else</span> <span class="kw">if</span> (s[j] == <span class="st">&#39;W&#39;</span>) start.board[i][j] = <span class="dv">2</span>;
            <span class="kw">else</span> start.board[i][j] = <span class="dv">0</span>;
        }
    }

    bfs(start);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
<dt>C++ version <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// wikioi 1004 &#22235;&#23376;&#36830;&#26827;  , http://www.wikioi.com/problem/1004</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;unordered_set&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> state_t {
    <span class="dt">int</span> board[<span class="dv">4</span>][<span class="dv">4</span>], color, count;
    <span class="dt">bool</span> <span class="kw">operator</span>==( <span class="dt">const</span> state_t &amp;rhs ) <span class="dt">const</span> {
        <span class="kw">if</span>( color != rhs.color ) { <span class="kw">return</span> <span class="kw">false</span>; }
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">4</span>; ++i ) {
            <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">4</span>; ++j ) {
                <span class="kw">if</span>( board[i][j] != rhs.board[i][j] ) {
                    <span class="kw">return</span> <span class="kw">false</span>;
                }
            }
        }
        <span class="kw">return</span> <span class="kw">true</span>;
    }
};

<span class="kw">namespace</span> std {
<span class="kw">template</span>&lt;&gt; <span class="kw">struct</span> hash&lt;state_t&gt; {
    size_t <span class="kw">operator</span>()( <span class="dt">const</span> state_t &amp;x ) <span class="dt">const</span> {
        <span class="dt">const</span> <span class="dt">static</span> <span class="dt">int</span> RADIX = <span class="dv">3</span>;
        <span class="dt">int</span> ret = <span class="dv">0</span>;
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">4</span>; ++i ) {
            <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">4</span>; ++j ) {
                ret = ret * RADIX + x.board[i][j];
            }
        }
        <span class="kw">return</span> ret;
    }
};
}

<span class="kw">class</span> FourGo {
<span class="kw">public</span>:
    FourGo() { }
    unordered_set&lt;state_t&gt; visited[<span class="dv">2</span>];
    <span class="dt">const</span> <span class="dt">static</span> <span class="dt">int</span> ACTION_BEGIN = <span class="dv">0</span>;
    <span class="dt">const</span> <span class="dt">static</span> <span class="dt">int</span> ACTION_END = <span class="dv">4</span>;
    <span class="dt">bool</span> isVisited( <span class="dt">const</span> state_t &amp;s ) { <span class="kw">return</span> visited[s.color - <span class="dv">1</span>].count(s); }
    <span class="dt">void</span> insertState( <span class="dt">const</span> state_t &amp;s ) { visited[s.color - <span class="dv">1</span>].insert(s); }

    <span class="dt">int</span> action_cur[<span class="dv">2</span>];
    <span class="dt">void</span> state_extend_init(<span class="dt">const</span> state_t &amp;s) {
        action_cur[<span class="dv">0</span>] = ACTION_BEGIN;
        action_cur[<span class="dv">1</span>] = ACTION_BEGIN;
        space_cur = <span class="dv">0</span>;

        <span class="dt">int</span> k = <span class="dv">0</span>;
        <span class="co">// &#23547;&#25214;&#20004;&#20010;&#31354;&#30333;&#30340;&#26684;&#23376;&#30340;&#20301;&#32622;</span>
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">4</span>; i++) {
            <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">4</span>; j++) {
                <span class="kw">if</span> (s.board[i][j] == <span class="dv">0</span>) {
                    extend_pos[k].x = i;
                    extend_pos[k].y = j;
                    k++;
                }
            }
        }
    }

    <span class="co">// &#25193;&#23637;&#30340;&#26102;&#20505;&#65292;&#20808;&#23450;&#31354;&#26684;&#65292;&#20877;&#23450;&#26041;&#21521;</span>
    <span class="co">// &#35760;&#24405;&#24403;&#21069;&#26041;&#21521;&#65292;&#20363;&#22914;action_cur[0]&#35760;&#24405;&#20102;&#31532;&#19968;&#20010;&#31354;&#26684;&#65292;&#24403;&#21069;&#22312;&#25193;&#23637;&#21738;&#20010;&#26041;&#21521;</span>
    <span class="dt">bool</span> state_extend(<span class="dt">const</span> state_t &amp;s, state_t &amp;next) {
        <span class="dt">const</span> <span class="dt">static</span> <span class="dt">int</span> dx[<span class="dv">4</span>] = { <span class="dv">1</span>, <span class="dv">-1</span>, <span class="dv">0</span>, <span class="dv">0</span> };
        <span class="dt">const</span> <span class="dt">static</span> <span class="dt">int</span> dy[<span class="dv">4</span>] = { <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">-1</span> };
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">2</span>; ++i ) {
            <span class="kw">while</span> (action_cur[i] &lt; ACTION_END) {
                <span class="dt">int</span> x = extend_pos[i].x;
                <span class="dt">int</span> y = extend_pos[i].y;
                <span class="dt">int</span> nextx = x + dx[action_cur[i]];
                <span class="dt">int</span> nexty = y + dy[action_cur[i]];
                next = s;
                next.count = s.count + <span class="dv">1</span>;
                next.color = <span class="dv">3</span> - s.color;

                ++action_cur[i];
                <span class="kw">if</span> ( <span class="dv">0</span> &lt;= nextx &amp;&amp; nextx &lt; <span class="dv">4</span> &amp;&amp; <span class="dv">0</span> &lt;= nexty &amp;&amp; nexty &lt; <span class="dv">4</span>
                  &amp;&amp; next.color == s.board[nextx][nexty])     <span class="co">// &#24517;&#39035;&#40657;&#30333;&#20132;&#26367;&#36208;</span>
                {
                    swap(next.board[x][y], next.board[nextx][nexty]);
                    <span class="kw">if</span> (!isVisited(next)) { <span class="kw">return</span> <span class="kw">true</span>; }
                }
            }
        }
        <span class="kw">return</span> <span class="kw">false</span>;
    }

    <span class="kw">struct</span> Point { <span class="dt">int</span> x, y; } extend_pos[<span class="dv">2</span>];
    <span class="dt">int</span> space_cur;
    <span class="dt">bool</span> isTarget( <span class="dt">const</span> state_t &amp;s ) {
        <span class="dt">bool</span> okay;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">4</span>; i++) {
            okay = <span class="kw">true</span>;
            <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt; <span class="dv">4</span>; j++) {
                <span class="kw">if</span> (s.board[i][j - <span class="dv">1</span>] != s.board[i][j]) { okay = <span class="kw">false</span>; }
            }
            <span class="kw">if</span> (okay) { <span class="kw">return</span> <span class="kw">true</span>; }
        }
        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">4</span>; j++) {
            okay = <span class="kw">true</span>;
            <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="dv">4</span>; i++) {
                <span class="kw">if</span> (s.board[i][j] != s.board[i - <span class="dv">1</span>][j]) { okay = <span class="kw">false</span>; }
            }
            <span class="kw">if</span> (okay) { <span class="kw">return</span> <span class="kw">true</span>; }
        }
        <span class="kw">if</span> ( (s.board[<span class="dv">0</span>][<span class="dv">0</span>] == s.board[<span class="dv">1</span>][<span class="dv">1</span>] &amp;&amp; s.board[<span class="dv">1</span>][<span class="dv">1</span>] == s.board[<span class="dv">2</span>][<span class="dv">2</span>] &amp;&amp; s.board[<span class="dv">2</span>][<span class="dv">2</span>] == s.board[<span class="dv">3</span>][<span class="dv">3</span>]) ||
             (s.board[<span class="dv">0</span>][<span class="dv">3</span>] == s.board[<span class="dv">1</span>][<span class="dv">2</span>] &amp;&amp; s.board[<span class="dv">1</span>][<span class="dv">2</span>] == s.board[<span class="dv">2</span>][<span class="dv">1</span>] &amp;&amp; s.board[<span class="dv">2</span>][<span class="dv">1</span>] == s.board[<span class="dv">3</span>][<span class="dv">0</span>]) ) { <span class="kw">return</span> <span class="kw">true</span>; }

        <span class="kw">return</span> <span class="kw">false</span>;
    }

    <span class="dt">void</span> bfs(state_t &amp;start) {
        <span class="kw">if</span>(isTarget(start)) { <span class="kw">return</span>; }

        <span class="co">// init vis hash</span>
        visited[<span class="dv">0</span>].clear();
        visited[<span class="dv">1</span>].clear();

        queue&lt;state_t&gt; q;

        start.count = <span class="dv">0</span>;

        start.color = <span class="dv">1</span>;
        insertState(start);
        q.push(start);

        start.color = <span class="dv">2</span>;
        insertState(start);
        q.push(start);

        <span class="kw">while</span> (!q.empty()) {
            state_t s = q.front(); q.pop();
            state_t next;

            state_extend_init(s);
            <span class="kw">while</span> (state_extend(s, next)) {
                <span class="kw">if</span> (isTarget(next)) {
                    printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, next.count);
                    <span class="kw">return</span>;
                }
                q.push(next);
                insertState(next);
            }
        }
    }
};

<span class="dt">int</span> main() {
    state_t start;
    FourGo fg;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">4</span>; i++) {
        <span class="dt">char</span> s[<span class="dv">10</span>];
        scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, s);
        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">4</span>; j++) {
            <span class="kw">if</span> (s[j] == <span class="st">&#39;B&#39;</span>) start.board[i][j] = <span class="dv">1</span>;
            <span class="kw">else</span> <span class="kw">if</span> (s[j] == <span class="st">&#39;W&#39;</span>) start.board[i][j] = <span class="dv">2</span>;
            <span class="kw">else</span> start.board[i][j] = <span class="dv">0</span>;
        }
    }

    fg.bfs(start);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>two-queue BFS (nothing here) <code class="fold">@</code></dt>
<dd><p>See again. See Milo Yip&#8217;s blog post.</p>
</dd>
</dl></li>
<li><dl>
<dt><code>A*</code> Algorithm (nothing here) :TODO: <code class="fold">@</code></dt>
<dd><p>TODO</p>
</dd>
</dl></li>
<li><dl>
<dt>Conclusion <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#36866;&#29992;&#22330;&#26223; <code class="fold">@</code></dt>
<dd><ul>
<li><strong>&#36755;&#20837;</strong>&#25968;&#25454;&#65306;&#27809;&#20160;&#20040;&#29305;&#24449;&#65292;&#19981;&#20687;&#28145;&#25628;&#65292;&#38656;&#35201;&#26377;&#8220;&#36882;&#24402;&#8221;&#30340;&#24615;&#36136;&#12290;&#22914;&#26524;&#26159;&#26641;&#25110;&#32773;&#22270;&#65292;&#27010;&#29575;&#26356;&#22823;&#12290;</li>
<li><strong>&#29366;&#24577;&#36716;&#25442;&#22270;</strong>&#65306;&#26641;&#25110;&#32773;&#22270;&#12290;</li>
<li>&#27714;&#35299;<strong>&#30446;&#26631;</strong>&#65306;&#27714;&#26368;&#30701;&#12290;</li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#24605;&#32771;&#30340;&#27493;&#39588; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#26159;&#27714;&#36335;&#24452;&#38271;&#24230;&#65292;&#36824;&#26159;&#36335;&#24452;&#26412;&#36523;&#65288;&#25110;&#21160;&#20316;&#24207;&#21015;&#65289;&#65311;</dt>
<dd><ul>
<li>&#22914;&#26524;&#26159;&#27714;&#36335;&#24452;&#38271;&#24230;&#65292;&#21017;&#29366;&#24577;&#37324;&#38754;&#35201;&#23384;&#36335;&#24452;&#38271;&#24230;</li>
<li>&#22914;&#26524;&#26159;&#27714;&#36335;&#24452;&#26412;&#36523;&#25110;&#21160;&#20316;&#24207;&#21015;
<ul>
<li>&#35201;&#29992;&#19968;&#26869;&#26641;&#23384;&#20648;&#23485;&#25628;&#36807;&#31243;&#20013;&#30340;&#36335;&#24452;</li>
<li>&#26159;&#21542;&#21487;&#20197;&#39044;&#20272;&#29366;&#24577;&#20010;&#25968;&#30340;&#19978;&#38480;&#65311;&#33021;&#22815;&#39044;&#20272;&#29366;&#24577;&#24635;&#25968;&#65292;&#21017;&#24320;&#19968;&#20010;&#22823;&#25968;&#32452;&#65292;&#29992;&#26641;&#30340;&#21452;&#20146;&#34920;&#31034;&#27861;&#65307;&#22914;&#26524;&#19981;&#33021;&#39044;&#20272;&#29366;&#24577;&#24635;&#25968;&#65292;&#21017;&#35201;&#20351;&#29992;&#19968;&#26869;&#36890;&#29992;&#30340;&#26641;&#12290;&#36825;&#19968;&#27493;&#20063;&#26159;&#31532;4&#27493;&#30340;&#24517;&#35201;&#19981;&#20805;&#20998;&#26465;&#20214;&#12290;</li>
</ul></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#22914;&#20309;&#34920;&#31034;&#29366;&#24577;&#65311; <code class="fold">@</code></dt>
<dd><p>&#21363;&#19968;&#20010;&#29366;&#24577;&#38656;&#35201;&#23384;&#20648;&#21738;&#20123;&#20123;&#24517;&#35201;&#30340;&#25968;&#25454;&#65292;&#25165;&#33021;&#22815;&#23436;&#25972;&#25552;&#20379;&#22914;&#20309;&#25193;&#23637;&#21040;&#19979;&#19968;&#27493;&#29366;&#24577;&#30340;&#25152;&#26377;&#20449;&#24687;&#12290;&#19968;&#33324;&#35760;&#24405;&#24403;&#21069;&#20301;&#32622;&#25110;&#25972;&#20307;&#23616;&#38754;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#22914;&#20309;&#25193;&#23637;&#29366;&#24577;&#65311; <code class="fold">@</code></dt>
<dd><p>&#36825;&#19968;&#27493;&#36319;&#31532; 2 &#27493;&#30456;&#20851;&#12290;&#29366;&#24577;&#37324;&#35760;&#24405;&#30340;&#25968;&#25454;&#19981;&#21516;&#65292;&#25193;&#23637;&#26041;&#27861;&#23601;&#19981;&#21516;&#12290;&#23545;&#20110;&#22266;&#23450;&#19981;&#21464;&#30340;&#25968;&#25454;&#32467;&#26500;&#65288;&#19968;&#33324;&#39064;&#30446;&#30452;&#25509;&#32473;&#20986;&#65292;&#20316;&#20026;&#36755;&#20837;&#25968;&#25454;&#65289;&#65292;&#22914;&#20108;&#21449;&#26641;&#65292;&#22270;&#31561;&#65292;&#25193;&#23637;&#26041;&#27861;&#24456;&#31616;&#21333;&#65292;&#30452;&#25509;&#24448;&#19979;&#19968;&#23618;&#36208;&#65292;&#23545;&#20110;&#38544;&#24335;&#22270;&#65292;&#35201;&#20808;&#22312;&#31532; 1 &#27493;&#37324;&#24819;&#28165;&#26970;&#29366;&#24577;&#25152;&#24102;&#30340;&#25968;&#25454;&#65292;&#24819;&#28165;&#26970;&#20102;&#36825;&#28857;&#65292;&#37027;&#22914;&#20309;&#25193;&#23637;&#23601;&#24456;&#31616;&#21333;&#20102;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#20851;&#20110;&#21028;&#37325;&#65292;&#29366;&#24577;&#26159;&#21542;&#23384;&#22312;&#23436;&#32654;&#21704;&#24076;&#26041;&#26696;&#65311;</dt>
<dd><p>&#21363;&#23558;&#29366;&#24577;&#19968;&#19968;&#26144;&#23556;&#21040;&#25972;&#25968;&#65292;&#20114;&#30456;&#20043;&#38388;&#19981;&#20250;&#20914;&#31361;&#12290;</p>
<ul>
<li>&#22914;&#26524;&#19981;&#23384;&#22312;&#65292;&#21017;&#38656;&#35201;&#20351;&#29992;&#36890;&#29992;&#30340;&#21704;&#24076;&#34920;&#65288;&#33258;&#24049;&#23454;&#29616;&#25110;&#29992;&#26631;&#20934;&#24211;&#65292;&#20363;&#22914; <code>unordered_set</code>&#65289;&#26469;&#21028;&#37325;&#65307;&#33258;&#24049;&#23454;&#29616;&#21704;&#24076;&#34920;&#30340;&#35805;&#65292;&#22914;&#26524;&#33021;&#22815;&#39044;&#20272;&#29366;&#24577;&#20010;&#25968;&#30340;&#19978;&#38480;&#65292;&#21017;&#21487;&#20197;&#24320;&#20004;&#20010;&#25968;&#32452;&#65292;head &#21644; next&#65292;&#34920;&#31034;&#21704;&#24076;&#34920;&#65292;&#21442;&#32771;&#31532; subsec:eightDigits &#33410;&#26041;&#26696; 2&#12290;</li>
<li>&#22914;&#26524;&#23384;&#22312;&#65292;&#21017;&#21487;&#20197;&#24320;&#19968;&#20010;&#22823;&#24067;&#23572;&#25968;&#32452;&#65292;&#20316;&#20026;&#21704;&#24076;&#34920;&#26469;&#21028;&#37325;&#65292;&#19988;&#27492;&#26102;&#21487;&#20197;&#31934;&#30830;&#35745;&#31639;&#20986;&#29366;&#24577;&#24635;&#25968;&#65292;&#32780;&#19981;&#20165;&#20165;&#26159;&#39044;&#20272;&#19978;&#38480;&#12290;</li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#30446;&#26631;&#29366;&#24577;&#26159;&#21542;&#24050;&#30693;&#65311; <code class="fold">@</code></dt>
<dd><p>&#22914;&#26524;&#39064;&#30446;&#24050;&#32463;&#32473;&#20986;&#20102;&#30446;&#26631;&#29366;&#24577;&#65292;&#21487;&#20197;&#24102;&#26469;&#24456;&#22823;&#20415;&#21033;&#65292;&#36825;&#26102;&#20505;&#21487;&#20197;&#20174;&#36215;&#22987;&#29366;&#24577;&#20986;&#21457;&#65292;&#27491;&#21521;&#24191;&#25628;&#65307;&#20063;&#21487;&#20197;&#20174;&#30446;&#26631;&#29366;&#24577;&#20986;&#21457;&#65292;&#36870;&#21521;&#24191;&#25628;&#65307;&#20063;&#21487;&#20197;&#21516;&#26102;&#20986;&#21457;&#65292;&#21452;&#21521;&#24191;&#25628;&#12290;</p>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#20195;&#30721;&#27169;&#26495; <code class="fold">@</code></dt>
<dd><p>&#24191;&#25628;&#38656;&#35201;&#19968;&#20010;&#38431;&#21015;&#65292;&#29992;&#20110;&#19968;&#23618;&#19968;&#23618;&#25193;&#23637;&#65292;&#19968;&#20010; hashset&#65292;&#29992;&#20110;&#21028;&#37325;&#65292;&#19968;&#26869;&#26641;&#65288;&#21482;&#27714;&#38271;&#24230;&#26102;&#19981;&#38656;&#35201;&#65289;&#65292;&#29992;&#20110;&#23384;&#20648;&#25972;&#26869;&#26641;&#12290;</p>
<p>&#23545;&#20110;&#38431;&#21015;&#65292;&#22914;&#26524;&#29992;&#32431; C&#65292;&#38656;&#35201;&#36896;&#19968;&#20010;&#38431;&#21015;&#36718;&#23376;&#65307;&#22914;&#26524;&#29992; C++&#65292;&#21487;&#20197;&#29992; queue&#65292;&#20063;&#21487;&#20197;&#25226; vector &#24403;&#20570;&#38431;&#21015;&#20351;&#29992;&#12290;&#24403;&#27714;&#38271;&#24230;&#26102;&#65292;&#26377;&#20004;&#31181;&#20570;&#27861;&#65306;</p>
<ul>
<li>&#21482;&#29992;&#19968;&#20010;&#38431;&#21015;&#65292;&#20294;&#22312;&#29366;&#24577;&#32467;&#26500;&#20307; state_t &#37324;&#22686;&#21152;&#19968;&#20010;&#25972;&#25968;&#23383;&#27573; step&#65292;&#34920;&#31034;&#36208;&#21040;&#24403;&#21069;&#29366;&#24577;&#29992;&#20102;&#22810;&#23569;&#27493;&#65292;&#24403;&#30896;&#21040;&#30446;&#26631;&#29366;&#24577;&#65292;&#30452;&#25509;&#36755;&#20986; step &#21363;&#21487;&#12290;&#36825;&#20010;&#26041;&#26696;&#65292;&#21487;&#20197;&#24456;&#26041;&#20415;&#30340;&#21464;&#25104; <code>A*</code> &#31639;&#27861;&#65292;&#25226;&#38431;&#21015;&#25442;&#25104;&#20248;&#20808;&#38431;&#21015;&#21363;&#21487;&#12290;</li>
<li>&#29992;&#20004;&#20010;&#38431;&#21015;&#65292;current, next&#65292;&#20998;&#21035;&#34920;&#31034;&#24403;&#21069;&#23618;&#27425;&#21644;&#19979;&#19968;&#23618;&#65292;&#21478;&#35774;&#19968;&#20010;&#20840;&#23616;&#25972;&#25968; level&#65292;&#34920;&#31034;&#23618;&#25968;&#65288;&#20063;&#21363;&#36335;&#24452;&#38271;&#24230;&#65289;&#65292;&#24403;&#30896;&#21040;&#30446;&#26631;&#29366;&#24577;&#65292;&#36755;&#20986; level &#21363;&#21487;&#12290;&#36825;&#20010;&#26041;&#26696;&#65292;&#29366;&#24577;&#21487;&#20197;&#23569;&#19968;&#20010;&#23383;&#27573;&#65292;&#33410;&#30465;&#20869;&#23384;&#12290;</li>
</ul>
<p>&#23545;&#20110; hashset&#65292;&#22914;&#26524;&#26377;&#23436;&#32654;&#21704;&#24076;&#26041;&#26696;&#65292;&#29992;&#24067;&#23572;&#25968;&#32452; (<code>bool visited[STATE_MAX]</code> &#25110; <code>vector&lt;bool&gt; visited(STATE_MAX, false)</code>) &#26469;&#34920;&#31034;&#65307;&#22914;&#26524;&#27809;&#26377;&#65292;&#21487;&#20197;&#29992; STL &#37324;&#30340; set &#25110; unordered_set&#12290;</p>
<p>&#23545;&#20110;&#26641;&#65292;&#22914;&#26524;&#29992; STL&#65292;&#21487;&#20197;&#29992; <code>unordered_map&lt;state_t, state_t&gt; father</code> &#34920;&#31034;&#19968;&#39063;&#26641;&#65292;&#20195;&#30721;&#38750;&#24120;&#31616;&#27905;&#12290;&#22914;&#26524;&#33021;&#22815;&#39044;&#20272;&#29366;&#24577;&#24635;&#25968;&#30340;&#19978;&#38480;&#65288;&#35774;&#20026; STATE_MAX&#65289;&#65292;&#21487;&#20197;&#29992;&#25968;&#32452;(<code>state_t nodes[STATE_MAX]</code>)&#65292;&#21363;&#26641;&#30340;&#21452;&#20146;&#34920;&#31034;&#27861;&#26469;&#34920;&#31034;&#26641;&#65292;&#25928;&#29575;&#26356;&#39640;&#65292;&#24403;&#28982;&#65292;&#38656;&#35201;&#20889;&#26356;&#22810;&#20195;&#30721;&#12290;</p>
<dl>
<dt>C++ template <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> state_t&gt;
vector&lt;state_t&gt; gen_path( <span class="dt">const</span> unordered_map&lt;state_t, state_t&gt; &amp;father,
                          <span class="dt">const</span> state_t &amp;target)
{
    vector&lt;state_t&gt; path;
    path.push_back(target);

    state_t cur = target;
    <span class="kw">while</span> (father.find(cur) != father.end()) {
        cur = father.at(cur);
        path.push_back(cur);
    }
    reverse(path.begin(), path.end());

    <span class="kw">return</span> path;
}

<span class="co">/**</span>
 * <span class="er">@</span>brief &#24191;&#25628;.
<span class="er"> * @param[in] state_t &#29366;&#24577;&#65292;&#22914;&#25972;&#25968;&#65292;&#23383;&#31526;&#20018;&#65292;&#19968;&#32500;&#25968;&#32452;&#31561;</span>
 * <span class="er">@</span>param[in] start &#36215;&#28857;
 * <span class="er">@</span>param[in] state_is_target &#21028;&#26029;&#29366;&#24577;&#26159;&#21542;&#26159;&#30446;&#26631;&#30340;&#20989;&#25968;
 * <span class="er">@</span>param[in] state_extend &#29366;&#24577;&#25193;&#23637;&#20989;&#25968;
 * <span class="er">@</span>return &#20174;&#36215;&#28857;&#21040;&#30446;&#26631;&#29366;&#24577;&#30340;&#19968;&#26465;&#26368;&#30701;&#36335;&#24452;
 */
<span class="kw">template</span>&lt;<span class="kw">typename</span> state_t&gt;
vector&lt;state_t&gt; bfs(state_t &amp;start, <span class="dt">bool</span> (*state_is_target)(<span class="dt">const</span> state_t&amp;),
        vector&lt;state_t&gt;(*state_extend)(<span class="dt">const</span> state_t&amp;,
                unordered_set&lt;string&gt; &amp;visited)) {
    queue&lt;state_t&gt; next, current; <span class="co">// &#24403;&#21069;&#23618;&#65292;&#19979;&#19968;&#23618;</span>
    unordered_set&lt;state_t&gt; visited; <span class="co">// &#21028;&#37325;</span>
    unordered_map&lt;state_t, state_t&gt; father;

    <span class="dt">int</span> level = <span class="dv">0</span>;  <span class="co">// &#23618;&#27425;</span>
    <span class="dt">bool</span> found = <span class="kw">false</span>;
    state_t target;

    current.push(start);
    visited.insert(start);
    <span class="kw">while</span> (!current.empty() &amp;&amp; !found) {
        ++level;
        <span class="kw">while</span> (!current.empty() &amp;&amp; !found) {
            <span class="dt">const</span> state_t state = current.front();
            current.pop();
            vector&lt;state_t&gt; new_states = state_extend(state, visited);
            <span class="kw">for</span> (<span class="kw">auto</span> iter = new_states.begin();
                    iter != new_states.end() &amp;&amp; ! found; ++iter) {
                <span class="dt">const</span> state_t new_state(*iter);

                <span class="kw">if</span> (state_is_target(new_state)) {
                    found = <span class="kw">true</span>; <span class="co">//&#25214;&#21040;&#20102;</span>
                    target = new_state;
                    father[new_state] = state;
                    <span class="kw">break</span>;
                }

                next.push(new_state);
                <span class="co">// visited.insert(new_state); &#24517;&#39035;&#25918;&#21040; state_extend()&#37324;</span>
                father[new_state] = state;
            }
        }
        swap(next, current); <span class="co">//!</span>!! &#20132;&#25442;&#20004;&#20010;&#38431;&#21015;
    }

    <span class="kw">if</span> (found) {
        <span class="kw">return</span> gen_path(father, target);
        <span class="co">//return level + 1;</span>
    } <span class="kw">else</span> {
        <span class="kw">return</span> vector&lt;state_t&gt;();
        <span class="co">//return 0;</span>
    }
}</code></pre></div>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>C++ snippets &#9829;&#65039; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> State {
    <span class="dt">bool</span> <span class="kw">operator</span>==( <span class="dt">const</span> State &amp;rhs ) <span class="dt">const</span> {
        <span class="kw">return</span> <span class="kw">true</span>;
    }
    <span class="dt">bool</span> <span class="kw">operator</span>&lt;( <span class="dt">const</span> State &amp;rhs ) <span class="dt">const</span> {
        <span class="kw">return</span> <span class="kw">true</span>;
    }
};

<span class="kw">namespace</span> std {
<span class="kw">template</span>&lt;&gt; <span class="kw">struct</span> hash&lt;State&gt; {
    size_t <span class="kw">operator</span>()( <span class="dt">const</span> State &amp;s ) <span class="dt">const</span> {
        <span class="kw">return</span> <span class="dv">0</span>;
    }
};
}


unordered_set&lt;State&gt; visited;
priority_queue&lt;State&gt; pq;</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>chap10. DFS <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>four coloring <code class="fold">@</code></dt>
<dd><p>&#32473;&#23450; N (N &lt;= 8) &#20010;&#28857;&#30340;&#22320;&#22270;&#65292;&#20197;&#21450;&#22320;&#22270;&#19978;&#21508;&#28857;&#30340;&#30456;&#37051;&#20851;&#31995;&#65292;&#35831;&#36755;&#20986;&#29992; 4 &#31181;&#39068;&#33394;&#23558;&#22320;&#22270;&#28034;&#33394;&#30340;&#25152;&#26377;&#26041;&#26696;&#25968;&#65288;&#35201;&#27714;&#30456;&#37051;&#20004;&#28857;&#19981;&#33021;&#28034;&#25104;&#30456;&#21516;&#30340;&#39068;&#33394;&#65289;&#12290;</p>
<p>&#25968;&#25454;&#20013; 0 &#20195;&#34920;&#19981;&#30456;&#37051;&#65292;1 &#20195;&#34920;&#30456;&#37051;&#12290;</p>
<pre><code>&#36755;&#20837;

    &#31532;&#19968;&#34892;&#19968;&#20010;&#25972;&#25968; N&#65292;&#20195;&#34920;&#22320;&#22270;&#19978;&#26377; N &#20010;&#28857;&#12290;

    &#25509;&#19979;&#26469; N &#34892;&#65292;&#27599;&#34892; N &#20010;&#25972;&#25968;&#65292;&#27599;&#20010;&#25972;&#25968;&#26159; 0 &#25110;&#32773; 1&#12290;&#31532;
    i &#34892;&#31532; j&#21015;&#30340;&#20540;&#20195;&#34920;&#20102;&#31532; i &#20010;&#28857;&#21644;&#31532; j &#20010;&#28857;&#20043;&#38388;&#26159;&#30456;&#37051;
    &#30340;&#36824;&#26159;&#19981;&#30456;&#37051;&#65292;&#30456;&#37051;&#23601;&#26159; 1&#65292;&#19981;&#30456;&#37051;&#23601;&#26159; 0&#12290;
    &#25105;&#20204;&#20445;&#35777; a[i][j] = a[j][i]&#12290;

    8
    0 0 0 1 0 0 1 0
    0 0 0 0 0 1 0 1
    0 0 0 0 0 0 1 0
    1 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 1 0 0 0 0 0 0
    1 0 1 0 0 0 0 0
    0 1 0 0 0 0 0 0

&#36755;&#20986;

    &#26579;&#33394;&#30340;&#26041;&#26696;&#25968;

    15552</code></pre>
<p>&#36825;&#26159;&#19968;&#36947;&#32463;&#20856;&#30340;&#39064;&#30446;&#12290;&#28145;&#25628;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// &#28145;&#25628;&#65292;&#32473;&#31532; cur &#20010;&#33410;&#28857;&#28034;&#33394;.</span>
<span class="dt">void</span> dfs( vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; &amp;table, vector&lt;<span class="dt">int</span>&gt; &amp;history, <span class="dt">int</span> cur, <span class="dt">int</span> N, <span class="dt">int</span> &amp;count ) {
    <span class="kw">if</span> ( cur == N ) {
        ++count;
        <span class="kw">return</span>;
    }

    <span class="kw">for</span> ( <span class="dt">int</span> c = <span class="dv">1</span>; c &lt; <span class="dv">5</span>; ++c ) {                         <span class="co">// try all possibilities</span>
                                                            <span class="co">// if okay, then go inside</span>
        <span class="dt">int</span> j;
        <span class="kw">for</span> ( j = <span class="dv">0</span>; j &lt; cur; ++j ) {
            <span class="kw">if</span> ( table[cur][j] &amp;&amp; c == history[j] ) {       <span class="co">// &#30456;&#37051;&#19988;&#21516;&#33394;</span>
                <span class="kw">break</span>;
            }
        }
        <span class="kw">if</span> ( j == cur ) {                                   <span class="co">// you can also use `ok&#39;</span>
            history[cur] = c;
            dfs( table, history, cur<span class="dv">+1</span>, N, count );
        }
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> N;
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;N );
    vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; table(N, vector&lt;<span class="dt">int</span>&gt;(N));
    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i ) {
        <span class="kw">for</span> ( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; N; ++j ) {
            scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;table[i][j] );
        }
    }

    <span class="dt">int</span> count = <span class="dv">0</span>;
    vector&lt;<span class="dt">int</span>&gt; history(N);                 <span class="co">// &#35760;&#24405;&#27599;&#20010;&#28857;&#30340;&#39068;&#33394;&#65292;&#22235;&#31181;&#39068;&#33394;&#29992;1234&#34920;&#31034;&#65292;0&#34920;&#31034;&#26410;&#26579;&#33394;</span>
    dfs( table, history, <span class="dv">0</span>, N, count );
    printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, count );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><p>all arrangements (dup)</p></li>
<li><p>eight queen (dup)</p></li>
<li><dl>
<dt>restore IP addr <code class="fold">@</code></dt>
<dd><p>&#26412;&#39064;&#26159; LeetCode Online Judge&#19978;&#30340;&#8220;Restore IP Addresses&#8221;&#12290;</p>
<p>&#32473;&#23450;&#19968;&#20010;&#21482;&#21253;&#21547;&#25968;&#23383;&#30340;&#23383;&#31526;&#20018;&#65292;&#36824;&#21407;&#20986;&#25152;&#26377;&#21512;&#27861;&#30340;IP&#22320;&#22336;&#12290;</p>
<p>&#20363;&#22914;&#65306;&#32473;&#23450; &#8220;25525511135&#8221;&#65292;&#36820;&#22238; <code>[&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</code>&#12290; (&#39034;&#24207;&#26080;&#20851;&#32039;&#35201;)</p>
<p>&#36825;&#39064;&#24456;&#26126;&#26174;&#20998;&#20026;&#22235;&#27493;&#65292;&#26377;&#23618;&#27425;&#65292;&#22240;&#27492;&#21487;&#20197;&#23581;&#35797;&#29992;&#22238;&#28335;&#27861;&#35299;&#20915;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// LeetCode, Restore IP Addresses</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    vector&lt;string&gt; restoreIpAddresses(string s) {
        vector&lt;string&gt; result;
        string ip;                                  <span class="co">// &#23384;&#25918;&#20013;&#38388;&#32467;&#26524;</span>
        dfs( s, <span class="dv">0</span>, <span class="dv">0</span>, ip, result );
        <span class="kw">return</span> result;
    }

    <span class="dt">void</span> dfs( string s, <span class="dt">int</span> start, <span class="dt">int</span> step, string ip, vector&lt;string&gt; &amp;result ) {
        <span class="kw">if</span> ( s.size() - start &gt; (<span class="dv">4</span> - step) * <span class="dv">3</span> ||
             s.size() - start &lt; (<span class="dv">4</span> - step) ) { <span class="kw">return</span>; } <span class="co">// &#38750;&#27861;&#32467;&#26524;&#65292;&#21098;&#26525;</span>

        <span class="kw">if</span> (start == s.size() &amp;&amp; step == <span class="dv">4</span>) {            <span class="co">// &#25214;&#21040;&#19968;&#20010;&#21512;&#27861;&#35299;</span>
            ip.resize(ip.size() - <span class="dv">1</span>);
            result.push_back(ip);
            <span class="kw">return</span>;
        }

        <span class="dt">int</span> num = <span class="dv">0</span>;
        <span class="kw">for</span> ( <span class="dt">int</span> i = start; i &lt; start + <span class="dv">3</span>; ++i ) {
            num = num * <span class="dv">10</span> + (s[i] - <span class="st">&#39;0&#39;</span>);
            <span class="kw">if</span>( num &lt;= <span class="dv">255</span> ) {                          <span class="co">// &#24403;&#21069;&#32467;&#28857;&#21512;&#27861;&#65292;&#21017;&#32487;&#32493;&#24448;&#19979;&#36882;&#24402;</span>
                ip += s[i];
                dfs( s, i<span class="dv">+1</span>, step<span class="dv">+1</span>, ip+<span class="st">&#39;.&#39;</span>, result );
            }
            <span class="kw">if</span> ( num == <span class="dv">0</span> ) <span class="kw">break</span>;  <span class="co">// &#19981;&#20801;&#35768;&#21069;&#32512; 0&#65292;&#20294;&#20801;&#35768;&#21333;&#20010;0</span>
        }
    }
};</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>combination sum <code class="fold">@</code></dt>
<dd><p>&#26412;&#39064;&#26159; LeetCode Online Judge &#19978;&#30340; &#8220;Combination Sum&#8221;&#12290;</p>
<p>&#32473;&#23450;&#19968;&#20010;&#25968;&#30340;&#38598;&#21512; (C) &#21644;&#19968;&#20010;&#30446;&#26631;&#25968; (T)&#65292;&#25214;&#21040; C &#20013;&#25152;&#26377;&#19981;&#37325;&#22797;&#30340;&#32452;&#21512;&#65292;&#35753;&#36825;&#20123;&#34987;&#36873;&#20986;&#26469;&#30340;&#25968;&#21152;&#36215;&#26469;&#31561;&#20110; T&#12290;</p>
<p>&#27599;&#19968;&#20010;&#25968;&#21487;&#20197;&#34987;&#36873;&#26080;&#25968;&#27425;&#12290;</p>
<p>&#27880;&#24847;&#65306;</p>
<ul>
<li>&#25152;&#26377;&#30340;&#25968;&#65288;&#21253;&#25324;&#30446;&#26631;&#65289;&#37117;&#26159;&#27491;&#25972;&#25968;</li>
<li>&#19968;&#20010;&#32452;&#21512;&#65288;a<sub>1</sub>, a<sub>2</sub>, &#8230;, a<sub>k</sub>&#65289;&#20013;&#30340;&#20803;&#32032;&#24517;&#39035;&#20197;&#38750;&#36882;&#20943;&#39034;&#24207;&#25490;&#21015;</li>
<li>&#19968;&#20010;&#32452;&#21512;&#19981;&#33021;&#19982;&#21478;&#19968;&#20010;&#32452;&#21512;&#37325;&#22797;</li>
</ul>
<p>&#20363;&#22914;&#65292;&#32473;&#23450;&#19968;&#32452;&#25968; 2,3,6,7, &#21644;&#30446;&#26631; 7&#65292;&#21017;&#31572;&#26696;&#26159;</p>
<pre><code>[7]
[2, 2, 3]</code></pre>
<p>&#36825;&#39064;&#27809;&#26377;&#22266;&#23450;&#30340;&#27493;&#39588;&#25968;&#65292;&#20294;&#26159;&#27493;&#39588;&#20063;&#26159;&#26377;&#38480;&#30340;&#65292;&#22240;&#27492;&#21487;&#20197;&#23581;&#35797;&#29992;&#22238;&#28335;&#27861;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; combinationSum(vector&lt;<span class="dt">int</span>&gt; &amp;nums, <span class="dt">int</span> target) {
        sort(nums.begin(), nums.end());
        vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; result;                <span class="co">// &#26368;&#32456;&#32467;&#26524;</span>
        vector&lt;<span class="dt">int</span>&gt; cur;                            <span class="co">// &#20013;&#38388;&#32467;&#26524;</span>
        dfs(nums, target, <span class="dv">0</span>, cur, result);
        <span class="kw">return</span> result;
    }

<span class="kw">private</span>:
    <span class="dt">void</span> dfs( vector&lt;<span class="dt">int</span>&gt; &amp;nums, <span class="dt">int</span> gap, <span class="dt">int</span> level, vector&lt;<span class="dt">int</span>&gt; &amp;cur, vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; &amp;result ) {
        <span class="kw">if</span>( gap == <span class="dv">0</span> ) {                            <span class="co">// &#25214;&#21040;&#19968;&#20010;&#21512;&#27861;&#35299;</span>
            result.push_back( cur );
            <span class="kw">return</span>;
        }
        <span class="dt">int</span> n = nums.size();
        <span class="kw">for</span>( <span class="dt">int</span> i = level; i &lt; n; ++i ) {          <span class="co">// &#25193;&#23637;&#29366;&#24577;</span>
            <span class="kw">if</span>( gap &lt; nums[i] ) { <span class="kw">return</span>; }         <span class="co">// &#21098;&#26525;</span>
            cur.push_back( nums[i] );               <span class="co">// &#25191;&#34892;&#25193;&#23637;&#21160;&#20316;</span>
            dfs(nums, gap - nums[i], i, cur, result);
            cur.pop_back();                         <span class="co">// &#25764;&#38144;&#21160;&#20316;</span>
        }
    }
};</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>combination sum ii <code class="fold">@</code></dt>
<dd><p>&#26412;&#39064;&#19982;&#19978;&#19968;&#39064;&#21807;&#19968;&#19981;&#21516;&#30340;&#26159;&#65292;&#27599;&#20010;&#25968;&#21482;&#33021;&#20351;&#29992;&#19968;&#27425;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// LeetCode, Combination Sum II</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; combinationSum2( vector&lt;<span class="dt">int</span>&gt; &amp;nums, <span class="dt">int</span> target ) {
        sort( nums.begin(), nums.end() );
        vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; result;
        vector&lt;<span class="dt">int</span>&gt; cur;
        dfs( nums, target, <span class="dv">0</span>, cur, result );
        <span class="kw">return</span> result;
    }
<span class="kw">private</span>:
    <span class="co">// &#20351;&#29992; nums[index, nums.size()) &#20043;&#38388;&#30340;&#20803;&#32032;&#65292;&#33021;&#25214;&#21040;&#30340;&#25152;&#26377;&#21487;&#34892;&#35299;</span>
    <span class="dt">static</span> <span class="dt">void</span> dfs( vector&lt;<span class="dt">int</span>&gt; &amp;nums, <span class="dt">int</span> gap, <span class="dt">int</span> index, vector&lt;<span class="dt">int</span>&gt; &amp;cur, vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; &amp;result ) {
        <span class="kw">if</span>( gap == <span class="dv">0</span> ) {                            <span class="co">//  &#25214;&#21040;&#19968;&#20010;&#21512;&#27861;&#35299;</span>
            result.push_back(cur);
            <span class="kw">return</span>;
        }
        <span class="dt">int</span> previous = nums[<span class="dv">0</span>]<span class="dv">-1</span>;                   <span class="co">// so will not dup</span>
        <span class="dt">int</span> n = nums.size();
        <span class="kw">for</span>( <span class="dt">int</span> i = index; i &lt; n; ++i ) {
            <span class="co">// &#22914;&#26524;&#19978;&#19968;&#36718;&#24490;&#29615;&#36873; nums[i]&#65292;&#21017;&#26412;&#27425;&#24490;&#29615;&#23601;&#19981;&#33021;&#20877;&#36873; nums[i]&#65292;</span>
            <span class="co">// &#30830;&#20445;nums[i] &#26368;&#22810;&#21482;&#29992;&#19968;&#27425;</span>
            <span class="kw">if</span>( previous == nums[i] ) { <span class="kw">continue</span>; }
            <span class="kw">if</span>( gap &lt; nums[i] ) { <span class="kw">return</span>; }         <span class="co">// &#21098;&#26525;</span>
            previous = nums[i];
            cur.push_back( nums[i] );
            dfs( nums, gap - nums[i], i + <span class="dv">1</span>, cur, result);
            cur.pop_back();
        }
    }
};</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>conclusion &#9829;&#65039; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#36755;&#20837;&#25968;&#25454;</dt>
<dd><p>&#22914;&#26524;&#26159;&#36882;&#24402;&#25968;&#25454;&#32467;&#26500;&#65292;&#22914;&#21333;&#38142;&#34920;&#65292;&#20108;&#21449;&#26641;&#65292;&#38598;&#21512;&#65292;&#21017;&#30334;&#20998;&#20043;&#30334;&#21487;&#20197;&#29992;&#28145;&#25628;&#65307;&#22914;&#26524;&#26159;&#38750;&#36882;&#24402;&#25968;&#25454;&#32467;&#26500;&#65292;&#22914;&#19968;&#32500;&#25968;&#32452;&#65292;&#20108;&#32500;&#25968;&#32452;&#65292;&#23383;&#31526;&#20018;&#65292;&#22270;&#65292;&#21017;&#27010;&#29575;&#23567;&#19968;&#20123;&#12290;</p>
</dd>
<dt>&#29366;&#24577;&#36716;&#25442;&#22270;</dt>
<dd><p>&#26641;&#25110;&#32773;&#22270;&#12290;</p>
</dd>
<dt>&#27714;&#35299;&#30446;&#26631;</dt>
<dd><p>&#24517;&#39035;&#35201;&#36208;&#21040;&#26368;&#28145;&#65288;&#20363;&#22914;&#23545;&#20110;&#26641;&#65292;&#24517;&#39035;&#35201;&#36208;&#21040;&#21494;&#23376;&#33410;&#28857;&#65289;&#25165;&#33021;&#24471;&#21040;&#19968;&#20010;&#35299;&#65292;&#36825;&#31181;&#24773;&#20917;&#36866;&#21512;&#29992;&#28145;&#25628;&#12290;</p>
</dd>
<dt>&#24605;&#32771;&#30340;&#27493;&#39588;</dt>
<dd><ul>
<li><p>&#26159;&#27714;&#36335;&#24452;&#26465;&#25968;&#65292;&#36824;&#26159;&#36335;&#24452;&#26412;&#36523;&#65288;&#25110;&#21160;&#20316;&#24207;&#21015;&#65289;&#65311;&#28145;&#25628;&#26368;&#24120;&#35265;&#30340;&#19977;&#20010;&#38382;&#39064;&#65292;<strong>&#27714;&#21487;&#34892;&#35299;&#30340;&#24635;&#25968;</strong>&#65292;<strong>&#27714;&#19968;&#20010;&#21487;&#34892;&#35299;</strong>&#65292;<strong>&#27714;&#25152;&#26377;&#21487;&#34892;&#35299;</strong>&#12290;</p>
<ul>
<li><p>&#22914;&#26524;&#26159;&#27714;&#36335;&#24452;&#26412;&#36523;&#65292;&#21017;&#35201;&#29992;&#19968;&#20010;&#25968;&#32452; <code>path[]</code> &#23384;&#20648;&#36335;&#24452;&#12290;<strong>&#36319;&#23485;&#25628;&#19981;&#21516;&#65292;&#23485;&#25628;&#34429;&#28982;&#26368;&#32456;&#27714;&#30340;&#20063;&#26159;&#19968;&#26465;&#36335;&#24452;&#65292;&#20294;&#26159;&#38656;&#35201;&#23384;&#20648;&#25193;&#23637;&#36807;&#31243;&#20013;&#30340;&#25152;&#26377;&#36335;&#24452;&#65292;&#22312;&#27809;&#25214;&#21040;&#31572;&#26696;&#20043;&#21069;&#25152;&#26377;&#36335;&#24452;&#37117;&#19981;&#33021;&#25918;&#24323;&#65307;&#32780;&#28145;&#25628;&#65292;&#22312;&#25628;&#32034;&#36807;&#31243;&#20013;&#22987;&#32456;&#21482;&#26377;&#19968;&#26465;&#36335;&#24452;&#65292;&#22240;&#27492;&#29992;&#19968;&#20010;&#25968;&#32452;&#23601;&#36275;&#22815;&#20102;&#12290;</strong></p></li>
<li><p>&#22914;&#26524;&#26159;&#36335;&#24452;&#26465;&#25968;&#65292;&#21017;&#19981;&#38656;&#35201;&#23384;&#20648;&#36335;&#24452;&#12290;</p></li>
</ul></li>
<li><p>&#21482;&#35201;&#27714;&#19968;&#20010;&#35299;&#65292;&#36824;&#26159;&#35201;&#27714;&#25152;&#26377;&#35299;&#65311;&#22914;&#26524;&#21482;&#35201;&#27714;&#19968;&#20010;&#35299;&#65292;&#37027;&#25214;&#21040;&#19968;&#20010;&#23601;&#21487;&#20197;&#36820;&#22238;&#65307;&#22914;&#26524;&#35201;&#27714;&#25152;&#26377;&#35299;&#65292;&#25214;&#21040;&#20102;&#19968;&#20010;&#21518;&#65292;&#36824;&#35201;&#32487;&#32493;&#25193;&#23637;&#65292;&#30452;&#21040;&#36941;&#21382;&#23436;&#12290;&#24191;&#25628;&#19968;&#33324;&#21482;&#35201;&#27714;&#19968;&#20010;&#35299;&#65292;&#22240;&#32780;&#19981;&#38656;&#35201;&#32771;&#34385;&#36825;&#20010;&#38382;&#39064;&#65288;&#24191;&#25628;&#24403;&#28982;&#20063;&#21487;&#20197;&#27714;&#25152;&#26377;&#35299;&#65292;&#36825;&#26102;&#38656;&#35201;&#25193;&#23637;&#21040;&#25152;&#26377;&#21494;&#23376;&#33410;&#28857;&#65292;&#30456;&#24403;&#20110;&#22312;&#20869;&#23384;&#20013;&#23384;&#20648;&#25972;&#20010;&#29366;&#24577;&#36716;&#25442;&#22270;&#65292;&#38750;&#24120;&#21344;&#20869;&#23384;&#65292;&#22240;&#27492;&#24191;&#25628;&#19981;&#36866;&#21512;&#35299;&#36825;&#31867;&#38382;&#39064;&#65289;&#12290;</p></li>
<li><p>&#22914;&#20309;&#34920;&#31034;&#29366;&#24577;&#65311;&#21363;&#19968;&#20010;&#29366;&#24577;&#38656;&#35201;&#23384;&#20648;&#21738;&#20123;&#20123;&#24517;&#35201;&#30340;&#25968;&#25454;&#65292;&#25165;&#33021;&#22815;&#23436;&#25972;&#25552;&#20379;&#22914;&#20309;&#25193;&#23637;&#21040;&#19979;&#19968;&#27493;&#29366;&#24577;&#30340;&#25152;&#26377;&#20449;&#24687;&#12290;&#36319;&#24191;&#25628;&#19981;&#21516;&#65292;&#28145;&#25628;&#30340;&#24815;&#29992;&#20889;&#27861;&#65292;&#19981;&#26159;&#25226;&#25968;&#25454;&#35760;&#24405;&#22312;&#29366;&#24577; struct &#37324;&#65292;&#32780;&#26159;&#28155;&#21152;&#20989;&#25968;&#21442;&#25968;&#65288;&#26377;&#26102;&#20026;&#20102;&#33410;&#30465;&#36882;&#24402;&#22534;&#26632;&#65292;&#29992;&#20840;&#23616;&#21464;&#37327;&#65289;&#65292;struct &#37324;&#30340;&#23383;&#27573;&#19982;&#20989;&#25968;&#21442;&#25968;&#19968;&#19968;&#23545;&#24212;&#12290;</p></li>
<li><p>&#22914;&#20309;&#25193;&#23637;&#29366;&#24577;&#65311;&#36825;&#19968;&#27493;&#36319;&#19978;&#19968;&#27493;&#30456;&#20851;&#12290;&#29366;&#24577;&#37324;&#35760;&#24405;&#30340;&#25968;&#25454;&#19981;&#21516;&#65292;&#25193;&#23637;&#26041;&#27861;&#23601;&#19981;&#21516;&#12290;&#23545;&#20110;&#22266;&#23450;&#19981;&#21464;&#30340;&#25968;&#25454;&#32467;&#26500;&#65288;&#19968;&#33324;&#39064;&#30446;&#30452;&#25509;&#32473;&#20986;&#65292;&#20316;&#20026;&#36755;&#20837;&#25968;&#25454;&#65289;&#65292;&#22914;&#20108;&#21449;&#26641;&#65292;&#22270;&#31561;&#65292;&#25193;&#23637;&#26041;&#27861;&#24456;&#31616;&#21333;&#65292;&#30452;&#25509;&#24448;&#19979;&#19968;&#23618;&#36208;&#65292;&#23545;&#20110;&#38544;&#24335;&#22270;&#65292;&#35201;&#20808;&#22312;&#31532;1&#27493;&#37324;&#24819;&#28165;&#26970;&#29366;&#24577;&#25152;&#24102;&#30340;&#25968;&#25454;&#65292;&#24819;&#28165;&#26970;&#20102;&#36825;&#28857;&#65292;&#37027;&#22914;&#20309;&#25193;&#23637;&#23601;&#24456;&#31616;&#21333;&#20102;&#12290;</p></li>
</ul>
</dd>
</dl>
<ul>
<li><dl>
<dt>&#20851;&#20110;&#21028;&#37325;</dt>
<dd><ul>
<li><p>&#22914;&#26524;&#29366;&#24577;&#36716;&#25442;&#22270;&#26159;&#19968;&#26869;&#26641;&#65292;&#21017;&#19981;&#38656;&#35201;&#21028;&#37325;&#65292;&#22240;&#20026;&#22312;&#36941;&#21382;&#36807;&#31243;&#20013;&#19981;&#21487;&#33021;&#37325;&#22797;&#12290;</p></li>
<li><p>&#22914;&#26524;&#29366;&#24577;&#36716;&#25442;&#22270;&#26159;&#19968;&#20010;&#22270;&#65292;&#21017;&#38656;&#35201;&#21028;&#37325;&#65292;&#26041;&#27861;&#36319;&#24191;&#25628;&#30456;&#21516;&#65292;&#35265;&#31532; bfs-template &#33410;&#12290;&#36825;&#37324;&#36319;&#31532; 8 &#27493;&#20013;&#30340;&#21152;&#32531;&#23384;&#26159;&#30456;&#21516;&#30340;&#65292;&#22914;&#26524;&#26377;&#37325;&#21472;&#23376;&#38382;&#39064;&#65292;&#21017;&#38656;&#35201;&#21028;&#37325;&#65292;&#27492;&#26102;&#21152;&#32531;&#23384;&#33258;&#28982;&#20063;&#26159;&#26377;&#25928;&#26524;&#30340;&#12290;</p></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#32456;&#27490;&#26465;&#20214;&#26159;&#20160;&#20040;&#65311;</dt>
<dd><p>&#32456;&#27490;&#26465;&#20214;&#26159;&#25351;&#21040;&#20102;&#19981;&#33021;&#25193;&#23637;&#30340;&#26411;&#31471;&#33410;&#28857;&#12290;&#23545;&#20110;&#26641;&#65292;&#26159;&#21494;&#23376;&#33410;&#28857;&#65292;&#23545;&#20110;&#22270;&#25110;&#38544;&#24335;&#22270;&#65292;&#26159;&#20986;&#24230;&#20026; 0 &#30340;&#33410;&#28857;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#25910;&#25947;&#26465;&#20214;&#26159;&#20160;&#20040;&#65311;</dt>
<dd><p>&#25910;&#25947;&#26465;&#20214;&#26159;&#25351;&#25214;&#21040;&#20102;&#19968;&#20010;&#21512;&#27861;&#35299;&#30340;&#26102;&#21051;&#12290;&#22914;&#26524;&#26159;&#27491;&#21521;&#28145;&#25628;&#65288;&#29238;&#29366;&#24577;&#22788;&#29702;&#23436;&#20102;&#25165;&#36827;&#34892;&#36882;&#24402;&#65292;&#21363;&#29238;&#29366;&#24577;&#19981;&#20381;&#36182;&#23376;&#29366;&#24577;&#65292;&#36882;&#24402;&#35821;&#21477;&#19968;&#23450;&#26159;&#22312;&#26368;&#21518;&#65292;&#23614;&#36882;&#24402;&#65289;&#65292;&#21017;&#26159;&#25351;&#26159;&#21542;&#36798;&#21040;&#30446;&#26631;&#29366;&#24577;&#65307;&#22914;&#26524;&#26159;&#36870;&#21521;&#28145;&#25628;&#65288;&#22788;&#29702;&#29238;&#29366;&#24577;&#26102;&#38656;&#35201;&#20808;&#30693;&#36947;&#23376;&#29366;&#24577;&#30340;&#32467;&#26524;&#65292;&#27492;&#26102;&#36882;&#24402;&#35821;&#21477;&#19981;&#22312;&#26368;&#21518;&#65289;&#65292;&#21017;&#26159;&#25351;&#26159;&#21542;&#21040;&#36798;&#21021;&#22987;&#29366;&#24577;&#12290;</p>
</dd>
</dl></li>
</ul>
<p>&#30001;&#20110;&#24456;&#22810;&#26102;&#20505;&#32456;&#27490;&#26465;&#20214;&#21644;&#25910;&#25947;&#26465;&#20214;&#26159;&#26159;&#21512;&#20108;&#20026;&#19968;&#30340;&#65292;&#22240;&#27492;&#24456;&#22810;&#20154;&#19981;&#21306;&#20998;&#36825;&#20004;&#31181;&#26465;&#20214;&#12290;&#20180;&#32454;&#21306;&#20998;&#36825;&#20004;&#31181;&#26465;&#20214;&#65292;&#36824;&#26159;&#24456;&#26377;&#24517;&#35201;&#30340;&#12290;</p>
<p>&#20026;&#20102;&#21028;&#26029;&#26159;&#21542;&#21040;&#20102;&#25910;&#25947;&#26465;&#20214;&#65292;&#35201;&#22312;&#20989;&#25968;&#25509;&#21475;&#37324;&#29992;&#19968;&#20010;&#21442;&#25968;&#35760;&#24405;&#24403;&#21069;&#30340;&#20301;&#32622;&#65288;&#25110;&#36317;&#31163;&#30446;&#26631;&#36824;&#26377;&#22810;&#36828;&#65289;&#12290;&#22914;&#26524;&#26159;&#27714;&#19968;&#20010;&#35299;&#65292;&#30452;&#25509;&#36820;&#22238;&#36825;&#20010;&#35299;&#65307;&#22914;&#26524;&#26159;&#27714;&#25152;&#26377;&#35299;&#65292;&#35201;&#22312;&#36825;&#37324;&#25910;&#38598;&#35299;&#65292;&#21363;&#25226;&#31532;&#19968;&#27493;&#20013;&#34920;&#31034;&#36335;&#24452;&#30340;&#25968;&#32452; <code>path[]</code> &#22797;&#21046;&#21040;&#35299;&#38598;&#21512;&#37324;&#12290;}</p>
<ul>
<li><dl>
<dt>&#22914;&#20309;&#21152;&#36895;&#65311;</dt>
<dd><ul>
<li><p>&#21098;&#26525;&#12290;&#28145;&#25628;&#19968;&#23450;&#35201;&#22909;&#22909;&#32771;&#34385;&#24590;&#20040;&#21098;&#26525;&#65292;&#25104;&#26412;&#23567;&#25910;&#30410;&#22823;&#65292;&#21152;&#20960;&#34892;&#20195;&#30721;&#65292;&#23601;&#33021;&#22823;&#22823;&#21152;&#36895;&#12290;&#36825;&#37324;&#27809;&#26377;&#36890;&#29992;&#26041;&#27861;&#65292;&#21482;&#33021;&#20855;&#20307;&#38382;&#39064;&#20855;&#20307;&#20998;&#26512;&#65292;&#35201;&#20805;&#20998;&#35266;&#23519;&#65292;&#20805;&#20998;&#21033;&#29992;&#21508;&#31181;&#20449;&#24687;&#26469;&#21098;&#26525;&#65292;&#22312;&#20013;&#38388;&#33410;&#28857;&#25552;&#21069;&#36820;&#22238;&#12290;</p></li>
<li><p>&#32531;&#23384;&#12290;&#22914;&#26524;&#23376;&#38382;&#39064;&#30340;&#35299;&#20250;&#34987;&#37325;&#22797;&#21033;&#29992;&#65292;&#21487;&#20197;&#32771;&#34385;&#20351;&#29992;&#32531;&#23384;&#12290;</p>
<ul>
<li><p>&#21069;&#25552;&#26465;&#20214;&#65306;&#23376;&#38382;&#39064;&#30340;&#35299;&#20250;&#34987;&#37325;&#22797;&#21033;&#29992;&#65292;&#21363;&#23376;&#38382;&#39064;&#20043;&#38388;&#30340;&#20381;&#36182;&#20851;&#31995;&#26159;&#26377;&#21521;&#26080;&#29615;&#22270; (DAG)&#12290;&#22914;&#26524;&#20381;&#36182;&#20851;&#31995;&#26159;&#26641;&#29366;&#30340;&#65288;&#20363;&#22914;&#26641;&#65292;&#21333;&#38142;&#34920;&#65289;&#65292;&#27809;&#24517;&#35201;&#21152;&#32531;&#23384;&#65292;&#22240;&#20026;&#23376;&#38382;&#39064;&#21482;&#20250;&#19968;&#23618;&#23618;&#24448;&#19979;&#65292;&#29992;&#19968;&#27425;&#23601;&#20877;&#20063;&#19981;&#20250;&#29992;&#21040;&#65292;&#21152;&#20102;&#32531;&#23384;&#20063;&#27809;&#20160;&#20040;&#21152;&#36895;&#25928;&#26524;&#12290;</p></li>
<li><p>&#20855;&#20307;&#23454;&#29616;&#65306;&#21487;&#20197;&#29992;&#25968;&#32452;&#25110; HashMap&#12290;&#32500;&#24230;&#31616;&#21333;&#30340;&#65292;&#29992;&#25968;&#32452;&#65307;&#32500;&#24230;&#22797;&#26434;&#30340;&#65292;&#29992; HashMap&#65292;C++ &#26377; <code>map</code>&#65292;C++ 11 &#20197;&#21518;&#26377; <code>unordered_map</code>&#65292;&#27604; <code>map</code> &#24555;&#12290;</p></li>
</ul></li>
</ul>
</dd>
</dl></li>
</ul>
<p>&#25343;&#21040;&#19968;&#20010;&#39064;&#30446;&#65292;&#24403;&#24863;&#35273;&#23427;&#36866;&#21512;&#29992;&#28145;&#25628;&#35299;&#20915;&#26102;&#65292;&#22312;&#24515;&#37324;&#38754;&#25226;&#19978;&#38754; 8 &#20010;&#38382;&#39064;&#40664;&#40664;&#22238;&#31572;&#19968;&#36941;&#65292;&#20195;&#30721;&#22522;&#26412;&#19978;&#23601;&#33021;&#20889;&#20986;&#26469;&#20102;&#12290;&#23545;&#20110;&#26641;&#65292;&#19981;&#38656;&#35201;&#22238;&#31572;&#31532; 5 &#21644;&#31532; 8 &#20010;&#38382;&#39064;&#12290;&#22914;&#26524;&#35835;&#32773;&#23545;&#19978;&#38754;&#30340;&#32463;&#39564;&#24635;&#32467;&#30475;&#19981;&#25026;&#25110;&#24863;&#35273;&#8220;&#19981;&#23454;&#29992;&#8221;&#65292;&#24456;&#27491;&#24120;&#65292;&#22240;&#20026;&#36825;&#20123;&#32463;&#39564;&#24635;&#32467;&#26159;&#31508;&#32773;&#20570;&#20102;&#24456;&#22810;&#28145;&#25628;&#39064;&#21518;&#24635;&#32467;&#20986;&#26469;&#30340;&#65292;&#20174;&#24605;&#32500;&#30340;&#21457;&#23637;&#36807;&#31243;&#30475;&#65292;&#8220;&#32463;&#39564;&#24635;&#32467;&#8221;&#35201;&#26202;&#20110;&#24863;&#24615;&#35748;&#35782;&#65292;&#25152;&#20197;&#36825;&#26102;&#20505;&#24314;&#35758;&#35835;&#32773;&#20808;&#20570;&#20570;&#21518;&#38754;&#30340;&#39064;&#30446;&#65292;&#31215;&#32047;&#19968;&#23450;&#30340;&#24863;&#24615;&#35748;&#35782;&#21518;&#65292;&#22312;&#22238;&#36807;&#22836;&#26469;&#30475;&#36825;&#19968;&#33410;&#30340;&#24635;&#32467;&#65292;&#30456;&#20449;&#20250;&#21644;&#31508;&#32773;&#26377;&#20849;&#40483;&#12290;</p>
<dl>
<dt>&#20195;&#30721;&#27169;&#26495; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//  @param[in] input &#36755;&#20837;&#25968;&#25454;&#25351;&#38024;</span>
<span class="co">//  @param[inout] cur or gap &#26631;&#35760;&#24403;&#21069;&#20301;&#32622;&#25110;&#36317;&#31163;&#30446;&#26631;&#30340;&#36317;&#31163;</span>
<span class="co">//  @param[out] path &#24403;&#21069;&#36335;&#24452;&#65292;&#20063;&#26159;&#20013;&#38388;&#32467;&#26524;</span>
<span class="co">//  @param[out] result &#23384;&#25918;&#26368;&#32456;&#32467;&#26524;</span>
<span class="co">//  @return &#36335;&#24452;&#38271;&#24230;&#65292;&#22914;&#26524;&#26159;&#27714;&#36335;&#24452;&#26412;&#36523;&#65292;&#21017;&#19981;&#38656;&#35201;&#36820;&#22238;&#38271;&#24230;</span>
<span class="co">//</span>
<span class="dt">void</span> dfs(type *input, type *path, <span class="dt">int</span> cur <span class="kw">or</span> gap, type *result) {
    <span class="kw">if</span> (&#25968;&#25454;&#38750;&#27861;) <span class="kw">return</span> <span class="dv">0</span>;   <span class="co">// &#32456;&#27490;&#26465;&#20214;</span>
    <span class="kw">if</span> (cur == input.size( <span class="kw">or</span> gap == <span class="dv">0</span>)) { <span class="co">// &#25910;&#25947;&#26465;&#20214;</span>
        &#23558;path&#25918;&#20837;result
    }

    <span class="kw">if</span> (&#21487;&#20197;&#21098;&#26525;) <span class="kw">return</span>;

    <span class="kw">for</span>(...) { <span class="co">// &#25191;&#34892;&#25152;&#26377;&#21487;&#33021;&#30340;&#25193;&#23637;&#21160;&#20316;</span>
        &#25191;&#34892;&#21160;&#20316;&#65292;&#20462;&#25913;path
        dfs(input, step + <span class="dv">1</span> <span class="kw">or</span> gap--, result);
        &#24674;&#22797;path
    }
}</code></pre></div>
</dd>
<dt>&#28145;&#25628;&#19982;&#22238;&#28335;&#27861;&#30340;&#21306;&#21035;</dt>
<dd><ul>
<li><p><strong>&#22238;&#28335;&#27861; = &#28145;&#25628; + &#21098;&#26525;</strong>&#12290;&#19968;&#33324;&#22823;&#23478;&#29992;&#28145;&#25628;&#26102;&#65292;&#25110;&#22810;&#25110;&#23569;&#20250;&#21098;&#26525;&#65292;&#22240;&#27492;&#28145;&#25628;&#19982;&#22238;&#28335;&#27861;&#27809;&#26377;&#20160;&#20040;&#19981;&#21516;&#65292;&#21487;&#20197;&#22312;&#23427;&#20204;&#20043;&#38388;&#30011;&#19978;&#19968;&#20010;&#31561;&#21495;&#12290;&#26412;&#20070;&#21516;&#26102;&#20351;&#29992;&#28145;&#25628;&#21644;&#22238;&#28335;&#27861;&#20004;&#20010;&#26415;&#35821;&#65292;&#20294;&#35835;&#32773;&#21487;&#20197;&#35748;&#20026;&#20108;&#32773;&#31561;&#20215;&#12290;</p></li>
<li><p>&#28145;&#25628;&#19968;&#33324;&#29992;&#36882;&#24402; (recursion) &#26469;&#23454;&#29616;&#65292;&#36825;&#26679;&#27604;&#36739;&#31616;&#27905;&#12290;</p></li>
<li><p>&#28145;&#25628;&#33021;&#22815;&#22312;&#20505;&#36873;&#31572;&#26696;&#29983;&#25104;&#21040;&#19968;&#21322;&#26102;&#65292;&#23601;&#36827;&#34892;&#21028;&#26029;&#65292;&#25243;&#24323;&#19981;&#28385;&#36275;&#35201;&#27714;&#30340;&#31572;&#26696;&#65292;&#25152;&#20197;&#28145;&#25628;&#27604;&#26292;&#21147;&#25628;&#32034;&#27861;&#35201;&#24555;&#12290;</p></li>
</ul>
</dd>
<dt>&#28145;&#25628;&#19982;&#36882;&#24402;&#30340;&#21306;&#21035;</dt>
<dd><ul>
<li><p>&#28145;&#25628;&#32463;&#24120;&#29992;&#36882;&#24402; (recursion) &#26469;&#23454;&#29616;&#65292;&#20108;&#32773;&#24120;&#24120;&#21516;&#26102;&#20986;&#29616;&#65292;&#23548;&#33268;&#24456;&#22810;&#20154;&#35823;&#20197;&#20026;&#20182;&#20457;&#26159;&#19968;&#20010;&#19996;&#35199;&#12290;</p></li>
<li><p>&#28145;&#25628;&#65292;&#26159;&#36923;&#36753;&#24847;&#20041;&#19978;&#30340;&#31639;&#27861;&#65292;&#36882;&#24402;&#65292;&#26159;&#19968;&#31181;&#29289;&#29702;&#24847;&#20041;&#19978;&#30340;&#23454;&#29616;&#65292;&#23427;&#21644;&#36845;&#20195; (iteration) &#26159;&#23545;&#24212;&#30340;&#12290;&#28145;&#25628;&#65292;&#21487;&#20197;&#29992;&#36882;&#24402;&#26469;&#23454;&#29616;&#65292;&#20063;&#21487;&#20197;&#29992;&#26632;&#26469;&#23454;&#29616;&#65307;&#32780;&#36882;&#24402;&#65292;&#19968;&#33324;&#24635;&#26159;&#29992;&#26469;&#23454;&#29616;&#28145;&#25628;&#12290;&#21487;&#20197;&#35828;&#65292;<strong>&#36882;&#24402;&#19968;&#23450;&#26159;&#28145;&#25628;&#65292;&#28145;&#25628;&#19981;&#19968;&#23450;&#29992;&#36882;&#24402;</strong>&#12290;</p></li>
<li><p>&#36882;&#24402;&#26377;&#20004;&#31181;&#21152;&#36895;&#31574;&#30053;&#65292;&#19968;&#31181;&#26159;<strong>&#21098;&#26525; (prunning)</strong>&#65292;&#23545;&#20013;&#38388;&#32467;&#26524;&#36827;&#34892;&#21028;&#26029;&#65292;&#25552;&#21069;&#36820;&#22238;&#65307;&#19968;&#31181;&#26159;<strong>&#21152;&#32531;&#23384;</strong>&#65288;&#23601;&#21464;&#25104;&#20102; memoization&#65292;&#22791;&#24536;&#24405;&#27861;&#65289;&#65292;&#32531;&#23384;&#20013;&#38388;&#32467;&#26524;&#65292;&#38450;&#27490;&#37325;&#22797;&#35745;&#31639;&#65292;&#29992;&#31354;&#38388;&#25442;&#26102;&#38388;&#12290;</p></li>
<li><p>&#20854;&#23454;&#65292;&#36882;&#24402; + &#32531;&#23384;&#65292;&#23601;&#26159;&#19968;&#31181; memorization &#12290;&#25152;&#35859;memorization&#65288;&#22791;&#24536;&#24405;&#27861;&#65289;&#65292;&#23601;&#26159; <strong>&#8220;top-down with cache&#8221;&#65288;&#33258;&#39030;&#21521;&#19979; + &#32531;&#23384;&#65289;</strong>&#65292;&#23427;&#26159; Donald Michie &#22312; 1968 &#24180;&#21019;&#36896;&#30340;&#26415;&#35821;&#65292;&#34920;&#31034;&#19968;&#31181;&#20248;&#21270;&#25216;&#26415;&#65292;&#22312; top-down &#24418;&#24335;&#30340;&#31243;&#24207;&#20013;&#65292;&#20351;&#29992;&#32531;&#23384;&#26469;&#36991;&#20813;&#37325;&#22797;&#35745;&#31639;&#65292;&#20174;&#32780;&#36798;&#21040;&#21152;&#36895;&#30340;&#30446;&#30340;&#12290;</p></li>
<li><p>memorization &#19981;&#19968;&#23450;&#29992;&#36882;&#24402;&#65292;&#23601;&#20687;&#28145;&#25628;&#19981;&#19968;&#23450;&#29992;&#36882;&#24402;&#19968;&#26679;&#65292;&#21487;&#20197;&#22312;&#36845;&#20195; (iterative) &#20013;&#20351;&#29992; memorization &#12290;&#36882;&#24402;&#20063;&#19981;&#19968;&#23450;&#29992; memorization&#65292;&#21487;&#20197;&#29992; memorization &#26469;&#21152;&#36895;&#65292;&#20294;&#19981;&#26159;&#24517;&#39035;&#30340;&#12290;&#21482;&#26377;&#24403;&#36882;&#24402;&#20351;&#29992;&#20102;&#32531;&#23384;&#65292;&#23427;&#25165;&#26159; memorization &#12290;</p></li>
</ul>
</dd>
</dl>
<blockquote>
<p><strong>&#26082;&#28982;&#36882;&#24402;&#19968;&#23450;&#26159;&#28145;&#25628;&#65292;&#20026;&#20160;&#20040;&#24456;&#22810;&#20070;&#31821;&#37117;&#21516;&#26102;&#20351;&#29992;&#36825;&#20004;&#20010;&#26415;&#35821;&#21602;&#65311;&#22312;&#36882;&#24402;&#21619;&#36947;&#26356;&#27987;&#30340;&#22320;&#26041;&#65292;&#19968;&#33324;&#29992;&#36882;&#24402;&#36825;&#20010;&#26415;&#35821;&#65292;&#22312;&#28145;&#25628;&#26356;&#27987;&#30340;&#22330;&#26223;&#19979;&#65292;&#29992;&#28145;&#25628;&#36825;&#20010;&#26415;&#35821;&#65292;&#35835;&#32773;&#24515;&#37324;&#35201;&#24324;&#28165;&#26970;&#20182;&#20457;&#22823;&#37096;&#20998;&#26102;&#20505;&#26159;&#19968;&#22238;&#20107;&#12290;&#22312;&#21333;&#38142;&#34920;&#12289;&#20108;&#21449;&#26641;&#31561;&#36882;&#24402;&#25968;&#25454;&#32467;&#26500;&#19978;&#65292;&#36882;&#24402;&#30340;&#21619;&#36947;&#26356;&#27987;&#65292;&#36825;&#26102;&#29992;&#36882;&#24402;&#36825;&#20010;&#26415;&#35821;&#65307;&#22312;&#22270;&#12289;&#38544;&#22763;&#22270;&#31561;&#25968;&#25454;&#32467;&#26500;&#19978;&#65292;&#36882;&#24402;&#30340;&#27604;&#37325;&#19981;&#22823;&#65292;&#28145;&#25628;&#30340;&#24847;&#22270;&#26356;&#27987;&#65292;&#36825;&#26102;&#29992;&#28145;&#25628;&#36825;&#20010;&#26415;&#35821;&#12290;</strong></p>
</blockquote>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/08/13 &#19978;&#21320; 9:30:00 4. &#21160;&#24577;&#35268;&#21010; Dynamic Programming I <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#20160;&#20040;&#26159;&#21160;&#24577;&#35268;&#21010;&#65311;&#21160;&#24577;&#35268;&#21010;&#30340;&#24847;&#20041;&#26159;&#20160;&#20040;&#65311; <code class="fold">@</code></dt>
<dd><p>&#21160;&#24577;&#35268;&#21010;&#65288;Dynamic programming&#65289;&#20013;&#36882;&#25512;&#24335;&#30340;&#27714;&#35299;&#26041;&#27861;&#19981;&#26159;&#21160;&#24577;&#35268;&#21010;&#30340;&#26412;&#36136;&#12290;</p>
<p>&#21160;&#24577;&#35268;&#21010;&#30340;&#26412;&#36136;&#65292;&#26159;&#23545;&#38382;&#39064;&#12304;<strong>&#29366;&#24577;</strong>&#12305;&#30340;&#23450;&#20041;&#21644;&#12304;<strong>&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;</strong>&#12305;&#30340;&#23450;&#20041;&#12290;</p>
<p>&#24341;&#33258;&#32500;&#22522;&#30334;&#31185;</p>
<blockquote>
<p>dynamic programming is a method for solving a complex problem by <strong>breaking it down into a collection of simpler subproblems</strong>.</p>
</blockquote>
<p>&#21160;&#24577;&#35268;&#21010;&#26159;&#36890;&#36807;&#25286;&#20998;&#38382;&#39064;&#65292;&#23450;&#20041;&#38382;&#39064;&#29366;&#24577;&#21644;&#29366;&#24577;&#20043;&#38388;&#30340;&#20851;&#31995;&#65292;&#20351;&#24471;&#38382;&#39064;&#33021;&#22815;&#20197;&#36882;&#25512;&#65288;&#25110;&#32773;&#35828;&#20998;&#27835;&#65289;&#30340;&#26041;&#24335;&#21435;&#35299;&#20915;&#12290;&#26412;&#39064;&#19979;&#30340;&#20854;&#20182;&#31572;&#26696;&#65292;&#22823;&#22810;&#37117;&#26159;&#22312;&#35828;&#36882;&#25512;&#30340;&#27714;&#35299;&#26041;&#27861;&#65292;&#20294;<strong>&#22914;&#20309;&#25286;&#20998;&#38382;&#39064;&#65292;&#25165;&#26159;&#21160;&#24577;&#35268;&#21010;&#30340;&#26680;&#24515;</strong>&#12290;&#32780;&#25286;&#20998;&#38382;&#39064;&#65292;&#38752;&#30340;&#23601;&#26159;&#29366;&#24577;&#30340;&#23450;&#20041;&#21644;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#30340;&#23450;&#20041;&#12290;</p>
<dl>
<dt>&#21160;&#24577;&#35268;&#21010;&#36855;&#24605;</dt>
<dd><ul>
<li><dl>
<dt>&#8220;&#32531;&#23384;&#65288;memoization&#65289;&#8221;&#65292;&#8220;&#37325;&#21472;&#23376;&#38382;&#39064;&#65288;subproblems&#65289;&#8221;&#65292;&#8220;&#35760;&#24518;&#21270;&#8221;&#65306; <code class="fold">@</code></dt>
<dd><p>&#36825;&#19977;&#20010;&#21517;&#35789;&#65292;&#37117;&#26159;&#22312;&#38416;&#36848;&#36882;&#25512;&#24335;&#27714;&#35299;&#30340;&#25216;&#24039;&#12290;&#20197; Fibonacci &#25968;&#21015;&#20026;&#20363;&#65292;&#35745;&#31639;&#31532; 100 &#39033;&#30340;&#26102;&#20505;&#65292;&#38656;&#35201;&#35745;&#31639;&#31532; 99 &#39033;&#21644; 98 &#39033;&#65307;&#22312;&#35745;&#31639;&#31532; 101 &#39033;&#30340;&#26102;&#20505;&#65292;&#38656;&#35201;&#31532; 100 &#39033;&#21644;&#31532; 99 &#39033;&#65292;&#36825;&#26102;&#20505;&#20320;&#36824;&#38656;&#35201;&#37325;&#26032;&#35745;&#31639;&#31532; 99 &#39033;&#21527;&#65311;&#19981;&#38656;&#35201;&#65292;&#20320;&#21482;&#38656;&#35201;&#22312;&#31532;&#19968;&#27425;&#35745;&#31639;&#30340;&#26102;&#20505;&#25226;&#23427;&#35760;&#19979;&#26469;&#23601;&#21487;&#20197;&#20102;&#12290;</p>
<p>&#19978;&#36848;&#30340;&#38656;&#35201;&#20877;&#27425;&#35745;&#31639;&#30340;&#8220;&#31532; 99 &#39033;&#8221;&#65292;&#23601;&#21483;&#8220;&#37325;&#21472;&#23376;&#38382;&#39064;&#8221;&#12290;&#22914;&#26524;&#27809;&#26377;&#35745;&#31639;&#36807;&#65292;&#23601;&#25353;&#29031;&#36882;&#25512;&#24335;&#35745;&#31639;&#65292;&#22914;&#26524;&#35745;&#31639;&#36807;&#65292;&#30452;&#25509;&#20351;&#29992;&#65292;&#23601;&#20687;&#8220;&#32531;&#23384;&#8221;&#19968;&#26679;&#65292;&#36825;&#31181;&#26041;&#27861;&#65292;&#21483;&#20570;&#8220;&#35760;&#24518;&#21270;&#8221;&#65292;&#36825;&#26159;&#36882;&#25512;&#24335;&#27714;&#35299;&#30340;&#25216;&#24039;&#12290;&#36825;&#31181;&#25216;&#24039;&#65292;&#36890;&#20439;&#30340;&#35828;&#21483;&#8220;&#33457;&#36153;&#31354;&#38388;&#26469;&#33410;&#30465;&#26102;&#38388;&#8221;&#12290;&#37117;&#19981;&#26159;&#21160;&#24577;&#35268;&#21010;&#30340;&#26412;&#36136;&#65292;&#19981;&#26159;&#21160;&#24577;&#35268;&#21010;&#30340;&#26680;&#24515;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#8220;&#36882;&#24402;&#8221; <code class="fold">@</code></dt>
<dd><p>&#36882;&#24402;&#26159;&#36882;&#25512;&#24335;&#27714;&#35299;&#30340;&#26041;&#27861;&#65292;&#36830;&#25216;&#24039;&#37117;&#31639;&#19981;&#19978;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#8220;&#26080;&#21518;&#25928;&#24615;&#8221;&#65292;&#8220;&#26368;&#20248;&#23376;&#32467;&#26500;&#8221; <code class="fold">@</code></dt>
<dd><p>&#19978;&#36848;&#30340;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#20013;&#65292;&#31561;&#24335;&#21491;&#36793;&#19981;&#20250;&#29992;&#21040;&#19979;&#26631;&#22823;&#20110;&#24038;&#36793; i &#25110;&#32773; k &#30340;&#20540;&#65292;&#36825;&#26159;&#8220;&#26080;&#21518;&#25928;&#24615;&#8221;&#30340;&#36890;&#20439;&#19978;&#30340;&#25968;&#23398;&#23450;&#20041;&#65292;&#31526;&#21512;&#36825;&#31181;&#23450;&#20041;&#30340;&#29366;&#24577;&#23450;&#20041;&#65292;&#25105;&#20204;&#21487;&#20197;&#35828;&#23427;&#20855;&#26377;&#8220;&#26368;&#20248;&#23376;&#32467;&#26500;&#8221;&#30340;&#24615;&#36136;&#65292;&#22312;&#21160;&#24577;&#35268;&#21010;&#20013;&#25105;&#20204;&#35201;&#20570;&#30340;&#65292;&#23601;&#26159;&#25214;&#21040;&#36825;&#31181;&#8220;&#26368;&#20248;&#23376;&#32467;&#26500;&#8221;&#12290;</p>
</dd>
</dl></li>
</ul>
</dd>
</dl>
<p>&#25991;&#33402;&#30340;&#35828;&#65292;&#21160;&#24577;&#35268;&#21010;&#26159;&#23547;&#25214;&#19968;&#31181;&#23545;&#38382;&#39064;&#30340;&#35266;&#23519;&#35282;&#24230;&#65292;&#35753;&#38382;&#39064;&#33021;&#22815;&#20197;&#36882;&#25512;&#65288;&#25110;&#32773;&#35828;&#20998;&#27835;&#65289;&#30340;&#26041;&#24335;&#21435;&#35299;&#20915;&#12290;<strong>&#23547;&#25214;&#30475;&#38382;&#39064;&#30340;&#35282;&#24230;</strong>&#65292;&#25165;&#26159;&#21160;&#24577;&#35268;&#21010;&#20013;&#26368;&#32768;&#30524;&#30340;&#23453;&#30707;&#65281;</p>
<p>&#21478;&#19968;&#20010;&#22238;&#31572;&#65306;</p>
<ul>
<li>&#19968;&#20010;&#38454;&#27573;&#30340;&#26368;&#20248;&#21487;&#20197;&#30001;&#21069;&#19968;&#20010;&#38454;&#27573;&#30340;&#26368;&#20248;&#24471;&#21040;&#12290;</li>
<li>&#22914;&#26524;&#19968;&#20010;&#38454;&#27573;&#30340;&#26368;&#20248;&#26080;&#27861;&#29992;&#21069;&#19968;&#20010;&#38454;&#27573;&#30340;&#26368;&#20248;&#24471;&#21040;&#21602;&#65311;</li>
</ul>
<p>&#21018;&#21018;&#30340;&#24773;&#20917;&#23454;&#22312;&#22826;&#26222;&#36941;&#65292;&#35299;&#20915;&#26041;&#27861;&#23454;&#22312;&#22826;&#26292;&#21147;&#65292;&#26377;&#27809;&#26377;&#21738;&#20123;&#24773;&#20917;&#21487;&#20197;&#36991;&#20813;&#22914;&#27492;&#30340;&#26292;&#21147;&#21602;&#65311;</p>
<p>&#22865;&#26426;&#23601;&#22312;&#20110;<strong>&#21518;&#25928;&#24615;</strong>&#12290;</p>
<p>&#26377;&#19968;&#31867;&#38382;&#39064;&#65292;&#30475;&#20284;&#38656;&#35201;&#20043;&#21069;&#25152;&#26377;&#30340;&#29366;&#24577;&#65292;&#20854;&#23454;&#19981;&#29992;&#12290;&#19981;&#22952;&#20063;&#26159;&#25343;&#26368;&#38271;&#19978;&#21319;&#23376;&#24207;&#21015;&#30340;&#20363;&#23376;&#26469;&#35828;&#26126;&#20026;&#20160;&#20040;&#20182;&#19981;&#24517;&#38656;&#35201;&#26292;&#21147;&#25628;&#32034;&#65292;&#36827;&#32780;&#24341;&#20986;&#21160;&#24577;&#35268;&#21010;&#30340;&#24605;&#36335;&#12290;&#65288;&#36825;&#20854;&#23454;&#26159;&#35828;&#20320;&#35201;&#20180;&#32454;&#21306;&#20998;&#29366;&#24577;&#65292;&#37027;&#20123;&#26159;<strong>&#26080;&#25152;&#35859;&#30340;&#29366;&#24577;</strong>&#65292;&#21738;&#20123;&#26159;<strong>&#26412;&#36136;&#30340;&#24517;&#39035;&#35201;&#30041;&#24847;&#30340;&#29366;&#24577;</strong>&#12290;&#36825;&#20063;&#21644;&#19978;&#38754;&#30340;&#27491;&#30830;&#36873;&#25321;&#12304;&#29366;&#24577;&#12305;&#30340;&#23450;&#20041;&#19968;&#20010;&#24847;&#24605;&#12290;&#65289;</p>
<p>&#36825;&#23601;&#21487;&#20197;&#32437;&#23481;&#25105;&#20204;&#19981;&#38656;&#35201;&#35760;&#24405;&#20043;&#21069;&#25152;&#26377;&#30340;&#29366;&#24577;&#21834;&#65281;&#26082;&#28982;&#25105;&#20204;&#30340;&#36873;&#25321;&#24050;&#32463;&#19981;&#21463;&#20043;&#21069;&#29366;&#24577;&#30340;&#32452;&#21512;&#30340;&#24433;&#21709;&#20102;&#65292;&#37027;&#26102;&#38388;&#22797;&#26434;&#24230;&#33258;&#28982;&#20063;&#19981;&#26159;&#25351;&#25968;&#30340;&#20102;&#21834;&#65281;&#34429;&#28982;&#25105;&#20204;&#19981;&#22312;&#20046;&#26576;&#24207;&#21015;&#20043;&#21069;&#37117;&#26159;&#20160;&#20040;&#20803;&#32032;&#65292;&#20294;&#25105;&#20204;&#36824;&#26159;&#38656;&#35201;&#36825;&#20010;&#24207;&#21015;&#30340;&#38271;&#24230;&#30340;&#12290;&#25152;&#20197;&#25105;&#20204;&#21482;&#38656;&#35201;&#35760;&#24405;&#20197;&#26576;&#20010;&#20803;&#32032;&#32467;&#23614;&#30340; LIS &#38271;&#24230;&#23601;&#22909;&#65281;&#22240;&#27492;&#31532; i &#20010;&#38454;&#27573;&#30340;&#26368;&#20248;&#35299;&#21482;&#26159;&#30001;&#21069; i-1 &#20010;&#38454;&#27573;&#30340;&#26368;&#20248;&#35299;&#24471;&#21040;&#30340;&#65292;&#28982;&#21518;&#23601;&#24471;&#21040;&#20102; DP &#26041;&#31243;&#65306;</p>
<p><code>LIS(i) = max{ LIS(j)+1 } for j&lt;i &amp; a[j] &lt; a[i]</code></p>
<p><strong>&#25152;&#20197;&#19968;&#20010;&#38382;&#39064;&#26159;&#35813;&#29992;&#36882;&#25512;&#12289;&#36138;&#24515;&#12289;&#25628;&#32034;&#36824;&#26159;&#21160;&#24577;&#35268;&#21010;&#65292;&#23436;&#20840;&#26159;&#30001;&#36825;&#20010;&#38382;&#39064;&#26412;&#36523;&#38454;&#27573;&#38388;&#29366;&#24577;&#30340;&#36716;&#31227;&#26041;&#24335;&#20915;&#23450;&#30340;&#65281;</strong></p>
<ul>
<li>&#27599;&#20010;&#38454;&#27573;&#21482;&#26377;&#19968;&#20010;&#29366;&#24577; -&gt; <strong>&#36882;&#25512;</strong>&#65307;</li>
<li>&#27599;&#20010;&#38454;&#27573;&#30340;&#26368;&#20248;&#29366;&#24577;&#37117;&#26159;&#30001;&#19978;&#19968;&#20010;&#38454;&#27573;&#30340;&#26368;&#20248;&#29366;&#24577;&#24471;&#21040;&#30340; -&gt; <strong>&#36138;&#24515;</strong>&#65307;</li>
<li>&#27599;&#20010;&#38454;&#27573;&#30340;&#26368;&#20248;&#29366;&#24577;&#26159;&#30001;&#20043;&#21069;&#25152;&#26377;&#38454;&#27573;&#30340;&#29366;&#24577;&#30340;&#32452;&#21512;&#24471;&#21040;&#30340; -&gt; <strong>&#25628;&#32034;</strong>&#65307;</li>
<li>&#27599;&#20010;&#38454;&#27573;&#30340;&#26368;&#20248;&#29366;&#24577;&#21487;&#20197;&#20174;&#20043;&#21069;&#26576;&#20010;&#38454;&#27573;&#30340;&#26576;&#20010;&#25110;&#26576;&#20123;&#29366;&#24577;&#30452;&#25509;&#24471;&#21040;&#32780;&#19981;&#31649;&#20043;&#21069;&#36825;&#20010;&#29366;&#24577;&#26159;&#22914;&#20309;&#24471;&#21040;&#30340; -&gt; <strong>&#21160;&#24577;&#35268;&#21010;</strong>&#12290;</li>
</ul>
<blockquote>
<p>&#27599;&#20010;&#38454;&#27573;&#30340;&#26368;&#20248;&#29366;&#24577;&#21487;&#20197;&#20174;&#20043;&#21069;&#26576;&#20010;&#38454;&#27573;&#30340;&#26576;&#20010;&#25110;&#26576;&#20123;&#29366;&#24577;&#30452;&#25509;&#24471;&#21040;</p>
</blockquote>
<p>&#36825;&#20010;&#24615;&#36136;&#21483;&#20570;<strong>&#26368;&#20248;&#23376;&#32467;&#26500;&#65288;optimal substructure&#65289;</strong>&#65307;</p>
<blockquote>
<p>&#32780;&#19981;&#31649;&#20043;&#21069;&#36825;&#20010;&#29366;&#24577;&#26159;&#22914;&#20309;&#24471;&#21040;&#30340;</p>
</blockquote>
<p>&#36825;&#20010;&#24615;&#36136;&#21483;&#20570;<strong>&#26080;&#21518;&#25928;&#24615;</strong>&#12290;&#65288;&#21382;&#21490;&#19981;&#23545;&#26410;&#26469;&#20135;&#29983;&#28145;&#36828;&#24433;&#21709;&#12290;&#65289;</p>
<hr />
<p>&#21160;&#24577;&#35268;&#21010;&#26368;&#37325;&#35201;&#30340;&#23601;&#26159;&#29702;&#35299;&#12304;&#26368;&#20248;&#21407;&#29702;&#12305;&#65306;&#22914;&#26524;&#19968;&#20010;&#20915;&#31574;&#30340;&#21069;&#38754;&#33509;&#24178;&#27493;&#39588;&#24050;&#32463;&#30830;&#23450;&#20174;&#32780;&#36827;&#20837;&#26576;&#31181;&#29366;&#24577;&#20043;&#21518;&#65292;&#21518;&#38754;&#30340;&#27493;&#39588;&#20174;&#25353;&#29031;&#24403;&#21069;&#29366;&#24577;&#24320;&#22987;&#30340;&#26368;&#20248;&#35299;&#24517;&#28982;&#26159;&#25972;&#20307;&#65288;&#21253;&#25324;&#35813;&#29366;&#24577;&#30340;&#24773;&#20917;&#19979;&#65289;&#30340;&#26368;&#20248;&#35299;&#65292;&#21017;&#35813;&#38382;&#39064;&#28385;&#36275;&#26368;&#20248;&#21407;&#29702;&#12290;&#25442;&#21477;&#35805;&#35828;&#65292;&#22312;&#27714;&#35299;&#65288;&#25972;&#20307;&#38382;&#39064;&#65289;&#30340;&#26368;&#20248;&#35299;&#30340;&#26102;&#20505;&#65292;&#21518;&#38754;&#30340;&#27493;&#39588;&#36873;&#25321;&#21482;&#19982;&#24403;&#21069;&#29366;&#24577;&#26377;&#20851;&#65292;&#32780;&#12304;&#19982;&#22914;&#20309;&#21040;&#36798;&#36825;&#20010;&#29366;&#24577;&#30340;&#27493;&#39588;&#26080;&#20851;&#12305;&#12290;</p>
<p>&#38382;&#39064;&#28385;&#36275;&#26368;&#20248;&#21407;&#29702;&#20043;&#21518;&#65292;&#25105;&#20204;&#21487;&#20197;&#25226;&#26576;&#20010;&#29366;&#24577;&#21040;&#30446;&#26631;&#30340;&#26368;&#20248;&#35299;&#35760;&#24405;&#19979;&#26469;&#65292;&#36825;&#26679;&#24403;&#36890;&#36807;&#19981;&#21516;&#30340;&#27493;&#39588;&#36208;&#21040;&#30456;&#21516;&#30340;&#29366;&#24577;&#30340;&#26102;&#20505;&#65292;&#23601;&#19981;&#38656;&#35201;&#37325;&#22797;&#25628;&#32034;&#20102;&#65292;&#26377;&#19968;&#20123;&#38382;&#39064;&#36824;&#21487;&#20197;&#25512;&#20986;&#36882;&#25512;&#20844;&#24335;&#36827;&#34892;&#27714;&#35299;&#12290;</p>
<p>&#35774;&#35745;&#21160;&#24577;&#35268;&#21010;&#31639;&#27861;&#30340;&#26102;&#20505;&#65292;&#26368;&#26680;&#24515;&#30340;&#23601;&#26159;&#22914;&#20309;&#12304;&#35774;&#35745;&#29366;&#24577;&#12305;&#65292;&#20351;&#24471;&#29366;&#24577;&#30340;&#21487;&#33021;&#24615;&#23613;&#37327;&#23569;&#65292;&#21364;&#21448;&#21516;&#26102;&#28385;&#36275;&#26368;&#20248;&#21407;&#29702;&#12290;&#20363;&#22914;&#65292;&#22914;&#26524;&#29366;&#24577;&#34987;&#35774;&#32622;&#20026;&#25152;&#26377;&#21040;&#36798;&#35813;&#29366;&#24577;&#27493;&#39588;&#32452;&#25104;&#65292;&#26174;&#28982;&#31526;&#21512;&#26368;&#26377;&#21407;&#29702;&#65292;&#20294;&#36825;&#23601;&#21644;&#21407;&#26469;&#30340;&#38382;&#39064;&#19968;&#26679;&#20102;&#65292;&#24182;&#27809;&#26377;&#35753;&#38382;&#39064;&#26356;&#31616;&#21333;&#12290;</p>
<p>&#26368;&#21518;&#65292;&#21160;&#24577;&#35268;&#21010;&#31639;&#27861;&#21644;&#24191;&#24230;&#20248;&#20808;&#25628;&#32034;&#35299;&#20915;&#30340;&#26159;&#21516;&#26679;&#30340;&#38382;&#39064;&#65292;&#35299;&#20915;&#38382;&#39064;&#30340;&#26041;&#27861;&#30340;&#25551;&#36848;&#26041;&#24335;&#19981;&#21516;&#32780;&#24050;&#12290;</p>
<dl>
<dt>&#23545;&#21160;&#24577;&#35268;&#21010;&#65288;Dynamic Programming&#65289;&#30340;&#29702;&#35299;&#65306;&#20174;&#31351;&#20030;&#24320;&#22987; <code class="fold">@</code></dt>
<dd><p>TODO</p>
<p>&#12298;&#31639;&#27861;&#31454;&#36187;&#20837;&#38376;&#32463;&#20856; (&#35910;&#29923;)&#12299;&#20013; LiuRuJia &#26159;&#25353;&#8220;&#31351;&#20030;&#65293;&#20998;&#27835;&#65293;dp&#8221; &#26469;&#23433;&#25490;&#20070;&#26412;&#31456;&#33410;&#30340;&#65292;&#36825;&#24182;&#38750;&#20598;&#28982;&#65292;&#35201;&#28145;&#20837;&#29702;&#35299;&#24182;&#28789;&#27963;&#36816;&#29992; dp &#24517;&#39035;&#35201;&#20808;&#23545;&#31351;&#20030;&#21644;&#20998;&#27835;&#26377;&#24456;&#22909;&#30340;&#22522;&#30784;&#12290;&#21542;&#21017;&#23601;&#20250;&#38519;&#20837; LRJ &#25351;&#20986;&#30340;&#19968;&#31181;&#29616;&#35937;&#65306;</p>
<blockquote>
<p>&#8220;&#27599;&#27425;&#30896;&#21040;&#26032;&#39064;&#33258;&#24049;&#37117;&#24819;&#19981;&#20986;&#26469;&#65292;&#20294;&#19968;&#30475;&#39064;&#35299;&#23601;&#25026;&#8221;&#30340;&#23604;&#23596;&#24773;&#20917;&#12290;</p>
</blockquote>
</dd>
<dt>&#21160;&#24577;&#35268;&#21010; - &#21326;&#31185;&#23567;&#28059; <code class="fold">@</code></dt>
<dd><p>TODO</p>
<p>&#26368;&#36817;&#22312;&#30475;&#31639;&#27861;&#23548;&#35770;&#65306;&#19978;&#38754;&#35762;&#30340;&#19981;&#38169;&#65306;&#24403;&#38382;&#39064;&#20855;&#26377;&#26368;&#20248;&#23376;&#32467;&#26500;&#21644;&#37325;&#21472;&#23376;&#38382;&#39064;&#26102;&#65292;&#21487;&#20197;&#32771;&#34385;&#29992;&#21160;&#24577;&#35268;&#21010;&#31639;&#27861;&#12290;&#21160;&#24577;&#35268;&#21010;&#26041;&#27861;&#23433;&#25490;&#27714;&#35299;&#39034;&#24207;&#65292;&#23545;&#27599;&#20010;&#23376;&#38382;&#39064;&#21482;&#27714;&#35299;&#19968;&#27425;&#65292;&#24182;&#23558;&#32467;&#26524;&#20445;&#23384;&#19979;&#26469;&#12290;&#22914;&#26524;&#38543;&#21518;&#20877;&#27425;&#38656;&#35201;&#27492;&#23376;&#38382;&#39064;&#30340;&#35299;&#65292;&#21482;&#38656;&#26597;&#25214;&#20445;&#23384;&#30340;&#32467;&#26524;&#65292;&#32780;&#19981;&#24517;&#37325;&#26032;&#35745;&#31639;&#12290;&#22240;&#27492;&#21160;&#24577;&#35268;&#21010;&#31639;&#27861;&#26159;&#20184;&#20986;&#39069;&#22806;&#30340;&#20869;&#23384;&#31354;&#38388;&#26469;&#33410;&#30465;&#35745;&#31639;&#26102;&#38388;&#65292;&#26159;&#20856;&#22411;&#30340;&#26102;&#31354;&#26435;&#34913;&#30340;&#20363;&#23376;&#12290;</p>
</dd>
<dt>&#22914;&#20309;&#29702;&#35299;&#21160;&#24577;&#35268;&#21010;&#65311; <code class="fold">@</code></dt>
<dd><pre><code>&#36138;&#24515;&#65306;                                  &#12304;&#27599;&#19968;&#27493;&#21482;&#36873;&#26368;&#20248;&#12305;
        +----H----+             +----P----+
       /           \           /           \
   A -+             +----O----+             +-- Z
       \           /           \           /
        +----I----+             +----Q----+
                min(H,I)          min(P,Q)

&#31351;&#20030;&#65306;                                  &#12304;&#25226;&#36825;&#20123;&#36335;&#37117;&#23581;&#35797;&#19968;&#36941;&#65292;&#25165;&#30693;&#36947;&#21738;&#20010;&#26368;&#20248;&#12305;
   A  --+-- H ----- P -------- Z
        |    \                /
        |     +---- Q -------/
        |                   /
        +-- I ----- R -----/
             \            /
              +----- S --+

&#21160;&#24577;&#35268;&#21010;&#65306;                              &#12304;&#26292;&#21147;&#65292;&#20294; A-H-Q &#21644; A-I-Q &#20445;&#23384;&#19968;&#26465;&#23601;&#21487;&#20197;&#20102;&#12305;
                 -- P --
                /       \
         -- H -+         \
        /       \         \
    A -+         -- Q -----+-- Z
        \       /          /
         -- I -+          /
                \        /
                 -- R --</code></pre>
<p>&#26368;&#21518;&#29992;&#32463;&#20856;&#30340; 0-1 &#32972;&#21253;&#38382;&#39064;&#20570;&#20010;&#20363;&#23376;&#65292;&#24041;&#22266;&#19968;&#19979;&#21543;&#65292;&#36825;&#20010;&#20219;&#21153;&#26159;&#65292;&#25105;&#20204;&#20174; N &#20010;&#29289;&#21697;&#36873;&#33509;&#24178;&#22622;&#21040;&#21487;&#20197;&#25215;&#21463;&#26368;&#22823;&#37325;&#37327; W &#30340;&#21253;&#21253;&#37324;&#38754;&#65292;&#35201;&#20215;&#20540;&#26368;&#22823;&#65292;&#22240;&#27492;&#23601;&#21487;&#20197;&#23558;&#20219;&#21153;&#20998;&#25104; N &#20010;&#27493;&#39588;&#65292;&#27599;&#20010;&#27493;&#39588;&#38754;&#23545;&#31532; i &#21495;&#29289;&#21697;&#65292;&#20915;&#31574;&#26377;&#20004;&#26465;&#65306;&#36873;&#65292;&#36824;&#26159;&#25918;&#24323;&#65292;&#36825;&#37324;&#30340;&#29366;&#24577;&#65292;&#23601;&#26159;&#24433;&#21709;&#20043;&#21518;&#27493;&#39588;&#20915;&#31574;&#30340;&#22240;&#32032;&#65292;&#22312;&#36825;&#37324;&#65292;&#23601;&#26159;&#8220;&#32972;&#21253;&#30340;&#21097;&#20313;&#31354;&#38388;&#8221;</p>
<p>&#27604;&#22914;&#65292;&#29289;&#21697;&#30340;&#37325;&#37327;&#26159; 1,2,3,4,5,6&#65292;W=12&#65292;&#20174;&#22836;&#20915;&#31574;&#65292;0 &#34920;&#31034;&#25918;&#24323;&#65292;1 &#34920;&#31034;&#36873;&#65292; BFS &#19977;&#27425;&#21518;&#26377;&#20843;&#31181;&#29366;&#24577;&#65306;</p>
<p>&#160;&#160;000 &#21097;12<br />
&#160;&#160;001 &#21097;9<br />
&#160;&#160;&#8230;&#8230;&#65288;&#30053;&#65289;<br />
&#160;&#160;110 &#21097;9<br />
&#160;&#160;&#8230;&#8230;&#65288;&#30053;&#65289;</p>
<p>&#21069;&#19977;&#27425;&#27493;&#39588;&#21518;&#65292;001 &#21644; 110 &#21040;&#36798;&#20102;&#21516;&#26679;&#30340;&#29366;&#24577;&#65292;&#37117;&#26159;&#21097;&#20313;&#21487;&#35013;&#37325;&#37327; 9 &#30340;&#19996;&#35199;&#65292;&#36825;&#26679;&#22312;&#21097;&#19979;&#30340;&#20915;&#31574;&#20013;&#65292;&#36825;&#20457;&#20998;&#25903;&#36208;&#30340;&#36335;&#37117;&#26159;&#19968;&#26679;&#30340;&#65292;&#36319;&#20320;&#20043;&#21069;&#26159;&#36873;&#20102; 001 &#36824;&#26159; 110 &#27809;&#26377;&#20219;&#20309;&#20851;&#31995;&#65288;&#26080;&#21518;&#25928;&#24615;&#65289;&#65292;&#22240;&#27492;&#21482;&#35201;&#30475; 001 &#20215;&#20540;&#22823;&#65292;&#36824;&#26159; 110 &#20215;&#20540;&#22823;&#23601;&#21487;&#20197;&#20102;&#65292;8 &#20010;&#29366;&#24577;&#20943;&#23569;&#20026; 7 &#20010;&#65292;&#32487;&#32493; BFS &#19979;&#21435;&#65292;&#27599;&#19968;&#36718;&#37117;&#21512;&#24182;&#21516;&#26679;&#29366;&#24577;&#65292;&#23436;&#25104;&#21518;&#65292;&#20174;&#26368;&#21518;&#19968;&#36718;&#30340;&#25152;&#26377;&#29366;&#24577;&#20013;&#65292;&#25214;&#21040;&#20215;&#20540;&#26368;&#22823;&#30340;&#23601; ok &#20102;</p>
<p>&#30001;&#20110;&#29366;&#24577;&#26368;&#22810;&#26377; W+1 &#20010;&#65292;&#36827;&#34892; N &#36718;&#65292;&#22240;&#27492;&#22797;&#26434;&#24230; O(NW)&#65292;&#20070;&#19978;&#35828;&#30340;&#29366;&#24577;&#36801;&#31227;&#26041;&#31243;&#30340;&#21150;&#27861;&#20854;&#23454;&#36319;&#36825;&#20010;&#36807;&#31243;&#24456;&#31867;&#20284;&#65292;&#19981;&#36807;&#23545;&#20110;&#26377;&#20123;&#39064;&#30446;&#65292;&#27604;&#36215; BFS+ &#29366;&#24577;&#21512;&#24182;&#65292;&#29366;&#24577;&#26041;&#31243;&#30340;&#20998;&#26512;&#21487;&#20197;&#20570;&#26356;&#22909;&#30340;&#20248;&#21270;&#65292;&#22914;&#24341;&#20837;&#21333;&#35843;&#38431;&#21015;&#20160;&#20040;&#30340;&#65292;&#20294; BFS+ &#29366;&#24577;&#21512;&#24182;&#21487;&#20197;&#35753;&#20320;&#24471;&#21040;&#19968;&#20010;&#27809;&#26377;&#36861;&#27714;&#26497;&#38480;&#20294;&#26159;&#20063;&#27604;&#36739;&#24555;&#30340;&#35299;&#20915;&#26041;&#26696;&#20102;&#65292;&#32467;&#21512;&#20855;&#20307;&#38382;&#39064;&#26377;&#26102;&#20505;&#26356;&#36866;&#21512;&#65292;&#27604;&#22914;&#26681;&#25454;&#38382;&#39064;&#30340;&#23454;&#38469;&#38656;&#27714;&#65292;&#25628;&#32034;&#21487;&#20197;&#38480;&#30028;&#21098;&#26525;&#20943;&#23569;&#24037;&#20316;&#37327;&#65292;&#25105;&#22312;&#24037;&#20316;&#20013;&#23601;&#29992;&#36807;&#65292;&#26367;&#25442;&#20102;&#21516;&#20107;&#20174; wiki &#25220;&#30340; DP &#31639;&#27861;&#65292;&#25928;&#29575;&#33021;&#25552;&#21319;&#19968;&#20123;</p>
<p>&#26368;&#21518;&#30041;&#20010;&#23567;&#39064;&#65292;&#26159;&#20197;&#21069;&#20570;&#32771;&#23448;&#26102;&#20505;&#32463;&#24120;&#29992;&#30340;&#19968;&#36947;&#38754;&#35797;&#39064;&#65292;&#21360;&#35937;&#20013;&#26377;&#31639;&#27861;&#22522;&#30784;&#30340;&#21516;&#23398;&#20845;&#19971;&#25104;&#37117;&#33021;&#31435;&#21363;&#35828;&#8220;&#29992; DP&#8221;&#65292;&#28982;&#32780;&#19968;&#38382;&#29366;&#24577;&#36716;&#31227;&#23601;&#26197;&#20102; ^_^&#65306;&#22312;&#32422;&#23450;&#30340;&#35268;&#21017;&#19979;&#65292;&#20197;&#25968;&#23383;&#25968;&#32452;&#30340;&#24418;&#24335;&#36755;&#20837;&#19968;&#25163;&#26007;&#22320;&#20027;&#30340;&#29260;&#65292;&#35774;&#35745;&#31639;&#27861;&#35745;&#31639;&#36825;&#25163;&#29260;&#26368;&#23569;&#20960;&#25226;&#21487;&#20197;&#20986;&#23436;&#27880;&#24847;&#36825;&#37324;&#21482;&#26159;&#29992;&#26007;&#22320;&#20027;&#20570;&#20010;&#20363;&#23376;&#65292;&#19981;&#20195;&#34920;&#29260;&#25968;&#38480;&#21046;&#20026; 20 &#24352;&#65292;&#21487;&#20197;&#30475;&#20570;&#26159;&#19968;&#20010; N &#20010;&#25968;&#23383;&#26681;&#25454;&#35268;&#21017;&#20998;&#32452;&#30340;&#38382;&#39064;&#65292;&#35828;&#26007;&#22320;&#20027;&#26159;&#22240;&#20026;&#20043;&#21069;&#26159;&#20570;&#28216;&#25103;&#34892;&#19994;&#30340;&#65292;&#32780;&#19988;&#38754;&#35797;&#26102;&#20505;&#36825;&#26679;&#35828;&#27604;&#36739;&#23481;&#26131;&#38477;&#20302;&#21516;&#23398;&#20204;&#30340;&#32039;&#24352;&#24230;&#65292;&#21516;&#26102;&#20063;&#26159;&#19968;&#20010;&#26263;&#31034;&#65306;&#22823;&#23478;&#37117;&#30693;&#36947;&#26007;&#22320;&#20027;&#38752;&#36138;&#24515;&#27861;&#26159;&#24471;&#19981;&#21040;&#26368;&#20248;&#20986;&#29260;&#39034;&#24207;&#30340;&#21543;&#65292;&#21704;&#12290;&#12290;&#12290;</p>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="https://www.zhihu.com/question/23995189">&#20160;&#20040;&#26159;&#21160;&#24577;&#35268;&#21010;&#65311;&#21160;&#24577;&#35268;&#21010;&#30340;&#24847;&#20041;&#26159;&#20160;&#20040;&#65311; - &#30693;&#20046;</a></li>
<li><a href="http://janfan.github.io/chinese/2015/01/21/dynamic-programming.html">&#23545;&#21160;&#24577;&#35268;&#21010;&#65288;Dynamic Programming&#65289;&#30340;&#29702;&#35299;&#65306;&#20174;&#31351;&#20030;&#24320;&#22987; &#183; Jan Fan</a></li>
<li><a href="http://www.cnblogs.com/hust-ghtao/p/4150159.html">&#21160;&#24577;&#35268;&#21010; - &#21326;&#31185;&#23567;&#28059; - &#21338;&#23458;&#22253;</a></li>
<li><a href="https://www.zhihu.com/question/24347044">&#22914;&#20309;&#26356;&#22909;&#30340;&#25484;&#25569;&#21160;&#24577;&#35268;&#21010;&#30340;&#24605;&#24819;&#65311; - &#30693;&#20046;</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Dynamic programming <code class="fold">@</code></dt>
<dd><p>Sometimes, applying memoization to the naive recursive algorithm (namely the one obtained by a direct translation of the problem into recursive form) already results in a dynamic programming algorithm with asymptotically optimal time complexity, but for optimization problems in general the optimal algorithm might require more sophisticated algorithms. Some of these may be recursive (and hence can be memoized) but parametrized differently from the naive algorithm. For other problems the optimal algorithm may not even be a memoized recursive algorithm in any reasonably natural sense. An example of such a problem is the <strong>Egg Dropping puzzle</strong> described below.</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/03/Shortest_path_optimal_substructure.svg/250px-Shortest_path_optimal_substructure.svg.png" alt="Figure 1. Finding the shortest path in a graph using optimal substructure; a straight line indicates a single edge; a wavy line indicates a shortest path between the two vertices it connects (other nodes on these paths are not shown); the bold line is the overall shortest path from start to goal." />
<p class="caption">Figure 1. Finding the shortest path in a graph using optimal substructure; a straight line indicates a single edge; a wavy line indicates a shortest path between the two vertices it connects (other nodes on these paths are not shown); the bold line is the overall shortest path from start to goal.</p>
</div>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/06/Fibonacci_dynamic_programming.svg/162px-Fibonacci_dynamic_programming.svg.png" alt="Fibonacci &#24207;&#21015;&#30340;&#23376;&#38382;&#39064;&#31034;&#24847;&#22270;&#65306;&#20351;&#29992;&#26377;&#21521;&#26080;&#29615;&#22270;&#65288;DAG, directed acyclic graph&#65289;&#32780;&#38750;&#26641;&#34920;&#31034;&#37325;&#22797;&#23376;&#38382;&#39064;&#30340;&#20998;&#35299;&#12290;&#20026;&#20160;&#20040;&#26159; DAG &#32780;&#19981;&#26159;&#26641;&#21602;&#65311;&#31572;&#26696;&#23601;&#26159;&#65292;&#22914;&#26524;&#26159;&#26641;&#30340;&#35805;&#65292;&#20250;&#26377;&#24456;&#22810;&#37325;&#22797;&#35745;&#31639;&#65292;&#19979;&#38754;&#26377;&#30456;&#20851;&#30340;&#35299;&#37322;&#12290;" />
<p class="caption">Fibonacci &#24207;&#21015;&#30340;&#23376;&#38382;&#39064;&#31034;&#24847;&#22270;&#65306;&#20351;&#29992;&#26377;&#21521;&#26080;&#29615;&#22270;&#65288;DAG, directed acyclic graph&#65289;&#32780;&#38750;&#26641;&#34920;&#31034;&#37325;&#22797;&#23376;&#38382;&#39064;&#30340;&#20998;&#35299;&#12290;&#20026;&#20160;&#20040;&#26159; DAG &#32780;&#19981;&#26159;&#26641;&#21602;&#65311;&#31572;&#26696;&#23601;&#26159;&#65292;&#22914;&#26524;&#26159;&#26641;&#30340;&#35805;&#65292;&#20250;&#26377;&#24456;&#22810;&#37325;&#22797;&#35745;&#31639;&#65292;&#19979;&#38754;&#26377;&#30456;&#20851;&#30340;&#35299;&#37322;&#12290;</p>
</div>
<p>&#20026;&#36991;&#20813;&#37325;&#22797;&#35745;&#31639;&#65292;&#21487;&#23558;&#24050;&#32463;&#24471;&#21040;&#30340;&#23376;&#38382;&#39064;&#30340;&#35299;&#20445;&#23384;&#36215;&#26469;&#65292;&#24403;&#25105;&#20204;&#35201;&#35299;&#20915;&#30456;&#21516;&#30340;&#23376;&#38382;&#39064;&#26102;&#65292;&#37325;&#29992;&#21363;&#21487;&#12290;&#35813;&#26041;&#27861;&#21363;&#25152;&#35859;&#30340;<strong>&#32531;&#23384;</strong>&#65288;<strong>memoization</strong>&#65292;&#32780;&#19981;&#26159;&#23384;&#20648; memorization&#65292;&#34429;&#28982;&#36825;&#20010;&#35789;&#20134;&#36866;&#21512;&#65292;&#22993;&#19988;&#36825;&#20040;&#21483;&#21543;&#65292;&#36825;&#20010;&#21333;&#35789;&#22826;&#38590;&#32763;&#35793;&#20102;&#65292;&#31616;&#30452;&#23601;&#26159;&#21487;&#24847;&#20250;&#19981;&#21487;&#35328;&#20256;&#65292;&#20854;&#24847;&#20041;&#26159;&#27809;&#35745;&#31639;&#36807;&#21017;&#35745;&#31639;&#65292;&#35745;&#31639;&#36807;&#21017;&#20445;&#23384;&#65289;&#12290;&#24403;&#25105;&#20204;&#30830;&#20449;&#23558;&#19981;&#20250;&#20877;&#38656;&#35201;&#26576;&#19968;&#35299;&#26102;&#65292;&#21487;&#20197;&#23558;&#20854;&#25243;&#24323;&#65292;&#20197;&#33410;&#30465;&#31354;&#38388;&#12290;&#22312;&#26576;&#20123;&#24773;&#20917;&#19979;&#65292;&#25105;&#20204;&#29978;&#33267;&#21487;&#20197;&#25552;&#21069;&#35745;&#31639;&#20986;&#37027;&#20123;&#23558;&#26469;&#20250;&#29992;&#21040;&#30340;&#23376;&#38382;&#39064;&#30340;&#35299;&#12290;</p>
<pre><code>var m := map(0 &#8594; 0, 1 &#8594; 1)
function fib(n)
    if key n is not in map m
        m[n] := fib(n &#8722; 1) + fib(n &#8722; 2)
    return m[n]</code></pre>
<p>This technique of <strong>saving values that have already been calculated</strong> is called <strong>&#12304;memoization&#12305;</strong>;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.cppblog.com/Fox/archive/2008/05/07/Dynamic_programming.html">&#21160;&#24577;&#35268;&#21010;&#31639;&#27861; - &#28216;&#25103;&#20154;&#29983; - C++&#21338;&#23458;</a></li>
<li><a href="https://en.wikipedia.org/wiki/Optimal_substructure">Optimal substructure - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Overlapping_subproblems">Overlapping subproblems - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Memoization">Memoization - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dynamic_programming">Dynamic programming - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#21160;&#24577;&#35268;&#21010;&#31639;&#27861;&#30340;&#36866;&#29992;&#26465;&#20214; <code class="fold">@</code></dt>
<dd><p>&#24517;&#39035;&#28385;&#36275;&#22914;&#19979;&#19977;&#28857;&#65306;</p>
<ul>
<li><strong>&#26368;&#20248;&#21270;&#21407;&#29702;</strong>&#65306;&#22914;&#26524;&#38382;&#39064;&#30340;&#26368;&#20248;&#35299;&#25152;&#21253;&#21547;&#30340;&#23376;&#38382;&#39064;&#30340;&#35299;&#20063;&#26159;&#26368;&#20248;&#30340;&#65292;&#23601;&#31216;&#35813;&#38382;&#39064;&#20855;&#26377;&#26368;&#20248;&#23376;&#32467;&#26500;&#65288;<strong>optimal substructure</strong>&#65289;&#65292;&#21363;&#28385;&#36275;&#26368;&#20248;&#21270;&#21407;&#29702;&#12290;</li>
<li><strong>&#26080;&#21518;&#25928;&#24615;</strong>&#65306;&#21363;&#26576;&#38454;&#27573;&#29366;&#24577;&#19968;&#26086;&#30830;&#23450;&#65292;&#23601;&#19981;&#21463;&#36825;&#20010;&#29366;&#24577;&#20197;&#21518;&#20915;&#31574;&#30340;&#24433;&#21709;&#12290;&#20063;&#23601;&#26159;&#35828;&#65292;&#26576;&#29366;&#24577;&#20197;&#21518;&#30340;&#36807;&#31243;&#19981;&#20250;&#24433;&#21709;&#20197;&#21069;&#30340;&#29366;&#24577;&#65292;&#21482;&#19982;&#24403;&#21069;&#29366;&#24577;&#26377;&#20851;&#12290;</li>
<li><strong>&#26377;&#37325;&#21472;&#23376;&#38382;&#39064;&#65288;overlapping subproblem&#65289;</strong>&#65306;&#21363;&#23376;&#38382;&#39064;&#20043;&#38388;&#26159;&#19981;&#29420;&#31435;&#30340;&#65292;&#19968;&#20010;&#23376;&#38382;&#39064;&#22312;&#19979;&#19968;&#38454;&#27573;&#20915;&#31574;&#20013;&#21487;&#33021;&#34987;&#22810;&#27425;&#20351;&#29992;&#21040;&#12290;&#65288;&#35813;&#24615;&#36136;&#24182;&#19981;&#26159;&#21160;&#24577;&#35268;&#21010;&#36866;&#29992;&#30340;&#24517;&#35201;&#26465;&#20214;&#65292;&#20294;&#26159;&#22914;&#26524;&#27809;&#26377;&#36825;&#26465;&#24615;&#36136;&#65292;&#21160;&#24577;&#35268;&#21010;&#31639;&#27861;&#21516;&#20854;&#20182;&#31639;&#27861;&#30456;&#27604;&#23601;&#19981;&#20855;&#22791;&#20248;&#21183;&#65289;</li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="http://1985wanggang.blog.163.com/blog/static/776383320081052347452/">&#21160;&#24577;&#35268;&#21010;&#30340;&#36866;&#29992;&#26465;&#20214; - &#21644;&#30003;&#30340;&#26085;&#24535; - &#32593;&#26131;&#21338;&#23458;</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#21160;&#24577;&#35268;&#21010;&#31639;&#27861;&#30340;&#22235;&#20010;&#35299;&#39064;&#35201;&#32032; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#20316;&#20026; Sia &#31881;&#65288;Sia Furler&#65289;&#65292;&#25105;&#25226;&#23427;&#35760;&#20316; sfia&#12290;</p>
<ul>
<li><dl>
<dt>&#29366; &#24577; State</dt>
<dd>&#28789;&#24863;&#65292;&#21019;&#36896;&#21147;&#65292;&#23384;&#20648;&#23567;&#35268;&#27169;&#38382;&#39064;&#30340;&#32467;&#26524;
</dd>
</dl></li>
<li><dl>
<dt>&#26041;&#31243; Function</dt>
<dd>&#29366;&#24577;&#20043;&#38388;&#30340;&#32852;&#31995;&#65292;&#24590;&#20040;&#36890;&#36807;&#23567;&#30340;&#29366;&#24577;&#65292;&#26469;&#31639;&#22823;&#30340;&#29366;&#24577;
</dd>
</dl></li>
<li><dl>
<dt>&#21021;&#22987;&#21270; Initialization</dt>
<dd>&#26368;&#26497;&#38480;&#30340;&#23567;&#29366;&#24577;&#26159;&#20160;&#20040;, &#36215;&#28857;
</dd>
</dl></li>
<li><dl>
<dt>&#31572;&#26696; Answer</dt>
<dd>&#26368;&#22823;&#30340;&#37027;&#20010;&#29366;&#24577;&#26159;&#20160;&#20040;&#65292;&#32456;&#28857;
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><p><strong>&#21160;&#35268;&#30340;&#20004;&#31181;&#23454;&#29616;&#26041;&#24335;&#65306;&#35760;&#24518;&#21270;&#25628;&#32034; (top-down) <em>vs</em> &#24490;&#29615;&#36882;&#25512; (bottom-up)</strong></p></li>
<li><dl>
<dt>&#38754;&#35797;&#20013;&#21160;&#24577;&#35268;&#21010;&#30340;&#24120;&#35265;&#31867;&#22411; <code class="fold">@</code></dt>
<dd><p>&#28385;&#36275;&#19979;&#38754;&#19977;&#20010;&#26465;&#20214;&#20043;&#19968;&#65306;</p>
<ul>
<li>&#27714;&#26368;&#22823;&#20540;&#12289;&#26368;&#23567;&#20540;</li>
<li>&#21028;&#26029;&#26159;&#21542;&#21487;&#34892;</li>
<li>&#32479;&#35745;&#26041;&#26696;&#20010;&#25968;</li>
</ul>
<p>&#21017;&#26497;&#26377;&#21487;&#33021; &#26159;&#20351;&#29992;&#21160;&#24577;&#35268;&#21010;&#27714;&#35299;</p>
<dl>
<dt>&#20160;&#20040;&#24773;&#20917;&#19979;&#19981;&#20351;&#29992;&#21160;&#24577;&#35268;&#21010;&#65311;</dt>
<dd><p>&#28385;&#36275;&#19979;&#38754;&#19977;&#20010;&#26465;&#20214;&#20043;&#19968;&#65306;</p>
<ul>
<li><p>&#27714;&#20986;&#25152;&#26377;<strong>&#20855;&#20307;</strong>&#30340;&#26041;&#26696;&#32780;&#38750;&#26041;&#26696;<strong>&#20010;&#25968;</strong> <a href="http://www.lintcode.com/problem/palindrome-partitioning/" class="uri">http://www.lintcode.com/problem/palindrome-partitioning/</a></p></li>
<li><p>&#36755;&#20837;&#25968;&#25454;&#26159;&#19968;&#20010;<strong>&#38598;&#21512;</strong>&#32780;&#19981;<strong>&#24207;&#21015;</strong> <a href="http://www.lintcode.com/problem/longest-consecutive-sequence/" class="uri">http://www.lintcode.com/problem/longest-consecutive-sequence/</a></p></li>
<li><p>&#26292;&#21147;&#30340;&#31639;&#27861;&#24050;&#32463;&#26159;&#22810;&#39033;&#24335;&#32423;&#21035;&#65292;2<sup>n</sup> &#8594; n<sup>2</sup> &#26159; DP &#25797;&#38271;&#30340;&#20107;</p></li>
</ul>
<p>&#21017;&#26497;&#19981;&#21487;&#33021;&#20351;&#29992;&#21160;&#24577;&#35268;&#21010;&#27714;&#35299;</p>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>leetcode &#20013;&#20960;&#36947;&#21160;&#24577;&#35268;&#21010;&#39064; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>Triangle <code class="fold">@</code></dt>
<dd><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle</p>
<pre><code>[
     [2]
    [3,4],
   [6,5,7],
  [4,1,8,3]
]</code></pre>
<p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p>Note:</p>
<p>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p>
<pre><code>    &#31867;&#20284;&#20110;&#22270;&#20687;&#22788;&#29702;&#37324;&#30340;&#12304;&#30452;&#26041;&#22270; vs. &#32047;&#35745;&#30452;&#26041;&#22270;&#12305;&#65292;&#27010;&#29575;&#35770;&#37324;&#30340;&#12304;PDF&#65292;CDF&#12305;&#65306;

      [2]                                      [2=2]
     [3,4],                            [ 5 =(2+3), 6 =(2+4) ]
    [6,5,7],                      [ 11 =(5+6),  10 =(5+5 )   13 =(6+7) ]
   [4,1,8,3]                  [   15         11        18          16       ]
                                              ^
                                              |
                                              +----got you

&#20174;&#19979;&#24448;&#19978;&#30475;&#21602;&#65311;

      | j = 0   1   2   3
------+------------------------------------------------------------------------------
i = 0 |     2               |                   |                   |   11
    1 |     3   4           |                   |   9   10          |   9   10
    2 |     6   5   7       |   7   6   10      |   7   6   10      |   7   6   10
    3 |     4   1   8   3   |   4   1   8   3   |   4   1   8   3   |   4   1   8   3</code></pre>
<p>&#39318;&#20808;&#65292;&#23450;&#20041;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#65306;</p>
<pre><code>f(i,j) = min{
                    f(i+i,j),
                    f(i+1,j+1)
            }                       +       f(i,j),
                                                            for j = 0..i, i = n-2..0</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> minimumTotal( vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; &amp;triangle ) {
    <span class="kw">for</span>( <span class="dt">int</span> i = triangle.size() <span class="dv">-2</span>; i &gt;= <span class="dv">0</span>; --i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; i<span class="dv">+1</span>; ++j ) {
            vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; &amp;t = triangle;                  <span class="co">// save some typing</span>
            t[i][j] += min(t[i<span class="dv">+1</span>][j], t[i<span class="dv">+1</span>][j<span class="dv">+1</span>]);
        }
    }
    <span class="kw">return</span> triangle[<span class="dv">0</span>][<span class="dv">0</span>];
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/triangle/">Triangle | LeetCode OJ</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Maximum Subarray <code class="fold">@</code></dt>
<dd><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array <code>[&#8722;2,1,&#8722;3,4,&#8722;1,2,1,&#8722;5,4]</code>, the contiguous subarray <code>[4,&#8722;1,2,1]</code> has the largest sum = 6.</p>
<p>&#36143;&#24207;&#22320;&#30475;&#65292;&#23545;&#20110;&#26032;&#21152;&#20837;&#25968;&#32452;&#30340;&#19968;&#20010;&#20803;&#32032;&#65292;&#25105;&#20204;&#26377;&#12304;&#20004;&#31181;&#36873;&#25321;&#12305;&#65306;</p>
<ul>
<li>&#21152;&#20837;&#21407;&#26469;&#30340; sub array&#65292;</li>
<li>&#26032;&#29983;&#25104;&#19968;&#20010; sub array&#65288;&#21407;&#26469;&#30340; sub array &#20026;&#36127;&#65289;</li>
</ul>
<p><code>S[n]</code> &#20026;&#24207;&#21015;&#65292;<code>S[j]</code> &#20026;&#31532; j &#20010;&#20803;&#32032;&#65288;1 based&#65289;&#12290;&#35774;&#29366;&#24577; <code>f[j]</code> &#34920;&#31034;&#20197; <code>S[j]</code> &#32467;&#23614;&#30340;&#26368;&#22823;&#36830;&#32493;&#23376;&#24207;&#21015;&#21644;&#65292;&#21017;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#22914;&#19979;&#65306;</p>
<ul>
<li><code>f[j] = max( f[j-1]+S[j], S[j] ), j = 2..n, f = S</code></li>
<li><code>target = max{ f[j] }, j = 1..n</code></li>
</ul>
<p>&#20195;&#30721;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Time: O(n), Space: O(1)</span>
<span class="dt">int</span> maxSubArray( vector&lt;<span class="dt">int</span>&gt; &amp;nums ) {
    <span class="dt">int</span> result = INT_MIN, f = <span class="dv">0</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nums.size(); ++i ) {
        f = max( f+nums[i], nums[i] );
        result = max( f, result );
    }
    <span class="kw">return</span> result;
}</code></pre></div>
<p>&#24863;&#20852;&#36259;&#30340;&#35835;&#32773;&#35831;&#21442;&#32771;&#36825;&#31687;&#21338;&#23458; <a href="http://www.cnblogs.com/gj-Acit/archive/2013/02/12/2910332.html" class="uri">http://www.cnblogs.com/gj-Acit/archive/2013/02/12/2910332.html</a></p>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/maximum-subarray/">Maximum Subarray | LeetCode OJ</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Minimum Path Sum <code class="fold">@</code></dt>
<dd><p>Given a m x n grid filled with non-negative numbers, find a path from <strong>top left</strong> to <strong>bottom right</strong> which minimizes the sum of all numbers along its path.</p>
<p>Note: You can only move either down or right at any point in time.</p>
<p>&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#65306; <code>f[i][j] = min(f[i-1][j], f[i][j-1]) + grid(i,j)</code></p>
<ul>
<li><dl>
<dt>&#22791;&#24536;&#24405;&#27861; (top-down) <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> minPathSum( vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; &amp;grid ) {
        <span class="dt">const</span> <span class="dt">int</span> m = grid.size();
        <span class="dt">const</span> <span class="dt">int</span> n = grid[<span class="dv">0</span>].size();
        f = vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt;( m, vector&lt;<span class="dt">int</span>&gt;(n, <span class="dv">-1</span>) );
        <span class="kw">return</span> dfs( grid, m<span class="dv">-1</span>, n<span class="dv">-1</span> );
    }
<span class="kw">private</span>:
    vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; f;                          <span class="co">// &#32531;&#23384;</span>

    <span class="dt">int</span> dfs( <span class="dt">const</span> vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; &amp;grid, <span class="dt">int</span> x, <span class="dt">int</span> y ) {
        <span class="kw">if</span>( x &lt; <span class="dv">0</span> || y &lt; <span class="dv">0</span> )    { <span class="kw">return</span> INT_MAX; }
        <span class="kw">if</span>( x == <span class="dv">0</span> &amp;&amp; y == <span class="dv">0</span> )  { <span class="kw">return</span> grid[<span class="dv">0</span>][<span class="dv">0</span>]; }
        <span class="kw">return</span> min( getOrUpdate(grid, x<span class="dv">-1</span>, y), getOrUpdate(grid, x, y<span class="dv">-1</span>) ) + grid[x][y];
    }
    <span class="dt">int</span> getOrUpdate( <span class="dt">const</span> vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; &amp;grid, <span class="dt">int</span> x, <span class="dt">int</span> y ) {
        <span class="kw">if</span>( x &lt; <span class="dv">0</span> || y &lt; <span class="dv">0</span> )    { <span class="kw">return</span> INT_MAX; }
        <span class="kw">if</span>( f[x][y] &gt;= <span class="dv">0</span> ) {
            <span class="kw">return</span> f[x][y];
        } <span class="kw">else</span> {
            <span class="kw">return</span> f[x][y] = dfs(grid,x,y);
        }
    }
};</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#21160;&#24577;&#35268;&#21010; (bottom-up) <code class="fold">@</code></dt>
<dd><p>??? works???</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> minPathSum( vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; &amp;grid ) {
    <span class="dt">const</span> <span class="dt">int</span> m = grid.size();
    <span class="dt">const</span> <span class="dt">int</span> n = grid[<span class="dv">0</span>].size();
    <span class="dt">int</span> f[m][n];
    f[<span class="dv">0</span>][<span class="dv">0</span>] = grid[<span class="dv">0</span>][<span class="dv">0</span>];
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt; m; ++i ) {
        f[i][<span class="dv">0</span>] = f[i<span class="dv">-1</span>][<span class="dv">0</span>] + grid[i][<span class="dv">0</span>];
    }
    <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">1</span>; j &lt; n; ++j ) {
        f[<span class="dv">0</span>][j] = f[<span class="dv">0</span>][j<span class="dv">-1</span>] + grid[<span class="dv">0</span>][j];
    }
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt; m; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">1</span>; j &lt;n; ++j ) {
            f[i][j] = min( f[i<span class="dv">-1</span>][j], f[i][j<span class="dv">-1</span>] ) + grid[i][j];
        }
    }
    <span class="kw">return</span> f[m<span class="dv">-1</span>][n<span class="dv">-1</span>];
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#21160;&#24577;&#35268;&#21010; + &#28378;&#21160;&#25968;&#32452; <code class="fold">@</code></dt>
<dd><p>Works???</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> minPathSum( vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; &amp;grid ) {
    <span class="dt">const</span> <span class="dt">int</span> m = grid.size();
    <span class="dt">const</span> <span class="dt">int</span> n = grid[<span class="dv">0</span>].size();

    <span class="dt">int</span> f[n];
    fill( f, f+n, INT_MAX );                    <span class="co">// !!! important</span>
    f[<span class="dv">0</span>] = <span class="dv">0</span>;                                   <span class="co">// not grid[0][0]</span>

    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; ++i ) {
        f[<span class="dv">0</span>] += grid[i][<span class="dv">0</span>];
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">1</span>; j &lt; n; ++j ) {
            f[j] = min( f[j<span class="dv">-1</span>], f[j] ) + grid[i][j];
        }
    }
    <span class="kw">return</span> f[n<span class="dv">-1</span>];
}</code></pre></div>
</dd>
</dl></li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/minimum-path-sum/">Minimum Path Sum | LeetCode OJ</a></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#38754;&#35797;&#20013;&#24120;&#35265;&#30340;&#21160;&#24577;&#35268;&#21010;&#31867;&#22411; <code class="fold">@</code></dt>
<dd><ul>
<li><strong>&#22352;&#26631;&#22411;&#21160;&#24577;&#35268;&#21010; 15%</strong>
<ul>
<li>state:
<ul>
<li><code>f[x]</code> &#34920;&#31034;&#25105;&#20174;&#36215;&#28857;&#36208;&#21040;&#22352;&#26631; x&#8230;&#8230;</li>
<li><code>f[x][y]</code> &#34920;&#31034;&#25105;&#20174;&#36215;&#28857;&#36208;&#21040;&#22352;&#26631; x,y&#8230;&#8230;</li>
</ul></li>
<li>function: &#30740;&#31350;&#36208;&#21040; x,y &#36825;&#20010;&#28857;&#20043;&#21069;&#30340;&#19968;&#27493;</li>
<li>initialize: &#36215;&#28857;</li>
<li>answer: &#32456;&#28857;</li>
</ul></li>
<li><strong>&#24207;&#21015;&#22411;&#21160;&#24577;&#35268;&#21010; 30%</strong>
<ul>
<li>state: <code>f[i]</code> &#34920;&#31034;&#21069; i &#20010;&#20301;&#32622; / &#25968;&#23383; / &#23383;&#31526;, &#31532; i &#20010;&#8230;</li>
<li>function: <code>f[i]</code> = <code>f[j]</code> &#8230; j &#26159; i &#20043;&#21069;&#30340;&#19968;&#20010;&#20301;&#32622;</li>
<li>initialize: f..</li>
<li>answer: <code>f[n]</code>..
<ul>
<li>&#19968;&#33324; answer &#26159; f(n) &#32780;&#19981;&#26159; f(n-1)</li>
<li>&#22240;&#20026;&#23545;&#20110; n &#20010;&#23383;&#31526;, &#21253;&#21547;&#21069; 0 &#20010;&#23383;&#31526; (&#31354;&#20018;), &#21069; 1 &#20010;&#23383;&#31526;&#8230;&#8230; &#21069; n &#20010;&#23383;&#31526;&#12290;</li>
</ul></li>
</ul></li>
<li><strong>&#21452;&#24207;&#21015;&#21160;&#24577;&#35268;&#21010; 30%</strong></li>
<li>&#21010;&#20998;&#22411;&#21160;&#24577;&#35268;&#21010; 10%</li>
<li>&#32972;&#21253;&#22411;&#21160;&#24577;&#35268;&#21010; 10%</li>
<li>&#21306;&#38388;&#22411;&#21160;&#24577;&#35268;&#21010; 5%</li>
</ul>
<blockquote>
<p>&#22914;&#26524;&#19981;&#26159;&#36319;&#22352;&#26631;&#30456;&#20851;&#30340;&#21160;&#24577;&#35268;&#21010;, &#19968;&#33324;&#26377; N &#20010;&#25968; / &#23383;&#31526;, &#23601;&#24320; N+1 &#20010;&#20301;&#32622;&#30340;&#25968;&#32452;, &#31532; 0 &#20010;&#20301;&#32622;&#21333;&#29420;&#30041;&#20986;&#26469;&#20316;&#21021;&#22987;&#21270;</p>
</blockquote>
</dd>
</dl></li>
<li><p>dp and memoization</p></li>
<li><dl>
<dt>Longest Consecutive Sequence <code class="fold">@</code></dt>
<dd><p>&#24038;&#21491;&#25193;&#24352;&#12290;</p>
<p>TODO</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> longestConsecutive(vector&lt;<span class="dt">int</span>&gt; &amp;num) {
        <span class="dt">int</span> r = <span class="dv">0</span>;
        unordered_set&lt;<span class="dt">int</span>&gt; s;
        <span class="kw">for</span> (<span class="kw">auto</span> i: num)
            s.insert(i);
        <span class="kw">for</span> (<span class="kw">auto</span> i: num) {
            <span class="dt">int</span> j = i, k = i<span class="dv">+1</span>;
            <span class="kw">while</span> (s.count(j<span class="dv">-1</span>)) s.erase(--j);  <span class="co">// j--?</span>
            <span class="kw">while</span> (s.count(k)) s.erase(k++);
            r = max(r, k-j);
        }
        <span class="kw">return</span> r;
    }
};</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/longest-consecutive-sequence/">Longest Consecutive Sequence | LeetCode OJ</a></li>
</ul>
</dd>
</dl></li>
<li><p>longest common subseq</p></li>
<li><p>longest consequtive common subseq</p></li>
<li><p>long M subseq</p></li>
<li><p>backpack</p></li>
<li><dl>
<dt>Word Break &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words. For example, given s = &#8220;leetcode&#8221;, dict = [&#8220;leet&#8221;, &#8220;code&#8221;]. Return true because &#8220;leetcode&#8221; can be segmented as &#8220;leet code&#8221;.</p>
<p>java code:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> Solution {
    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">getMaxLength</span>(Set&lt;String&gt; dict) {
        <span class="dt">int</span> maxLength = <span class="dv">0</span>;
        <span class="kw">for</span> (String word : dict) {
            maxLength = Math.<span class="fu">max</span>(maxLength, word.<span class="fu">length</span>());
        }
        <span class="kw">return</span> maxLength;
    }

    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">wordBreak</span>(String s, Set&lt;String&gt; dict) {
        <span class="kw">if</span> (s == <span class="kw">null</span> || s.<span class="fu">length</span>() == <span class="dv">0</span>) {
            <span class="kw">return</span> <span class="kw">true</span>;
        }

        <span class="dt">int</span> maxLength = <span class="fu">getMaxLength</span>(dict);
        <span class="dt">boolean</span>[] canSegment = <span class="kw">new</span> <span class="dt">boolean</span>[s.<span class="fu">length</span>() + <span class="dv">1</span>];

        canSegment = <span class="kw">true</span>;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= s.<span class="fu">length</span>(); i++) {
            canSegment[i] = <span class="kw">false</span>;
            <span class="kw">for</span> (<span class="dt">int</span> lastWordLength = <span class="dv">1</span>;
                     lastWordLength &lt;= maxLength &amp;&amp; lastWordLength &lt;= i;
                     lastWordLength++) {
                <span class="kw">if</span> (!canSegment[i - lastWordLength]) {
                    <span class="kw">continue</span>;
                }
                String word = s.<span class="fu">substring</span>(i - lastWordLength, i);
                <span class="kw">if</span> (dict.<span class="fu">contains</span>(word)) {
                    canSegment[i] = <span class="kw">true</span>;
                    <span class="kw">break</span>;
                }
            }
        }

        <span class="kw">return</span> canSegment[s.<span class="fu">length</span>()];
    }
}</code></pre></div>
<ul>
<li>state: f[i] &#34920;&#31034;&#8220;&#21069; i&#8221;&#20010;&#23383;&#31526;&#33021;&#21542;&#34987;&#23436;&#32654;&#20999;&#20998;</li>
<li>function: f[i] = OR{f[j] &amp;&amp; j+1~i is a word}, &#20854;&#20013; j &lt; i</li>
<li>initialize: f = true</li>
<li>answer: f[n]</li>
</ul>
<p>&#27880;&#24847;: &#20999;&#20998;&#20301;&#32622;&#30340;&#26522;&#20030; -&gt;&#21333;&#35789;&#38271;&#24230;&#26522;&#20030; O(NL<sup>2</sup>), N: &#23383;&#31526;&#20018;&#38271;&#24230;, L: &#26368;&#38271;&#30340;&#21333;&#35789;&#30340;&#38271;&#24230;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/word-break/">Word Break &#21442;&#32771;&#31243;&#24207; Java/C++/Python</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Palindrome Partitioning <code class="fold">@</code></dt>
<dd><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of s.</p>
<p>For example, given s = &#8220;aab&#8221;, Return</p>
<pre><code>[
  [&quot;aa&quot;,&quot;b&quot;],
  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]
]</code></pre>
<dl>
<dt>&#28145;&#25628; 1 <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#26102;&#38388;&#22797;&#26434;&#24230; O(2^n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(n)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    vector&lt;vector&lt;string&gt;&gt; partition(string s) {
        vector&lt;vector&lt;string&gt;&gt; result;
        vector&lt;string&gt; path;  <span class="co">// &#19968;&#20010;partition&#26041;&#26696;</span>
        dfs(s, path, result, <span class="dv">0</span>, <span class="dv">1</span>);
        <span class="kw">return</span> result;
    }

    <span class="co">// prev &#34920;&#31034;&#21069;&#19968;&#20010;&#38548;&#26495;, start &#34920;&#31034;&#24403;&#21069;&#38548;&#26495;</span>
    <span class="dt">void</span> dfs(string &amp;s, vector&lt;string&gt;&amp; path,
            vector&lt;vector&lt;string&gt;&gt; &amp;result, size_t prev, size_t start) {
        <span class="kw">if</span> (start == s.size()) { <span class="co">// &#26368;&#21518;&#19968;&#20010;&#38548;&#26495;</span>
            <span class="kw">if</span> (isPalindrome(s, prev, start - <span class="dv">1</span>)) { <span class="co">// &#24517;&#39035;&#20351;&#29992;</span>
                path.push_back(s.substr(prev, start - prev));
                result.push_back(path);
                path.pop_back();
            }
            <span class="kw">return</span>;
        }
        <span class="co">// &#19981;&#26029;&#24320;</span>
        dfs(s, path, result, prev, start + <span class="dv">1</span>);
        <span class="co">// &#22914;&#26524;[prev, start-1] &#26159;&#22238;&#25991;&#65292;&#21017;&#21487;&#20197;&#26029;&#24320;&#65292;&#20063;&#21487;&#20197;&#19981;&#26029;&#24320;&#65288;&#19978;&#19968;&#34892;&#24050;&#32463;&#20570;&#20102;&#65289;</span>
        <span class="kw">if</span> (isPalindrome(s, prev, start - <span class="dv">1</span>)) {
            <span class="co">// &#26029;&#24320;</span>
            path.push_back(s.substr(prev, start - prev));
            dfs(s, path, result, start, start + <span class="dv">1</span>);
            path.pop_back();
        }
    }

    <span class="dt">bool</span> isPalindrome(<span class="dt">const</span> string &amp;s, <span class="dt">int</span> start, <span class="dt">int</span> end) {
        <span class="kw">while</span> (start &lt; end &amp;&amp; s[start] == s[end]) {
            ++start;
            --end;
        }
        <span class="kw">return</span> start &gt;= end;
    }
};</code></pre></div>
</dd>
<dt>&#28145;&#25628; 2 <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#26102;&#38388;&#22797;&#26434;&#24230; O(2^n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(n)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    vector&lt;vector&lt;string&gt;&gt; partition(string s) {
        vector&lt;vector&lt;string&gt;&gt; result;
        vector&lt;string&gt; path;  <span class="co">// &#19968;&#20010;partition&#26041;&#26696;</span>
        dfs(s, path, result, <span class="dv">0</span>, <span class="dv">1</span>);
        <span class="kw">return</span> result;
    }

    <span class="co">// prev &#34920;&#31034;&#21069;&#19968;&#20010;&#38548;&#26495;, start &#34920;&#31034;&#24403;&#21069;&#38548;&#26495;</span>
    <span class="dt">void</span> dfs(string &amp;s, vector&lt;string&gt;&amp; path,
            vector&lt;vector&lt;string&gt;&gt; &amp;result, size_t prev, size_t start) {
        <span class="kw">if</span> (start == s.size()) { <span class="co">// &#26368;&#21518;&#19968;&#20010;&#38548;&#26495;</span>
            <span class="kw">if</span> (isPalindrome(s, prev, start - <span class="dv">1</span>)) { <span class="co">// &#24517;&#39035;&#20351;&#29992;</span>
                path.push_back(s.substr(prev, start - prev));
                result.push_back(path);
                path.pop_back();
            }
            <span class="kw">return</span>;
        }
        <span class="co">// &#19981;&#26029;&#24320;</span>
        dfs(s, path, result, prev, start + <span class="dv">1</span>);
        <span class="co">// &#22914;&#26524;[prev, start-1] &#26159;&#22238;&#25991;&#65292;&#21017;&#21487;&#20197;&#26029;&#24320;&#65292;&#20063;&#21487;&#20197;&#19981;&#26029;&#24320;&#65288;&#19978;&#19968;&#34892;&#24050;&#32463;&#20570;&#20102;&#65289;</span>
        <span class="kw">if</span> (isPalindrome(s, prev, start - <span class="dv">1</span>)) {
            <span class="co">// &#26029;&#24320;</span>
            path.push_back(s.substr(prev, start - prev));
            dfs(s, path, result, start, start + <span class="dv">1</span>);
            path.pop_back();
        }
    }

    <span class="dt">bool</span> isPalindrome(<span class="dt">const</span> string &amp;s, <span class="dt">int</span> start, <span class="dt">int</span> end) {
        <span class="kw">while</span> (start &lt; end &amp;&amp; s[start] == s[end]) {
            ++start;
            --end;
        }
        <span class="kw">return</span> start &gt;= end;
    }
};</code></pre></div>
</dd>
<dt>&#21160;&#24402; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#21160;&#35268;&#65292;&#26102;&#38388;&#22797;&#26434;&#24230; O(n^2)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(1)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    vector&lt;vector&lt;string&gt; &gt; partition(string s) {
        <span class="dt">const</span> <span class="dt">int</span> n = s.size();
        <span class="dt">bool</span> p[n][n]; <span class="co">// whether s[i,j] is palindrome</span>
        fill_n(&amp;p[<span class="dv">0</span>][<span class="dv">0</span>], n * n, <span class="kw">false</span>);
        <span class="kw">for</span> (<span class="dt">int</span> i = n - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; --i)
            <span class="kw">for</span> (<span class="dt">int</span> j = i; j &lt; n; ++j)
                p[i][j] = s[i] == s[j] &amp;&amp; ((j - i &lt; <span class="dv">2</span>) || p[i + <span class="dv">1</span>][j - <span class="dv">1</span>]);

        vector&lt;vector&lt;string&gt; &gt; sub_palins[n]; <span class="co">// sub palindromes of s[0,i]</span>
        <span class="kw">for</span> (<span class="dt">int</span> i = n - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; --i) {
            <span class="kw">for</span> (<span class="dt">int</span> j = i; j &lt; n; ++j)
                <span class="kw">if</span> (p[i][j]) {
                    <span class="dt">const</span> string palindrome = s.substr(i, j - i + <span class="dv">1</span>);
                    <span class="kw">if</span> (j + <span class="dv">1</span> &lt; n) {
                        <span class="kw">for</span> (<span class="kw">auto</span> v : sub_palins[j + <span class="dv">1</span>]) {
                            v.insert(v.begin(), palindrome);
                            sub_palins[i].push_back(v);
                        }
                    } <span class="kw">else</span> {
                        sub_palins[i].push_back(vector&lt;string&gt; { palindrome });
                    }
                }
        }
        <span class="kw">return</span> sub_palins[<span class="dv">0</span>];
    }
};</code></pre></div>
</dd>
<dt>&#21160;&#24402; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Palindrome Partitioning</span>
<span class="ot">#define ROF(i, a, b) for (int i = (b); --i &gt;= (a); )</span>
<span class="ot">#define FOR(i, a, b) for (int i = (a); i &lt; (b); i++)</span>
<span class="ot">#define REP(i, n) for (int i = 0; i &lt; (n); i++)</span>

<span class="kw">class</span> Solution {
<span class="kw">private</span>:
    vector&lt;vector&lt;<span class="dt">bool</span>&gt;&gt; f;
    vector&lt;string&gt; rr;
    vector&lt;vector&lt;string&gt;&gt; r;
    <span class="dt">void</span> g(string &amp;s, <span class="dt">int</span> i) {
        <span class="kw">if</span> (i == s.size())
            r.push_back(rr);
        <span class="kw">else</span>
            REP(j, s.size())
                <span class="kw">if</span> (f[i][j]) {
                    rr.push_back(s.substr(i, j-i<span class="dv">+1</span>));
                    g(s, j<span class="dv">+1</span>);
                    rr.pop_back();
                }
    }
<span class="kw">public</span>:
    vector&lt;vector&lt;string&gt;&gt; partition(string s) {
        <span class="dt">int</span> n = s.size();
        f.assign(n, vector&lt;<span class="dt">bool</span>&gt;(n));
        ROF(i, <span class="dv">0</span>, n) {
            f[i][i] = <span class="kw">true</span>;
            <span class="kw">if</span> (i<span class="dv">+1</span> &lt; n &amp;&amp; s[i] == s[i<span class="dv">+1</span>])
                f[i][i<span class="dv">+1</span>] = <span class="kw">true</span>;
            FOR(j, i<span class="dv">+2</span>, n)
                f[i][j] = f[i<span class="dv">+1</span>][j<span class="dv">-1</span>] &amp;&amp; s[i] == s[j];
        }
        r.clear();
        g(s, <span class="dv">0</span>);
        <span class="kw">return</span> r;
    }
};</code></pre></div>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/palindrome-partitioning/">Palindrome Partitioning | LeetCode OJ</a></li>
<li><a href="http://www.jiuzhang.com/solutions/palindrome-partitioning-ii/">Palindrome Partitioning II &#21442;&#32771;&#31243;&#24207; Java/C++/Python</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>TODO <code class="fold">@</code></dt>
<dd><ul>
<li><p>&#21333;&#24207;&#21015;&#21160;&#24577;&#35268;&#21010;&#65288;&#19979;&#65289; Sequnece DP</p></li>
<li><dl>
<dt>&#21452;&#24207;&#21015;&#21160;&#24577;&#35268;&#21010; Two Sequences DP <code class="fold">@</code></dt>
<dd><ul>
<li>state: <code>f[i][j]</code> &#20195;&#34920;&#20102;&#31532;&#19968;&#20010; sequence &#30340;&#21069; i &#20010;&#25968;&#23383; / &#23383;&#31526;, &#37197;&#19978;&#31532;&#20108;&#20010; sequence &#30340;&#21069; j &#20010;&#8230;</li>
<li>function: <code>f[i][j]</code> = &#30740;&#31350;&#31532; i &#20010;&#21644;&#31532; j &#20010;&#30340;&#21305;&#37197;&#20851;&#31995;</li>
<li>initialize: <code>f[i]</code> &#21644; <code>f[i]</code></li>
<li>answer: <code>f[n][m]</code></li>
<li>n = s1.length()</li>
<li>m = s2.length()</li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>problems <code class="fold">@</code></dt>
<dd><dl>
<dt>&#27714; Max, <a href="http://www.jiuzhang.com/solutions/longest-common-subsequence/">Longest Common Subsequence &#21442;&#32771;&#31243;&#24207; Java/C++/Python</a> <code class="fold">@</code></dt>
<dd><ul>
<li><p>http://www.lintcode.com/problem/longest-common-substring/</p></li>
<li><p>state: <code>f[i][j]</code> &#34920;&#31034;&#21069; i &#20010;&#23383;&#31526;&#37197;&#19978;&#21069; j &#20010;&#23383;&#31526;&#30340; LCS &#30340;&#38271;&#24230;</p></li>
<li><p>function:</p>
<pre><code>f[i][j]` = MAX(f[i-1][j], f[i][j-1], f[i-1][j-1] + 1)
// A[i - 1] == B[j - 1] = MAX(f[i-1][j], f[i][j-1]) // A[i - 1] != B[j - 1]</code></pre></li>
<li><p>intialize: f[i] = 0 f[j] = 0</p></li>
<li><p>answer: f[n][m]</p></li>
</ul>
</dd>
</dl>
<p>&#27714; Min, <a href="http://www.jiuzhang.com/solutions/edit-distance/">Edit Distance &#21442;&#32771;&#31243;&#24207; Java/C++/Python</a></p>
<dl>
<dt>&#27714;&#26041;&#26696;&#24635;&#25968;, <a href="http://www.jiuzhang.com/solutions/distinct-subsequences/">Distinct Subsequences &#21442;&#32771;&#31243;&#24207; Java/C++/Python</a> <code class="fold">@</code></dt>
<dd><ul>
<li><p>state: <code>f[i][j]</code> &#34920;&#31034; S &#30340;&#21069; i &#20010;&#23383;&#31526;&#20013;&#36873;&#21462; T &#30340;&#21069; j &#20010;&#23383;&#31526;, &#26377;&#22810;&#23569;&#31181;&#26041;&#26696;</p></li>
<li><p>function: <code>f[i][j]</code> = <code>f[i - 1][j]</code> + <code>f[i - 1][j - 1]</code> <code>// S[i-1] == T[j-1] = f[i - 1][j] // S[i-1] != T[j-1]</code></p></li>
<li><p>initialize: <code>f[i] = 1, f[j] = 0 (j &gt; 0)</code></p></li>
<li><p>answer: <code>f[n][m] (n = sizeof(S), m = sizeof(T))</code></p></li>
</ul>
</dd>
</dl>
<p>&#27714;&#26159;&#21542;&#21487;&#34892;, <a href="http://www.jiuzhang.com/solutions/interleaving-string/">Interleaving String &#21442;&#32771;&#31243;&#24207; Java/C++/Python</a></p>
<p>&#20160;&#20040;&#24773;&#20917;&#19979;&#21487;&#33021;&#20351;&#29992;/&#19981;&#29992;&#21160;&#24577;&#35268;&#21010;?</p>
<ul>
<li>&#26368;&#22823;&#20540;&#26368;&#23567;&#20540; / &#26159;&#21542;&#21487;&#34892; / &#26041;&#26696;&#24635;&#25968;</li>
<li>&#27714;&#25152;&#26377;&#26041;&#26696; / &#38598;&#21512;&#32780;&#19981;&#26159;&#24207;&#21015; / &#25351;&#25968;&#32423;&#21040;&#22810;&#39033;&#24335;</li>
<li>&#35299;&#20915;&#21160;&#24577;&#35268;&#21010;&#38382;&#39064;&#30340;&#22235;&#28857;&#35201;&#32032;</li>
<li>&#29366;&#24577;, &#26041;&#31243;, &#21021;&#22987;&#21270;, &#31572;&#26696;</li>
<li>&#19977;&#31181;&#38754;&#35797;&#24120;&#35265;&#30340;&#21160;&#24577;&#35268;&#21010;&#31867;&#21035;&#21450;&#29366;&#24577;&#29305;&#28857;</li>
<li>&#22352;&#26631;, &#21333;&#24207;&#21015;, &#21452;&#24207;&#21015;</li>
<li>&#20004;&#25307;&#29420;&#23396;&#20061;&#21073;</li>
<li>&#20108;&#32500; DP &#38656;&#35201;&#21021;&#22987;&#21270;&#31532; 0 &#34892;&#21644;&#31532; 0 &#21015;</li>
<li>n &#20010;&#23383;&#31526;&#30340;&#23383;&#31526;&#20018;&#35201;&#24320; n+1 &#20010;&#20301;&#32622;&#30340;&#25968;&#32452;</li>
</ul>
<dl>
<dt>&#20854;&#20182;&#31867;&#22411;&#30340;&#21160;&#24577;&#35268;&#21010;(&#31639;&#27861;&#24378;&#21270;&#29677;) <code class="fold">@</code></dt>
<dd><p>&#32972;&#21253;&#31867;:</p>
<ul>
<li>http://www.lintcode.com/problem/backpack/</li>
<li>http://www.lintcode.com/problem/backpack-ii/</li>
<li>http://www.lintcode.com/problem/minimum-adjustment-cost/</li>
<li>http://www.lintcode.com/problem/k-sum/</li>
</ul>
<p>&#21306;&#38388;&#31867;:</p>
<ul>
<li>http://www.lintcode.com/problem/coins-in-a-line-iii/</li>
<li>http://www.lintcode.com/problem/scramble-string/</li>
</ul>
<p>&#21010;&#20998;&#31867;:</p>
<ul>
<li>http://www.lintcode.com/problem/best-time-to-buy-and-sell-stock-iv/</li>
<li>http://www.lintcode.com/problem/maximum-subarray-iii/</li>
</ul>
</dd>
</dl>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/08/14 &#19978;&#21320; 9:30:00 5. &#21160;&#24577;&#35268;&#21010; Dynamic Programming II <code class="fold">@</code></dt>
<dd><dl>
<dt>Theories <code class="fold">@</code></dt>
<dd><p>&#22914;&#26524;&#19968;&#20010;&#38382;&#39064;&#20855;&#26377;&#20197;&#19979;&#20004;&#20010;&#35201;&#32032;&#65306;</p>
<ul>
<li>&#26368;&#20248;&#23376;&#32467;&#26500; (optimal substructure)</li>
<li>(&#26080;&#21518;&#25928;&#24615;)</li>
<li>&#37325;&#21472;&#23376;&#38382;&#39064; (overlapping subproblem), &#35813;&#24615;&#36136;&#24182;&#19981;&#26159;&#21160;&#24577;&#35268;&#21010;&#36866;&#29992;&#30340;&#24517;&#35201;&#26465;&#20214;&#65292;&#20294;&#26159;&#22914;&#26524;&#27809;&#26377;&#36825;&#26465;&#24615;&#36136;&#65292;&#21160;&#24577;&#35268;&#21010;&#31639;&#27861;&#21516;&#20854;&#20182;&#31639;&#27861;&#30456;&#27604;&#23601;&#19981;&#20855;&#22791;&#20248;&#21183;</li>
</ul>
<p>&#21017;&#21487;&#20197;&#29992;&#21160;&#24577;&#35268;&#21010;&#27714;&#26368;&#20248;&#35299;&#12290;</p>
<p>&#21160;&#24577;&#35268;&#21010;&#20998;&#20026; 4 &#20010;&#27493;&#39588;&#65306;</p>
<ol style="list-style-type: decimal">
<li>&#25551;&#36848;&#26368;&#20248;&#35299;&#30340;&#32467;&#26500;&#12290;&#21363;&#25277;&#35937;&#20986;&#19968;&#20010;&#29366;&#24577;&#26469;&#34920;&#31034;&#26368;&#20248;&#35299;&#12290;</li>
<li>&#36882;&#24402;&#30340;&#23450;&#20041;&#26368;&#20248;&#35299;&#30340;&#20540;&#12290;&#25214;&#20986;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#65292;&#28982;&#21518;&#36882;&#24402;&#30340;&#23450;&#20041;</li>
<li>&#35745;&#31639;&#26368;&#20248;&#35299;&#30340;&#20540;&#12290;&#20856;&#22411;&#30340;&#20570;&#27861;&#26159;&#33258;&#24213;&#21521;&#19978; (bottom-up, iteration)&#65292;&#24403;&#28982;&#20063;&#21487;&#20197;&#33258;&#39030;&#21521;&#19979; (top-down, memoization)&#12290;</li>
<li>&#26681;&#25454;&#35745;&#31639;&#36807;&#31243;&#20013;&#24471;&#21040;&#30340;&#20449;&#24687;&#65292;&#26500;&#36896;&#20986;&#26368;&#20248;&#35299;&#12290;&#22914;&#26524;&#25105;&#20204;&#21482;&#38656;&#35201;&#26368;&#20248;&#35299;&#30340;&#20540;&#65292;&#19981;&#38656;&#35201;&#26368;&#20248;&#35299;&#26412;&#36523;&#65292;&#21017;&#21487;&#20197;&#24573;&#30053;&#31532; 4 &#27493;&#12290;&#24403;&#25191;&#34892;&#31532; 4 &#27493;&#26102;&#65292;&#25105;&#20204;&#38656;&#35201;&#22312;&#31532; 3 &#27493;&#30340;&#36807;&#31243;&#20013;&#32500;&#25252;&#19968;&#20123;&#39069;&#22806;&#30340;&#20449;&#24687;&#65292;&#20197;&#20415;&#25105;&#20204;&#33021;&#26041;&#20415;&#30340;&#26500;&#36896;&#20986;&#26368;&#20248;&#35299;&#12290;</li>
</ol>
<p>&#22312;&#31532; 1 &#27493;&#20013;&#65292;&#25105;&#20204;&#38656;&#35201;&#25277;&#35937;&#20986;&#19968;&#20010;&#8220;&#29366;&#24577;&#8221;&#65292;&#22312;&#31532; 2 &#27493;&#20013;&#65292;&#25105;&#20204;&#35201;&#25214;&#20986;&#8220;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#8221;&#65292;&#28982;&#21518;&#25165;&#33021;&#36882;&#24402;&#30340;&#23450;&#20041;&#26368;&#20248;&#35299;&#30340;&#20540;&#12290;&#31532; 3 &#27493;&#21644;&#31532; 4 &#27493;&#23601;&#26159;&#20889;&#20195;&#30721;&#23454;&#29616;&#20102;&#12290;</p>
<p>&#20889;&#20195;&#30721;&#23454;&#29616;&#26102;&#26377;&#20004;&#31181;&#26041;&#24335;&#65292;&#8220;&#36882;&#24402; (recursive)+ &#33258;&#39030;&#21521;&#19979; (top-down)+ &#34920;&#26684;&#8221;&#21644;&#8220;&#33258;&#24213;&#21521;&#19978; (bottom-up) + &#34920;&#26684;&#8221;&#12290;&#21069;&#32773;&#23646;&#20110;&#19968;&#31181; memoization &#65288;&#32763;&#35793;&#20026;&#22791;&#24536;&#24405;&#27861;&#65289;&#65292;&#21518;&#32773;&#25165;&#26159;&#27491;&#23447;&#30340;&#21160;&#35268;&#12290;</p>
<p>&#21160;&#35268;&#29992;&#34920;&#26684;&#23558;&#21508;&#20010;&#23376;&#38382;&#39064;&#30340;&#26368;&#20248;&#35299;&#23384;&#36215;&#26469;&#65292;&#36991;&#20813;&#37325;&#22797;&#35745;&#31639;&#65292;&#26159;&#19968;&#31181;&#31354;&#38388;&#25442;&#26102;&#38388;&#12290;</p>
<p><strong>&#21160;&#35268;&#19982;&#36138;&#24515;</strong></p>
<ul>
<li>&#30456;&#21516;&#28857;&#65306;&#26368;&#20248;&#23376;&#32467;&#26500;&#12290;</li>
<li>&#19981;&#21516;&#28857;&#65306;
<ul>
<li>1&#12289;&#21160;&#35268;&#30340;&#23376;&#38382;&#39064;&#26159;&#37325;&#21472;&#30340;&#65292;&#32780;&#36138;&#24515;&#30340;&#23376;&#38382;&#39064;&#26159;&#19981;&#37325;&#21472;&#30340; (disjoint subproblems)&#65307;</li>
<li>2&#12289;&#21160;&#35268;&#19981;&#20855;&#26377;&#36138;&#24515;&#36873;&#25321;&#24615;&#36136;&#65307;</li>
<li>3&#12289;&#36138;&#24515;&#30340;&#21069;&#36827;&#36335;&#32447;&#26159;&#19968;&#26465;&#32447;&#65292;&#32780;&#21160;&#35268;&#26159;&#19968;&#20010; DAG&#12290;</li>
</ul></li>
</ul>
<p><strong>&#20998;&#27835;&#21644;&#36138;&#24515;</strong>&#30340;&#30456;&#21516;&#28857;&#65306;disjoint subproblems&#12290;</p>
<p><strong>&#21160;&#35268;&#21644;&#22791;&#24536;&#24405;&#27861;</strong>&#30340;&#21306;&#21035;</p>
<ul>
<li>&#21160;&#35268; (dynamic programming) &#19968;&#23450;&#26159;&#33258;&#24213;&#21521;&#19978;&#30340;&#65292;&#22791;&#24536;&#24405;&#27861; (memoization) &#19968;&#23450;&#26159;&#33258;&#39030;&#21521;&#19979;&#30340;&#12290;</li>
<li>&#21160;&#35268;&#19981;&#26159; lazy &#30340;&#65292; memoization &#26159; lazy &#30340;&#65292;&#26159;&#25353;&#38656; (on-demand) &#35745;&#31639;&#30340;&#12290;&#25152;&#20197;&#65292;&#22914;&#26524;&#25152;&#26377;&#30340;&#23376;&#38382;&#39064;&#33267;&#23569;&#20250;&#30896;&#21040;&#19968;&#27425;&#65292;&#21017;&#21160;&#35268;&#26377;&#20248;&#21183;&#65307;&#22914;&#26524;&#26377;&#20123;&#23376;&#38382;&#39064;&#22312;&#25628;&#32034;&#36807;&#31243;&#20013;&#19981;&#20250;&#34987;&#30896;&#21040;&#65288;&#21363;&#26377;&#21098;&#26525;&#65289;&#65292;&#21017; memorization &#26377;&#20248;&#21183;&#12290;&#26356;&#35814;&#32454;&#30340;&#35299;&#37322;&#35831;&#21442;&#32771; StackOverflow &#19978;&#30340;&#36825;&#20010;&#24086;&#23376; <a href="http://t.cn/z80ZS6B" class="uri">http://t.cn/z80ZS6B</a>&#12290;</li>
<li>&#22791;&#24536;&#24405;&#27861;&#21487;&#20197;&#23454;&#29616;&#36319;&#21160;&#35268;&#31867;&#20284;&#30340;&#21151;&#33021;&#65292;&#20294;&#23427;&#19981;&#26159;&#21160;&#35268;&#12290;&#20004;&#32773;&#30340;&#26041;&#21521;&#26159;&#21453;&#30340;&#65292;&#19968;&#20010;&#26159;&#33258;&#39030;&#21521;&#19979;&#65292;&#19968;&#20010;&#33258;&#24213;&#21521;&#19978;&#65292;&#25105;&#20204;&#24212;&#35813;&#21306;&#20998;&#24320;&#36825;&#20004;&#20010;&#27010;&#24565;&#12290;&#26412;&#20070;&#21518;&#38754;&#25552;&#21040;&#30340;&#21160;&#35268;&#65292;&#37117;&#26159;&#25351;&#33258;&#24213;&#21521;&#19978;&#30340;&#21160;&#35268;&#12290;</li>
</ul>
</dd>
</dl>
<ul>
<li><dl>
<dt>longest common subsequence <code class="fold">@</code></dt>
<dd><p>&#19968;&#20010;&#24207;&#21015;&#30340;&#23376;&#24207;&#21015; (subsequence) &#26159;&#25351;&#22312;&#35813;&#24207;&#21015;&#20013;&#21024;&#21435;&#33509;&#24178;&#65288;&#21487;&#20197;&#20026; 0 &#20010;&#65289;&#20803;&#32032;&#21518;&#24471;&#21040;&#30340;&#24207;&#21015;&#12290;&#20934;&#30830;&#30340;&#35828;&#65292;&#33509;&#32473;&#23450;&#24207;&#21015; X = (x<sub>1</sub>, x<sub>2</sub>, &#8230;, x<sub>m</sub>)&#65292;&#21017;&#21478;&#19968;&#20010;&#24207;&#21015; Z = (z<sub>1</sub>, z<sub>2</sub>, &#8230;, z<sub>k</sub>)&#65292;&#26159; X &#30340;&#23376;&#24207;&#21015;&#26159;&#25351;&#23384;&#22312;&#19968;&#20010;&#20005;&#26684;&#36882;&#22686;&#19979;&#26631;&#24207;&#21015; (i<sub>1</sub>, i<sub>2</sub>, &#8230;, i<sub>k</sub>) &#20351;&#24471;&#23545;&#20110;&#25152;&#26377; j=1, 2, &#8230;, k &#26377; z<sub>j</sub>=x<sub>i_j</sub>&#12290;&#20363;&#22914;&#65292;&#24207;&#21015; Z = (B, C, D, B) &#26159;&#24207;&#21015; X = (A, B, C, B, D, A, B) &#30340;&#23376;&#24207;&#21015;&#65292;&#30456;&#24212;&#30340;&#36882;&#22686;&#19979;&#26631;&#24207;&#21015;&#20026; (1, 2, 4, 6)&#12290;</p>
<p>&#32473;&#23450;&#20004;&#20010;&#24207;&#21015; X &#21644; Y&#65292;&#27714; X &#21644; Y &#30340;&#26368;&#38271;&#20844;&#20849;&#23376;&#24207;&#21015; (longest common subsequence)&#12290;</p>
<pre><code>&#36755;&#20837;

    &#36755;&#20837;&#21253;&#25324;&#22810;&#32452;&#27979;&#35797;&#25968;&#25454;&#65292;&#27599;&#32452;&#25968;&#25454;&#21344;&#19968;&#34892;&#65292;&#21253;&#21547;&#20004;&#20010;&#23383;&#31526;&#20018;&#65288;&#23383;&#31526;
    &#20018;&#38271;&#24230;&#19981;&#36229;&#36807; 200&#65289;&#65292;&#20195;&#34920;&#20004;&#20010;&#24207;&#21015;&#12290;&#20004;&#20010;&#23383;&#31526;&#20018;&#20043;&#38388;&#30001;&#33509;&#24178;&#20010;&#31354;
    &#26684;&#38548;&#24320;&#12290;

    abcfbc abfcab
    programming contest
    abcd mnp
    nicenice nice

&#36755;&#20986;

    &#23545;&#27599;&#32452;&#27979;&#35797;&#25968;&#25454;&#65292;&#36755;&#20986;&#26368;&#22823;&#20844;&#20849;&#23376;&#24207;&#21015;&#30340;&#38271;&#24230;&#65292;&#27599;&#32452;&#19968;&#34892;&#12290;

    4   &quot;abcb&quot;
    2   &quot;on&quot;
    0   &quot;&quot;
    4   &quot;nice&quot;</code></pre>
<p>&#26368;&#38271;&#20844;&#20849;&#23376;&#24207;&#21015;&#38382;&#39064;&#20855;&#26377;&#26368;&#20248;&#23376;&#32467;&#26500;&#24615;&#36136;&#12290;</p>
<pre><code>if X[m] &amp; Y[n] ---&gt; Z[k], and

a)      x[m] == y[n], then
                                z[k] = x[m] = y[n], X[m-1] &amp; Y[n-1] ---&gt; Z[k-1]
b)      x[m] != y[n], and
    b1. z[k] != x[m], then
                                X[m-1] &amp; Y[n] ---&gt; Z[k]
    b2. z[k] != y[m], then
                                X[m] &amp; Y[n-1] ---&gt; Z[k]</code></pre>
<p>&#35774;&#29366;&#24577;&#20026; <code>d[i][j]</code>&#65292;&#34920;&#31034;&#24207;&#21015; X<sub>i</sub> &#21644; Y<sub>j</sub> &#30340;&#26368;&#38271;&#20844;&#20849;&#23376;&#24207;&#21015;&#30340;&#38271;&#24230;&#12290;&#30001;&#26368;&#20248;&#23376;&#32467;&#26500;&#21487;&#24471;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#22914;&#19979;&#65306;</p>
<pre><code>                0                               i=0, or j=0
d[i][j]=        d[i-1][j-1] + 1                 i,j&gt;0, x_i == y_i
                max{ d[i][j-1], d[i-1][j] }     i,j&gt;0, x_i != y_i</code></pre>
<p>&#22914;&#26524;&#35201;&#25171;&#21360;&#20986;&#26368;&#38271;&#20844;&#20849;&#23376;&#24207;&#21015;&#65292;&#38656;&#35201;&#21478;&#35774;&#19968;&#20010;&#25968;&#32452; p&#65292;<code>p[i][j]</code> &#35760;&#24405; <code>d[i][j]</code> &#26159;&#30001;&#21738;&#20010;&#23376;&#38382;&#39064;&#24471;&#21040;&#30340;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>

<span class="ot">#define MAX 201                         </span><span class="co">// &#23383;&#31526;&#20018;&#26368;&#22823;&#38271;&#24230;&#20026;200</span>

<span class="dt">char</span> x[MAX], y[MAX];
<span class="dt">int</span> d[MAX][MAX];                        <span class="co">// d[i][j] &#34920;&#31034;&#24207;&#21015; Xi &#21644; Yj &#30340;&#26368;&#38271;&#20844;&#20849;&#23376;&#24207;&#21015;&#30340;&#38271;&#24230;</span>

<span class="dt">void</span> lcs( <span class="dt">const</span> <span class="dt">char</span> *x, <span class="dt">const</span> <span class="dt">int</span> m, <span class="dt">const</span> <span class="dt">char</span> *y, <span class="dt">const</span> <span class="dt">int</span> n ) {
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= m; ++i ) { d[i][<span class="dv">0</span>] = <span class="dv">0</span>; }                          <span class="co">// &#36793;&#30028;&#21021;&#22987;&#21270;</span>
    <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= n; ++j ) { d[<span class="dv">0</span>][j] = <span class="dv">0</span>; }
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= m; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= n; ++j ) {
            <span class="kw">if</span>( x[i<span class="dv">-1</span>] == y[j<span class="dv">-1</span>] ) {
                d[i][j] = d[i<span class="dv">-1</span>][j<span class="dv">-1</span>] + <span class="dv">1</span>;
            } <span class="kw">else</span> {
                d[i][j] = d[i<span class="dv">-1</span>][j] &gt; d[i][j<span class="dv">-1</span>] ? d[i<span class="dv">-1</span>][j] : d[i][j<span class="dv">-1</span>];    <span class="co">// choose the bigger one</span>
            }
        }
    }
}

<span class="dt">void</span> lcs_extend(<span class="dt">const</span> <span class="dt">char</span> *x, <span class="dt">const</span> <span class="dt">int</span> m, <span class="dt">const</span> <span class="dt">char</span> *y, <span class="dt">const</span> <span class="dt">int</span> n);
<span class="dt">void</span> lcs_print(<span class="dt">const</span> <span class="dt">char</span> *x, <span class="dt">const</span> <span class="dt">int</span> m, <span class="dt">const</span> <span class="dt">char</span> *y, <span class="dt">const</span> <span class="dt">int</span> n);

<span class="dt">int</span> main() {
    <span class="kw">while</span> ( <span class="dv">2</span> == scanf (<span class="st">&quot;</span><span class="ch">%s%s</span><span class="st">&quot;</span>, x, y) ) {
        <span class="dt">const</span> <span class="dt">int</span> lx = strlen(x);
        <span class="dt">const</span> <span class="dt">int</span> ly = strlen(y);
        lcs(x, lx, y, ly);
        printf (<span class="st">&quot;</span><span class="ch">%d\t</span><span class="st">&quot;</span>, d[lx][ly] );
        {
            lcs_extend(x, lx, y, ly);
            printf(<span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">&quot;</span>);
            lcs_print(x, lx, y, ly);
            printf(<span class="st">&quot;</span><span class="ch">\&quot;\n</span><span class="st">&quot;</span>);
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> p[MAX][MAX];  <span class="co">// p[i][j] &#35760;&#24405; d[i][j] &#26159;&#30001;&#21738;&#20010;&#23376;&#38382;&#39064;&#24471;&#21040;&#30340;</span>

<span class="dt">void</span> lcs_extend( <span class="dt">const</span> <span class="dt">char</span> *x, <span class="dt">const</span> <span class="dt">int</span> m, <span class="dt">const</span> <span class="dt">char</span> *y, <span class="dt">const</span> <span class="dt">int</span> n ) {
    memset( p, <span class="dv">0</span>, <span class="kw">sizeof</span>(p) );                      <span class="co">// sizeof(p) == MAX*MAX*sizeof(int)</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= m; ++i ) { d[i][<span class="dv">0</span>] = <span class="dv">0</span>; }  <span class="co">// &#36793;&#30028;&#21021;&#22987;&#21270;</span>
    <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= n; ++j ) { d[<span class="dv">0</span>][j] = <span class="dv">0</span>; }
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= m; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= n; ++j ) {
            <span class="kw">if</span> (x[i<span class="dv">-1</span>] == y[j<span class="dv">-1</span>]) {
                d[i][j] = d[i<span class="dv">-1</span>][j<span class="dv">-1</span>] + <span class="dv">1</span>;
                p[i][j] = <span class="dv">1</span>;
            } <span class="kw">else</span> {
                <span class="kw">if</span> (d[i<span class="dv">-1</span>][j] &gt;= d[i][j<span class="dv">-1</span>]) {
                    d[i][j] = d[i<span class="dv">-1</span>][j];
                    p[i][j] = <span class="dv">2</span>;
                } <span class="kw">else</span> {
                    d[i][j] = d[i][j<span class="dv">-1</span>];
                    p[i][j] = <span class="dv">3</span>;
                }
            }
        }
    }
}

<span class="dt">void</span> lcs_print( <span class="dt">const</span> <span class="dt">char</span> *x, <span class="dt">const</span> <span class="dt">int</span> m, <span class="dt">const</span> <span class="dt">char</span> *y, <span class="dt">const</span> <span class="dt">int</span> n ) {
    <span class="kw">if</span> ( !m || !n ) { <span class="kw">return</span>; }
    <span class="kw">if</span> (p[m][n] == <span class="dv">1</span>) {
        lcs_print(x, m - <span class="dv">1</span>, y, n - <span class="dv">1</span>);
        printf(<span class="st">&quot;</span><span class="ch">%c</span><span class="st">&quot;</span>, x[m - <span class="dv">1</span>]);
    } <span class="kw">else</span> <span class="kw">if</span> (p[m][n] == <span class="dv">2</span>) {
        lcs_print(x, m - <span class="dv">1</span>, y, n);
    } <span class="kw">else</span> {
        lcs_print(x, m, y, n - <span class="dv">1</span>);
    }
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>maximum continuous subsequence sum <code class="fold">@</code></dt>
<dd><p>Maximum Subarray (dup)</p>
<dl>
<dt>take a peak</dt>
<dd><ul>
<li><code>f[j] = max( f[j-1]+S[j], S[j] ), j = 2..n, f = S</code></li>
<li><code>target = max{ f[j] }, j = 1..n</code></li>
</ul>
<p>&#20195;&#30721;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Time: O(n), Space: O(1)</span>
<span class="dt">int</span> maxSubArray( vector&lt;<span class="dt">int</span>&gt; &amp;nums ) {
    <span class="dt">int</span> result = INT_MIN, f = <span class="dv">0</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nums.size(); ++i ) {
        f = max( f+nums[i], nums[i] );
        result = max( f, result );
    }
    <span class="kw">return</span> result;
}</code></pre></div>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>&#26368;&#22823; M &#23376;&#27573;&#21644;, maximum m segments sum <code class="fold">@</code></dt>
<dd><p>&#32473;&#23450;&#19968;&#20010;&#25972;&#25968;&#24207;&#21015; S<sub>1</sub>, S<sub>2</sub>, &#8230;, S<sub>n</sub> (1 &lt;= n &lt;= 1,000,000, -32768 &lt;= S<sub>i</sub> &lt;= 32768)&#65292;&#23450;&#20041;&#20989;&#25968; sum(i,j)= S<sub>i</sub> + &#8230; + S<sub>j</sub> (1 &lt;= i &lt;= j &lt;= n)&#12290;</p>
<p>&#29616;&#32473;&#23450;&#19968;&#20010;&#27491;&#25972;&#25968; m&#65292;&#25214;&#20986; m &#23545; i &#21644; j&#65292;&#20351;&#24471; sum(i<sub>1</sub>,j<sub>1</sub>) + sum(i<sub>2</sub>,j<sub>2</sub>) + &#8230; + sum(i<sub>m</sub>,j<sub>m</sub>) &#26368;&#22823;&#12290;&#36825;&#23601;&#26159; <strong>&#26368;&#22823; M &#23376;&#27573;&#21644; (maximum m segments sum)</strong>&#12290;</p>
<pre><code>input:

    &#27599;&#20010;&#27979;&#35797;&#29992;&#20363;&#30001;&#20004;&#20010;&#27491;&#25972;&#25968;m&#21644;n&#24320;&#22836;&#65292;&#25509;&#30528;&#26159;n&#20010;&#25972;&#25968;&#12290;

    1   3       1   2   3
    2   6      -1   4  -2   3  -2   3

output:

    &#27599;&#34892;&#36755;&#20986;&#19968;&#20010;&#26368;&#22823;&#21644;&#12290;

    6
    8</code></pre>
<p>&#20998;&#26512;</p>
<p>&#35774;&#29366;&#24577;&#20026; <code>d[i,j]</code>&#65292;&#34920;&#31034;&#21069; j &#39033;&#20998;&#20026; i &#27573;&#30340;&#26368;&#22823;&#21644;&#65292;&#19988;&#31532; i &#27573;&#24517;&#39035;&#21253;&#21547; <code>S[j]</code>&#65292;&#21017;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#22914;&#19979;&#65306;</p>
<pre><code>d[i,j] = max {
                    d[i,j-1] + S[j],                # S[j] &#21253;&#21547;&#22312;&#31532; i &#27573;&#20043;&#20013;&#65292;d[i,j-1]+S[j]&#12290;
                    max{    d[i-1,t] + S[j] }       # S[j] &#29420;&#31435;&#21010;&#20998;&#25104;&#20026;&#19968;&#27573;
             },                                     i &lt;= j &lt;= n, i-1 &lt;= t &lt; j
target = max {      d[m,j]                  },      m &lt;= j &lt;= n</code></pre>
<p>&#35266;&#23519;&#19978;&#36848;&#20004;&#31181;&#24773;&#20917;&#21487;&#30693; <code>d[i,j]</code> &#30340;&#20540;&#21482;&#21644; <code>d[i,j-1]</code> &#21644; <code>d[i-1,t]</code> &#36825;&#20004;&#20010;&#20540;&#30456;&#20851;&#65292;&#22240;&#27492;&#19981;&#38656;&#35201;&#20108;&#32500;&#25968;&#32452;&#65292;&#21487;&#20197;&#29992;&#28378;&#21160;&#25968;&#32452;&#65292;&#21482;&#38656;&#35201;&#20004;&#20010;&#19968;&#32500;&#25968;&#32452;&#65292;&#29992; <code>d[j]</code> &#34920;&#31034;&#29616;&#38454;&#27573;&#30340;&#26368;&#22823;&#20540;&#65292;&#21363; <code>d[i,j-1] + S[j]</code>&#65292;&#29992; <code>prev[j]</code> &#34920;&#31034;&#19978;&#19968;&#38454;&#27573;&#30340;&#26368;&#22823;&#20540;&#65292;&#21363; <code>max{ d[i-1,t] + S[j] }</code>&#12290;</p>
<p>TODO.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;limits.h&gt;</span>

<span class="co">// @brief &#26368;&#22823;m&#27573;&#23376;&#24207;&#21015;&#21644;</span>
<span class="co">// @param[in] S &#25968;&#32452;</span>
<span class="co">// @param[in] n &#25968;&#32452;&#38271;&#24230;</span>
<span class="co">// @param[in] m m&#27573;</span>
<span class="co">// @return &#26368;&#22823;m&#27573;&#23376;&#24207;&#21015;&#21644;</span>
<span class="dt">int</span> mmss(<span class="dt">int</span> S[], <span class="dt">int</span> n, <span class="dt">int</span> m) {
    <span class="dt">int</span> max_sum, i, j;

    <span class="co">/* d[i]&#34920;&#31034;&#29616;&#38454;&#27573;&#26368;&#22823;&#20540;&#65292;prev[i]&#34920;&#31034;&#19978;&#38454;&#27573;&#26368;&#22823;&#20540; */</span>
    <span class="co">/* d[0], prev[0] &#26410;&#20351;&#29992; */</span>
    <span class="dt">int</span> *d = (<span class="dt">int</span>*) calloc(n + <span class="dv">1</span>, <span class="kw">sizeof</span>(<span class="dt">int</span>));
    <span class="dt">int</span> *prev = (<span class="dt">int</span>*) calloc(n + <span class="dv">1</span>, <span class="kw">sizeof</span>(<span class="dt">int</span>));
    S--;  <span class="co">// &#22240;&#20026; j&#26159;&#20174;1&#24320;&#22987;&#65292;&#32780;S&#20174;0&#24320;&#22987;&#65292;&#36825;&#37324;&#35201;&#20943;&#19968;</span>

    <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt;= m; ++i) {
        max_sum = INT_MIN;
        <span class="kw">for</span> (j = i; j &lt;= n; ++j) {
            <span class="co">// &#29366;&#24577;&#36716;&#31227;&#26041;&#31243;</span>
            <span class="kw">if</span> (d[j - <span class="dv">1</span>] &lt; prev[j - <span class="dv">1</span>])
                d[j] = prev[j - <span class="dv">1</span>] + S[j];
            <span class="kw">else</span>
                d[j] = d[j - <span class="dv">1</span>] + S[j];

            prev[j - <span class="dv">1</span>] = max_sum;  <span class="co">// &#23384;&#25918;&#19978;&#38454;&#27573;&#26368;&#22823;&#20540;</span>
            <span class="kw">if</span> (max_sum &lt; d[j])
                max_sum = d[j];  <span class="co">// &#26356;&#26032; max_sum</span>
        }
        prev[j - <span class="dv">1</span>] = max_sum;
    }

    free(d);
    free(prev);
    <span class="kw">return</span> max_sum;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, m, i, *S;
    <span class="kw">while</span> (scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;m, &amp;n) == <span class="dv">2</span>) {
        S = (<span class="dt">int</span>*) malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>) * n);
        <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; ++i)
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;S[i]);
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, mmss(S, n, m));
        free(S);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#32972;&#21253;&#38382;&#39064; <code class="fold">@</code></dt>
<dd><p>&#32972;&#21253;&#38382;&#39064; (<a href="http://en.wikipedia.org/wiki/Knapsack_problem">Knapsack problem</a>)</p>
<p>&#26377;&#24456;&#22810;&#31181;&#29256;&#26412;&#65292;&#24120;&#35265;&#30340;&#26159;&#20197;&#19979;&#19977;&#31181;&#65306;</p>
<ul>
<li>0-1 &#32972;&#21253;&#38382;&#39064; (0-1 knapsack problem)&#65306;&#27599;&#31181;&#29289;&#21697;&#21482;&#26377;&#19968;&#20010;</li>
<li>&#23436;&#20840;&#32972;&#21253;&#38382;&#39064; (UKP, unbounded knapsack problem)&#65306;&#27599;&#31181;&#29289;&#21697;&#37117;&#26377;&#26080;&#38480;&#20010;&#21487;&#29992;</li>
<li>&#22810;&#37325;&#32972;&#21253;&#38382;&#39064; (BKP, bounded knapsack problem)&#65306;&#31532; i &#31181;&#29289;&#21697;&#26377; <code>c[i]</code> &#20010;&#21487;&#29992;</li>
</ul>
<p>&#32972;&#21253;&#38382;&#39064;&#26159;&#19968;&#31181;&#8220;&#22810;&#38454;&#27573;&#20915;&#31574;&#38382;&#39064;&#8221;&#12290;</p>
<p>&#36825;&#37096;&#20998;&#26469;&#33258;&#23828;&#28155;&#32764;&#65306;<a href="https://github.com/tianyicui/pack">tianyicui/pack: &#32972;&#21253;&#38382;&#39064;&#20061;&#35762;</a>&#12290;</p>
<ul>
<li><dl>
<dt>0-1&#32972;&#21253;&#38382;&#39064; <code class="fold">@</code></dt>
<dd><p>&#26377; N &#20214;&#29289;&#21697;&#21644;&#19968;&#20010;&#23481;&#37327;&#20026; V &#30340;&#32972;&#21253;&#12290;&#25918;&#20837;&#31532; i &#20214;&#29289;&#21697;&#32791;&#36153;&#30340;&#36153;&#29992;&#26159; C<sub>i</sub>&#65292;&#24471;&#21040;&#30340;&#20215;&#20540;&#26159; W<sub>i</sub>&#12290;&#27714;&#35299;&#23558;&#21738;&#20123;&#29289;&#21697;&#35013;&#20837;&#32972;&#21253;&#21487;&#20351;&#20215;&#20540;&#24635;&#21644;&#26368;&#22823;&#12290;</p>
<pre><code>input:

    &#31532; 1 &#34892;&#21253;&#21547;&#19968;&#20010;&#25972;&#25968; T&#65292;&#34920;&#31034;&#26377; T &#32452;&#27979;&#35797;&#29992;&#20363;&#12290;
    &#27599;&#32452;&#27979;&#35797;&#29992;&#20363;&#26377; 3 &#34892;&#65292;&#31532; 1 &#34892;&#21253;&#21547;&#20004;&#20010;&#25972;&#25968; N, W (N &lt;= 1000 , W &lt;= 1000)
    &#20998;&#21035;&#34920;&#31034;&#29289;&#21697;&#30340;&#31181;&#25968;&#21644;&#32972;&#21253;&#30340;&#23481;&#37327;&#65292;&#31532; 2 &#34892;&#21253;&#21547; N &#20010;&#25972;
    &#25968;&#34920;&#31034;&#27599;&#31181;&#29289;&#21697;&#30340;&#20215;&#20540;&#65292;&#31532; 3 &#34892;&#21253;&#21547; N &#20010;&#25972;&#25968;&#34920;&#31034;&#27599;&#31181;
    &#29289;&#21697;&#30340;&#37325;&#37327;&#12290;

    1
    5 10
    1 2 3 4 5
    5 4 3 2 1

output:

    &#27599;&#34892;&#19968;&#20010;&#25972;&#25968;&#65292;&#34920;&#31034;&#20215;&#20540;&#24635;&#21644;&#30340;&#26368;&#22823;&#20540;&#12290;

    14</code></pre>
<p>&#36825;&#26159;&#26368;&#22522;&#30784;&#30340;&#32972;&#21253;&#38382;&#39064;&#65292;&#29305;&#28857;&#26159;&#65306;&#27599;&#31181;&#29289;&#21697;&#20165;&#26377;&#19968;&#20214;&#65292;&#21487;&#20197;&#36873;&#25321;&#25918;&#25110;&#19981;&#25918;&#12290;</p>
<p>&#29992;&#23376;&#38382;&#39064;&#23450;&#20041;&#29366;&#24577;&#65306;&#21363; <code>F[i,v]</code> &#34920;&#31034;&#21069; i &#20214;&#29289;&#21697;&#25918;&#20837;&#19968;&#20010;&#23481;&#37327;&#20026; v &#30340;&#32972;&#21253;&#21487;&#20197;&#33719;&#24471;&#30340;&#26368;&#22823;&#20215;&#20540;&#12290;&#21017;&#20854;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#20415;&#26159;&#65306;</p>
<pre><code>                            &#19981;&#25918;                            &#25918;
F[i,v] = max{           F[i&#8722;1, v],                  F[i&#8722;1, v&#8722;C_i] + W_i         }</code></pre>
<p>&#21160;&#35268;&#36807;&#31243;&#30340;&#20266;&#20195;&#30721;&#22914;&#19979;&#65306;</p>
<pre><code>f[0..N][0..W] = 0
for i=1..N
    for j=0..W
        f[i][j] = max{      f[i-1][j],      f[i-1][j-w[i]]+v[i]     };</code></pre>
<p>&#20869;&#24490;&#29615;&#20174;&#21491;&#21521;&#24038;&#20063;&#21487;&#20197;&#65306;</p>
<pre><code>f[0..N][0..W] = 0
for i=1..N
    for j=W..0
        f[i][j] = max{      f[i-1][j],      f[i-1][j-w[i]]+v[i]     };</code></pre>
<p>&#20869;&#24490;&#29615;&#20174;&#21491;&#21521;&#24038;&#26102;&#65292;&#21487;&#20197;&#25226;&#20108;&#32500;&#25968;&#32452;&#20248;&#21270;&#25104;&#19968;&#32500;&#25968;&#32452;&#12290;&#20266;&#20195;&#30721;&#22914;&#19979;&#65306;</p>
<pre><code>for i=1..N
    for j=W..0
        d[j]    = max{           d[j],           d[j-w[i]]+v[i]     };
     // f[i][j] = max{      f[i-1][j],      f[i-1][j-w[i]]+v[i]     };
     //                                             ^
     //                                             |
     //                                             +-- still valid, so we can
     //                                                 iterate from right to left</code></pre>
<p>&#20026;&#20160;&#20040;&#21602;&#65311;</p>
<p>&#24403;&#20869;&#24490;&#29615;&#26159;&#36870;&#24207;&#26102;&#65292;&#19988;&#21160;&#35268;&#26159;&#29992;&#33258;&#24213;&#21521;&#19978;&#26041;&#24335;&#23454;&#29616;&#26102;&#65292;&#23601;&#21487;&#20197;&#20445;&#35777;&#21516;&#19968;&#34892;<strong>&#21487;&#20197;&#20174;&#21491;&#21521;&#24038;&#26356;&#26032;</strong>&#12290;</p>
<p>&#35774;&#19968;&#32500;&#25968;&#32452;&#20026; d&#65288;&#21448;&#31216;&#20026;&#28378;&#21160;&#25968;&#32452;&#65292;&#22312;&#26356;&#26032; <code>d[j]</code> &#20043;&#21069;&#65292;<code>d[j]</code> &#37324;&#20445;&#23384;&#30340; <code>f[i-1][j]</code>&#65292;&#26356;&#26032;&#20043;&#21518;&#65292;<code>d[j]</code> &#37324;&#20445;&#23384;&#30340;&#26159; <code>f[i][j]</code> )&#12290;</p>
<p>&#20107;&#23454;&#19978;&#65292;&#20351;&#29992;&#19968;&#32500;&#25968;&#32452;&#35299; 0-1 &#32972;&#21253;&#38382;&#39064;&#30340;&#31243;&#24207;&#22312;&#21518;&#38754;&#20250;&#34987;&#22810;&#27425;&#29992;&#21040;&#65292;&#25152;&#20197;&#36825;&#37324;&#25277;&#35937;&#20986;&#19968;&#20010;&#22788;&#29702;&#21333;&#20010;&#29289;&#21697;&#30340;&#20989;&#25968;&#65292;&#20197;&#21518;&#30340;&#20195;&#30721;&#20013;&#30452;&#25509;&#35843;&#29992;&#19981;&#21152;&#35828;&#26126;&#12290;</p>
<pre><code>def ZeroOneKnapsack(d[], i)
    for j = W..w[i]
        d[j] = max( d[j], d[j-w[i]] + v[i] )</code></pre>
<p>&#26377;&#20102;&#36825;&#20010;&#20989;&#25968;&#20197;&#21518;&#65292;0-1 &#32972;&#21253;&#38382;&#39064;&#30340;&#20266;&#20195;&#30721;&#23601;&#21487;&#20197;&#36825;&#26679;&#20889;&#65306;</p>
<pre><code>d[0..W] = 0
for i = 1..N
    ZeroOneKnapsack(d[], i)</code></pre>
<ul>
<li><dl>
<dt>&#29256;&#26412;1&#65292;&#33258;&#24213;&#21521;&#19978; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="ot">#define MAXN 1000</span>
<span class="ot">#define MAXW 1000</span>

<span class="dt">int</span> N, W;
<span class="dt">int</span> w[MAXN<span class="dv">+1</span>], v[MAXN<span class="dv">+1</span>];               <span class="co">// 0 &#27809;&#26377;&#29992;</span>
<span class="dt">int</span> f[MAXN + <span class="dv">1</span>][MAXW + <span class="dv">1</span>];

<span class="dt">void</span> dp() {
    <span class="dt">int</span> i, j;
    memset(f, <span class="dv">0</span>, <span class="kw">sizeof</span>(f));            <span class="co">// &#32972;&#21253;&#19981;&#19968;&#23450;&#35201;&#35013;&#28385;</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= N; ++i ) {
        <span class="co">// for( int j = W; j &gt;= 0; --j ) {</span>
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= W; ++j ) {
            f[i][j] = f[i<span class="dv">-1</span>][j];
            <span class="kw">if</span>(j &gt;= w[i]) {
                <span class="dt">int</span> sum = f[i<span class="dv">-1</span>][j-w[i]] + v[i];    <span class="co">// when i = 1, init f[0][i] to v[i]</span>
                <span class="kw">if</span>(sum &gt; f[i][j]) f[i][j] = sum;
            }
        }
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;N, &amp;W);
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= N; ++i ) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;v[i]);
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= N; ++i ) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;w[i]);
        dp();
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, f[N][W]);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#29256;&#26412;2&#65292;&#33258;&#24213;&#21521;&#19978;&#65292;&#28378;&#21160;&#25968;&#32452; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="ot">#define MAXN 1000</span>
<span class="ot">#define MAXW 1000</span>

<span class="dt">int</span> N, W;
<span class="dt">int</span> w[MAXN], v[MAXN];

<span class="dt">int</span> d[MAXW + <span class="dv">1</span>];

<span class="co">// put ith object</span>
<span class="dt">void</span> zero_one_knapsack(<span class="dt">int</span> d[], <span class="dt">const</span> <span class="dt">int</span> i) {
    <span class="kw">for</span>( <span class="dt">int</span> j = W; j &gt;= w[i]; --j ) {
        <span class="dt">int</span> sum = d[j - w[i]] + v[i];
        <span class="kw">if</span>(sum &gt; d[j]) { d[j] = sum; }
    }
}

<span class="dt">void</span> dp() {
    memset(d, <span class="dv">0</span>, <span class="kw">sizeof</span>(d));
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i ) {
        zero_one_knapsack(d, i);
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;N, &amp;W);
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= N; ++i ) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;v[i]);
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= N; ++i ) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;w[i]);

        dp();
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, d[W]);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>WORKS??</p>
<p>9???</p>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#23436;&#20840;&#32972;&#21253;&#38382;&#39064; <code class="fold">@</code></dt>
<dd><p>&#32473;&#20320;&#19968;&#20010;&#20648;&#38065;&#32592; (piggy bank)&#65292;&#24448;&#37324;&#38754;&#23384;&#30828;&#24065;&#12290;&#23384;&#20837;&#30340;&#36807;&#31243;&#26159;&#19981;&#21487;&#36870;&#30340;&#65292;&#35201;&#24819;&#25226;&#38065;&#25343;&#20986;&#26469;&#21482;&#33021;&#25684;&#30862;&#20648;&#38065;&#32592;&#12290;&#22240;&#27492;&#65292;&#20320;&#24819;&#30693;&#36947;&#37324;&#38754;&#26159;&#21542;&#26377;&#36275;&#22815;&#22810;&#30340;&#38065;&#65292;&#25226;&#23427;&#25684;&#30862;&#26159;&#20540;&#24471;&#30340;&#12290;</p>
<p>&#20320;&#21487;&#20197;&#36890;&#36807;&#20648;&#38065;&#32592;&#30340;&#37325;&#37327;&#26469;&#25512;&#27979;&#37324;&#38754;&#33267;&#23569;&#26377;&#22810;&#23569;&#38065;&#12290;&#24050;&#30693;&#20648;&#38065;&#32592;&#31354;&#30340;&#26102;&#20505;&#30340;&#37325;&#37327;&#21644;&#35013;&#20102;&#30828;&#24065;&#21518;&#30340;&#37325;&#37327;&#65292;&#36824;&#26377;&#27599;&#31181;&#30828;&#24065;&#30340;&#37325;&#37327;&#21644;&#38754;&#20540;&#65292;&#27599;&#31181;&#30828;&#24065;&#30340;&#25968;&#37327;&#19981;&#38480;&#12290;&#27714;&#22312;&#26368;&#22351;&#24773;&#20917;&#19979;&#65292;&#20648;&#38065;&#32592;&#37324;&#26368;&#23569;&#26377;&#22810;&#23569;&#38065;&#12290;</p>
<pre><code>&#36755;&#20837;

    &#31532; 1 &#34892;&#21253;&#21547;&#19968;&#20010;&#25972;&#25968; T&#65292;&#34920;&#31034;&#26377; T &#32452;&#27979;&#35797;&#29992;&#20363;&#12290;&#27599;&#32452;&#27979;
    &#35797;&#29992;&#20363;&#65292;&#31532;&#19968;&#34892;&#26159;&#20004;&#20010;&#25972;&#25968; E &#21644; F&#65292;&#20998;&#21035;&#34920;&#31034;&#31354;&#20648;&#38065;&#32592;&#30340;
    &#37325;&#37327;&#21644;&#35013;&#20102;&#30828;&#24065;&#21518;&#30340;&#37325;&#37327;&#65292;&#20197;&#20811; (gram) &#20026;&#21333;&#20301;&#65292;&#20648;&#38065;&#32592;
    &#30340;&#37325;&#37327;&#19981;&#20250;&#36229;&#36807; 10kg&#65292;&#21363; 1 &lt;= E &lt;= F &lt;= 10000&#12290;&#31532;&#20108;
    &#34892;&#26159;&#19968;&#20010;&#25972;&#25968;N (1 &lt;= N &lt;= 500)&#65292;&#34920;&#31034;&#30828;&#24065;&#30340;&#31181;&#31867;&#25968;&#30446;&#12290;
    &#25509;&#19979;&#26469;&#26159; N &#34892;&#65292;&#27599;&#34892;&#21253;&#21547;&#20004;&#20010;&#25972;&#25968; v &#21644; w
    (1 &lt;= v &lt;= 50000, 1 &lt;= w &lt;= 10000)&#65292;&#20998;&#21035;&#34920;&#31034;&#30828;&#24065;&#30340;&#38754;&#20540;&#21644;&#37325;&#37327;&#12290;

    3
    10 110
    2
    1 1
    30 50
    10 110
    2
    1 1
    50 30
    1 6
    2
    10 3
    20 4

&#36755;&#20986;

    &#27599;&#20010;&#26696;&#20363;&#25171;&#21360;&#19968;&#34892;&#12290;&#20869;&#23481;&#26159; &quot;The minimum amount of money in the piggy-bank is X.&quot;&#65292;
    &#20854;&#20013; X &#34920;&#31034;&#20648;&#38065;&#32592;&#37324;&#26368;&#23569;&#26377;&#22810;&#23569;&#38065;&#12290;&#22914;&#26524;&#19981;&#33021;&#31934;&#30830;&#22320;&#36798;&#21040;&#32473;&#23450;&#30340;&#37325;&#37327;&#65292;&#21017;&#25171;&#21360;
    &quot;This is impossible.&quot;&#12290;

    The minimum amount of money in the piggy-bank is 60.
    The minimum amount of money in the piggy-bank is 100.
    This is impossible.</code></pre>
<p>&#27599;&#31181;&#29289;&#21697;&#26377;&#26080;&#38480;&#20010;&#21487;&#29992;&#65292;&#36825;&#26159;<strong>&#23436;&#20840;&#32972;&#21253;</strong>&#38382;&#39064;&#12290;</p>
<p>&#26412;&#39064;&#27809;&#26377;&#32473;&#20986;&#20648;&#38065;&#32592;&#30340;&#23481;&#37327;&#65292;&#20294;&#27599;&#20010;&#26696;&#20363;&#32473;&#20986;&#20102;&#65292;&#21021;&#22987;&#20026;&#31354;&#26102;&#30340;&#37325;&#37327; E &#21644;&#35013;&#20102;&#30828;&#24065;&#21518;&#30340;&#37325;&#37327; F&#65292;&#22240;&#27492;&#21487;&#20197;&#25226;&#20648;&#38065;&#32592;&#30475;&#20316;&#19968;&#20010;&#23481;&#37327;&#20026; F-E &#30340;&#32972;&#21253;&#65292;&#32972;&#21253;&#24517;&#39035;&#35201;&#35013;&#28385;&#12290;</p>
<p>&#36825;&#20010;&#38382;&#39064;&#38750;&#24120;&#31867;&#20284;&#20110; 0-1 &#32972;&#21253;&#38382;&#39064;&#65292;&#25152;&#19981;&#21516;&#30340;&#26159;&#27599;&#31181;&#29289;&#21697;&#26377;&#26080;&#38480;&#20010;&#12290;&#20063;&#23601;&#26159;&#20174;&#27599;&#31181;&#29289;&#21697;&#30340;&#35282;&#24230;&#32771;&#34385;&#65292;&#19982;&#23427;&#30456;&#20851;&#30340;&#31574;&#30053;&#24050;&#24182;&#38750;&#21462;&#25110;&#19981;&#21462;&#20004;&#31181;&#65292;&#32780;&#26159;&#21462; 0 &#20010;&#12289;&#21462; 1 &#20010;&#12289;&#21462; 2 &#20010;&#8230;&#8230;&#30452;&#33267;&#21462; <code>W/w[i]</code> &#20010;&#12290;</p>
<p>&#19968;&#31181;&#22909;&#24819;&#22909;&#20889;&#30340;&#22522;&#26412;&#26041;&#27861;&#26159;&#36716;&#21270;&#20026; 0-1 &#32972;&#21253;&#38382;&#39064;&#65306;&#25226;&#31532; i &#31181;&#29289;&#21697;&#25442;&#25104; <code>W/w[i]</code> &#20010; 0-1 &#32972;&#21253;&#38382;&#39064;&#20013;&#30340;&#29289;&#21697;&#65292;&#21017;&#24471;&#21040;&#20102;&#29289;&#21697;&#25968;&#20026; <code>sum(W/W[i])</code> &#30340; 0-1 &#32972;&#21253;&#38382;&#39064;&#12290;&#26102;&#38388;&#22797;&#26434;&#24230;&#26159; <code>O(W*sum(W/W[i]))</code></p>
<p>&#25353;&#29031;&#35813;&#24605;&#36335;&#65292;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#20026;&#65306;</p>
<pre><code>f[i][j] = max {
                        f[i-1][j-k*w[i]] + k*v[i]
},                                                                  0 &lt;= k*w[i] &lt;= j
                                                                    0 &lt;= k      &lt;= j/w[i]</code></pre>
<p>&#20266;&#20195;&#30721;&#22914;&#19979;&#65306;</p>
<pre><code>for i = 1..N
    for j = W..w[i]
        for k = 1..j/w[i]
            d[j] = max{ d[j], d[j-k*w[i]] + k*v[i] };</code></pre>
<p>&#20063;&#21487;&#20197;&#20889;&#25104;&#65306;</p>
<pre><code>for i = 1..N
    for k = 1..W/w[i]
        ZeroOneKnapsack(d[], w, v)</code></pre>
<dl>
<dt>&#8220;&#25286;&#20998;&#29289;&#21697;&#8221;&#36824;&#26377;&#26356;&#39640;&#25928;&#30340;&#25286;&#20998;&#26041;&#27861;&#65306; <code class="fold">@</code></dt>
<dd><p>&#25226;&#31532; i &#31181;&#29289;&#21697;&#25286;&#20998;&#25104;&#37325;&#37327;&#20026; 2<sup>k</sup> &#215; <code>w[i]</code>&#12289;&#20215;&#20540;&#20026; 2^k &#215; <code>v[i]</code> &#30340;&#33509;&#24178;&#29289;&#21697;&#65292;&#20854;&#20013; k &#21462;&#25152;&#26377;&#28385;&#36275; 2<sup>k</sup> &#215; <code>w[i]</code> &lt;= W &#30340;&#38750;&#36127;&#25972;&#25968;&#12290;&#36825;&#26159;&#20108;&#36827;&#21046;&#30340;&#24605;&#24819;&#65292;&#22240;&#20026;&#38381;&#21306;&#38388; <code>[1, W/w[i]]</code> &#20013;&#30340;&#20219;&#20309;&#25972;&#25968;&#37117;&#21487;&#20197;&#34920;&#31034;&#20026; 1, 2, 4, &#8230;, 2<sup>k</sup> &#20013;&#33509;&#24178;&#20010;&#30340;&#21644;&#12290;</p>
<p>&#36825;&#26679;&#22788;&#29702;&#21333;&#20010;&#29289;&#21697;&#30340;&#22797;&#26434;&#24230;&#30001; <code>O(W/w[i])</code> &#38477;&#21040;&#20102; <code>O(lg(W/w[i]))</code>&#65292;&#20266;&#20195;&#30721;&#22914;&#19979;&#65306;</p>
<pre><code>def UnboundedKnapsack(d[], i)
    k=1
    while k*w[i] &lt;= W
        ZeroOneKnapsack(d[], k*w[i], k*v[i])
        k=2*k</code></pre>
<p>&#36824;&#23384;&#22312;&#26356;&#20248;&#21270;&#30340;&#31639;&#27861;&#65292;&#22797;&#26434;&#24230;&#20026; O(NW)&#65292;&#20266;&#20195;&#30721;&#22914;&#19979;&#65306;</p>
<pre><code>for i = 1..N
    for j = 0..W
        d[j] = max{ d[j], d[j-w[i]] + v[i]  };</code></pre>
<p>&#19982; 0-1 &#32972;&#21253;&#38382;&#39064;&#30456;&#27604;&#65292;&#20165;&#26377;&#19968;&#34892;&#20195;&#30721;&#19981;&#21516;&#65292;&#36825;&#37324;&#20869;&#24490;&#29615;&#26159;&#39034;&#24207;&#30340;&#65292;&#32780; 0-1 &#32972;&#21253;&#26159;&#36870;&#24207;&#30340;&#65288;&#22312;&#20351;&#29992;&#28378;&#21160;&#25968;&#32452;&#30340;&#24773;&#20917;&#19979;&#65289;&#12290;</p>
<p>&#20026;&#20160;&#20040;&#36825;&#20010;&#31639;&#27861;&#21487;&#34892;&#21602;&#65311;&#39318;&#20808;&#24819;&#24819;&#20026;&#20160;&#20040; 0-1 &#32972;&#21253;&#20013;&#20869;&#24490;&#29615;&#35201;&#36870;&#24207;&#65292;&#36870;&#24207;&#26159;&#20026;&#20102;&#20445;&#35777;&#27599;&#20010;&#29289;&#21697;&#21482;&#36873;&#19968;&#27425;&#65292;&#20445;&#35777;&#22312;&#8220;&#36873;&#25321;&#31532; i &#20214;&#29289;&#21697;&#8221;&#26102;&#65292;&#20381;&#36182;&#30340;&#26159;&#19968;&#20010;&#27809;&#26377;&#36873;&#25321;&#31532; i &#20214;&#29289;&#21697;&#30340;&#23376;&#32467;&#26524; <code>f[i-1][j-w[i]]</code>&#12290;&#32780;&#29616;&#22312;&#23436;&#20840;&#32972;&#21253;&#30340;&#29305;&#28857;&#21364;&#26159;&#27599;&#31181;&#29289;&#21697;&#21487;&#36873;&#26080;&#38480;&#20010;&#65292;&#27809;&#26377;&#20102;&#27599;&#20010;&#29289;&#21697;&#21482;&#36873;&#19968;&#27425;&#30340;&#38480;&#21046;&#65292;&#25152;&#20197;&#23601;&#21487;&#20197;&#24182;&#19988;<strong>&#24517;&#39035;&#37319;&#29992; j &#36882;&#22686;&#30340;&#39034;&#24207;</strong>&#24490;&#29615;&#12290;</p>
<p>&#26681;&#25454;&#19978;&#38754;&#30340;&#20266;&#20195;&#30721;&#65292;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#20063;&#21487;&#20197;&#20889;&#25104;&#36825;&#31181;&#24418;&#24335;&#65306;</p>
<pre><code>f[i][j] = max {
                        f[i-1][j],
                        f[i][j-w[i]] + v[i]
}</code></pre>
<p>&#25277;&#35937;&#20986;&#22788;&#29702;&#21333;&#20010;&#29289;&#21697;&#30340;&#20989;&#25968;&#65306;</p>
<pre><code>def UnboundedKnapsack(d[], i)
    for j = w[i]..W
        d[j] = max(d[j], d[j-w[i]] + v[i])</code></pre>
</dd>
</dl>
<p>code</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="ot">#define MAXN 500</span>
<span class="ot">#define MAXW 10000</span>

<span class="dt">const</span> <span class="dt">int</span> INF = <span class="bn">0x0FFFFFFF</span>;                     <span class="co">// &#26080;&#25928;&#20540;&#65292;&#19981;&#35201;&#29992; 0x7FFFFFFF&#65292;&#25191;&#34892;&#21152;&#36816;&#31639;&#21518;&#20250;&#21464;&#25104;&#36127;&#25968;</span>

<span class="dt">int</span> N, W;
<span class="dt">int</span> w[MAXN], v[MAXN];
<span class="dt">int</span> d[MAXW + <span class="dv">1</span>];

<span class="co">// @brief &#23436;&#20840;&#32972;&#21253;&#38382;&#39064;&#20013;&#65292;&#22788;&#29702;&#21333;&#20010;&#29289;&#21697;.</span>
<span class="co">// @param[in] d &#28378;&#21160;&#25968;&#32452;</span>
<span class="co">// @param[in] i &#35813;&#29289;&#21697;&#30340;&#19979;&#26631;</span>
<span class="co">// @return &#26080;</span>
<span class="dt">void</span> unbounded_knapsack(<span class="dt">int</span> d[], <span class="dt">const</span> <span class="dt">int</span> i) {
    <span class="kw">for</span>( <span class="dt">int</span> j = w[i]; j &lt;= W; ++j ) {
        <span class="dt">int</span> sum = d[j - w[i]] + v[i];
        <span class="kw">if</span>( sum &lt; d[j] ) { d[j] = sum; }        <span class="co">// min!</span>
                                                <span class="co">// &quot;&#27714;&#22312;&#26368;&#22351;&#24773;&#20917;&#19979;&#65292;&#20648;&#38065;&#32592;&#37324;&#26368;&#23569;&#26377;&#22810;&#23569;&#38065;&#12290;&quot;</span>
    }
}
<span class="co">// c&#65292;&#29289;&#21697;&#30340;&#31995;&#25968;</span>
<span class="dt">void</span> zero_one_knapsack(<span class="dt">int</span> d[], <span class="dt">const</span> <span class="dt">int</span> i, <span class="dt">const</span> <span class="dt">int</span> c) {
    <span class="dt">const</span> <span class="dt">int</span> neww = c * w[i];
    <span class="dt">const</span> <span class="dt">int</span> newv = c * v[i];
    <span class="kw">for</span>( <span class="dt">int</span> j = W; j &gt;= neww; --j) {
        <span class="dt">const</span> <span class="dt">int</span> tmp = d[j - neww] + newv;
        <span class="kw">if</span>(tmp &lt; d[j]) d[j] = tmp;
    }
}

<span class="dt">void</span> unbounded_knapsack1(<span class="dt">int</span> d[], <span class="dt">const</span> <span class="dt">int</span> i) {
    <span class="dt">int</span> k = <span class="dv">1</span>;
    <span class="kw">while</span>(k * w[i] &lt;= W) {
        zero_one_knapsack(d, i, k);
        k *= <span class="dv">2</span>;
    }
}

<span class="dt">void</span> dp() {
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= W; ++i ) { d[i] = INF; }   <span class="co">// &#32972;&#21253;&#35201;&#35013;&#28385;</span>
    d[<span class="dv">0</span>] = <span class="dv">0</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt;  N; ++i ) { unbounded_knapsack(d, i); }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        <span class="dt">int</span> E, F;
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;E, &amp;F);
        W = F - E;
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;N);
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i ) {
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;v[i], &amp;w[i]);
        }
        dp();
        <span class="kw">if</span>(d[W] == INF) {
            printf(<span class="st">&quot;This is impossible.</span><span class="ch">\n</span><span class="st">&quot;</span>);
        } <span class="kw">else</span> {
            printf(<span class="st">&quot;The minimum amount of money in the piggy-bank is </span><span class="ch">%d</span><span class="st">.</span><span class="ch">\n</span><span class="st">&quot;</span>,
                    d[W]);
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="co">// &#23558;&#31532; i &#31181;&#29289;&#21697;&#21462; 0 &#20010;&#65292;1 &#20010;&#65292;...&#65292;W/w[i] &#20010;&#65292;&#35813;&#29256;&#26412;&#19981;&#33021; AC&#65292;&#20250; TLE</span>
<span class="dt">void</span> unbounded_knapsack2(<span class="dt">int</span> d[], <span class="dt">const</span> <span class="dt">int</span> w, <span class="dt">const</span> <span class="dt">int</span> v) {
    <span class="dt">int</span> j, k;
    <span class="kw">for</span>(j = W; j &gt;= w; --j) {
        <span class="dt">const</span> <span class="dt">int</span> K = j / w;
        <span class="kw">for</span>(k = <span class="dv">1</span>; k &lt;= K; ++k) {
            <span class="dt">const</span> <span class="dt">int</span> tmp = d[j - k * w] + k * v;
            <span class="kw">if</span>(tmp &lt; d[j]) d[j] = tmp; <span class="co">/* &#27714;&#26368;&#23567;&#29992; &lt;&#65292;&#27714;&#26368;&#22823;&#29992; &gt; */</span>
        }
    }
}

<span class="co">// &#23558;&#31532; i &#31181;&#29289;&#21697;&#21462; 0 &#20010;&#65292;1 &#20010;&#65292;...&#65292;W/w[i] &#20010;&#65292;&#35813;&#29256;&#26412;&#19981;&#33021; AC&#65292;&#20250; TLE</span>
<span class="dt">void</span> unbounded_knapsack3(<span class="dt">int</span> d[], <span class="dt">const</span> <span class="dt">int</span> w, <span class="dt">const</span> <span class="dt">int</span> v) {
    <span class="dt">int</span> k;
    <span class="dt">const</span> <span class="dt">int</span> K = W / w;
    <span class="kw">for</span>(k = <span class="dv">0</span>; k &lt; K; ++k){
        zero_one_knapsack(d, w, v);
    }
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#22810;&#37325;&#32972;&#21253;&#38382;&#39064; <code class="fold">@</code></dt>
<dd><p>&#26576;&#22320;&#21457;&#29983;&#22320;&#38663;&#65292;&#20026;&#20102;&#25405;&#25937;&#28798;&#21306;&#21516;&#32990;&#30340;&#29983;&#21629;&#65292;&#24515;&#31995;&#28798;&#21306;&#21516;&#32990;&#30340;&#20320;&#20934;&#22791;&#33258;&#24049;&#37319;&#36141;&#19968;&#20123;&#31918;&#39135;&#25903;&#25588;&#28798;&#21306;&#65292;&#29616;&#22312;&#20551;&#35774;&#20320;&#19968;&#20849;&#26377;&#36164;&#37329; W &#20803;&#65292;&#32780;&#24066;&#22330;&#26377; N &#31181;&#22823;&#31859;&#65292;&#27599;&#31181;&#22823;&#31859;&#37117;&#26159;&#34955;&#35013;&#20135;&#21697;&#65292;&#20854;&#20215;&#26684;&#19981;&#31561;&#65292;&#24182;&#19988;&#21482;&#33021;&#25972;&#34955;&#36141;&#20080;&#12290;</p>
<p>&#35831;&#38382;&#65306;&#20320;&#29992;&#26377;&#38480;&#30340;&#36164;&#37329;&#26368;&#22810;&#33021;&#37319;&#36141;&#22810;&#23569;&#20844;&#26020;&#31918;&#39135;&#21602;&#65311;</p>
<pre><code>&#36755;&#20837;

    &#31532; 1 &#34892;&#21253;&#21547;&#19968;&#20010;&#25972;&#25968; T&#65292;&#34920;&#31034;&#26377; T &#32452;&#27979;&#35797;&#29992;&#20363;&#12290;
    &#27599;&#32452;&#27979;&#35797;&#29992;&#20363;&#30340;&#31532;&#19968;&#34892;&#26159;&#20004;&#20010;&#25972;&#25968; W &#21644; N(1 &lt;= W &lt;= 100, 1 &lt;= N &lt;= 100),
    &#20998;&#21035;&#34920;&#31034;&#32463;&#36153;&#30340;&#37329;&#39069;&#21644;&#22823;&#31859;&#30340;&#31181;&#31867;&#65292;&#28982;&#21518;&#26159; N &#34892;&#25968;&#25454;&#65292;
    &#27599;&#34892;&#21253;&#21547; 3 &#20010;&#25972;&#25968; w&#65292;v &#21644; c (1 &lt;= w &lt;= 20,1 &lt;= v &lt;= 200,1 &lt;= c &lt;= 20)&#65292;
    &#20998;&#21035;&#34920;&#31034;&#27599;&#34955;&#30340;&#20215;&#26684;&#12289;&#27599;&#34955;&#30340;&#37325;&#37327;&#20197;&#21450;&#23545;&#24212;&#31181;&#31867;&#22823;&#31859;&#30340;&#34955;&#25968;&#12290;

    1
    8 2
    2 100 4
    4 100 2

&#36755;&#20986;

    &#23545;&#20110;&#27599;&#32452;&#27979;&#35797;&#29992;&#20363;&#65292;&#36755;&#20986;&#33021;&#22815;&#36141;&#20080;&#22823;&#31859;&#30340;&#26368;&#22823;&#37325;&#37327;&#65292;&#20320;&#21487;
    &#20197;&#20551;&#35774;&#32463;&#36153;&#20080;&#19981;&#20809;&#25152;&#26377;&#30340;&#22823;&#31859;&#65292;&#24182;&#19988;&#32463;&#36153;&#20320;&#21487;&#20197;&#19981;&#29992;&#23436;&#12290;
    &#27599;&#20010;&#23454;&#20363;&#30340;&#36755;&#20986;&#21344;&#19968;&#34892;&#12290;

    400</code></pre>
<p>&#31532; i &#31181;&#29289;&#21697;&#26377; <code>c[i]</code> &#20010;&#21487;&#29992;&#65292;&#36825;&#26159;<strong>&#22810;&#37325;&#32972;&#21253;</strong>&#38382;&#39064;&#12290;</p>
<p>&#19982;&#23436;&#20840;&#32972;&#21253;&#38382;&#39064;&#31867;&#20284;&#65292;&#20063;&#21487;&#20197;&#29992;&#8220;&#25286;&#20998;&#29289;&#21697;&#8221;&#30340;&#24605;&#24819;&#25226;&#26412;&#38382;&#39064;&#36716;&#21270;&#20026; 0-1 &#32972;&#21253;&#38382;&#39064;&#65306;&#25226;&#31532; i &#31181;&#29289;&#21697;&#25442;&#25104; <code>c[i]</code> &#20010; 0-1 &#32972;&#21253;&#38382;&#39064;&#20013;&#30340;&#29289;&#21697;&#65292;&#21017;&#24471;&#21040;&#20102;&#29289;&#21697;&#25968;&#20026; <code>sum( c[i] )</code> &#30340; 0-1 &#32972;&#21253;&#38382;&#39064;&#12290;&#26102;&#38388;&#22797;&#26434;&#24230;&#26159; <code>O(W/sum{c[i]})</code>&#12290;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#20026;&#65306;</p>
<pre><code>f[i][j] = max {
                f[i-1][j-k*w[i]] + k*v[i]
},                                                  0 &lt;= k &lt;= c[i], 0 &lt;= k*w[i] &lt;= j
                                                    0 &lt;= k &lt;= min(c[i], j/w[i])</code></pre>
<p>&#20266;&#20195;&#30721;&#22914;&#19979;&#65306;</p>
<pre><code>for i = 1..N
    for j = W..w[i]
        K = min{j/w[i], c[i]}
        for k = 1..K                                // k = 0, already considered in max( d[j], &#39;value when choose k&#39; )
            d[j] = max{d[j], d[j-k*w[i]] + k*v[i]};</code></pre>
<p>&#20063;&#21487;&#20197;&#20889;&#25104;&#65306;</p>
<pre><code>for i = 1..N
    for k = 1..c[i]
        ZeroOneKnapsack(d[], i)</code></pre>
<p>&#25286;&#20998;&#29289;&#21697;&#20063;&#21487;&#20197;&#20351;&#29992;&#20108;&#36827;&#21046;&#30340;&#25216;&#24039;&#65292;&#25226;&#31532; i &#31181;&#29289;&#21697;&#25286;&#20998;&#25104;&#33509;&#24178;&#29289;&#21697;&#65292;&#20854;&#20013;&#27599;&#20214;&#29289;&#21697;&#37117;&#26377;&#19968;&#20010;&#31995;&#25968;&#65292;&#36825;&#20010;&#26032;&#29289;&#21697;&#30340;&#37325;&#37327;&#21644;&#20215;&#20540;&#22343;&#26159;&#21407;&#26469;&#30340;&#37325;&#37327;&#21644;&#20215;&#20540;&#20056;&#20197;&#36825;&#20010;&#31995;&#25968;&#12290;&#31995;&#25968;&#20998;&#21035;&#20026; 1, 2, 2<sup>2</sup>, &#8230;, 2<sup>k-1</sup>, <code>c[i]</code>-(2<sup>k</sup>-1)&#65292;&#20854;&#20013; k &#26159;&#28385;&#36275; 2<sup>k</sup> - 1 &lt; <code>c[i]</code> &#30340;&#26368;&#22823;&#25972;&#25968;&#12290;&#20363;&#22914;&#65292;&#26576;&#31181;&#29289;&#21697;&#26377; 13 &#20010;&#65292;&#21363; <code>c[i]=13</code>&#65292;&#21017;&#30456;&#24212;&#30340; k=3&#65292;&#36825;&#31181;&#29289;&#21697;&#24212;&#35813;&#34987;&#25286;&#20998;&#25104;&#31995;&#25968;&#20998;&#21035; 1, 2, 4 (2<sup>2</sup>), 6 (13-(2<sup>3</sup>-1)) &#30340;&#22235;&#20010;&#29289;&#21697;&#12290;</p>
<p>&#36825;&#26679;&#22788;&#29702;&#21333;&#20010;&#29289;&#21697;&#30340;&#22797;&#26434;&#24230;&#30001; <code>O(c[i])</code> &#38477;&#21040;&#20102; <code>O(log(c[i]))</code>&#65292;&#20266;&#20195;&#30721;&#22914;&#19979;&#65306;</p>
<pre><code>// c, &#29289;&#21697;&#31995;&#25968;
def ZeroOneKnapsack(d[], i, c)
    for j = W..w[i]
        d[j] = max(d[j], d[j-c*w[i]] + c*v[i])
def BoundedKnapsack(d[], i)
    if c[i]*w[i] &gt;= W
        unbounded_knapsack(d[], i);
        return;

    k = 1;
    while k &lt; c[i]
        zero_one_knapsack(d[], i, k);
        c[i] -= k;
        k *= 2;

    zero_one_knapsack(d[], i, c);</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="ot">#define MAXN 100</span>
<span class="ot">#define MAXW 100</span>

<span class="dt">int</span> N, W;
<span class="dt">int</span> w[MAXN], v[MAXN], c[MAXN];

<span class="dt">int</span> d[MAXW + <span class="dv">1</span>];

<span class="co">// c&#65292;&#29289;&#21697;&#30340;&#31995;&#25968;</span>
<span class="dt">void</span> zero_one_knapsack(<span class="dt">int</span> d[], <span class="dt">const</span> <span class="dt">int</span> i, <span class="dt">const</span> <span class="dt">int</span> c) {
    <span class="dt">const</span> <span class="dt">int</span> neww = c * w[i];
    <span class="dt">const</span> <span class="dt">int</span> newv = c * v[i];
    <span class="kw">for</span>( <span class="dt">int</span> j = W; j &gt;= neww; --j ) {
        <span class="dt">const</span> <span class="dt">int</span> tmp = d[j - neww] + newv;
        <span class="kw">if</span>(tmp &gt; d[j]) d[j] = tmp;
    }
}

<span class="dt">void</span> unbounded_knapsack(<span class="dt">int</span> d[], <span class="dt">const</span> <span class="dt">int</span> i) {
    <span class="kw">for</span>( <span class="dt">int</span> j = w[i]; j &lt;= W; ++j ) {
        <span class="dt">const</span> <span class="dt">int</span> tmp = d[j - w[i]] + v[i];
        <span class="kw">if</span>(tmp &gt; d[j]) d[j] = tmp;
    }
}

<span class="co">// @brief &#22810;&#37325;&#32972;&#21253;&#38382;&#39064;&#20013;&#65292;&#22788;&#29702;&#21333;&#20010;&#29289;&#21697;.</span>
<span class="co">// @param[in] d &#28378;&#21160;&#25968;&#32452;</span>
<span class="co">// @param[in] i &#35813;&#29289;&#21697;&#30340;&#19979;&#26631;</span>
<span class="co">// @param[in] c &#35813;&#29289;&#21697;&#30340;&#25968;&#37327;</span>
<span class="co">// @return &#26080;</span>
<span class="dt">void</span> bounded_knapsack(<span class="dt">int</span> d[], <span class="dt">const</span> <span class="dt">int</span> i) {
    <span class="kw">for</span>( <span class="dt">int</span> k = <span class="dv">0</span>; k &lt; c[i]; ++k ) {
        zero_one_knapsack(d, i, <span class="dv">1</span>);
    }
}

<span class="co">// &#21478;&#19968;&#20010;&#29256;&#26412;&#65292;&#25286;&#20998;&#29289;&#21697;&#26356;&#21152;&#20248;&#21270;</span>
<span class="dt">void</span> bounded_knapsack1(<span class="dt">int</span> d[], <span class="dt">const</span> <span class="dt">int</span> i) {
    <span class="kw">if</span>(c[i] * w[i] &gt;= W) {
        unbounded_knapsack(d, i);
        <span class="kw">return</span>;
    }

    <span class="dt">int</span> k = <span class="dv">1</span>;
    <span class="kw">while</span>(k &lt; c[i]) {
        zero_one_knapsack(d, i, k);
        c[i] -= k;
        k *= <span class="dv">2</span>;
    }
    zero_one_knapsack(d, i, c[i]);
}

<span class="dt">void</span> dp() {
    memset(d, <span class="dv">0</span>, <span class="kw">sizeof</span>(d));
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i ) { bounded_knapsack1(d, i); }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;W, &amp;N);
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i ) { scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;w[i], &amp;v[i], &amp;c[i]); }
        dp();
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, d[W]);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#24207;&#21015;&#22411;&#21160;&#24577;&#35268;&#21010; <code class="fold">@</code></dt>
<dd><p>&#23545;&#20110;&#25152;&#26377;&#21160;&#35268;&#39064;&#30446;&#65292;&#22914;&#26524;&#25226;&#29366;&#24577;&#36716;&#31227;&#22270;&#30011;&#20986;&#26469;&#65292;&#19968;&#23450;&#26159;&#19968;&#20010;&#26377;&#21521;&#26080;&#29615;&#22270; (DAG)&#12290;&#20877;&#36827;&#19968;&#27493;&#32454;&#20998;&#31867;&#21035;&#65292;&#26377;&#24207;&#21015;&#22411;&#21160;&#24577;&#35268;&#21010;&#65292;&#26827;&#30424;&#22411;&#21160;&#24577;&#35268;&#21010;&#65292;&#26641;&#22411;&#21160;&#24577;&#35268;&#21010;&#31561;&#31561;&#12290;</p>
<ul>
<li><dl>
<dt>&#26368;&#38271;&#19978;&#21319;&#23376;&#24207;&#21015; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#24403;&#19968;&#20010;&#24207;&#21015;&#20005;&#26684;&#36882;&#22686;&#26102;&#65292;&#25105;&#20204;&#31216;&#36825;&#20010;&#24207;&#21015;&#26159;&#19978;&#21319;&#30340;&#12290;</p>
<p>&#23545;&#20110;&#19968;&#20010;&#32473;&#23450;&#30340;&#24207;&#21015; a<sub>1</sub>, a<sub>2</sub>, &#8230;, a<sub>N</sub>&#65292;&#25105;&#20204;&#21487;&#20197;&#24471;&#21040;&#19968;&#20123;&#19978;&#21319;&#30340;&#23376;&#24207;&#21015; a<sub>i1</sub>, a<sub>i2</sub>, &#8230;, a<sub>iK</sub>&#65292;&#36825;&#37324; 1 &lt;= i<sub>1</sub> &lt; i<sub>2</sub> &lt; &#8230; &lt; i<sub>K</sub> &lt;= N&#12290;&#20363;&#22914;&#65292;&#23545;&#20110;&#24207;&#21015; (1, 7, 3, 5, 9, 4, 8)&#65292;&#26377;&#23427;&#30340;&#19968;&#20123;&#19978;&#21319;&#23376;&#24207;&#21015;&#65292;&#22914; (1, 7), (3, 4, 8) &#31561;&#31561;&#65292;&#36825;&#20123;&#23376;&#24207;&#21015;&#20013;&#26368;&#38271;&#30340;&#38271;&#24230;&#26159; 4&#65292;&#27604;&#22914;&#23376;&#24207;&#21015; (1, 3, 5, 8)&#12290;</p>
<p>&#23545;&#20110;&#32473;&#23450;&#30340;&#24207;&#21015;&#65292;&#27714;<strong>&#26368;&#38271;&#19978;&#21319;&#23376;&#24207;&#21015;</strong> (longest increasing subsequence) &#30340;&#38271;&#24230;&#12290;</p>
<pre><code>&#36755;&#20837;

    &#31532;&#19968;&#34892;&#26159;&#24207;&#21015;&#30340;&#38271;&#24230; N (1 &lt;= N &lt;= 1000)&#12290;
    &#31532;&#20108;&#34892;&#32473;&#20986;&#24207;&#21015;&#20013;&#30340; N &#20010;&#25972;&#25968;&#65292;&#36825;&#20123;&#25972;&#25968;&#30340;&#21462;&#20540;&#33539;&#22260;&#37117;&#22312;0 &#21040; 10000&#12290;

    7
    1 7 3 5 9 4 8

&#36755;&#20986;

    &#26368;&#38271;&#19978;&#21319;&#23376;&#24207;&#21015;&#30340;&#38271;&#24230;&#12290;

    4</code></pre>
<p>&#35774;&#29366;&#24577;&#20026; <code>d[j]</code>&#65292;&#34920;&#31034;&#20197; a<sub>j</sub> &#20026;&#32456;&#28857;&#30340;&#26368;&#38271;&#19978;&#21319;&#23376;&#24207;&#21015;&#30340;&#38271;&#24230;&#12290;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#22914;&#19979;&#65307;</p>
<pre><code>d[j]= max {
                    1,                          j=1
                    max{ d[i] } + 1,            1 &lt; i &lt; j, a_i &lt; a_j
}</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;stdio.h&gt;</span>

<span class="ot">#define MAXN 1001                           </span><span class="co">// a[0]&#26410;&#29992;</span>
<span class="dt">int</span> N, a[MAXN], d[MAXN];

<span class="dt">void</span> dp() {
    d[<span class="dv">1</span>] = <span class="dv">1</span>;
    <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">2</span>; j &lt;= N; ++j ) {         <span class="co">// &#27599;&#27425;&#27714;&#20197; aj &#20026;&#32456;&#28857;&#30340;&#26368;&#38271;&#19978;&#21319;&#23376;&#24207;&#21015;&#30340;&#38271;&#24230;</span>
        <span class="dt">int</span> max = <span class="dv">0</span>;                        <span class="co">// &#35760;&#24405; aj &#24038;&#36793;&#30340;&#19978;&#21319;&#23376;&#24207;&#21015;&#30340;&#26368;&#22823;&#38271;&#24230;</span>
        <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt; j; ++i )  {
            <span class="kw">if</span> (a[i] &lt;a[j] &amp;&amp; max &lt; d[i]) {
                max = d[i];
            }
        }
        d[j] = max + <span class="dv">1</span>;
    }
}

<span class="dt">int</span> main() {
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;N );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= N; ++i ) {
        scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;a[i] );
    }

    dp();

    <span class="dt">int</span> max = <span class="dv">0</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= N; ++i ) {
        <span class="kw">if</span>( d[i] &gt; max ) {
            max = d[i];
        }
    }
    printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, max );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#23884;&#22871;&#30697;&#24418; <code class="fold">@</code></dt>
<dd><p>&#26377; n &#20010;&#30697;&#24418;&#65292;&#27599;&#20010;&#30697;&#24418;&#21487;&#20197;&#29992; a,b &#26469;&#25551;&#36848;&#65292;&#34920;&#31034;&#38271;&#21644;&#23485;&#12290;&#30697;&#24418; X(a,b) &#21487;&#20197;&#23884;&#22871;&#22312;&#30697;&#24418; Y(c,d) &#20013;&#24403;&#19988;&#20165;&#24403; a&lt;c,b&lt;d &#25110;&#32773; b&lt;c,a&lt;d&#65288;&#30456;&#24403;&#20110;&#26059;&#36716; X90 &#24230;&#65289;&#12290;&#20363;&#22914; (1,5) &#21487;&#20197;&#23884;&#22871;&#22312; (6,2) &#20869;&#65292;&#20294;&#19981;&#33021;&#23884;&#22871;&#22312; (3,4) &#20013;&#12290;&#20320;&#30340;&#20219;&#21153;&#26159;&#36873;&#20986;&#23613;&#21487;&#33021;&#22810;&#30340;&#30697;&#24418;&#25490;&#25104;&#19968;&#34892;&#65292;&#20351;&#24471;&#38500;&#26368;&#21518;&#19968;&#20010;&#22806;&#65292;&#27599;&#19968;&#20010;&#30697;&#24418;&#37117;&#21487;&#20197;&#23884;&#22871;&#22312;&#19979;&#19968;&#20010;&#30697;&#24418;&#20869;&#12290;</p>
<pre><code>&#36755;&#20837;

    &#31532;&#19968;&#34892;&#26159;&#19968;&#20010;&#27491;&#25972;&#25968; N(0&lt;N&lt;10)&#65292;&#34920;&#31034;&#27979;&#35797;&#25968;&#25454;&#32452;&#25968;&#65292;
    &#27599;&#32452;&#27979;&#35797;&#25968;&#25454;&#30340;&#31532;&#19968;&#34892;&#26159;&#19968;&#20010;&#27491;&#27491;&#25968; n&#65292;&#34920;&#31034;&#35813;&#32452;&#27979;&#35797;&#25968;
    &#25454;&#20013;&#21547;&#26377;&#30697;&#24418;&#30340;&#20010;&#25968; (n&lt;=1000), &#38543;&#21518;&#30340; n &#34892;&#65292;&#27599;&#34892;&#26377;&#20004;
    &#20010;&#25968; a, b (0&lt;a,b&lt;100)&#65292;&#34920;&#31034;&#30697;&#24418;&#30340;&#38271;&#21644;&#23485;

    1
    10
    1 2
    2 4
    5 8
    6 10
    7 9
    3 1
    5 8
    12 10
    9 7
    2 2

&#36755;&#20986;

    &#27599;&#32452;&#27979;&#35797;&#25968;&#25454;&#37117;&#36755;&#20986;&#19968;&#20010;&#25968;&#65292;&#34920;&#31034;&#26368;&#22810;&#31526;&#21512;&#26465;&#20214;&#30340;&#30697;&#24418;&#25968;&#30446;&#65292;&#27599;&#32452;&#36755;&#20986;&#21344;&#19968;&#34892;

    5</code></pre>
<p>&#26412;&#39064;&#23454;&#36136;&#19978;&#26159;<strong>&#27714; DAG &#20013;&#19981;&#22266;&#23450;&#36215;&#28857;&#30340;&#26368;&#38271;&#36335;&#24452;</strong>&#12290;</p>
<p>&#35774; <code>d[i]</code> &#34920;&#31034;&#20174;&#32467;&#28857; i &#20986;&#21457;&#30340;&#26368;&#38271;&#38271;&#24230;&#65292;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#22914;&#19979;&#65306;</p>
<pre><code>d[i] = max {
                        d[j]+1,                     (i,j) ~ E
}</code></pre>
<p>&#20854;&#20013;&#65292;E &#20026;&#36793;&#30340;&#38598;&#21512;&#12290;&#26368;&#32456;&#31572;&#26696;&#26159; <code>d[i]</code> &#20013;&#30340;&#26368;&#22823;&#20540;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="ot">#define MAXN 1000                           </span><span class="co">// &#30697;&#24418;&#26368;&#22823;&#20010;&#25968;</span>

<span class="dt">int</span> n;                                      <span class="co">// &#30697;&#24418;&#20010;&#25968;</span>
<span class="dt">int</span> G[MAXN][MAXN];                          <span class="co">// &#30697;&#24418;&#21253;&#21547;&#20851;&#31995;</span>
<span class="dt">int</span> d[MAXN];                                <span class="co">// &#34920;&#26684;</span>

<span class="co">// @brief &#22791;&#24536;&#24405;&#27861;.</span>
<span class="co">// @param[in] i &#36215;&#28857;</span>
<span class="co">// @return &#20197; i &#20026;&#36215;&#28857;&#65292;&#33021;&#36798;&#21040;&#30340;&#26368;&#38271;&#36335;&#24452;</span>
<span class="dt">int</span> dp(<span class="dt">const</span> <span class="dt">int</span> i) {
    <span class="dt">int</span> *ans= &amp;d[i];
    <span class="kw">if</span>( *ans &gt; <span class="dv">0</span> ) { <span class="kw">return</span> *ans; }

    *ans = <span class="dv">1</span>;
    <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j ) {
        <span class="kw">if</span>(G[i][j]) {
            <span class="dt">int</span> next = dp(j) + <span class="dv">1</span>;
            <span class="kw">if</span>( *ans &lt; next ) {
                *ans = next;
            }
        }
    }
    <span class="kw">return</span> *ans;
}

<span class="co">// @brief &#25353;&#23383;&#20856;&#24207;&#25171;&#21360;&#36335;&#24452;.</span>
<span class="co">// &#22914;&#26524;&#22810;&#20010; d[i] &#30456;&#31561;&#65292;&#36873;&#25321;&#26368;&#23567;&#30340; i&#12290;</span>
<span class="co">// @param[in] i &#36215;&#28857;</span>
<span class="dt">void</span> print_path(<span class="dt">const</span> <span class="dt">int</span> i) {
    printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, i);
    <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j ) {
        <span class="kw">if</span>(G[i][j] &amp;&amp; d[i] == d[j] + <span class="dv">1</span>) {
            print_path(j);
            <span class="kw">break</span>;
        }
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> N, i, j;
    <span class="dt">int</span> max, maxi;
    <span class="dt">int</span> a[MAXN],b[MAXN];

    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;N);
    <span class="kw">while</span>(N--) {
        memset(G, <span class="dv">0</span>, <span class="kw">sizeof</span>(G));
        memset(d, <span class="dv">0</span>, <span class="kw">sizeof</span>(d));

        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; n; i++) scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;a[i], &amp;b[i]);

        <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; n; i++)
            <span class="kw">for</span>(j = <span class="dv">0</span>; j &lt; n; j++)
                <span class="kw">if</span>((a[i] &gt; a[j] &amp;&amp; b[i] &gt; b[j]) ||
                    (a[i] &gt; b[j] &amp;&amp; b[i] &gt; a[j])) G[i][j] = <span class="dv">1</span>;

        max = <span class="dv">0</span>;
        maxi = <span class="dv">-1</span>;
        <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; n; i++) <span class="kw">if</span>(dp(i) &gt; max) {
            max = dp(i);
            maxi = i;
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, max);
        <span class="co">// print_path(maxi);</span>
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#32447;&#27573;&#35206;&#30422; 2 <code class="fold">@</code></dt>
<dd><p>&#25968;&#36724;&#19978;&#26377; n (n &lt;= 1000) &#26465;&#32447;&#27573;&#65292;&#32447;&#27573;&#30340;&#20004;&#31471;&#37117;&#26159;&#25972;&#25968;&#22352;&#26631;&#65292;&#22352;&#26631;&#33539;&#22260;&#22312; 0 ~ 1000000&#65292;&#27599;&#26465;&#32447;&#27573;&#26377;&#19968;&#20010;&#20215;&#20540;&#65292;&#35831;&#20174; n &#26465;&#32447;&#27573;&#20013;&#25361;&#20986;&#33509;&#24178;&#26465;&#32447;&#27573;&#65292;&#20351;&#24471;&#36825;&#20123;&#32447;&#27573;&#20004;&#20004;&#19981;&#35206;&#30422;&#65288;&#31471;&#28857;&#21487;&#20197;&#37325;&#21512;&#65289;&#19988;&#32447;&#27573;&#20215;&#20540;&#20043;&#21644;&#26368;&#22823;&#12290;</p>
<pre><code>&#36755;&#20837;

    &#31532;&#19968;&#34892;&#19968;&#20010;&#25972;&#25968; n&#65292;&#34920;&#31034;&#26377;&#22810;&#23569;&#26465;&#32447;&#27573;&#12290;

    &#25509;&#19979;&#26469; n &#34892;&#27599;&#34892;&#19977;&#20010;&#25972;&#25968;, a_i,b_i,c_i&#65292;&#20998;&#21035;&#20195;&#34920;&#31532; i
    &#26465;&#32447;&#27573;&#30340;&#24038;&#31471;&#28857; a_i&#65292;&#21491;&#31471;&#28857; b_i&#65288;&#20445;&#35777;&#24038;&#31471;&#28857; &lt; &#21491;&#31471;&#28857;&#65289;
    &#21644;&#20215;&#20540; c_i&#12290;

    3
    1 2 1
    2 3 2
    1 3 4

&#36755;&#20986;

    &#36755;&#20986;&#33021;&#22815;&#33719;&#24471;&#30340;&#26368;&#22823;&#20215;&#20540;

    4</code></pre>
<p>&#20808;&#23558;&#32447;&#27573;&#25490;&#24207;&#12290;&#25353;&#29031;&#21491;&#31471;&#28857;&#20174;&#23567;&#21040;&#22823;&#25490;&#24207;&#12290;&#21407;&#22240;&#26159;&#24490;&#29615;&#32467;&#26500;&#20013;&#26159; i &#20174; 1 &#21040; n, i &#27604;&#36739;&#23567;&#30340;&#26102;&#20505;&#23613;&#21487;&#33021;&#36873;&#21491;&#31471;&#28857;&#27604;&#36739;&#23567;&#30340;&#65292;&#36825;&#26679;&#25165;&#21487;&#20197;&#20026;&#21518;&#38754;&#30340;&#32447;&#27573;&#30041;&#19979;&#26356;&#22823;&#30340;&#31354;&#38388;&#12290;</p>
<p>&#35774;&#29366;&#24577;&#20026; <code>f[i]</code>&#65292;&#34920;&#31034;&#21069; i &#26465;&#32447;&#27573;&#26102;&#65292;&#36873;&#19978;&#31532; i &#26465;&#32447;&#27573;&#65292;&#33021;&#33719;&#24471;&#30340;&#26368;&#22823;&#20215;&#20540;&#12290;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#22914;&#19979;&#65306;</p>
<pre><code>f[i] = max {
                    max{ f[j] } + c[i],         2 &lt;= i &lt;= n, 1 &lt;= j &lt;= i-1, and b[j] &lt;= a[i]
}

b[j] &lt;= a[i] &#34920;&#31034; j &#30340;&#21491;&#31471;&#28857;&#22312; i &#30340;&#24038;&#31471;&#28857;&#24038;&#36793;&#65292;&#21363;&#19981;&#37325;&#21512;&#12290;</code></pre>
<p>&#36755;&#20986; <code>f[i]</code> &#25968;&#32452;&#20013;&#30340;&#26368;&#22823;&#20540;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// http://www.wikioi.com/problem/3027</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;limits.h&gt;</span>

<span class="ot">#define MAXN 1000</span>

<span class="kw">typedef</span> <span class="kw">struct</span> line_t {
    <span class="dt">int</span> a, b, c;
} line_t;

<span class="dt">int</span> line_cmp( <span class="dt">const</span> <span class="dt">void</span> *a, <span class="dt">const</span> <span class="dt">void</span> *b ) {
    line_t *la = (line_t*)a;
    line_t *lb = (line_t*)b;
    <span class="kw">return</span> la-&gt;b - lb-&gt;b;
}

<span class="dt">int</span> n;
line_t line[MAXN];
<span class="dt">int</span> f[MAXN];

<span class="dt">void</span> dp() {
    <span class="dt">int</span> i, j;
    qsort(line, n, <span class="kw">sizeof</span>(line_t), line_cmp);
    f[<span class="dv">0</span>] = line[<span class="dv">0</span>].c;

    <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt; n; i++) {
        <span class="dt">int</span> max = <span class="dv">0</span>;
        <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; i; j++) {
            <span class="kw">if</span> (line[j].b &lt;= line[i].a) max = max &gt; f[j] ? max : f[j];
        }
        f[i] = max + line[i].c;
    }
}

<span class="dt">static</span> <span class="dt">int</span> max_element(<span class="dt">const</span> <span class="dt">int</span> a[], <span class="dt">int</span> begin, <span class="dt">int</span> end) {
    <span class="dt">int</span> i;
    <span class="dt">int</span> max_value = INT_MIN;
    <span class="dt">int</span> max_pos = <span class="dv">-1</span>;
    <span class="kw">for</span> (i = begin; i &lt; end; i++) {
        <span class="kw">if</span> (max_value &lt; a[i]) {
            max_value = a[i];
            max_pos = i;
        }
    }
    <span class="kw">return</span> max_pos;
}


<span class="dt">int</span> main() {
    <span class="dt">int</span> i;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; i++) scanf(<span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, &amp;line[i].a, &amp;line[i].b, &amp;line[i].c);
    dp();
    printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, f[max_element(f, <span class="dv">0</span>, n)]);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#30828;&#24065;&#38382;&#39064; <code class="fold">@</code></dt>
<dd><p>&#26377; n &#31181;&#30828;&#24065;&#65292;&#38754;&#20540;&#20026;&#21035;&#20026; v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>, &#8230;, v<sub>n</sub>&#65292;&#27599;&#31181;&#37117;&#26377;&#26080;&#38480;&#22810;&#12290;&#32473;&#23450;&#38750;&#36127;&#25972;&#25968; S&#65292;&#21487;&#20197;&#36873;&#21462;&#22810;&#23569;&#20010;&#30828;&#24065;&#65292;&#20351;&#24471;&#38754;&#20540;&#21644;&#24688;&#22909;&#20026; S&#65311;&#36755;&#20986;&#30828;&#24065;&#25968;&#30446;&#30340;&#26368;&#23567;&#20540;&#21644;&#26368;&#22823;&#20540;&#12290; 1 &lt;= n &lt;= 100, 1 &lt;= S &lt;= 10000, 1 &lt;= v<sub>i</sub> &lt;= S&#12290;</p>
<pre><code>&#36755;&#20837;

    &#31532; 1 &#34892; n&#65292;&#31532; 2 &#34892; S&#65292;&#31532; 3 &#21040; n+2 &#34892;&#20026; n &#31181;&#19981;&#21516;&#30340;&#38754;&#20540;&#12290;

    3
    6
    1
    2
    3

&#36755;&#20986;

    &#31532; 1 &#34892;&#20026;&#26368;&#23567;&#20540;&#65292;
    &#31532; 2 &#34892;&#20026;&#26368;&#22823;&#20540;&#12290;

    2
    6</code></pre>
<p>&#26412;&#39064;&#23454;&#36136;&#19978;&#26159;&#27714; DAG &#20013;&#22266;&#23450;&#32456;&#28857;&#30340;&#26368;&#38271;&#36335;&#24452;&#21644;&#26368;&#30701;&#36335;&#24452;&#12290;</p>
<p>&#25226;&#27599;&#31181;&#38754;&#20540;&#30475;&#20316;&#19968;&#20010;&#28857;&#65292;&#34920;&#31034;&#8220;&#36824;&#38656;&#35201;&#20945;&#36275;&#30340;&#38754;&#20540;&#8221;&#65292;&#21017;&#21021;&#22987;&#29366;&#24577;&#20026; S&#65292;&#30446;&#26631;&#29366;&#24577;&#20026; 0&#12290;&#33509;&#24403;&#21069;&#29366;&#24577;&#20026; i&#65292;&#27599;&#20351;&#29992;&#19968;&#20010;&#30828;&#24065; j&#65292;&#29366;&#24577;&#20415;&#36716;&#31227;&#21040; i-v<sub>j</sub>&#12290;</p>
<p>&#35774;&#29366;&#24577;&#20026; <code>d[i]</code>&#65292;&#34920;&#31034;&#20174;&#33410;&#28857; i &#20986;&#21457;&#30340;&#26368;&#38271;&#36335;&#24452;&#38271;&#24230;&#65292;&#21017;&#21407;&#38382;&#39064;&#30340;&#35299;&#26159; <code>d[S]</code>&#12290;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#22914;&#19979;&#65306;</p>
<pre><code>d[i] = max {
                            d[j] + 1,                   (i,j) ~ E
}</code></pre>
<p>&#26412;&#39064;&#36824;&#21487;&#20197;&#30475;&#20316;&#26159;&#23436;&#20840;&#32972;&#21253;&#38382;&#39064;: &#32972;&#21253;&#23481;&#37327;&#20026; S&#65292;&#32972;&#21253;&#24517;&#39035;&#35201;&#35013;&#28385;&#65292;&#29289;&#21697;&#21363;&#30828;&#24065;&#65292;&#27599;&#20010;&#30828;&#24065;&#30340;&#36153;&#29992;&#20026;&#38754;&#20540; v<sub>i</sub>&#65292;&#20215;&#20540;&#22343;&#20026; 1&#12290;&#27714;&#32972;&#21253;&#20013;&#29289;&#21697;&#30340;&#26368;&#23567;&#20215;&#20540;&#21644;&#26368;&#22823;&#20215;&#20540;&#12290;</p>
<dl>
<dt>&#29256;&#26412; 1&#65292;&#22791;&#24536;&#24405;&#27861;&#12290; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="ot">#define MAXN 100</span>
<span class="ot">#define MAXV 10000</span>

<span class="co">/** </span>&#30828;&#24065;&#38754;&#20540;&#30340;&#31181;&#31867;. */
<span class="dt">int</span> n;
<span class="co">/** </span>&#35201;&#25214;&#38646;&#30340;&#25968;&#30446;. */
<span class="dt">int</span> S;
<span class="co">/** </span>&#30828;&#24065;&#30340;&#21508;&#31181;&#38754;&#20540;. */
<span class="dt">int</span> v[MAXN];
<span class="er">/** min[i] &#34920;&#31034;&#38754;&#20540;&#20043;&#21644;&#20026;i&#30340;&#26368;&#30701;&#36335;&#24452;&#30340;&#38271;&#24230;&#65292;max&#21017;&#26159;&#26368;&#38271;. */</span>
<span class="dt">int</span> min[MAXV + <span class="dv">1</span>], max[MAXV + <span class="dv">1</span>];

<span class="co">/**</span>
 * <span class="er">@</span>brief &#26368;&#30701;&#36335;&#24452;.
 * <span class="er">@</span>param[in] s &#38754;&#20540;
 * <span class="er">@</span>return &#26368;&#30701;&#36335;&#24452;&#38271;&#24230;
 */
<span class="dt">int</span> dp1(<span class="dt">const</span> <span class="dt">int</span> s) { <span class="co">// &#26368;&#23567;&#20540;</span>
    <span class="dt">int</span> i;
    <span class="dt">int</span> *ans = &amp;min[s];
    <span class="kw">if</span>(*ans != <span class="dv">-1</span>) <span class="kw">return</span> *ans;
    *ans = <span class="dv">1</span>&lt;&lt;<span class="dv">30</span>;
    <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; n; ++i) <span class="kw">if</span>(v[i] &lt;= s) {
        <span class="dt">const</span> <span class="dt">int</span> tmp = dp1(s-v[i])<span class="dv">+1</span>;
        *ans = *ans &lt; tmp ? *ans : tmp;
    }
    <span class="kw">return</span> *ans;
}

<span class="dt">int</span> visited[MAXV + <span class="dv">1</span>];
<span class="co">/**</span>
 * <span class="er">@</span>brief &#26368;&#38271;&#36335;&#24452;.
 * <span class="er">@</span>param[in] s &#38754;&#20540;
 * <span class="er">@</span>return &#26368;&#38271;&#36335;&#24452;&#38271;&#24230;
 */
<span class="dt">int</span> dp2(<span class="dt">const</span> <span class="dt">int</span> s) { <span class="co">//&#26368;&#22823;&#20540;</span>
    <span class="dt">int</span> i;
    <span class="dt">int</span> *ans = &amp;max[s];

    <span class="kw">if</span>(visited[s]) <span class="kw">return</span> max[s];
    visited[s] = <span class="dv">1</span>;

    *ans = <span class="dv">-1</span>&lt;&lt;<span class="dv">30</span>;
    <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; n; ++i) <span class="kw">if</span>(v[i] &lt;= s) {
        <span class="dt">const</span> <span class="dt">int</span> tmp = dp2(s-v[i])<span class="dv">+1</span>;
        *ans = *ans &gt; tmp ? *ans : tmp;
    }
    <span class="kw">return</span> *ans;
}

<span class="dt">void</span> print_path(<span class="dt">const</span> <span class="dt">int</span>* d, <span class="dt">const</span> <span class="dt">int</span> s);

<span class="dt">int</span> main() {
    <span class="dt">int</span> i;
    scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span><span class="co">,</span> &amp;n, &amp;S);
    <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; n; ++i) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span><span class="co">,</span> &amp;v[i]);

    memset(min, <span class="dv">-1</span>, <span class="kw">sizeof</span>(min));
    min[<span class="dv">0</span>] = <span class="dv">0</span>;
    printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span><span class="co">,</span> dp1(S));
    <span class="co">// print_path(min, S);</span>

    memset(max, <span class="dv">-1</span>, <span class="kw">sizeof</span>(max));
    memset(visited, <span class="dv">0</span>, <span class="kw">sizeof</span>(visited));
    max[<span class="dv">0</span>] = <span class="dv">0</span>; visited[<span class="dv">0</span>] = <span class="dv">1</span>;
    printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span><span class="co">,</span> dp2(S));
    <span class="co">// print_path(max, S);</span>

    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="co">/**</span>
 * <span class="er">@</span>brief &#25171;&#21360;&#36335;&#24452;.
 * <span class="er">@</span>param[in] d &#19978;&#38754;&#30340; min &#25110; min
 * <span class="er">@</span>param[in] s &#38754;&#20540;&#20043;&#21644;
 * <span class="er">@</span>return &#26080;
 */
<span class="dt">void</span> print_path(<span class="dt">const</span> <span class="dt">int</span>* d, <span class="dt">const</span> <span class="dt">int</span> s) {<span class="co">//&#25171;&#21360;&#30340;&#26159;&#36793;</span>
    <span class="dt">int</span> i;
    <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; n; ++i) <span class="kw">if</span>(v[i] &lt;= s &amp;&amp; d[s-v[i]] + <span class="dv">1</span> == d[s]) {
        printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span><span class="co">,</span>i);
        print_path(d, s-v[i]);
        <span class="kw">break</span>;
    }
    printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span><span class="co">)</span>;
}</code></pre></div>
</dd>
<dt>&#29256;&#26412;2&#65292;&#33258;&#24213;&#21521;&#19978;&#12290; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;stdio.h&gt;</span>

<span class="ot">#define MAXN 100</span>
<span class="ot">#define MAXV 10000</span>

<span class="dt">int</span> n, S, v[MAXN], min[MAXV + <span class="dv">1</span>], max[MAXV + <span class="dv">1</span>];
<span class="dt">int</span> min_path[MAXV], max_path[MAXV];

<span class="dt">void</span> dp() {
    <span class="dt">int</span> i, j;

    min[<span class="dv">0</span>] = max[<span class="dv">0</span>] = <span class="dv">0</span>;
    <span class="kw">for</span>(i = <span class="dv">1</span>; i &lt;= S; ++i) {
        min[i] = MAXV;
        max[i] = -MAXV;
    }

    <span class="kw">for</span>(i = <span class="dv">1</span>; i &lt;= S; ++i) {
        <span class="kw">for</span>(j = <span class="dv">0</span>; j &lt; n; ++j) <span class="kw">if</span>(v[j] &lt;= i) {
            <span class="kw">if</span>(min[i-v[j]] + <span class="dv">1</span> &lt; min[i]) {
                min[i] = min[i-v[j]] + <span class="dv">1</span>;
                min_path[i] = j;
            }
            <span class="kw">if</span>(max[i-v[j]] + <span class="dv">1</span> &gt; max[i]) {
                max[i] = max[i-v[j]] + <span class="dv">1</span>;
                max_path[i] = j;
            }
        }
    }
}

<span class="dt">void</span> print_path(<span class="dt">const</span> <span class="dt">int</span> *d, <span class="dt">int</span> s);

<span class="dt">int</span> main() {
    <span class="dt">int</span> i;
    scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;S);
    <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; n; ++i) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;v[i]);

    dp();
    printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, min[S]);
    <span class="co">// print_path(min_path, S);</span>
    printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, max[S]);
    <span class="co">// print_path(max_path, S);</span>
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="co">/**</span>
 * <span class="er">@</span>brief &#25171;&#21360;&#36335;&#24452;.
 * <span class="er">@</span>param[in] d &#19978;&#38754;&#30340; min_path &#25110; min_path
 * <span class="er">@</span>param[in] s &#38754;&#20540;&#20043;&#21644;
 * <span class="er">@</span>return &#26080;
 */
<span class="dt">void</span> print_path(<span class="dt">const</span> <span class="dt">int</span> *d, <span class="dt">int</span> s) {
    <span class="kw">while</span>(s) {
        printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span><span class="co">,</span> d[S]);
        S -= v[d[s]];
    }
    printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span><span class="co">)</span>;
}</code></pre></div>
</dd>
<dt>&#29256;&#26412; 3&#65292;&#24403;&#20316;&#23436;&#20840;&#32972;&#21253;&#38382;&#39064;&#12290; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;stdio.h&gt;</span>

<span class="ot">#define MAXN 100</span>
<span class="ot">#define MAXV 10000</span>

<span class="dt">int</span> n, S, v[MAXN], min[MAXV + <span class="dv">1</span>], max[MAXV + <span class="dv">1</span>];
<span class="dt">int</span> min_path[MAXV], max_path[MAXV];

<span class="dt">void</span> dp() {
    <span class="dt">int</span> i, j;

    min[<span class="dv">0</span>] = max[<span class="dv">0</span>] = <span class="dv">0</span>;
    <span class="kw">for</span>(i = <span class="dv">1</span>; i &lt;= S; ++i) {
        min[i] = MAXV;
        max[i] = -MAXV;
    }

    <span class="kw">for</span>(i = <span class="dv">1</span>; i &lt;= S; ++i) {
        <span class="kw">for</span>(j = <span class="dv">0</span>; j &lt; n; ++j) <span class="kw">if</span>(v[j] &lt;= i) {
            <span class="kw">if</span>(min[i-v[j]] + <span class="dv">1</span> &lt; min[i]) {
                min[i] = min[i-v[j]] + <span class="dv">1</span>;
                min_path[i] = j;
            }
            <span class="kw">if</span>(max[i-v[j]] + <span class="dv">1</span> &gt; max[i]) {
                max[i] = max[i-v[j]] + <span class="dv">1</span>;
                max_path[i] = j;
            }
        }
    }
}

<span class="dt">void</span> print_path(<span class="dt">const</span> <span class="dt">int</span> *d, <span class="dt">int</span> s);

<span class="dt">int</span> main() {
    <span class="dt">int</span> i;
    scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;S);
    <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; n; ++i) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;v[i]);

    dp();
    printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, min[S]);
    <span class="co">// print_path(min_path, S);</span>
    printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, max[S]);
    <span class="co">// print_path(max_path, S);</span>
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="co">/**</span>
 * <span class="er">@</span>brief &#25171;&#21360;&#36335;&#24452;.
 * <span class="er">@</span>param[in] d &#19978;&#38754;&#30340; min_path &#25110; min_path
 * <span class="er">@</span>param[in] s &#38754;&#20540;&#20043;&#21644;
 * <span class="er">@</span>return &#26080;
 */
<span class="dt">void</span> print_path(<span class="dt">const</span> <span class="dt">int</span> *d, <span class="dt">int</span> s) {
    <span class="kw">while</span>(s) {
        printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span><span class="co">,</span> d[S]);
        S -= v[d[s]];
    }
    printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span><span class="co">)</span>;
}</code></pre></div>
</dd>
</dl>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#21306;&#38388;&#22411;&#21160;&#24577;&#35268;&#21010; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#26368;&#20248;&#30697;&#38453;&#38142;&#20056; <code class="fold">@</code></dt>
<dd><p>&#19968;&#20010; <code>m * n</code> &#30340;&#30697;&#38453;&#20056;&#20197;&#19968;&#20010; <code>n * p</code> &#30340;&#30697;&#38453;&#31561;&#20110;&#19968;&#20010; <code>m * p</code> &#30340;&#30697;&#38453;&#65292;&#36816;&#31639;&#37327;&#20026; <code>m * n * p</code>&#12290;</p>
<p>&#30697;&#38453;&#20056;&#27861;&#19981;&#28385;&#36275;&#20998;&#37197;&#24459;&#65292;&#20294;&#28385;&#36275;&#32467;&#21512;&#24459;&#65292;&#21363; <code>A * B * C = (A * B) * C = A * (B * C)</code>&#12290;</p>
<p>&#20551;&#35774; A&#12289;B&#12289;C &#20998;&#21035;&#26159; 2 x 3&#12289;3 x 4&#12289;4 x 5 &#30340;&#30697;&#38453;&#65292;&#21017; (A * B) * C &#30340;&#36816;&#31639;&#37327;&#20026; 2 x 3 x 4 + 2 x 4 x 5 = 64&#65292; A * (B * C) &#30340;&#36816;&#31639;&#37327;&#20026; 3 x 4 x 5 + 2 x 3 x 5 = 90&#65292;&#26174;&#28982;&#31532;&#19968;&#31181;&#36816;&#31639;&#39034;&#24207;&#33410;&#30465;&#36816;&#31639;&#37327;&#12290;</p>
<p>&#32473;&#20986; N &#20010;&#30697;&#38453;&#32452;&#25104;&#30340;&#24207;&#21015;&#65292;&#35774;&#35745;&#19968;&#31181;&#26041;&#27861;&#25226;&#23427;&#20204;&#20381;&#27425;&#20056;&#36215;&#26469;&#65292;&#20351;&#24471;&#24635;&#30340;&#36816;&#31639;&#37327;&#23613;&#37327;&#23567;&#12290;</p>
<pre><code>&#36755;&#20837;

    &#23545;&#20110;&#27599;&#20010;&#30697;&#38453;&#24207;&#21015;&#65292;&#21482;&#32473;&#20986;&#23427;&#20204;&#30340;&#32500;&#24230;&#12290;&#27599;&#20010;&#24207;&#21015;&#30001;&#20004;&#20010;
    &#37096;&#20998;&#32452;&#25104;&#65292;&#31532;&#19968;&#34892;&#21253;&#21547;&#19968;&#20010;&#25972;&#25968; N&#65292;&#34920;&#31034;&#30697;&#38453;&#30340;&#20010;&#25968;&#65307;&#25509;
    &#19979;&#26469;&#30340; N &#34892;&#65292;&#27599;&#34892;&#19968;&#23545;&#25972;&#25968;&#65292;&#20998;&#21035;&#34920;&#31034;&#30697;&#38453;&#30340;&#34892;&#25968;&#21644;&#21015;&#25968;&#12290;
    &#32473;&#20986;&#30340;&#39034;&#24207;&#19982;&#30697;&#38453;&#38142;&#20056;&#30340;&#39034;&#24207;&#19968;&#33268;&#12290;&#26368;&#21518;&#19968;&#34892; N &#20026; 0&#65292;
    &#34920;&#31034;&#36755;&#20837;&#32467;&#26463;&#12290;N &#19981;&#22823;&#20110; 10&#12290;

    3
    1 5
    5 20
    20 1
    3
    5 10
    10 20
    20 35
    6
    30 35
    35 15
    15 5
    5 10
    10 20
    20 25
    0

&#36755;&#20986;

    &#20551;&#35774;&#30697;&#38453;&#21629;&#21517;&#20026; A_1,A_2,...,A_N&#12290;&#23545;&#27599;&#20010;&#27979;&#35797;&#29992;&#20363;&#36755;&#20986;&#19968;
    &#34892;&#65292;&#21253;&#21547;&#19968;&#20010;&#20351;&#29992;&#20102;&#23567;&#25324;&#21495;&#30340;&#34920;&#36798;&#24335;&#65292;&#28165;&#26224;&#22320;&#25351;&#20986;&#20056;&#27861;&#30340;
    &#20808;&#21518;&#39034;&#24207;&#12290;&#27599;&#34892;&#36755;&#20986;&#20197;&quot;Case x: &quot;&#20026;&#21069;&#32512;&#65292;x &#34920;&#31034;&#27979;&#35797;&#29992;&#20363;
    &#32534;&#21495;&#12290;&#22914;&#26524;&#26377;&#22810;&#20010;&#27491;&#30830;&#32467;&#26524;&#65292;&#21482;&#38656;&#35201;&#36755;&#20986;&#20854;&#20013;&#19968;&#20010;&#12290;

    Case 1: (A1 x (A2 x A3))
    Case 2: ((A1 x A2) x A3)
    Case 3: ((A1 x (A2 x A3)) x ((A4 x A5) x A6))</code></pre>
<p>&#20551;&#35774;&#31532; i &#20010;&#30697;&#38453; A<sub>i</sub> &#30340;&#32500;&#24230;&#26159; p<sub>i-1</sub> * p<sub>i</sub>, i=1..N&#12290;</p>
<p>&#35774;&#29366;&#24577;&#20026; <code>d[i][j]</code>&#65292;&#34920;&#31034;&#23376;&#38382;&#39064; A<sub>i</sub>, A<sub>i+1</sub>, &#8230;, A<sub>j</sub> &#30340;&#26368;&#20248;&#35299;&#65292;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#22914;&#19979;&#65306;</p>
<pre><code>d[i][j] = min {
                    d[i][k] + d[k+1][j] + p_{i-1} * p_k * p_j
}</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;memory.h&gt;</span>
<span class="ot">#include &lt;limits.h&gt;</span>

<span class="ot">#define INF INT_MAX</span>
<span class="ot">#define MAXN 10</span>

<span class="dt">int</span> N;  <span class="co">/** </span>&#30697;&#38453;&#30340;&#20010;&#25968;. */
<span class="dt">int</span> p[MAXN + <span class="dv">1</span>];  <span class="co">/** </span>&#30697;&#38453;Ai&#30340;&#32500;&#24230;&#26159;p[i<span class="dv">-1</span>]xp[i]. */
<span class="er">int d[MAXN][MAXN];  /** &#29366;&#24577;&#65292;d[i][j]&#34920;&#31034;&#23376;&#38382;&#39064;Ai~Aj &#30340;&#26368;&#20248;&#35299;. */</span>
<span class="dt">int</span> s[MAXN][MAXN]; <span class="co">/** </span>&#23376;&#38382;&#39064;Ai~Aj &#24212;&#35813;&#22312;s[i][j]&#22788;&#26029;&#24320; */

<span class="co">/**</span>
 * <span class="er">@</span>brief &#25171;&#21360;&#23376;&#38382;&#39064;Ai~Aj&#30340;&#35299;
 * <span class="er">@</span>param[in] i Ai
 * <span class="er">@</span>param[in] j Aj
 * <span class="er">@</span>return &#26080;
 */
<span class="dt">void</span> print(<span class="dt">const</span> <span class="dt">int</span> i, <span class="dt">const</span> <span class="dt">int</span> j) {
    <span class="kw">if</span> (i == j) {
        printf(<span class="st">&quot;A</span><span class="ch">%d</span><span class="st">&quot;</span><span class="co">,</span>i);
    } <span class="kw">else</span> {  <span class="co">/* i &lt; j */</span>
        printf(<span class="st">&quot;(&quot;</span><span class="co">)</span>;
        print(i, s[i][j]);
        printf(<span class="st">&quot; x &quot;</span><span class="co">)</span>;
        print(s[i][j]<span class="dv">+1</span>, j);
        printf(<span class="st">&quot;)&quot;</span><span class="co">)</span>;
    }
}

<span class="dt">void</span> dp() {
    <span class="dt">int</span> i, j, k, l; <span class="co">/* l&#34920;&#31034;&#21306;&#38388;&#38271;&#24230; */</span>
    <span class="kw">for</span> (i = <span class="dv">1</span>;i &lt;= N; ++i) d[i][i]=<span class="dv">0</span>;

    <span class="kw">for</span> (l = <span class="dv">2</span>; l &lt;= N; ++l) {
        <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt;= N - l + <span class="dv">1</span>; ++i) {
            j = i + l <span class="dv">-1</span>;
            d[i][j] = INF;
            <span class="kw">for</span> (k = i; k &lt; j; ++k) {
                <span class="kw">if</span> (d[i][j] &gt; d[i][k] + d[k<span class="dv">+1</span>][j] + p[i<span class="dv">-1</span>] * p[k] * p[j]) {
                    d[i][j] = d[i][k] + d[k<span class="dv">+1</span>][j] + p[i<span class="dv">-1</span>] * p[k] * p[j];
                    s[i][j] = k;
                }
            }
        }
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> i;
    <span class="dt">int</span> cas = <span class="dv">1</span>;
    <span class="kw">while</span> (scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span><span class="co">,</span> &amp;N) &amp;&amp; N &gt; <span class="dv">0</span>) {
        memset(s, <span class="dv">0</span>, <span class="kw">sizeof</span>(s));
        <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; N; ++i)  scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span><span class="co">,</span>&amp;p[i],&amp;p[i<span class="dv">+1</span>]);

        dp();

        printf(<span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">: &quot;</span><span class="co">,</span> cas++);
        print(<span class="dv">1</span>, N);
        printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span><span class="co">)</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>Matrix67 - &#21313;&#20010;&#21033;&#29992;&#30697;&#38453;&#20056;&#27861;&#35299;&#20915;&#30340;&#32463;&#20856;&#39064;&#30446;&#65292;<a href="http://www.matrix67.com/blog/archives/276" class="uri">http://www.matrix67.com/blog/archives/276</a></p>
</dd>
</dl></li>
<li><dl>
<dt>&#30707;&#23376;&#21512;&#24182; <code class="fold">@</code></dt>
<dd><p>&#22312;&#19968;&#26465;&#30452;&#32447;&#19978;&#25670;&#30528; N &#22534;&#30707;&#23376;&#12290;&#29616;&#35201;&#23558;&#30707;&#23376;&#26377;&#27425;&#24207;&#22320;&#21512;&#24182;&#25104;&#19968;&#22534;&#12290;&#35268;&#23450;&#27599;&#27425;&#21482;&#33021;&#36873;&#30456;&#37051;&#30340; 2 &#22534;&#30707;&#23376;&#21512;&#24182;&#25104;&#26032;&#30340;&#19968;&#22534;&#65292;&#24182;&#23558;&#26032;&#30340;&#19968;&#22534;&#30707;&#23376;&#25968;&#35760;&#20026;&#35813;&#27425;&#21512;&#24182;&#30340;&#24471;&#20998;&#12290;</p>
<p>&#35797;&#35774;&#35745;&#19968;&#20010;&#31639;&#27861;&#65292;&#35745;&#31639;&#20986;&#23558; N &#22534;&#30707;&#23376;&#21512;&#24182;&#25104;&#19968;&#22534;&#30340;&#26368;&#23567;&#24471;&#20998;&#12290;</p>
<pre><code>&#36755;&#20837;

    &#31532;&#19968;&#34892;&#26159;&#19968;&#20010;&#25968; N, 1 &lt;= N &lt;= 40000&#65292;&#34920;&#31034;&#22534;&#25968;&#12290;

    &#25509;&#19979;&#26469;&#30340; N &#34892;&#27599;&#34892;&#19968;&#20010;&#25968;&#65292;&#34920;&#31034;&#35813;&#22534;&#30340;&#30707;&#23376;&#25968;&#30446;&#12290;

    4
    1
    1
    1
    1

&#36755;&#20986;

    &#19968;&#20010;&#25972;&#25968;&#65292;&#21363; N &#22534;&#30707;&#23376;&#21512;&#24182;&#25104;&#19968;&#22534;&#30340;&#26368;&#23567;&#24471;&#20998;&#12290;

    8</code></pre>
<p>&#36825;&#39064;&#19982;&#21069;&#38754;&#30340;&#30697;&#38453;&#38142;&#20056;&#38750;&#24120;&#30456;&#20284;&#65292;&#21482;&#26159;&#35745;&#31639;&#20195;&#20215;&#30340;&#26041;&#24335;&#19981;&#21516;&#12290;&#35774;&#29366;&#24577;&#20026; d(i,j)&#65292;&#34920;&#31034;&#23376;&#38382;&#39064;&#31532; i &#22534;&#21040;&#31532; j &#22534;&#30707;&#23376;&#30340;&#26368;&#20248;&#35299;&#65292;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#22914;&#19979;&#65306;</p>
<pre><code>d(i,j) = min {
                    d(i,k) + d(k+1,j) + sum(i,j)
}</code></pre>
<p>sum(i,j) &#34920;&#31034;&#20174;&#31532; i &#22534;&#21040;&#31532; j &#22534;&#30340;&#30707;&#23376;&#24635;&#25968;&#12290;&#20195;&#30721;&#35265; <a href="https://gist.github.com/soulmachine/6195139" class="uri">https://gist.github.com/soulmachine/6195139</a></p>
<p>&#19978;&#38754;&#30340;&#21160;&#35268;&#31639;&#27861;&#21487;&#20197;&#29992;&#22235;&#36793;&#24418;&#19981;&#31561;&#24335;&#36827;&#34892;&#20248;&#21270;&#65292;&#23558;&#26102;&#38388;&#22797;&#26434;&#24230;&#20174; O(N<sup>3</sup>) &#19979;&#38477;&#21040; O(N<sup>2</sup>)&#12290;</p>
<p>&#26080;&#35770;&#22914;&#20309;&#65292;&#26102;&#38388;&#22797;&#26434;&#24230;&#37117;&#26159; O(N<sup>2</sup>)&#65292;&#26412;&#39064;&#20013; N &#33539;&#22260;&#29305;&#21035;&#22823;&#65292;&#24320;&#19981;&#20102;&#36825;&#20040;&#22823;&#30340;&#20108;&#32500;&#25968;&#32452;&#12290;&#25152;&#20197;&#21160;&#35268;&#31639;&#27861;&#21482;&#33021;&#22788;&#29702;&#23567;&#35268;&#27169;&#30340;&#24773;&#20917;&#12290;&#19979;&#38754;&#20171;&#32461;&#31532;&#19977;&#31181;&#35299;&#27861;&#65292;Garsia-Wachs &#31639;&#27861;</p>
<p>&#20551;&#35774;&#25105;&#20204;&#21482;&#23545; 3 &#22534;&#30707;&#23376; a,b,c &#36827;&#34892;&#21512;&#24182;, &#20808;&#21512;&#24182;&#21738;&#20004;&#22534;, &#33021;&#20351;&#24471;&#24471;&#20998;&#26368;&#23567;&#65311;&#26377;&#20004;&#31181;&#26041;&#26696;&#65306;</p>
<pre><code>score1 = (a+b) + ((a+b)+c)
score2 = (b+c) + ((b+c)+a)</code></pre>
<p>&#20551;&#35774; score1 &lt;= score2, &#21487;&#20197;&#25512;&#23548;&#20986; a &lt;= c&#65292;&#21453;&#36807;&#26469;&#65292;&#21482;&#35201; a &#21644; c &#30340;&#20851;&#31995;&#30830;&#23450;&#65292;&#21512;&#24182;&#30340;&#39034;&#24207;&#20063;&#30830;&#23450;&#12290;&#36825;&#23601;&#26159;<strong>2- &#36882;&#20943;&#24615;&#36136;</strong>&#12290;</p>
<p>Garsia-Wachs &#31639;&#27861;&#65292;&#23601;&#26159;&#22522;&#20110;&#36825;&#20010;&#24615;&#36136;&#65292;&#25214;&#20986;&#24207;&#21015;&#20013;&#28385;&#36275; <code>A[i-1] &lt;= A[i+1]</code> &#26368;&#23567;&#30340; i&#65292;&#21512;&#24182; <code>temp = A[i]+A[i-1]</code>&#65292;&#25509;&#30528;&#24448;&#21069;&#38754;&#25214;&#26159;&#21542;&#26377;&#28385;&#36275; <code>A[j] &gt; temp</code>&#65292;&#25226; temp &#20540;&#25554;&#20837; <code>A[j]</code> &#30340;&#21518;&#38754; (&#25968;&#32452;&#30340;&#21491;&#36793;)&#12290;&#24490;&#29615;&#36825;&#20010;&#36807;&#31243;&#19968;&#30452;&#21040;&#21482;&#21097;&#19979;&#19968;&#22534;&#30707;&#23376;&#32467;&#26463;&#12290;</p>
<p>&#20363;&#22914;, <code>13 9 5 7 8 6 14</code>, &#39318;&#20808;&#65292;&#25214;&#31532;&#19968;&#20010;&#28385;&#36275; <code>A[i-1] &lt;= A[i+1]</code> &#30340;&#19977;&#20010;&#36830;&#32493;&#28857;&#65292;&#26412;&#20363;&#20013;&#23601;&#26159; 5 7 8&#65292;5 &#21644; 7 &#21512;&#24182;&#24471;&#21040; 12&#65292;12 &#19981;&#26159;&#20002;&#22312;&#21407;&#26469;&#30340;&#20301;&#32622;&#65292;&#32780;&#26159;&#23558;&#23427;&#25554;&#20837;&#21040;&#31532;&#19968;&#20010;&#27604;&#23427;&#22823;&#30340;&#20803;&#32032;&#30340;&#21518;&#38754;&#65292;&#24471;&#21040; <code>13 12 9 8 6 14</code></p>
<p>&#25509;&#30528;&#26469;&#65292;&#20174;&#24038;&#21040;&#21491;&#25628;&#32034;&#19977;&#20010;&#36830;&#32493;&#28857;&#65292;&#25214;&#21040; 8 6 14&#65292;&#21512;&#24182; 8 &#21644; 6 &#30340;&#21040; 14&#65292;&#23558; 14 &#25554;&#20837;&#21040;&#36866;&#24403;&#20301;&#32622;&#65292;&#24471;&#21040; 14 13 12 9 14</p>
<p>&#25214;&#21040; 12 9 14&#65292;&#21512;&#24182; 12 &#21644; 9 &#24471;&#21040; 21&#65292;&#23558; 21 &#25554;&#20837;&#21040;&#36866;&#24403;&#20301;&#32622;&#65292;&#24471;&#21040; 21 14 13 14</p>
<p>&#25214;&#21040; 14 13 14&#65292;&#21512;&#24182; 14 &#21644; 13 &#24471;&#21040; 27&#65292;&#23558; 27 &#25554;&#20837;&#21040;&#36866;&#24403;&#20301;&#32622;&#65292;&#24471;&#21040; 27 21 14</p>
<p>&#22240;&#20026; 27&lt;14&#65292;&#20808;&#21512;&#24182; 21 &#21644; 14&#65292;&#24471;&#21040; 35&#65292;&#26368;&#21518;&#21512;&#24182; 27 &#21644; 35&#65292;&#24471;&#21040; 62&#65292;&#23601;&#26159;&#26368;&#32456;&#31572;&#26696;&#12290;</p>
<p>&#20026;&#20160;&#20040;&#35201;&#23558; temp &#25554;&#20837; <code>A[j]</code> &#30340;&#21518;&#38754;, &#21487;&#20197;&#29702;&#35299;&#20026;&#26159;&#20026;&#20102;<strong>&#20445;&#25345; 2- &#36882;&#20943;&#24615;&#36136;</strong>&#12290;&#20174; <code>A[j+1]</code> &#21040; <code>A[i-2]</code> &#30475;&#25104;&#19968;&#20010;&#25972;&#20307; <code>A[mid]</code>&#65292;&#29616;&#22312; <code>A[j]</code>, <code>A[mid]</code>, <code>temp(A[i-1]+A[i])</code>&#65292;&#22240;&#20026; <code>temp &lt; A[j]</code>&#65292;&#22240;&#27492;&#19981;&#31649;&#24590;&#26679;&#37117;&#26159; <code>A[mid]</code> &#21644; temp &#20808;&#21512;&#24182;, &#25152;&#20197;&#23558; temp &#20540;&#25554;&#20837; <code>A[j]</code> &#30340;&#21518;&#38754;&#19981;&#20250;&#24433;&#21709;&#32467;&#26524;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#define MAXN 55555</span>

<span class="dt">int</span> N, A[MAXN];                                         <span class="co">// &#22534;&#25968;&#65292;&#27599;&#22534;&#30340;&#30707;&#22836;&#20010;&#25968;</span>
<span class="dt">int</span> num, result;                                        <span class="co">// &#25968;&#32452;&#23454;&#38469;&#38271;&#24230;&#65292;&#32467;&#26524;</span>

<span class="dt">void</span> combine(<span class="dt">int</span> k) {                                   <span class="co">// &#21069;&#25552; A[k-1] &lt; A[k+1]</span>
    <span class="dt">int</span> temp=A[k] + A[k<span class="dv">-1</span>];                             <span class="co">// &#21512;&#24182; k-1&#21644;k</span>
    result += temp;

    <span class="kw">for</span>( <span class="dt">int</span> i = k; i &lt; num - <span class="dv">1</span>; ++i ) {                <span class="co">// &#32039;&#32553;</span>
        A[i] = A[i<span class="dv">+1</span>];
    }
    num--;

    <span class="dt">int</span> j;
    <span class="kw">for</span>( j = k<span class="dv">-1</span>; j &gt; <span class="dv">0</span> &amp;&amp; A[j<span class="dv">-1</span>] &lt; temp; --j ) {       <span class="co">// &#25554;&#20837;temp&#21040;&#21512;&#36866;&#20301;&#32622;</span>
        A[j] = A[j<span class="dv">-1</span>];
    }
    A[j] = temp;
    <span class="kw">while</span>( j &gt;= <span class="dv">2</span> &amp;&amp; A[j] &gt;= A[j<span class="dv">-2</span>] ) {                 <span class="co">// why?</span>
        <span class="dt">int</span> d = num - j;
        combine(j - <span class="dv">1</span>);
        j = num - d;
    }
}

<span class="dt">int</span> main() {
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;N);
    <span class="kw">if</span>( !N ) { <span class="kw">return</span> <span class="dv">0</span>; }
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i ) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;A[i]);
    }

    num=<span class="dv">2</span>;
    result=<span class="dv">0</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">2</span>; i &lt; N; i++) {
        A[num++] = A[i];
        <span class="kw">while</span>(num &gt;= <span class="dv">3</span> &amp;&amp; A[num<span class="dv">-3</span>] &lt;= A[num<span class="dv">-1</span>]) combine(num<span class="dv">-2</span>);
    }
    <span class="kw">while</span>(num &gt; <span class="dv">1</span>) combine(num<span class="dv">-1</span>);
    printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>,result);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#30697;&#38453;&#21462;&#25968;&#28216;&#25103; <code class="fold">@</code></dt>
<dd><p>&#24069;&#24069;&#32463;&#24120;&#36319;&#21516;&#23398;&#29609;&#19968;&#20010;&#30697;&#38453;&#21462;&#25968;&#28216;&#25103;&#65306;&#23545;&#20110;&#19968;&#20010;&#32473;&#23450;&#30340; <code>n*m</code> &#30340;&#30697;&#38453;&#65292;&#30697;&#38453;&#20013;&#30340;&#27599;&#20010;&#20803;&#32032; a<sub>ij</sub> &#22343;&#20026;&#38750;&#36127;&#25972;&#25968;&#12290;&#28216;&#25103;&#35268;&#21017;&#22914;&#19979;&#65306;</p>
<ul>
<li>&#27599;&#27425;&#21462;&#25968;&#26102;&#39035;&#20174;&#27599;&#34892;&#21508;&#21462;&#36208;&#19968;&#20010;&#20803;&#32032;&#65292;&#20849; n &#20010;&#65292;m &#27425;&#21518;&#21462;&#23436;&#30697;&#38453;&#25152;&#26377;&#20803;&#32032;&#65307;</li>
<li>&#27599;&#27425;&#21462;&#25968;&#26102;&#39035;&#20174;&#27599;&#34892;&#21508;&#21462;&#36208;&#19968;&#20010;&#20803;&#32032;&#65292;&#20849; n &#20010;&#65292;m &#27425;&#21518;&#21462;&#23436;&#30697;&#38453;&#25152;&#26377;&#20803;&#32032;&#65307;&#27599;&#27425;&#21462;&#36208;&#30340;&#21508;&#20010;&#20803;&#32032;&#21482;&#33021;&#26159;&#35813;&#20803;&#32032;&#25152;&#22312;&#34892;&#30340;&#34892;&#39318;&#25110;&#34892;&#23614;&#65307;</li>
<li>&#27599;&#27425;&#21462;&#25968;&#26102;&#39035;&#20174;&#27599;&#34892;&#21508;&#21462;&#36208;&#19968;&#20010;&#20803;&#32032;&#65292;&#20849; n &#20010;&#65292;m &#27425;&#21518;&#21462;&#23436;&#30697;&#38453;&#25152;&#26377;&#20803;&#32032;&#65307;&#27599;&#27425;&#21462;&#25968;&#37117;&#26377;&#19968;&#20010;&#24471;&#20998;&#20540;&#65292;&#20026;&#27599;&#34892;&#21462;&#25968;&#30340;&#24471;&#20998;&#20043;&#21644;&#65292;&#27599;&#34892;&#21462;&#25968;&#30340;&#24471;&#20998; = &#34987;&#21462;&#36208;&#30340;&#20803;&#32032;&#20540;*2i&#65292;&#20854;&#20013; i &#34920;&#31034;&#31532; i &#27425;&#21462;&#25968;&#65288;&#20174; 1 &#24320;&#22987;&#32534;&#21495;&#65289;&#65307;</li>
<li>&#27599;&#27425;&#21462;&#25968;&#26102;&#39035;&#20174;&#27599;&#34892;&#21508;&#21462;&#36208;&#19968;&#20010;&#20803;&#32032;&#65292;&#20849; n &#20010;&#65292;m &#27425;&#21518;&#21462;&#23436;&#30697;&#38453;&#25152;&#26377;&#20803;&#32032;&#65307;&#28216;&#25103;&#32467;&#26463;&#24635;&#24471;&#20998;&#20026; m &#27425;&#21462;&#25968;&#24471;&#20998;&#20043;&#21644;&#12290;</li>
</ul>
<p>&#24069;&#24069;&#24819;&#35831;&#20320;&#24110;&#24537;&#20889;&#19968;&#20010;&#31243;&#24207;&#65292;&#23545;&#20110;&#20219;&#24847;&#30697;&#38453;&#65292;&#21487;&#20197;&#27714;&#20986;&#21462;&#25968;&#21518;&#30340;&#26368;&#22823;&#24471;&#20998;&#12290;</p>
<pre><code>&#36755;&#20837;

    &#31532; 1 &#34892;&#20026;&#20004;&#20010;&#29992;&#31354;&#26684;&#38548;&#24320;&#30340;&#25972;&#25968; n &#21644; m, 1 &lt;= n,m &lt;= 90&#12290;
    &#31532; 2 ~ n+1 &#34892;&#20026; n*m &#30697;&#38453;&#65292;&#20854;&#20013;&#27599;&#34892;&#26377; m &#20010;&#29992;&#21333;&#20010;&#31354;&#26684;
    &#38548;&#24320;&#30340;&#38750;&#36127;&#25972;&#25968; a_{ij}, 0 &lt;= a_{ij} &lt;= 1000&#12290;

    2 3
    1 2 3
    3 4 2

&#36755;&#20986;

    &#36755;&#20986;&#20165;&#21253;&#21547; 1 &#34892;&#65292;&#20026;&#19968;&#20010;&#25972;&#25968;&#65292;&#21363;&#36755;&#20837;&#30697;&#38453;&#21462;&#25968;&#21518;&#30340;&#26368;&#22823;&#24471;&#20998;&#12290;

    82

&#31532; 1 &#27425;&#65306;&#31532; 1 &#34892;&#21462;&#34892;&#39318;&#20803;&#32032;&#65292;&#31532; 2 &#34892;&#21462;&#34892;&#23614;&#20803;&#32032;&#65292;&#26412;&#27425;&#24471;&#20998;&#20026; 1*21+2*21=6
&#31532; 2 &#27425;&#65306;&#20004;&#34892;&#22343;&#21462;&#34892;&#39318;&#20803;&#32032;&#65292;&#26412;&#27425;&#24471;&#20998;&#20026; 2*22+3*22=20
&#31532; 3 &#27425;&#65306;&#24471;&#20998;&#20026; 3*23+4*23=56&#12290;&#24635;&#24471;&#20998;&#20026; 6+20+56=82</code></pre>
<p>&#39318;&#20808;&#65292;&#27599;&#34892;&#20043;&#38388;&#26159;&#20114;&#30456;&#29420;&#31435;&#30340;&#65292;&#22240;&#27492;&#21487;&#20197;&#20998;&#21035;&#27714;&#20986;&#27599;&#34892;&#30340;&#26368;&#22823;&#24471;&#20998;&#65292;&#26368;&#21518;&#30456;&#21152;&#36215;&#26469;&#12290;</p>
<p>&#35774;&#29366;&#24577;&#20026; f(i,j)&#65292;&#34920;&#31034;&#21333;&#34892;&#30340;&#21306;&#38388; <code>[i,j]</code> &#30340;&#26368;&#22823;&#20540;&#65292;&#36716;&#31227;&#26041;&#31243;&#20026;</p>
<pre><code>f(i,j) = max    {
                        f(i+1,j) + a(i)*2^x,
                        f(i,j-1) + a(j)*2^x
                },                                  1 &lt;= x &lt;= m

&#31561;&#20215;&#20110;

f(i,j) = 2 * max{
                        f(i+1,j) + a(i),
                        f(i,j-1) + a(j)
                }</code></pre>
<p>&#21516;&#26102;&#65292;&#27880;&#24847;&#21040;&#65292;&#26368;&#22823;&#24471;&#20998;&#21487;&#33021;&#20250;&#38750;&#24120;&#22823;&#65292;&#22240;&#27492;&#38656;&#35201;&#29992;&#21040;&#22823;&#25972;&#25968;&#36816;&#31639;&#12290;&#39044;&#20272;&#19968;&#19979;&#26368;&#22823;&#24471;&#20998;&#65292;&#22823;&#27010;&#26159; 1000x2<sup>80</sup>&#65292;&#29992;&#35745;&#31639;&#22120;&#31639;&#19968;&#19979;&#65292;&#26377; 28 &#20301;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;memory.h&gt;</span>
<span class="ot">#include &lt;limits.h&gt;</span>

<span class="co">/* &#19968;&#20010;&#25968;&#32452;&#20803;&#32032;&#34920;&#31034;4&#20010;&#21313;&#36827;&#21046;&#20301;&#65292;&#21363;&#25968;&#32452;&#26159;&#19975;&#36827;&#21046;&#30340; */</span>
<span class="ot">#define BIGINT_RADIX 10000</span>
<span class="ot">#define RADIX_LEN 4</span>
<span class="co">/* 1000*2^80 &#26377; 28 &#20301; */</span>
<span class="ot">#define MAX_LEN (28/RADIX_LEN+1)  </span><span class="co">/* &#25972;&#25968;&#30340;&#26368;&#22823;&#20301;&#25968; */</span>

<span class="co">/**</span>
 * <span class="er">@</span>brief &#25171;&#21360;&#22823;&#25972;&#25968;.
<span class="er"> * @param[in] x &#22823;&#25972;&#25968;&#65292;&#29992;&#25968;&#32452;&#34920;&#31034;&#65292;&#20302;&#20301;&#22312;&#20302;&#22320;&#22336;</span>
 * <span class="er">@</span>param[in] n &#25968;&#32452;x&#30340;&#38271;&#24230;
 * <span class="er">@</span>return &#26080;
 */
<span class="dt">void</span> bigint_print(<span class="dt">const</span> <span class="dt">int</span> x[], <span class="dt">const</span> <span class="dt">int</span> n) {
    <span class="dt">int</span> i;
    <span class="dt">int</span> start_output = <span class="dv">0</span>;  <span class="co">/* &#29992;&#20110;&#36339;&#36807;&#21069;&#23548;0 */</span>
    <span class="kw">for</span> (i = n - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; --i) {
        <span class="kw">if</span> (start_output) {  <span class="co">/* &#22914;&#26524;&#22810;&#20313;&#30340;0&#24050;&#32463;&#37117;&#36339;&#36807;&#65292;&#21017;&#36755;&#20986; */</span>
            printf(<span class="st">&quot;</span><span class="ch">%04d</span><span class="st">&quot;</span><span class="co">,</span> x[i]);
        } <span class="kw">else</span> <span class="kw">if</span> (x[i] &gt; <span class="dv">0</span>) {
            printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span><span class="co">,</span> x[i]);
            start_output = <span class="dv">1</span>; <span class="co">/* &#30896;&#21040;&#31532;&#19968;&#20010;&#38750;0&#30340;&#20540;&#65292;&#23601;&#35828;&#26126;&#22810;&#20313;&#30340;0&#24050;&#32463;&#37117;&#36339;&#36807; */</span>
        }
    }

    <span class="kw">if</span>(!start_output) printf(<span class="st">&quot;0&quot;</span><span class="co">)</span>;  <span class="co">/* &#24403;x&#20840;&#20026;0&#26102; */</span>
}

<span class="co">/**</span>
 * <span class="er">@</span>brief &#19968;&#20010;32&#20301;&#25972;&#25968;&#36716;&#21270;&#20026;&#22823;&#25972;&#25968;bigint.
 * <span class="er">@</span>param[in] n <span class="dv">32</span>&#20301;&#25972;&#25968;
 * <span class="er">@</span>param[out] x &#22823;&#25972;&#25968;
 * <span class="er">@</span>return &#22823;&#25972;&#25968;
 */
<span class="dt">int</span>* int_to_bigint(<span class="dt">int</span> n, <span class="dt">int</span> x[]) {
    <span class="dt">int</span> i = <span class="dv">0</span>;
    memset(x, <span class="dv">0</span>, MAX_LEN * <span class="kw">sizeof</span>(<span class="dt">int</span>));
    <span class="kw">while</span> (n &gt; <span class="dv">0</span>) {
        x[i++] = n % BIGINT_RADIX;
        n /= BIGINT_RADIX;
    }
    <span class="kw">return</span> x;
}


<span class="co">/**</span>
 * <span class="er">@</span>brief &#22823;&#25972;&#25968;&#27604;&#36739;.
 * <span class="er">@</span>param[in] x x
 * <span class="er">@</span>param[in] y y
<span class="er"> * @return x&lt;y&#65292;&#36820;&#22238;-1&#65292;&#30456;&#31561;&#20110;&#36820;&#22238;0&#65292;&#22823;&#20110;&#36820;&#22238;1.</span>
 */
<span class="dt">int</span> bigint_cmp(<span class="dt">const</span> <span class="dt">int</span> x[], <span class="dt">const</span> <span class="dt">int</span> y[]) {
    <span class="dt">int</span> i, lenx = <span class="dv">0</span>, leny = <span class="dv">0</span>;
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; MAX_LEN; i++) {
        <span class="kw">if</span> (x[i] != <span class="dv">0</span>) lenx++;
        <span class="kw">else</span> <span class="kw">break</span>;
    }
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; MAX_LEN; i++) {
        <span class="kw">if</span> (y[i] != <span class="dv">0</span>) leny++;
        <span class="kw">else</span> <span class="kw">break</span>;
    }
    <span class="kw">if</span> (lenx &lt; leny) <span class="kw">return</span> <span class="dv">-1</span>;
    <span class="kw">else</span> <span class="kw">if</span> (lenx &gt; leny) <span class="kw">return</span> <span class="dv">1</span>;
    <span class="kw">else</span> {
        <span class="kw">for</span> (i = lenx - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; i--) {
            <span class="kw">if</span> (x[i] == y[i]) <span class="kw">continue</span>;
            <span class="kw">else</span> <span class="kw">if</span> (x[i] &gt; y[i]) <span class="kw">return</span> <span class="dv">1</span>;
            <span class="kw">else</span> <span class="kw">return</span> <span class="dv">-1</span>;
        }
        <span class="kw">return</span> <span class="dv">0</span>;
    }
}

<span class="co">/**</span>
 * <span class="er">@</span>brief &#22823;&#25972;&#25968;&#21152;&#19978;&#26222;&#36890;&#25972;&#25968;.
 * <span class="er">@</span>param[inout] x &#22823;&#25972;&#25968;
 * <span class="er">@</span>param[in] y <span class="dv">32</span>&#20301;&#25972;&#25968;
 * <span class="er">@</span>return &#22823;&#25972;&#25968;
 */
<span class="dt">int</span>* bigint_add(<span class="dt">int</span> x[], <span class="dt">const</span> <span class="dt">int</span> y) {
    <span class="dt">int</span> i;

    x[<span class="dv">0</span>] += y;
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; MAX_LEN; i++) {
        <span class="kw">if</span> (x[i] &gt;= BIGINT_RADIX) {
            x[i<span class="dv">+1</span>] += x[i] / BIGINT_RADIX;
            x[i] %= BIGINT_RADIX;
        }
    }
    <span class="kw">return</span> x;
}


<span class="co">/**</span>
 * <span class="er">@</span>brief &#20004;&#20010;&#22823;&#25972;&#25968;&#30456;&#21152;, in place.
 * <span class="er">@</span>param[inout] x x=x+y
 * <span class="er">@</span>param[in] y y
 * <span class="er">@</span>return &#26080;
 */
<span class="dt">void</span> bigint_add1(<span class="dt">int</span> x[], <span class="dt">const</span> <span class="dt">int</span> y[]) {
    <span class="dt">int</span> i;
    <span class="dt">int</span> c = <span class="dv">0</span>;

    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; MAX_LEN; i++) {  <span class="co">/* &#36880;&#20301;&#30456;&#21152; */</span>
        <span class="dt">const</span> <span class="dt">int</span> tmp = x[i] + y[i] + c;
        x[i] = tmp % BIGINT_RADIX;
        c = tmp / BIGINT_RADIX;
    }
}

<span class="co">/**</span>
 * <span class="er">@</span>brief &#22823;&#25972;&#25968;&#20056;&#27861;, x = x*y.
 * <span class="er">@</span>param[inout] x x
 * <span class="er">@</span>param[in] y y
 * <span class="er">@</span>return &#26080;
 */
<span class="dt">void</span> bigint_mul(<span class="dt">int</span> x[], <span class="dt">const</span> <span class="dt">int</span> y) {
    <span class="dt">int</span> i;
    <span class="dt">int</span> c = <span class="dv">0</span>; <span class="co">/* &#20445;&#23384;&#36827;&#20301; */</span>

    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; MAX_LEN; i++) { <span class="co">/*&#29992;y&#65292;&#21435;&#20056;&#20197;x&#30340;&#21508;&#20301;*/</span>
        <span class="dt">const</span> <span class="dt">int</span> tmp = x[i] * y + c;
        x[i] = tmp % BIGINT_RADIX;
        c = tmp / BIGINT_RADIX;
    }
}


<span class="ot">#define MAX 80   </span><span class="co">/* n,m&#30340;&#26368;&#22823;&#20540; */</span>

<span class="dt">int</span> n, m;
<span class="dt">int</span> matrix[MAX][MAX];  <span class="co">/* &#36755;&#20837;&#30697;&#38453; */</span>
<span class="co">/* f[i][j] &#34920;&#31034;&#26576;&#19968;&#34892;&#21306;&#38388;[i,j]&#30340;&#26368;&#22823;&#20540;&#65292;&#36716;&#31227;&#26041;&#31243;</span>
<span class="co"> * f[i][j] = f[i+1][j]+a[i]*2^x, f[i][j-1]+a[j]*2^x, 1&lt;=x&lt;=m</span>
<span class="co"> * &#31561;&#20215;&#20110; f[i][j] = 2*max(f[i+1][j]+a[i], f[i][j-1]+a[j])</span>
<span class="co"> */</span>
<span class="dt">int</span> f[MAX][MAX][MAX_LEN];
<span class="dt">int</span> tmp[MAX_LEN];

<span class="co">/**</span>
 * <span class="er">@</span>brief &#35745;&#31639;&#21333;&#34892;.
 * <span class="er">@</span>param[in] a &#26576;&#19968;&#34892;
 * <span class="er">@</span>return &#27492;&#34892;&#33021;&#33719;&#24471;&#30340;&#26368;&#22823;&#24471;&#20998;
 */
<span class="dt">int</span>* dp(<span class="dt">int</span> a[MAX], <span class="dt">int</span> l, <span class="dt">int</span> r) {
    <span class="kw">if</span> (l == r) {
        int_to_bigint(a[l] * <span class="dv">2</span>, f[l][r]);
        <span class="kw">return</span> f[l][r];
    }
    <span class="kw">if</span> (f[l][r][<span class="dv">0</span>] &gt;= <span class="dv">0</span>) <span class="kw">return</span> f[l][r];

    <span class="kw">if</span> (l &lt; r) {
        memcpy(f[l][r], dp(a, l<span class="dv">+1</span>, r), <span class="kw">sizeof</span>(f[l][r]));
        bigint_mul(bigint_add(f[l][r], a[l]), <span class="dv">2</span>);
        memcpy(tmp, dp(a, l, r<span class="dv">-1</span>), <span class="kw">sizeof</span>(tmp));
        bigint_mul(bigint_add(tmp, a[r]), <span class="dv">2</span>);

        <span class="kw">if</span> (bigint_cmp(f[l][r], tmp) &lt; <span class="dv">0</span>) memcpy(f[l][r], tmp, <span class="kw">sizeof</span>(tmp));
    }
    <span class="kw">return</span> f[l][r];
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> i, j, result[MAX_LEN];
    scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span><span class="co">,</span> &amp;n, &amp;m);

    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; i++) {
        <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; m; j++) {
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span><span class="co">,</span> &amp;matrix[i][j]);
        }
    }

    memset(result, <span class="dv">0</span>, <span class="kw">sizeof</span>(result));
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; i++) {
        memset(f, <span class="dv">0</span>, <span class="kw">sizeof</span>(f));
        <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; m; j++) {
            <span class="dt">int</span> k;
            <span class="kw">for</span> (k = <span class="dv">0</span>; k &lt; m; k++) {
                f[j][k][<span class="dv">0</span>] = <span class="dv">-1</span>;
            }
        }
        bigint_add1(result, dp(matrix[i], <span class="dv">0</span>, m<span class="dv">-1</span>));
    }
    bigint_print(result, MAX_LEN);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#26827;&#30424;&#22411;&#21160;&#24577;&#35268;&#21010; <code class="fold">@</code></dt>
<dd><ul>
<li><p>&#25968;&#23383;&#19977;&#35282;&#24418;&#65288;&#65288;&#30053;&#65289;&#35265;&#19978;&#38754;&#30340; triangle&#65289;</p></li>
<li><dl>
<dt>&#36807;&#27827;&#21330; <code class="fold">@</code></dt>
<dd><p>A &#28857;&#26377;&#19968;&#20010;&#36807;&#27827;&#21330;&#65292;&#38656;&#35201;&#36208;&#21040;&#30446;&#26631; B &#28857;&#12290;&#21330;&#34892;&#36208;&#35268;&#21017;&#65306;&#21487;&#20197;&#21521;&#19979;&#12289;&#25110;&#32773;&#21521;&#21491;&#12290;&#21516;&#26102;&#22312;&#26827;&#30424;&#19978;&#30340;&#20219;&#19968;&#28857;&#26377;&#19968;&#20010;&#23545;&#26041;&#30340;&#39532;&#65288;&#22914;&#19978;&#22270;&#30340; C &#28857;&#65289;&#65292;&#35813;&#39532;&#25152;&#22312;&#30340;&#28857;&#21644;&#25152;&#26377;&#36339;&#36291;&#19968;&#27493;&#21487;&#36798;&#30340;&#28857;&#31216;&#20026;&#23545;&#26041;&#39532;&#30340;&#25511;&#21046;&#28857;&#12290;&#20363;&#22914;&#19978;&#22270; C &#28857;&#19978;&#30340;&#39532;&#21487;&#20197;&#25511;&#21046; 9 &#20010;&#28857;&#65288;&#22270;&#20013;&#30340; P1&#65292;P2 &#8230;P8 &#21644; C&#65289;&#12290;&#21330;&#19981;&#33021;&#36890;&#36807;&#23545;&#26041;&#39532;&#30340;&#25511;&#21046;&#28857;&#12290;</p>
<pre><code>    0   1   2   3   4   5   6   7   8
    A-----------*-------*------------
1   |       *               *
2   |               C
3   |       *               *
4   |           *       *           B</code></pre>
<p>&#26827;&#30424;&#29992;&#22352;&#26631;&#34920;&#31034;&#65292;A &#28857;&#65288;0&#65292;0&#65289;&#12289;B &#28857;&#65288;n,m&#65289;(n,m &#20026;&#19981;&#36229;&#36807; 20 &#30340;&#25972;&#25968;&#65292;&#24182;&#30001;&#38190;&#30424;&#36755;&#20837;)&#65292;&#21516;&#26679;&#39532;&#30340;&#20301;&#32622;&#22352;&#26631;&#26159;&#38656;&#35201;&#32473;&#20986;&#30340;&#65288;&#32422;&#23450;: C &#19981;&#31561;&#20110; A&#65292;&#21516;&#26102; C &#19981;&#31561;&#20110; B&#65289;&#12290;&#29616;&#22312;&#35201;&#27714;&#20320;&#35745;&#31639;&#20986;&#21330;&#20174; A &#28857;&#33021;&#22815;&#21040;&#36798; B &#28857;&#30340;&#36335;&#24452;&#30340;&#26465;&#25968;&#12290;</p>
<pre><code>&#36755;&#20837;

    B &#28857;&#30340;&#22352;&#26631;&#65288;n,m&#65289;&#20197;&#21450;&#23545;&#26041;&#39532;&#30340;&#22352;&#26631;&#65288;X,Y&#65289;

    6 6 3 2

&#36755;&#20986;

    &#19968;&#20010;&#25972;&#25968;&#65288;&#36335;&#24452;&#30340;&#26465;&#25968;&#65289;

    17</code></pre>
<p>&#36825;&#26159;&#19968;&#20010;&#26827;&#30424;&#24418;&#21160;&#24577;&#35268;&#21010;&#12290;</p>
<p>&#35774;&#29366;&#24577;&#20026; <code>f[i][j]</code>&#65292;&#34920;&#31034;&#20174; (0,0) &#21040; (i,j) &#30340;&#36335;&#24452;&#30340;&#26465;&#25968;&#65292;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#20026;</p>
<pre><code>f[i][j] = f[i-1][j] + f[i][j-1]         if no horse at (i,j), else 0</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;memory.h&gt;</span>

<span class="ot">#define MAX 21</span>

<span class="dt">int</span> n, m;
<span class="dt">int</span> x, y;                                                   <span class="co">// &#39532;&#20799;&#30340;&#22352;&#26631;</span>

<span class="dt">int</span> g[MAX][MAX];                                            <span class="co">// &#26827;&#30424;&#65292;&#39532;&#20799;&#20197;&#21450;&#39532;&#20799;&#30340;&#25511;&#21046;&#28857;&#20026;1&#65292;&#20854;&#20313;&#20026;0</span>
<span class="dt">int</span> f[MAX][MAX];                                            <span class="co">// f[i][j] = f[i-1][j] + f[i][j-1]</span>

<span class="dt">void</span> dp() {
    memset(g, <span class="dv">0</span>, <span class="kw">sizeof</span>(g));
    g[x][y] = <span class="dv">1</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">8</span>; ++i ) {
        <span class="dt">static</span> <span class="dt">int</span> dx[] = {<span class="dv">-2</span>, <span class="dv">-1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">-1</span>, <span class="dv">-2</span>};     <span class="co">// &#20843;&#20010;&#25511;&#21046;&#28857;&#65292;&#39034;&#26102;&#38024;&#26041;&#21521;</span>
        <span class="dt">static</span> <span class="dt">int</span> dy[] = {<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">-1</span>, <span class="dv">-2</span>, <span class="dv">-2</span>, <span class="dv">-1</span>};
        <span class="kw">if</span>( <span class="dv">0</span> &lt;= x+dx[i] &amp;&amp; x+dx[i] &lt;= n &amp;&amp; <span class="dv">0</span> &lt;= y+dy[i] &amp;&amp; y+dy[i] &lt;= n ) {
            g[x+dx[i]][y+dy[i]] = <span class="dv">1</span>;
        }
    }

    memset(f, <span class="dv">0</span>, <span class="kw">sizeof</span>(f));
    f[<span class="dv">0</span>][<span class="dv">0</span>] = <span class="dv">1</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i ) { <span class="kw">if</span>( !g[i][<span class="dv">0</span>] ) { f[i][<span class="dv">0</span>] = f[i<span class="dv">-1</span>][<span class="dv">0</span>]; } }   <span class="co">// &#21021;&#22987;&#21270;&#36793;&#30028;</span>
    <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= m; ++j ) { <span class="kw">if</span>( !g[<span class="dv">0</span>][j] ) { f[<span class="dv">0</span>][j] = f[<span class="dv">0</span>][j<span class="dv">-1</span>]; } }
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= m; ++j ) {
            <span class="kw">if</span>( !g[i][j] ) {
                f[i][j] = f[i<span class="dv">-1</span>][j] + f[i][j<span class="dv">-1</span>];
            }
        }
    }
}

<span class="dt">int</span> main() {
    <span class="kw">while</span>( <span class="dv">4</span> == scanf(<span class="st">&quot;</span><span class="ch">%d%d%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m, &amp;x, &amp;y)) {
        dp();
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, f[n][m]);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#20256;&#32440;&#26465; <code class="fold">@</code></dt>
<dd><p>&#23567;&#28170;&#21644;&#23567;&#36713;&#26159;&#22909;&#26379;&#21451;&#20063;&#26159;&#21516;&#29677;&#21516;&#23398;&#65292;&#20182;&#20204;&#22312;&#19968;&#36215;&#24635;&#26377;&#35848;&#19981;&#23436;&#30340;&#35805;&#39064;&#12290;&#19968;&#27425;&#32032;&#36136;&#25299;&#23637;&#27963;&#21160;&#20013;&#65292;&#29677;&#19978;&#21516;&#23398;&#23433;&#25490;&#20570;&#25104;&#19968;&#20010; m &#34892; n &#21015;&#30340;&#30697;&#38453;&#65292;&#32780;&#23567;&#28170;&#21644;&#23567;&#36713;&#34987;&#23433;&#25490;&#22312;&#30697;&#38453;&#23545;&#35282;&#32447;&#30340;&#20004;&#31471;&#65292;&#22240;&#27492;&#65292;&#20182;&#20204;&#23601;&#26080;&#27861;&#30452;&#25509;&#20132;&#35848;&#20102;&#12290;&#24184;&#36816;&#30340;&#26159;&#65292;&#20182;&#20204;&#21487;&#20197;&#36890;&#36807;&#20256;&#32440;&#26465;&#26469;&#36827;&#34892;&#20132;&#27969;&#12290;&#32440;&#26465;&#35201;&#32463;&#30001;&#35768;&#22810;&#21516;&#23398;&#20256;&#21040;&#23545;&#26041;&#25163;&#37324;&#65292;&#23567;&#28170;&#22352;&#22312;&#30697;&#38453;&#30340;&#24038;&#19978;&#35282;&#65292;&#22352;&#26631; (1,1)&#65292;&#23567;&#36713;&#22352;&#22312;&#30697;&#38453;&#30340;&#21491;&#19979;&#35282;&#65292;&#22352;&#26631; (m,n)&#12290;&#20174;&#23567;&#28170;&#20256;&#21040;&#23567;&#36713;&#30340;&#32440;&#26465;&#21482;&#21487;&#20197;&#21521;&#19979;&#25110;&#32773;&#21521;&#21491;&#20256;&#36882;&#65292;&#20174;&#23567;&#36713;&#20256;&#32473;&#23567;&#28170;&#30340;&#32440;&#26465;&#21482;&#21487;&#20197;&#21521;&#19978;&#25110;&#32773;&#21521;&#24038;&#20256;&#36882;&#12290;</p>
<p>&#22312;&#27963;&#21160;&#36827;&#34892;&#20013;&#65292;&#23567;&#28170;&#24076;&#26395;&#32473;&#23567;&#36713;&#20256;&#36882;&#19968;&#24352;&#32440;&#26465;&#65292;&#21516;&#26102;&#24076;&#26395;&#23567;&#36713;&#32473;&#20182;&#22238;&#22797;&#12290;&#29677;&#37324;&#27599;&#20010;&#21516;&#23398;&#37117;&#21487;&#20197;&#24110;&#20182;&#20204;&#20256;&#36882;&#65292;&#20294;&#21482;&#20250;&#24110;&#20182;&#20204;&#19968;&#27425;&#65292;&#20063;&#23601;&#26159;&#35828;&#22914;&#26524;&#27492;&#20154;&#22312;&#23567;&#28170;&#36882;&#32473;&#23567;&#36713;&#32440;&#26465;&#30340;&#26102;&#20505;&#24110;&#24537;&#65292;&#37027;&#20040;&#22312;&#23567;&#36713;&#36882;&#32473;&#23567;&#28170;&#30340;&#26102;&#20505;&#23601;&#19981;&#20250;&#20877;&#24110;&#24537;&#12290;&#21453;&#20043;&#20134;&#28982;&#12290;</p>
<p>&#36824;&#26377;&#19968;&#20214;&#20107;&#24773;&#38656;&#35201;&#27880;&#24847;&#65292;&#20840;&#29677;&#27599;&#20010;&#21516;&#23398;&#24895;&#24847;&#24110;&#24537;&#30340;&#22909;&#24863;&#24230;&#26377;&#39640;&#26377;&#20302;&#65288;&#27880;&#24847;&#65306;&#23567;&#28170;&#21644;&#23567;&#36713;&#30340;&#22909;&#24515;&#31243;&#24230;&#27809;&#26377;&#23450;&#20041;&#65292;&#36755;&#20837;&#26102;&#29992; 0 &#34920;&#31034;&#65289;&#65292;&#21487;&#20197;&#29992;&#19968;&#20010; 0 ~ 100 &#30340;&#33258;&#28982;&#25968;&#26469;&#34920;&#31034;&#65292;&#25968;&#36234;&#22823;&#34920;&#31034;&#36234;&#22909;&#24515;&#12290;&#23567;&#28170;&#21644;&#23567;&#36713;&#24076;&#26395;&#23613;&#21487;&#33021;&#25214;&#22909;&#24515;&#31243;&#24230;&#39640;&#30340;&#21516;&#23398;&#26469;&#24110;&#24537;&#20256;&#32440;&#26465;&#65292;&#21363;&#25214;&#21040;&#26469;&#22238;&#20004;&#26465;&#20256;&#36882;&#36335;&#24452;&#65292;&#20351;&#24471;&#36825;&#20004;&#26465;&#36335;&#24452;&#19978;&#21516;&#23398;&#30340;&#22909;&#24515;&#31243;&#24230;&#21482;&#21644;&#26368;&#22823;&#12290;&#29616;&#22312;&#65292;&#35831;&#20320;&#24110;&#21161;&#23567;&#28170;&#21644;&#23567;&#36713;&#25214;&#21040;&#36825;&#26679;&#30340;&#20004;&#26465;&#36335;&#24452;&#12290;</p>
<pre><code>&#36755;&#20837;

    &#36755;&#20837;&#30340;&#31532;&#19968;&#34892;&#26377; 2 &#20010;&#29992;&#31354;&#26684;&#38548;&#24320;&#30340;&#25972;&#25968; m &#21644; n&#65292;&#34920;&#31034;&#29677;
    &#37324;&#26377; m &#34892; n &#21015; (1 &lt;= m,n &lt;= 50)&#12290;&#25509;&#19979;&#26469;&#30340; m &#34892;&#26159;&#19968;
    &#20010; m*n &#30340;&#30697;&#38453;&#65292;&#30697;&#38453;&#20013;&#31532; i &#34892; j &#21015;&#30340;&#25972;&#25968;&#34920;&#31034;&#22352;&#22312;
    &#31532; i &#34892; j &#21015;&#30340;&#23398;&#29983;&#30340;&#22909;&#24515;&#31243;&#24230;&#12290;
    &#27599;&#34892;&#30340; n &#20010;&#25972;&#25968;&#20043;&#38388;&#29992;&#31354;&#26684;&#38548;&#24320;

    3 3
    0 3 9
    2 8 5
    5 7 0

&#36755;&#20986;

    &#36755;&#20986;&#20849;&#19968;&#34892;&#65292;&#21253;&#21547;&#19968;&#20010;&#25972;&#25968;&#65292;&#34920;&#31034;&#26469;&#22238;&#20004;&#26465;&#36335;&#19978;&#21442;&#19982;&#20256;&#36882;
    &#32440;&#26465;&#30340;&#23398;&#29983;&#30340;&#22909;&#24515;&#31243;&#24230;&#20043;&#21644;&#30340;&#26368;&#22823;&#20540;&#12290;

    34</code></pre>
<p>&#36825;&#26159;&#19968;&#20010;&#26827;&#30424;&#24418;&#21160;&#24577;&#35268;&#21010;&#12290;&#29992;&#30697;&#38453; <code>int g[MAX][MAX]</code> &#23384;&#20648;&#36755;&#20837;&#25968;&#25454;&#65292;&#21363;&#27599;&#20010;&#23398;&#29983;&#30340;&#22909;&#24515;&#20540;&#12290;</p>
<p>&#39064;&#30446;&#31561;&#20215;&#20026;&#20026;&#20174; (1,1) &#20256;&#20004;&#24352;&#32440;&#26465;&#21040; (m,n)&#12290;&#27599;&#20010;&#32440;&#26465;&#37117;&#26159;&#30001;&#19978;&#38754;&#25110;&#24038;&#36793;&#20256;&#36882;&#36807;&#26469;&#30340;&#65292; &#25152;&#20197;&#26377;&#22235;&#31181;&#24773;&#20917;&#12290;&#35774;&#29366;&#24577;&#20026; <code>f[i][j][k][l]</code>&#65292;&#34920;&#31034;&#32440;&#26465;&#19968;&#22312; (i,j), &#32440;&#26465;&#20108;&#22312; (k,l) &#30340;&#22909;&#24515;&#31243;&#24230;&#20043;&#21644;&#65292;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#20026;</p>
<pre><code>f[i][j][k][l]   =   max {
                            f[i-1][j][k-1][l],
                            f[i-1][j][k][l-1],
                            f[i][j-1][k][l-1],
                            f[i][j-1][k-1][l]
                        }                       +   g[i][j] +   g[k][l];

(i,j-1) ---+   +--- (k-1,l)
            \ /
             x
            / \
(i-1,j) ---+   +--- (k,l-1)</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">void</span> dp( <span class="dt">const</span> vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; &amp;goodness, vector&lt;vector&lt;vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; &gt; &gt; &amp;table ) {
    <span class="dt">int</span> m = goodness.size();
    <span class="dt">int</span> n = goodness[<span class="dv">0</span>].size();
    <span class="dt">const</span> vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt;              &amp;g = goodness;
    vector&lt;vector&lt;vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; &gt; &gt;  &amp;f = table;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j ) {
            <span class="kw">for</span>( <span class="dt">int</span> k = <span class="dv">0</span>; k &lt; m; ++k ) {
                <span class="kw">for</span>( <span class="dt">int</span> l = <span class="dv">0</span>; l &lt; n; ++l ) {
                    <span class="co">// (i-1,j), (k-1, l)</span>
                    <span class="kw">if</span>( i &gt; <span class="dv">0</span> &amp;&amp; k &gt; <span class="dv">0</span> &amp;&amp; (i != k || j != l) ) {
                        f[i][j][k][l] = max(    f[i][j][k][l],
                                                f[i<span class="dv">-1</span>][j][k<span class="dv">-1</span>][l] + g[i][j]+g[k][l] );
                    }
                    <span class="co">// (i-1,j), (k, l-1)</span>
                    <span class="kw">if</span>( i &gt; <span class="dv">0</span> &amp;&amp; l &lt; n &amp;&amp; (i<span class="dv">-1</span> != k || j != l<span class="dv">-1</span>) ) {
                        f[i][j][k][l] = max(    f[i][j][k][l],
                                                f[i<span class="dv">-1</span>][j][k][l<span class="dv">-1</span>] + g[i][j]+g[k][l] );
                    }
                    <span class="co">// (i,j-1), (k, l-1)</span>
                    <span class="kw">if</span>( j &gt; <span class="dv">0</span> &amp;&amp; l &gt; <span class="dv">0</span> &amp;&amp; (i != k || j != l) ) {
                        f[i][j][k][l] = max(    f[i][j][k][l],
                                                f[i][j<span class="dv">-1</span>][k][l<span class="dv">-1</span>] + g[i][j]+g[k][l] );
                    }
                    <span class="co">// (i,j-1), (k-1, l)</span>
                    <span class="kw">if</span>( j &gt; <span class="dv">0</span> &amp;&amp; k &gt; <span class="dv">0</span> &amp;&amp; (i != k<span class="dv">-1</span> || j<span class="dv">-1</span> != l) ) {
                        f[i][j][k][l] = max(    f[i][j][k][l],
                                                f[i][j<span class="dv">-1</span>][k<span class="dv">-1</span>][l] + g[i][j]+g[k][l] );
                    }
                }
            }
        }
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> m, n;
    <span class="kw">while</span>( <span class="dv">2</span> == scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;m, &amp;n) ) {
        vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; goodness( m, vector&lt;<span class="dt">int</span>&gt;(n) );
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; ++i ) {
            <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j ) {
                scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;goodness[i][j] );
            }
        }
        vector&lt;vector&lt;vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; &gt; &gt;
            table(  m,
                    vector&lt;vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; &gt;( n,
                                                   vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt;( m, vector&lt;<span class="dt">int</span>&gt;(n, <span class="dv">0</span>) ) ) );
        dp( goodness, table );
        printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, table[m<span class="dv">-1</span>][n<span class="dv">-1</span>][m<span class="dv">-1</span>][n<span class="dv">-1</span>] );
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>TODO: &#26412;&#39064;&#21487;&#20197;&#20248;&#21270;&#20026;&#19977;&#32500;</p>
<pre><code>for( int i = 0; i &lt; m; ++i ) {
    for( int j = 0; j &lt; n; ++j ) {
        for( int k = 0; k &lt; m; ++k ) {
            for( int l = 0; l &lt; n; ++l ) {
                printf( &quot;%p &quot;, &amp;table[i][j][k][l] );
            }
        }
        printf(&quot;\n&quot;);
    }
}

0x19464e0 0x19464e4 0x19464e8 0x1946500 0x1946504 0x1946508 0x1946520 0x1946524 0x1946528
0x1946590 0x1946594 0x1946598 0x19465b0 0x19465b4 0x19465b8 0x19465d0 0x19465d4 0x19465d8
0x1946640 0x1946644 0x1946648 0x1946660 0x1946664 0x1946668 0x1946680 0x1946684 0x1946688
0x1946740 0x1946744 0x1946748 0x1946760 0x1946764 0x1946768 0x1946780 0x1946784 0x1946788
0x19467f0 0x19467f4 0x19467f8 0x1946810 0x1946814 0x1946818 0x1946830 0x1946834 0x1946838
0x19468a0 0x19468a4 0x19468a8 0x19468c0 0x19468c4 0x19468c8 0x19468e0 0x19468e4 0x19468e8
0x19469a0 0x19469a4 0x19469a8 0x19469c0 0x19469c4 0x19469c8 0x19469e0 0x19469e4 0x19469e8
0x1946a50 0x1946a54 0x1946a58 0x1946a70 0x1946a74 0x1946a78 0x1946a90 0x1946a94 0x1946a98
0x1946b00 0x1946b04 0x1946b08 0x1946b20 0x1946b24 0x1946b28 0x1946b40 0x1946b44 0x1946b48</code></pre>
</dd>
</dl></li>
<li><dl>
<dt>&#39569;&#22763;&#28216;&#21382; <code class="fold">@</code></dt>
<dd><p>&#35774;&#26377;&#19968;&#20010; n &#215; m &#30340;&#26827;&#30424; (2 &lt;= n &lt;= 50, 2 &lt;= m &lt;= 50)&#65292;&#22312;&#26827;&#30424;&#19978;&#26377;&#19968;&#20010;&#20013;&#22269;&#35937;&#26827;&#39532;&#12290;&#35268;&#23450;&#65306;</p>
<ul>
<li>&#39532;&#21482;&#33021;&#36208;&#26085;&#23383;</li>
<li>&#39532;&#21482;&#33021;&#21521;&#21491;&#36339;</li>
</ul>
<p>&#38382;&#32473;&#23450;&#36215;&#28857; (x1, y1) &#21644;&#32456;&#28857; (x2, y2)&#65292;&#27714;&#20986;&#39532;&#20174; (x1, y1) &#20986;&#21457;&#21040; (x2, y2) &#30340;&#21512;&#27861;&#36335;&#24452;&#26465;&#25968;&#12290;</p>
<pre><code>&#36755;&#20837;

    &#31532;&#19968;&#34892; 2 &#20010;&#25972;&#25968; n &#21644; m&#65292;&#31532;&#20108;&#34892; 4 &#20010;&#25972;&#25968; x1,y1,x2,y2

    30 30
    1 15 3 15

&#36755;&#20986;

    &#21512;&#27861;&#36335;&#24452;&#26465;&#25968;

    2</code></pre>
<p>&#36825;&#26159;&#19968;&#36947;&#26827;&#30424;&#22411;&#21160;&#24577;&#35268;&#21010;&#12290;</p>
<p>&#35774;&#29366;&#24577;&#20026; <code>f[i][j]</code>&#65292;&#34920;&#31034;&#20174;&#36215;&#28857; (x1,y1) &#21040; (i,j) &#30340;&#21512;&#27861;&#36335;&#24452;&#26465;&#25968;&#65292;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#20026;</p>
<pre><code>f[i][j] = f[i-1][j-2] + f[i-1][j+2] + f[i-2][j-1] + f[i-2][j+1]</code></pre>
<p>&#27880;&#24847;&#65292;&#21512;&#27861;&#36335;&#24452;&#26465;&#25968;&#26377;&#21487;&#33021;&#38750;&#24120;&#22823;&#65292;32 &#20301;&#25972;&#25968;&#23384;&#19981;&#19979;&#65292;&#38656;&#35201;&#29992; 64 &#20301;&#25972;&#25968;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;memory.h&gt;</span>
<span class="ot">#include &lt;stdint.h&gt;</span>

<span class="ot">#define MAX  51                 </span><span class="co">// n, m &#26368;&#22823;&#20540;</span>

<span class="dt">int</span> n, m;
<span class="dt">int</span> x1, y1, x2, y2;
<span class="dt">int64_t</span> f[MAX<span class="dv">+1</span>][MAX<span class="dv">+1</span>];        <span class="co">// f[i][j] &#34920;&#31034;&#20174; (x1,y1) &#21040; (i,j) &#30340;&#21512;&#27861;&#36335;&#24452;&#30340;&#26465;&#25968;</span>

<span class="dt">void</span> dp() {
    memset(f, <span class="dv">0</span>, <span class="kw">sizeof</span>(f));
    f[x1][y1] = <span class="dv">1</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = x1<span class="dv">+1</span>; i &lt;= x2; ++i ) {
        <span class="kw">for</span> ( <span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= m; ++j ) {
            f[i][j] = f[i<span class="dv">-1</span>][j<span class="dv">-2</span>] + f[i<span class="dv">-1</span>][j<span class="dv">+2</span>] + f[i<span class="dv">-2</span>][j<span class="dv">-1</span>] + f[i<span class="dv">-2</span>][j<span class="dv">+1</span>];
        }
    }
}

<span class="dt">int</span> main() {
    scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m);
    scanf(<span class="st">&quot;</span><span class="ch">%d%d%d%d</span><span class="st">&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);
    dp();
    <span class="co">// printf(&quot;%lld\n&quot;, f[x2][y2]);</span>
    printf(<span class="st">&quot;</span><span class="ch">%ld\n</span><span class="st">&quot;</span>, f[x2][y2]);     <span class="co">// lld: long long int, ld: long int</span>
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#21010;&#20998;&#22411;&#21160;&#24577;&#35268;&#21010; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#20056;&#31215;&#26368;&#22823; <code class="fold">@</code></dt>
<dd><p>&#35774;&#26377;&#19968;&#20010;&#38271;&#24230;&#20026; N &#30340;&#25968;&#23383;&#20018;&#65292;&#35201;&#27714;&#36873;&#25163;&#20351;&#29992; K &#20010;&#20056;&#21495;&#23558;&#23427;&#20998;&#25104; K+1 &#20010;&#37096;&#20998;&#65292;&#25214;&#20986;&#19968;&#31181;&#20998;&#27861;&#65292;&#20351;&#24471;&#36825; K+1 &#20010;&#37096;&#20998;&#30340;&#20056;&#31215;&#33021;&#22815;&#20026;&#26368;&#22823;&#12290;</p>
<p>&#20030;&#20010;&#20363;&#23376;&#65306;&#26377;&#19968;&#20010;&#25968;&#23383;&#20018;&#65306;312&#65292; &#24403; N=3&#65292;K=1 &#26102;&#20250;&#26377;&#20197;&#19979;&#20004;&#31181;&#20998;&#27861;&#65306;</p>
<ul>
<li>3x12 = 36</li>
<li>31x2 = 62</li>
</ul>
<p>&#36825;&#26102;&#65292;&#31526;&#21512;&#39064;&#30446;&#35201;&#27714;&#30340;&#32467;&#26524;&#26159;&#65306;31x2 = 62&#12290;</p>
<pre><code>&#36755;&#20837;

    &#36755;&#20837;&#20849;&#26377;&#20004;&#34892;&#65306;
    &#31532;&#19968;&#34892;&#20849;&#26377; 2 &#20010;&#33258;&#28982;&#25968; N,K (6 &lt;= N &lt;= 40, 1 &lt;= K &lt;= 6)
    &#31532;&#20108;&#34892;&#26159;&#19968;&#20010;&#38271;&#24230;&#20026; N &#30340;&#25968;&#23383;&#20018;&#12290;

    4 2
    1231

&#36755;&#20986;

    &#36755;&#20986;&#26368;&#22823;&#20056;&#31215;

    62</code></pre>
<p>&#39318;&#20808;&#65292;&#26412;&#39064;&#21487;&#20197;&#29992;&#21306;&#38388;&#22411;&#21160;&#24577;&#35268;&#21010;&#30340;&#24605;&#36335;&#35299;&#20915;&#12290;&#35774;&#29366;&#24577;&#20026; <code>f[i][j][k]</code>&#65292;&#34920;&#31034; i &#21040; j &#36825;&#19968;&#27573;&#29992; k &#20010;&#20056;&#21495;&#30340;&#26368;&#22823;&#20056;&#31215;&#65292;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#22914;&#19979;&#65306;</p>
<pre><code>f[i][j][k] = max {
                        f[i][s][t] * f[s+1][j][k-t-1]
},                                                          i &lt;= s &lt; j, 0 &lt;= t &lt; k</code></pre>
<p>&#22797;&#26434;&#24230;&#26159; O(N<sup>3</sup>K<sup>2</sup>)&#65292;&#20195;&#30721;&#22914;&#19979;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;stdint.h&gt;</span>

<span class="ot">#define MAXN 40</span>
<span class="ot">#define MAXK 6</span>

<span class="dt">int</span> N, K;
<span class="dt">char</span> str[MAXN];

<span class="co">// f[i][j][k] &#34920;&#31034; i &#21040; j &#36825;&#19968;&#27573;&#29992; k &#20010;&#20056;&#21495;&#30340;&#26368;&#22823;&#20056;&#31215;.</span>
<span class="dt">int64_t</span> f[MAXN][MAXN][MAXK<span class="dv">+1</span>];

<span class="ot">#define max(a,b) ((a)&gt;(b)?(a):(b))</span>

<span class="co">// &#35745;&#31639; str[l,r] &#23383;&#31526;&#20018;&#30340;&#20540;&#65292;int64 &#21487;&#20197;&#36807;&#65292;&#19981;&#29992;&#39640;&#31934;&#24230;.</span>
<span class="dt">int64_t</span> num(<span class="dt">int</span> l, <span class="dt">int</span> r) {
    <span class="dt">int64_t</span> ret = <span class="dv">0</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = l; i &lt;= r; ++r ) {
        ret = ret * <span class="dv">10</span> + str[i] - <span class="st">&#39;0&#39;</span>;
    }
    <span class="kw">return</span> ret;
}

<span class="co">// &#21306;&#38388;&#22411;&#21160;&#24577;&#35268;&#21010;&#65292;&#22797;&#26434;&#24230;&#26159; O(n^3*k^2).</span>
<span class="co">// f[i][j][k] = max(f[i][s][t] * f[s+1][j][k-t-1]), i &lt;= s &lt; j , 0 &lt;= t &lt; k</span>
<span class="dt">void</span> dp() {
    memset(f, <span class="dv">0</span>, <span class="kw">sizeof</span>(f));
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = i; j &lt; N; ++j ) {
            f[i][j][<span class="dv">0</span>] = num(i, j);
        }
    }

    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = i; j &lt; N; ++j ) {
            <span class="kw">for</span>( <span class="dt">int</span> k = <span class="dv">1</span>; k &lt;= K; ++k ) {
                <span class="kw">for</span>( <span class="dt">int</span> s = i; s &lt; j; ++s ) {
                    <span class="kw">for</span>( <span class="dt">int</span> t = <span class="dv">0</span>; t &lt; k; ++t ) {
                        f[i][j][k] = max(   f[i][j][k],
                                            f[i][s][t] * f[s + <span class="dv">1</span>][j][k - t - <span class="dv">1</span>] );
                    }
                }
            }
        }
    }
}

<span class="dt">int</span> main() {
    scanf( <span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;N, &amp;K );
    scanf( <span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, str );
    dp();
    printf( <span class="st">&quot;</span><span class="ch">%lld\n</span><span class="st">&quot;</span>, f[<span class="dv">0</span>][N<span class="dv">-1</span>][K] );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<dl>
<dt>&#22797;&#26434;&#24230;&#26159;O(N<sup>2</sup>K)&#12290;&#20195;&#30721;&#22914;&#19979;&#12290; <code class="fold">@</code></dt>
<dd><p>&#23613;&#31649;&#19978;&#38754;&#30340;&#20195;&#30721;&#21487;&#20197; AC &#20102;&#65292;&#20294;&#36824;&#26377;&#26356;&#39640;&#25928;&#30340;&#24605;&#36335;&#12290;&#35774;&#29366;&#24577;&#20026; <code>f[k][j]</code>&#65292;&#34920;&#31034;&#22312;&#21306;&#38388; <code>[0,j]</code> &#25918;&#20837; k &#20010;&#20056;&#21495;&#30340;&#26368;&#22823;&#20056;&#31215;&#65292;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#22914;&#19979;&#65306;</p>
<pre><code>f[k][j]=    max     {
                            f[k][j],
                            f[k-1][i]*num(i+1,j)
                    },                                  0 &lt;= i &lt; j</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// wikioi 1017 &#20056;&#31215;&#26368;&#22823;, http://www.wikioi.com/problem/1017</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;stdint.h&gt;</span>

<span class="ot">#define MAXN 40</span>
<span class="ot">#define MAXK 6</span>

<span class="dt">int</span> N, K;
<span class="dt">char</span> str[MAXN];

<span class="co">/** </span>f[k][j]&#22312;&#21306;&#38388;[<span class="dv">0</span>,j]&#25918;&#20837;k&#20010;&#20056;&#21495;&#30340;&#26368;&#22823;&#20056;&#31215;. */
<span class="dt">int64_t</span> f[MAXK<span class="dv">+1</span>][MAXN];

<span class="ot">#define max(a,b) ((a)&gt;(b)?(a):(b))</span>

<span class="er">/** &#35745;&#31639;str[l,r]&#23383;&#31526;&#20018;&#30340;&#20540;&#65292;int64&#21487;&#20197;&#36807;&#65292;&#19981;&#29992;&#39640;&#31934;&#24230;. */</span>
<span class="dt">int64_t</span> num(<span class="dt">int</span> l, <span class="dt">int</span> r) {
    <span class="dt">int64_t</span> ret = <span class="dv">0</span>;
    <span class="dt">int</span> i;
    <span class="kw">for</span> (i = l; i &lt;= r; i++) {
        ret = ret * <span class="dv">10</span> + str[i] - <span class="st">&#39;0&#39;</span>;
    }
    <span class="kw">return</span> ret;
}

<span class="er">/** &#21010;&#20998;&#22411;&#22411;&#21160;&#24577;&#35268;&#21010;&#65292;&#22797;&#26434;&#24230;&#26159;O(n^3*k^2). */</span>
<span class="dt">void</span> dp() {
    <span class="dt">int</span> i, j, k;
    memset(f, <span class="dv">0</span>, <span class="kw">sizeof</span>(f));
    <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; N; j++) {
        f[<span class="dv">0</span>][j] = num(<span class="dv">0</span>, j);
    }

    <span class="kw">for</span> (k = <span class="dv">1</span>; k &lt;= K; k++) {
        <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; N; j++) {
            <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; j; i++) {
                f[k][j] = max(f[k][j], f[k<span class="dv">-1</span>][i]*num(i<span class="dv">+1</span>, j));
            }
        }
    }
}

<span class="dt">int</span> main() {
    scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span><span class="co">,</span> &amp;N, &amp;K);
    scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span><span class="co">,</span> str);
    dp();
    printf(<span class="st">&quot;</span><span class="ch">%lld\n</span><span class="st">&quot;</span><span class="co">,</span> f[K][N<span class="dv">-1</span>]);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>&#25968;&#30340;&#21010;&#20998; <code class="fold">@</code></dt>
<dd><p>&#23558;&#25972;&#25968; n &#20998;&#25104; k &#20221;&#65292;&#19988;&#27599;&#20221;&#19981;&#33021;&#20026;&#31354;&#65292;&#20219;&#24847;&#20004;&#31181;&#21010;&#20998;&#26041;&#26696;&#19981;&#33021;&#30456;&#21516; (&#19981;&#32771;&#34385;&#39034;&#24207;)&#12290;</p>
<p>&#20363;&#22914;&#65306;n=7&#65292;k=3&#65292;&#19979;&#38754;&#19977;&#31181;&#21010;&#20998;&#26041;&#26696;&#34987;&#35748;&#20026;&#26159;&#30456;&#21516;&#30340;&#12290;</p>
<pre><code>1 1 5
1 5 1
5 1 1</code></pre>
<p>&#38382;&#26377;&#22810;&#23569;&#31181;&#19981;&#21516;&#30340;&#20998;&#27861;&#12290;</p>
<pre><code>&#36755;&#20837;

    n, k (6&lt;n &lt;= 200,2 &lt;= k &lt;= 6)

    7 3

&#36755;&#20986;

    &#19968;&#20010;&#25972;&#25968;&#65292;&#21363;&#19981;&#21516;&#30340;&#20998;&#27861;&#12290;

    4</code></pre>
<p>&#35774;&#29366;&#24577;&#20026; <code>f[k][i]</code>&#65292;&#34920;&#31034;&#23558;&#25972;&#25968; i &#20998;&#25104; k &#20221;&#30340;&#26041;&#26696;&#25968;&#12290;&#26377;&#20004;&#31181;&#24773;&#20917;&#65292;&#19968;&#31181;&#21010;&#20998;&#20013;&#26377;&#33267;&#23569;&#19968;&#20010; 1&#65292;&#21478;&#22806;&#19968;&#31181;&#21010;&#20998;&#20013;&#25152;&#26377;&#30340;&#25968;&#37117;&#22823;&#20110; 1&#12290;&#23545;&#20110;&#31532;&#19968;&#31181;&#21010;&#20998;&#65292;&#21435;&#25481;&#19968;&#20010; 1&#65292;&#23601;&#21464;&#25104;&#20102;&#19968;&#20010;&#20110;&#23376;&#38382;&#39064; <code>f[n-1][k-1]</code>&#65292;&#23545;&#20110;&#31532;&#20108;&#31181;&#21010;&#20998;&#65292;&#25226;&#21010;&#20998;&#20013;&#30340;&#27599;&#20010;&#25968;&#37117;&#20943;&#21435; 1&#65292;&#23601;&#21464;&#25104;&#20102;&#19968;&#20010;&#23376;&#38382;&#39064;<code>f[k][n-k]</code>&#12290;&#22240;&#27492;&#65292;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#22914;&#19979;&#65306;</p>
<pre><code>f[k][i] = f[k-1][i-1] + f[k][i-k]</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// wikioi 1039 &#25968;&#30340;&#21010;&#20998;, http://www.wikioi.com/problem/1039</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;memory.h&gt;</span>

<span class="ot">#define MAXN 300</span>
<span class="ot">#define MAXK 10</span>

<span class="dt">int</span> N, K;
<span class="dt">int</span> f[MAXK<span class="dv">+1</span>][MAXN<span class="dv">+1</span>];                      <span class="co">// f[k][i] &#34920;&#31034;&#23558;&#25972;&#25968; i &#20998;&#25104; k &#20221;&#30340;&#26041;&#26696;&#25968;.</span>

<span class="dt">void</span> dp() {                                 <span class="co">// &#21010;&#20998;&#22411;&#21160;&#24577;&#35268;&#21010;&#65292;&#22797;&#26434;&#24230;&#26159; O(K*N)</span>
    memset(f, <span class="dv">0</span>, <span class="kw">sizeof</span>(f));
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= N; ++i ) {
        f[<span class="dv">1</span>][i] = <span class="dv">1</span>;
        <span class="kw">if</span>( i &lt;= K ) { f[i][i] = <span class="dv">1</span>; }
    }

    <span class="kw">for</span>( <span class="dt">int</span> k = <span class="dv">2</span>; k &lt;= K; ++k ) {
        <span class="kw">for</span>( <span class="dt">int</span> i = k<span class="dv">+1</span>; i &lt;= N; ++i ) {
            f[k][i] = f[k<span class="dv">-1</span>][i<span class="dv">-1</span>] + f[k][i-k];
        }
    }
}

<span class="dt">int</span> main() {
    scanf( <span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;N, &amp;K );
    dp();
    printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, f[K][N] );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#26641;&#22411;&#21160;&#24577;&#35268;&#21010; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#35775;&#38382;&#33402;&#26415;&#39302; <code class="fold">@</code></dt>
<dd><p>&#30382;&#23572;&#26159;&#19968;&#20010;&#20986;&#20102;&#21517;&#30340;&#30423;&#30011;&#32773;&#65292;&#20182;&#32463;&#36807;&#25968;&#26376;&#30340;&#31934;&#24515;&#20934;&#22791;&#65292;&#25171;&#31639;&#21040;&#33402;&#26415;&#39302;&#30423;&#30011;&#12290;&#33402;&#26415;&#39302;&#30340;&#32467;&#26500;&#65292;&#27599;&#26465;&#36208;&#24266;&#35201;&#20040;&#20998;&#21449;&#20026;&#20108;&#26465;&#36208;&#24266;&#65292;&#35201;&#20040;&#36890;&#21521;&#19968;&#20010;&#23637;&#35272;&#23460;&#12290;&#30382;&#23572;&#30693;&#36947;&#27599;&#20010;&#23637;&#23460;&#37324;&#34255;&#30011;&#30340;&#25968;&#37327;&#65292;&#24182;&#19988;&#20182;&#31934;&#30830;&#22320;&#27979;&#37327;&#20102;&#36890;&#36807;&#27599;&#26465;&#36208;&#24266;&#30340;&#26102;&#38388;&#65292;&#30001;&#20110;&#32463;&#39564;&#32769;&#36947;&#65292;&#20182;&#25343;&#19979;&#19968;&#21103;&#30011;&#38656;&#35201; 5 &#31186;&#30340;&#26102;&#38388;&#12290;&#20320;&#30340;&#20219;&#21153;&#26159;&#35774;&#35745;&#19968;&#20010;&#31243;&#24207;&#65292;&#35745;&#31639;&#22312;&#35686;&#23519;&#36214;&#26469;&#20043;&#21069; (&#35686;&#23519;&#21040;&#36798;&#26102;&#30382;&#23572;&#22238;&#21040;&#20102;&#20837;&#21475;&#20063;&#31639;)&#65292;&#20182;&#26368;&#22810;&#33021;&#20599;&#21040;&#22810;&#23569;&#24133;&#30011;&#12290;</p>
<pre><code>&#36755;&#20837;

    &#31532; 1 &#34892;&#26159;&#35686;&#23519;&#36214;&#21040;&#24471;&#26102;&#38388; s(s &lt;= 600)&#65292;&#20197;&#31186;&#20026;&#21333;&#20301;&#12290;&#31532;
    2 &#34892;&#25551;&#36848;&#20102;&#33402;&#26415;&#39302;&#24471;&#32467;&#26500;&#65292;&#26159;&#19968;&#20018;&#38750;&#36127;&#25972;&#25968;&#65292;&#25104;&#23545;&#22320;&#20986;&#29616;&#65306;
    &#27599;&#19968;&#23545;&#24471;&#31532;&#19968;&#20010;&#25968;&#26159;&#36208;&#36807;&#19968;&#26465;&#36208;&#24266;&#24471;&#26102;&#38388;&#65292;&#31532; 2 &#20010;&#25968;&#26159;
    &#23427;&#26411;&#31471;&#24471;&#34255;&#30011;&#25968;&#37327;&#65307;&#22914;&#26524;&#31532; 2 &#20010;&#25968;&#26159; 0&#65292;&#37027;&#20040;&#35828;&#26126;&#36825;&#26465;&#36208;
    &#24266;&#20998;&#21449;&#20026;&#20004;&#26465;&#21478;&#22806;&#24471;&#36208;&#24266;&#12290;&#36208;&#24266;&#30340;&#25968;&#30446; &lt;= 100&#12290;&#25968;&#25454;&#25353;&#29031;
    &#28145;&#24230;&#20248;&#20808;&#24471;&#27425;&#24207;&#32473;&#20986;&#65292;&#35831;&#30475;&#26679;&#20363;

    60
    7 0
        8 0
            3 1
            14 2
        10 0
            12 4
            6 2

&#36755;&#20986;

    &#36755;&#20986;&#20599;&#21040;&#24471;&#30011;&#24471;&#25968;&#37327;

    2</code></pre>
<p>&#35774;&#29366;&#24577;&#20026; <code>f[root][time]</code>&#65292;&#34920;&#31034;&#22312; root &#33410;&#28857;&#65292;&#21097;&#19979; time &#26102;&#38388;&#20869;&#33021;&#20599;&#21040;&#30340;&#30011;&#25968;&#65292;&#21017;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#22914;&#19979;&#65306;</p>
<pre><code>f[root][time]= max{
                            f[left][t] + f[right][ct-t]
},                                                              ct = time-T[root], 0 &lt;= t &lt;= ct</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// wikioi 1163 &#35775;&#38382;&#33402;&#26415;&#39302;, http://www.wikioi.com/problem/1163/</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;memory.h&gt;</span>

<span class="ot">#define max(a,b) ((a)&gt;(b)?(a):(b))</span>
<span class="ot">#define MAXN  1010                              </span><span class="co">// &#36208;&#24266;&#30340;&#26368;&#22823;&#25968;&#30446;</span>

<span class="dt">int</span> LIMIT, T[MAXN], P[MAXN];                    <span class="co">// &#35686;&#23519;&#21040;&#36798;&#26102;&#38388;&#65292;&#36208;&#24266;&#26102;&#38388;&#65292;&#34255;&#30011;&#25968;&#37327;</span>
<span class="dt">int</span> n, L[MAXN], R[MAXN];                        <span class="co">// &#20108;&#21449;&#26641;: &#33410;&#28857;&#20010;&#25968;&#65292;&#24038;&#23401;&#23376;&#65292;&#21491;&#23401;&#23376;, 0 &#20301;&#32622;&#26410;&#29992;</span>

<span class="dt">int</span> f[MAXN][MAXN];                              <span class="co">// f[root][time] &#34920;&#31034;&#22312; root &#33410;&#28857;&#65292;</span>
                                                <span class="co">// &#21097;&#19979; time &#26102;&#38388;&#20869;&#33021;&#20599;&#21040;&#30340;&#30011;&#25968;</span>

<span class="co">// &#36755;&#20837;&#30340;&#25968;&#25454;&#26159;&#21069;&#24207;&#36941;&#21382;&#24207;&#21015;&#65292;&#20381;&#27425;&#35835;&#20837;&#65292;&#36882;&#24402;&#24314;&#26641;</span>
<span class="dt">int</span> build_tree() {
    ++n;
    scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;T[n], &amp;P[n]);
    T[n] *= <span class="dv">2</span>;                                  <span class="co">// &#36208;&#24266;&#33457;&#36153;&#26102;&#38388;&#35201; x2, &#22240;&#20026;&#36824;&#35201;&#20986;&#26469;</span>
    <span class="dt">int</span> now = n;                                <span class="co">// &#24403;&#21069;&#33410;&#28857;</span>
    <span class="kw">if</span>( P[now] == <span class="dv">0</span> ) {
        L[now] = build_tree();                  <span class="co">// &#24314;&#31435;&#33410;&#28857; now &#30340;&#24038;&#23376;&#26641;</span>
        R[now] = build_tree();                  <span class="co">// &#24314;&#31435;&#33410;&#28857; now &#30340;&#21491;&#23376;&#26641;</span>
    }
    <span class="kw">return</span> now;
}

<span class="co">// &#22791;&#24536;&#24405;&#27861;.  root &#24320;&#22987;&#33410;&#28857;, &#21097;&#20313;&#26102;&#38388;, return &#20599;&#21040;&#24471;&#30011;&#30340;&#25968;&#37327;</span>
<span class="dt">int</span> dp( <span class="dt">int</span> root, <span class="dt">int</span> time ) {
    <span class="kw">if</span>( f[root][time] != <span class="dv">-1</span> ) {
        <span class="kw">return</span> f[root][time];
    }
    <span class="kw">if</span>( !time ) {                       <span class="co">// no time left</span>
        <span class="kw">return</span> f[root][time] = <span class="dv">0</span>;
    }

    <span class="dt">const</span> <span class="dt">int</span> ct = time - T[root];      <span class="co">// &#30041;&#32473;&#24038;&#21491;&#23376;&#33410;&#28857;&#30340;&#26102;&#38388;</span>

    <span class="co">// &#21040;&#36798;&#21494;&#23376;&#33410;&#28857;&#65292;&#21363;&#23637;&#35272;&#23460;</span>
    <span class="kw">if</span>( !L[root] &amp;&amp; !R[root] ) {
        <span class="kw">if</span> ( P[root] * <span class="dv">5</span> &lt;= ct ) {                  <span class="co">// &#19981;&#33021; tt / 5,&#22240;&#20026;&#26102;&#38388;&#22815;&#65292;&#20294;&#26159;&#21487;&#33021;&#30011;&#19981;&#22815;</span>
            <span class="kw">return</span> f[root][time] = P[root];         <span class="co">// take all the paintings</span>
        } <span class="kw">else</span> {
            <span class="kw">return</span> f[root][time] = ct / <span class="dv">5</span>;          <span class="co">// take as much as you can</span>
        }
    }

    f[root][time] = <span class="dv">0</span>;
    <span class="kw">for</span>( <span class="dt">int</span> t = <span class="dv">0</span>; t &lt;= ct; ++t ) {
        <span class="dt">int</span> lp = dp( L[root], t );
        <span class="dt">int</span> rp = dp( R[root], ct - t );
        f[root][time] = max( f[root][time], lp + rp );  <span class="co">// update</span>
    }
    <span class="kw">return</span> f[root][time];
}

<span class="dt">int</span> main() {
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;LIMIT );
    n = <span class="dv">0</span>;
    build_tree();
    memset( f, <span class="dv">-1</span>, <span class="kw">sizeof</span>(f) );
    printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, dp( <span class="dv">1</span>, LIMIT) );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#27809;&#26377;&#19978;&#21496;&#30340;&#33310;&#20250; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>Ural &#22823;&#23398;&#26377; N &#20010;&#32844;&#21592;&#65292;&#32534;&#21495;&#20026; 1 ~ N&#12290;&#20182;&#20204;&#26377;&#20174;&#23646;&#20851;&#31995;&#65292;&#20063;&#23601;&#26159;&#35828;&#20182;&#20204;&#30340;&#20851;&#31995;&#23601;&#20687;&#19968;&#26869;&#20197;&#26657;&#38271;&#20026;&#26681;&#30340;&#26641;&#65292;&#29238;&#32467;&#28857;&#23601;&#26159;&#23376;&#32467;&#28857;&#30340;&#30452;&#25509;&#19978;&#21496;&#12290;&#27599;&#20010;&#32844;&#21592;&#26377;&#19968;&#20010;&#24555;&#20048;&#25351;&#25968;&#12290;&#29616;&#22312;&#26377;&#20010;&#21608;&#24180;&#24198;&#23476;&#20250;&#65292;&#35201;&#27714;&#19982;&#20250;&#32844;&#21592;&#30340;&#24555;&#20048;&#25351;&#25968;&#26368;&#22823;&#12290;&#20294;&#26159;&#65292;&#27809;&#26377;&#32844;&#21592;&#24895;&#21644;&#30452;&#25509;&#19978;&#21496;&#19968;&#36215;&#19982;&#20250;&#12290;</p>
<pre><code>&#36755;&#20837;

    &#31532;&#19968;&#34892;&#19968;&#20010;&#25972;&#25968; N (1 &lt;= N &lt;= 6000)&#12290;
    &#25509;&#19979;&#26469; N &#34892;&#65292;&#31532; i+1 &#34892;&#34920;&#31034; i &#21495;&#32844;&#21592;&#30340;&#24555;&#20048;&#25351;&#25968; R_i (-128 &lt;= R_i &lt;= 127)&#12290;
    &#25509;&#19979;&#26469; N-1 &#34892;&#65292;&#27599;&#34892;&#36755;&#20837;&#19968;&#23545;&#25972;&#25968; L,K&#12290;&#34920;&#31034; K &#26159; L &#30340;&#30452;&#25509;&#19978;&#21496;&#12290;

    7
    1       1       1       1       1       1       1
    1 3     2 3     6 4     7 4     4 5     3 5

&#36755;&#20986;

    &#36755;&#20986;&#26368;&#22823;&#30340;&#24555;&#20048;&#25351;&#25968;

    5</code></pre>
<p>&#35774;&#29366;&#24577;&#20026; <code>f[k][0]</code> &#21644; <code>f[k][1]</code>&#65292;<code>f[k][0]</code> &#34920;&#31034;&#31532; k &#20010;&#20154;&#19981;&#21442;&#21152;&#26102;&#30340;&#26368;&#22823;&#20540;&#65292; <code>f[k][1]</code> &#34920;&#31034;&#31532; k &#20010;&#20154;&#21442;&#21152;&#30340;&#26368;&#22823;&#20540;&#65292;&#21017;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#22914;&#19979;&#65306;</p>
<pre><code>f[k][0] = sum_l max{ f[l][0], f[l][1] },            &#20854;&#20013; k &#26159; l &#30340;&#30452;&#25509;&#19978;&#21496;
f[k][1] = sum_l f[l][0] + r[k]                      r[k] is the happy value</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// wikioi 1380 &#27809;&#26377;&#19978;&#21496;&#30340;&#33310;&#20250;, http://www.wikioi.com/problem/1380</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="ot">#define max(a,b) ((a)&gt;(b)?(a):(b))</span>
<span class="ot">#define MAXN 6001                                           </span><span class="co">// 0 &#20301;&#32622;&#26410;&#29992;</span>

<span class="dt">int</span> n;
<span class="dt">int</span> r[MAXN];                                                <span class="co">// &#24555;&#20048;&#25351;&#25968;</span>

<span class="kw">struct</span> edge_t {                                             <span class="co">// &#38745;&#24577;&#38142;&#34920;&#33410;&#28857;</span>
    <span class="dt">int</span> v;
    <span class="dt">int</span> prev;                                               <span class="co">// &#19978;&#19968;&#26465;&#36793;&#65292;&#20498;&#30528;&#20018;&#36215;&#26469;</span>
};

edge_t edge[MAXN<span class="dv">-1</span>];                                        <span class="co">// &#22810;&#20010;&#38745;&#24577;&#38142;&#34920;&#22312;&#19968;</span>
                                                            <span class="co">// &#20010;&#25968;&#32452;&#37324;&#65292;&#23454;&#36136;&#19978;&#26159;&#26641;&#30340;&#23401;&#23376;&#34920;&#31034;&#27861;</span>

<span class="dt">int</span> head[MAXN];                                             <span class="co">// head[root]&#25351;&#21521;&#34920;&#22836;&#65292;&#21363;&#26368;&#21518;&#19968;&#26465;&#36793;</span>

<span class="dt">bool</span> has_boss[MAXN];                                        <span class="co">// has_boss[i] &#34920;&#31034;&#31532; i &#20010;&#20154;&#26159;&#21542;&#26377;&#19978;&#21496;</span>

<span class="dt">int</span> f[MAXN][<span class="dv">2</span>];

<span class="dt">int</span> cnt;                                                    <span class="co">// &#36793;&#20010;&#25968; - 1</span>
<span class="dt">void</span> add_edge( <span class="dt">int</span> u, <span class="dt">int</span> v ) {
    edge[cnt].v = v;                                        <span class="co">// v-&gt;u, v-&gt;head[u]</span>
    edge[cnt].prev = head[u];
    head[u] = cnt;                                          <span class="co">// u-&gt;v: edge[head[u]].v</span>
    ++cnt;
}

<span class="dt">void</span> printGraph( <span class="dt">int</span> x, <span class="dt">int</span> y ) {
    fprintf( stderr, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">Graph after </span><span class="ch">%d</span><span class="st">-&gt;</span><span class="ch">%d</span><span class="st">:</span><span class="ch">\n</span><span class="st">&quot;</span>, x, y );
    <span class="kw">for</span>( <span class="dt">int</span> k = <span class="dv">0</span>; k &lt; <span class="dv">6001</span>; ++k ) {
        <span class="dt">int</span> p = head[k];
        <span class="kw">if</span>( p == <span class="dv">-1</span> ) { <span class="kw">continue</span>; }
        fprintf( stderr, <span class="st">&quot;head[</span><span class="ch">%d</span><span class="st">]:&quot;</span>, k );
        <span class="kw">for</span>( ; p != <span class="dv">-1</span>; p = edge[p].prev ) {
            <span class="dt">int</span> v = edge[p].v;
            fprintf( stderr, <span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>, v );
        }
        fprintf( stderr, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
    }
}

<span class="dt">void</span> dp( <span class="dt">int</span> k ) {
    f[k][<span class="dv">1</span>] = r[k];
    f[k][<span class="dv">0</span>] = <span class="dv">0</span>;
    <span class="kw">for</span>( <span class="dt">int</span> p = head[k]; p != <span class="dv">-1</span>; p = edge[p].prev ) {
        <span class="dt">int</span> l = edge[p].v;
        dp(l);
        f[k][<span class="dv">1</span>] += f[l][<span class="dv">0</span>];
        f[k][<span class="dv">0</span>] = f[k][<span class="dv">0</span>] + max(f[l][<span class="dv">1</span>],f[l][<span class="dv">0</span>]);
    }
}

<span class="dt">int</span> solve() {
    memset(f, <span class="dv">0</span>, <span class="kw">sizeof</span>(f));
    <span class="dt">int</span> k;
    <span class="kw">for</span>( k = <span class="dv">1</span>; k &lt;= n; ++k ) {
        <span class="kw">if</span>( !has_boss[k] ) {
            <span class="kw">break</span>;
        }
    }
    dp(k);
    <span class="kw">return</span> max(f[k][<span class="dv">0</span>], f[k][<span class="dv">1</span>]);                           <span class="co">// cool!</span>
}

<span class="dt">int</span> main() {
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i ) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;r[i] );
    }

    cnt = <span class="dv">0</span>;
    memset( has_boss, <span class="dv">0</span>, <span class="kw">sizeof</span>(has_boss) );
    memset( head,    <span class="dv">-1</span>, <span class="kw">sizeof</span>(head) );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n<span class="dv">-1</span>; ++i ) {
        <span class="dt">int</span> x, y;
        scanf( <span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;x, &amp;y );
        has_boss[x] = <span class="dv">1</span>;
        add_edge( y, x );               <span class="co">//    x   -&gt;  y</span>
        printGraph( x, y );
    }
    printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, solve());
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<dl>
<dt>log in stderr, if you don&#8217;t understand it. <code class="fold">@</code></dt>
<dd><pre><code>Graph after 1-&gt;3:
head[3]: 1

Graph after 2-&gt;3:
head[3]: 2 1

Graph after 6-&gt;4:
head[3]: 2 1
head[4]: 6

Graph after 7-&gt;4:
head[3]: 2 1
head[4]: 7 6

Graph after 4-&gt;5:
head[3]: 2 1
head[4]: 7 6
head[5]: 4

Graph after 3-&gt;5:
head[3]: 2 1
head[4]: 7 6
head[5]: 3 4</code></pre>
</dd>
</dl>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#26368;&#22823;&#23376;&#30697;&#24418; <code class="fold">@</code></dt>
<dd><p>&#22312;&#19968;&#20010;&#32473;&#23450;&#30340;&#30697;&#24418;&#32593;&#26684;&#20013;&#26377;&#19968;&#20123;&#38556;&#30861;&#28857;&#65292;&#35201;&#25214;&#20986;&#32593;&#26684;&#20869;&#37096;&#19981;&#21253;&#21547;&#20219;&#20309;&#38556;&#30861;&#28857;&#65292;&#19988;&#36793;&#30028;&#19982;&#22352;&#26631;&#36724;&#24179;&#34892;&#30340;&#26368;&#22823;&#23376;&#30697;&#24418;&#12290;</p>
<p>&#36935;&#21040;&#27714;&#30697;&#24418;&#38754;&#31215;&#65292;&#19968;&#33324;&#25226;&#24038;&#19978;&#35282;&#35774;&#32622;&#20026;&#22352;&#26631;&#21407;&#28857;&#65292;&#36825;&#19982;&#25968;&#23398;&#20013;&#30340;&#22352;&#26631;&#31995;&#19981;&#21516;&#12290;</p>
<p>&#35299;&#20915;&#26041;&#27861;&#21442;&#32771; <a href="http://wenku.baidu.com/view/728cd5126edb6f1aff001fbb.html">&#8220;&#27973;&#35848;&#29992;&#26497;&#22823;&#21270;&#24605;&#24819;&#35299;&#20915;&#26368;&#22823;&#23376;&#30697;&#24418;&#38382;&#39064;&#8221;</a></p>
<p>&#26041;&#27861;&#19968;&#26159;&#19968;&#31181;&#26292;&#21147;&#26522;&#20030;&#27861;&#65292;&#26041;&#27861;&#20108;&#26159;&#19968;&#31181;&#21160;&#35268;&#27861;&#12290;</p>
<ul>
<li><dl>
<dt>&#22902;&#29275;&#28020;&#22330; <code class="fold">@</code></dt>
<dd><p>&#30001;&#20110; John &#24314;&#36896;&#20102;&#29275;&#22330;&#22260;&#26639;&#65292;&#28608;&#36215;&#20102;&#22902;&#29275;&#30340;&#24868;&#24594;&#65292;&#22902;&#29275;&#30340;&#20135;&#22902;&#37327;&#24613;&#21095;&#20943;&#23569;&#12290;&#20026;&#20102;&#35752;&#22909;&#22902;&#29275;&#65292;John &#20915;&#23450;&#22312;&#29275;&#22330;&#20013;&#24314;&#36896;&#19968;&#20010;&#22823;&#22411;&#28020;&#22330;&#12290;&#20294;&#26159; John &#30340;&#22902;&#29275;&#26377;&#19968;&#20010;&#22855;&#24618;&#30340;&#20064;&#24815;&#65292;&#27599;&#22836;&#22902;&#29275;&#37117;&#24517;&#39035;&#22312;&#29275;&#22330;&#20013;&#30340;&#19968;&#20010;&#22266;&#23450;&#30340;&#20301;&#32622;&#20135;&#22902;&#65292;&#32780;&#22902;&#29275;&#26174;&#28982;&#19981;&#33021;&#22312;&#28020;&#22330;&#20013;&#20135;&#22902;&#65292;&#20110;&#26159;&#65292;John &#24076;&#26395;&#25152;&#24314;&#36896;&#30340;&#28020;&#22330;&#19981;&#35206;&#30422;&#36825;&#20123;&#20135;&#22902;&#28857;&#12290;&#36825;&#22238;&#65292;&#20182;&#21448;&#35201;&#27714;&#21161;&#20110; Clevow &#20102;&#12290;&#20320;&#36824;&#33021;&#24110;&#21161; Clevow &#21527;&#65311;</p>
<p>John &#30340;&#29275;&#22330;&#21644;&#35268;&#21010;&#30340;&#28020;&#22330;&#37117;&#26159;&#30697;&#24418;&#12290;&#28020;&#22330;&#35201;&#23436;&#20840;&#20301;&#20110;&#29275;&#22330;&#20043;&#20869;&#65292;&#24182;&#19988;&#28020;&#22330;&#30340;&#36718;&#24275;&#35201;&#19982;&#29275;&#22330;&#30340;&#36718;&#24275;&#24179;&#34892;&#25110;&#32773;&#37325;&#21512;&#12290;&#28020;&#22330;&#19981;&#33021;&#35206;&#30422;&#20219;&#20309;&#20135;&#22902;&#28857;&#65292;&#20294;&#26159;&#20135;&#22902;&#28857;&#21487;&#20197;&#20301;&#20110;&#28020;&#22330;&#30340;&#36718;&#24275;&#19978;&#12290;</p>
<p>Clevow &#24403;&#28982;&#24076;&#26395;&#28020;&#22330;&#30340;&#38754;&#31215;&#23613;&#21487;&#33021;&#22823;&#20102;&#65292;&#25152;&#20197;&#20320;&#30340;&#20219;&#21153;&#23601;&#26159;&#24110;&#22905;&#35745;&#31639;&#28020;&#22330;&#30340;&#26368;&#22823;&#38754;&#31215;&#12290;</p>
<pre><code>&#36755;&#20837;

    &#36755;&#20837;&#25991;&#20214;&#30340;&#31532;&#19968;&#34892;&#21253;&#21547;&#20004;&#20010;&#25972;&#25968; L &#21644; W (1 &lt;= L,W &lt;= 30000)&#65292;
    &#20998;&#21035;&#34920;&#31034;&#29275;&#22330;&#30340;&#38271;&#21644;&#23485;&#12290;&#25991;&#20214;&#30340;&#31532;&#20108;&#34892;&#21253;&#21547;&#19968;&#20010;&#25972;&#25968; n(0 &lt;= n &lt;= 5000)&#65292;
    &#34920;&#31034;&#20135;&#22902;&#28857;&#30340;&#25968;&#37327;&#12290;&#20197;&#19979; n &#34892;&#27599;&#34892;&#21253;&#21547;&#20004;&#20010;&#25972;&#25968; x &#21644; y&#65292;
    &#34920;&#31034;&#19968;&#20010;&#20135;&#22902;&#28857;&#30340;&#22352;&#26631;&#12290;&#25152;&#26377;&#20135;&#22902;&#28857;&#37117;&#20301;&#20110;&#29275;&#22330;&#20869;&#65292;
    &#21363;&#65306;0 &lt;= x &lt;= l, 0 &lt;= y &lt;= w&#12290;

    10 10
    4
    1 1
    9 1
    1 9
    9 9

&#36755;&#20986;

    &#36755;&#20986;&#25991;&#20214;&#20165;&#19968;&#34892;&#65292;&#21253;&#21547;&#19968;&#20010;&#25972;&#25968; S&#65292;&#34920;&#31034;&#28020;&#22330;&#30340;&#26368;&#22823;&#38754;&#31215;&#12290;

    80</code></pre>
<p>&#26041;&#27861;&#19968;&#26159;&#26292;&#21147;&#26522;&#20030;&#27861;&#65292;&#26041;&#27861;&#20108;&#26159;&#21160;&#35268;&#27861;&#12290;&#36825;&#37324;&#20351;&#29992;&#26041;&#27861;&#20108;&#65292;&#38656;&#35201;&#20808;&#20570;&#19968;&#23450;&#30340;&#39044;&#22788;&#29702;&#12290;&#30001;&#20110;&#31532;&#20108;&#31181;&#31639;&#27861;&#22797;&#26434;&#24230;&#19982;&#29275;&#22330;&#30340;&#38754;&#31215;&#26377;&#20851;&#65292;&#32780;&#39064;&#30446;&#20013;&#29275;&#22330;&#30340;&#38754;&#31215;&#24456;&#22823;&#65288;30000&#215;30000&#65289;&#65292;&#22240;&#27492;&#38656;&#35201;&#23545;&#25968;&#25454;&#36827;&#34892;&#31163;&#25955;&#21270;&#22788;&#29702;&#12290;&#31163;&#25955;&#21270;&#21518;&#30697;&#24418;&#30340;&#22823;&#23567;&#38477;&#20026; S&#215;S&#65292;&#25152;&#20197;&#26102;&#38388;&#22797;&#26434;&#24230;&#20026; O(S2)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230;&#20026; O(S)&#12290;&#38656;&#35201;&#27880;&#24847;&#30340;&#26159;&#65292;&#20026;&#20102;&#20445;&#35777;&#31639;&#27861;&#33021;&#27491;&#30830;&#25191;&#34892;&#65292;&#25226; (0,0) &#21644; (m,n) &#35774;&#32622;&#20026;&#20135;&#22902;&#28857;&#65292;&#30456;&#24403;&#20110;&#21152;&#19978;&#20102;&#19968;&#20010;&#8220;&#34394;&#25311;&#36793;&#30028;&#8221;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// OJ: https://vijos.org/p/1055</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#define max(a,b) ((a)&gt;(b)?(a):(b))</span>
<span class="ot">#define min(a,b) ((a)&lt;(b)?(a):(b))</span>

<span class="dt">int</span> L, W;                   <span class="co">//            W</span>
                            <span class="co">//        +------&gt; y</span>
                            <span class="co">//        |</span>
                            <span class="co">//     L  |</span>
                            <span class="co">//        |</span>
                            <span class="co">//        V x</span>

<span class="ot">#define MAXN 5001</span>
<span class="dt">int</span> n;                      <span class="co">// n&#20010;&#20135;&#22902;&#28857;</span>
<span class="dt">int</span> x[MAXN], y[MAXN];       <span class="co">// &#20135;&#22902;&#28857;&#22352;&#26631;</span>

<span class="dt">int</span> int_cmp( <span class="dt">const</span> <span class="dt">void</span> *a, <span class="dt">const</span> <span class="dt">void</span> *b ) {
    <span class="dt">const</span> <span class="dt">int</span> *ia = (<span class="dt">const</span> <span class="dt">int</span>*) a;
    <span class="dt">const</span> <span class="dt">int</span> *ib = (<span class="dt">const</span> <span class="dt">int</span>*) b;
    <span class="kw">return</span> *ia - *ib;
}

<span class="dt">int</span> binary_search( <span class="dt">int</span> A[], <span class="dt">int</span> n, <span class="dt">int</span> target ) {
    <span class="dt">int</span> low = <span class="dv">0</span>, high = n<span class="dv">-1</span>, mid;
    <span class="kw">while</span>( low &lt;= high ) {
        mid = (low+high)/<span class="dv">2</span>;
        <span class="kw">if</span>( A[mid] &lt; target ) {
            low = mid<span class="dv">+1</span>;
        } <span class="kw">else</span> <span class="kw">if</span>( A[mid] &gt; target ) {
            high = mid<span class="dv">-1</span>;
        } <span class="kw">else</span> {
            <span class="kw">return</span> mid;
        }
    }
    <span class="kw">return</span> <span class="dv">-1</span>;
}

<span class="dt">int</span> max_submatrix(<span class="dt">const</span> <span class="dt">int</span> L, <span class="dt">const</span> <span class="dt">int</span> W,
        <span class="dt">const</span> <span class="dt">int</span> x[], <span class="dt">const</span> <span class="dt">int</span> y[], <span class="dt">int</span> n) {
    vector&lt;<span class="dt">int</span>&gt; aa( n<span class="dv">+1</span> );
    <span class="co">// int *a = (int*) malloc((n + 1) * sizeof(int));</span>
    <span class="dt">int</span> *a = &amp;aa[<span class="dv">0</span>];
    <span class="dt">int</span> *b = (<span class="dt">int</span>*) malloc((n + <span class="dv">1</span>) * <span class="kw">sizeof</span>(<span class="dt">int</span>));
    <span class="dt">int</span> la = n, lb = n;
    <span class="dt">int</span> i, j;
    <span class="dt">int</span> lm, rm; <span class="co">// &#24038;&#36793;&#30028;&#65292;&#21491;&#36793;&#30028;</span>
    <span class="dt">int</span> result = <span class="dv">0</span>, temp;
    <span class="dt">int</span> **v;  <span class="co">// &#26032;&#30340;01&#30697;&#38453;&#65292;1&#34920;&#31034;&#38556;&#30861;&#28857;</span>
    <span class="dt">int</span> *h;  <span class="co">// &#39640;&#24230;</span>
    <span class="dt">int</span> *l;  <span class="co">// &#24038;&#36793;&#30028;</span>
    <span class="dt">int</span> *r;  <span class="co">// &#21491;&#36793;&#30028;</span>

    memcpy(a, x, n * <span class="kw">sizeof</span>(<span class="dt">int</span>));
    memcpy(b, y, n * <span class="kw">sizeof</span>(<span class="dt">int</span>));
    a[la++] = <span class="dv">0</span>;
    b[lb++] = <span class="dv">0</span>;
    a[la++] = L;
    b[lb++] = W;

    <span class="co">// &#21435;&#37325;</span>
    qsort(a, la, <span class="kw">sizeof</span>(<span class="dt">int</span>), int_cmp);
    qsort(b, lb, <span class="kw">sizeof</span>(<span class="dt">int</span>), int_cmp);
    <span class="kw">for</span> (j = <span class="dv">1</span>, i = <span class="dv">1</span>; i &lt; la; i++) { <span class="co">// &#21435;&#37325;</span>
        <span class="kw">if</span> (a[i] != a[i - <span class="dv">1</span>])
            a[j++] = a[i];
    }
    la = j;
    <span class="kw">for</span> (j = <span class="dv">1</span>, i = <span class="dv">1</span>; i &lt; lb; i++) { <span class="co">// &#21435;&#37325;</span>
        <span class="kw">if</span> (b[i] != b[i - <span class="dv">1</span>])
            b[j++] = b[i];
    }
    lb = j;
    h = (<span class="dt">int</span>*) malloc(lb * <span class="kw">sizeof</span>(<span class="dt">int</span>));
    l = (<span class="dt">int</span>*) malloc(lb * <span class="kw">sizeof</span>(<span class="dt">int</span>));
    r = (<span class="dt">int</span>*) malloc(lb * <span class="kw">sizeof</span>(<span class="dt">int</span>));

    <span class="co">// &#35745;&#31639; v&#30697;&#38453;</span>
    v = (<span class="dt">int</span>**) malloc(la * <span class="kw">sizeof</span>(<span class="dt">int</span>*));
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; la; i++) {
        v[i] = (<span class="dt">int</span>*) calloc(lb, <span class="kw">sizeof</span>(<span class="dt">int</span>));
    }
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; i++) {
        <span class="dt">int</span> ia, ib;
        ia = binary_search(a, la, x[i]);
        ib = binary_search(b, lb, y[i]);
        v[ia][ib] = <span class="dv">1</span>; <span class="co">//&#26631;&#35760;&#38556;&#30861;&#28857;</span>
    }

    <span class="co">// &#21021;&#22987;&#21270;</span>
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; lb; i++) {
        l[i] = <span class="dv">0</span>;
        r[i] = W;
        h[i] = <span class="dv">0</span>;
    }

    <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt; la; i++) { <span class="co">// &#20174;&#19978;&#21040;&#19979;</span>
        lm = <span class="dv">0</span>;
        <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; lb; j++) { <span class="co">// &#20174;&#24038;&#21040;&#21491;&#35745;&#31639;l[j]</span>
            <span class="kw">if</span> (!v[i - <span class="dv">1</span>][j]) {  <span class="co">//&#22914;&#26524;&#19978;&#19968;&#20010;&#19981;&#26159;&#38556;&#30861;&#28857;</span>
                h[j] = h[j] + a[i] - a[i - <span class="dv">1</span>]; <span class="co">//&#39640;&#24230;&#32047;&#21152;</span>
                <span class="co">// l[i][j]=max(l[i-1][j] , &#24038;&#36793;&#31532;&#19968;&#20010;&#38556;&#30861;&#28857;(i-1,j)&#30340;&#20301;&#32622;)</span>
                l[j] = max(l[j], lm);
            } <span class="kw">else</span> {  <span class="co">//&#22914;&#26524;&#19978;&#19968;&#20010;&#28857;&#26159;&#38556;&#30861;&#28857;</span>
                h[j] = a[i] - a[i - <span class="dv">1</span>]; <span class="co">//&#39640;&#24230;&#37325;&#26032;&#35745;&#31639;</span>
                l[j] = <span class="dv">0</span>;
                r[j] = W;
                lm = b[j]; <span class="co">//&#26356;&#26032;(i-1,j)&#24038;&#36793;&#31532;&#19968;&#20010;&#38556;&#30861;&#28857;&#30340;&#20301;&#32622;</span>
            }
        }
        rm = W;
        <span class="kw">for</span> (j = lb - <span class="dv">1</span>; j &gt;= <span class="dv">0</span>; j--) {  <span class="co">//  &#20174;&#21491;&#21040;&#24038;&#35745;&#31639;r[j]</span>
            <span class="co">//r[i][j]=min(r[i-1][j] , (i-1,j)&#21491;&#36793;&#31532;&#19968;&#20010;&#38556;&#30861;&#28857;&#30340;&#20301;&#32622;)</span>
            r[j] = min(r[j], rm);
            temp = h[j] * (r[j] - l[j]);
            result = max(result, temp);  <span class="co">//&#35745;&#31639;&#26368;&#20248;&#35299;</span>
            <span class="kw">if</span> (v[i - <span class="dv">1</span>][j]) <span class="co">//&#22914;&#26524;&#35813;&#28857;&#26159;&#38556;&#30861;&#28857;&#65292;&#26356;&#26032;(i-1,j)&#21491;&#36793;&#31532;&#19968;&#20010;&#38556;&#30861;&#28857;&#30340;&#20301;&#32622;</span>
                rm = b[j];
        }
    }
    <span class="co">// &#35745;&#31639;&#27178;&#26465;&#30340;&#38754;&#31215;</span>
    <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt; la; i++) {
        temp = W * (a[i] - a[i - <span class="dv">1</span>]);
        result = max(result, temp);
    }

    <span class="co">// free(a);</span>
    free(b);
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; la; i++) {
        free(v[i]);
    }
    free(v);
    free(h);
    free(l);
    free(r);
    <span class="kw">return</span> result;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> i;
    <span class="kw">while</span> (scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;L, &amp;W) == <span class="dv">2</span>) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;x[i], &amp;y[i]);
        }

        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, max_submatrix(L, W, x, y, n));
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#26368;&#22823;&#20840; 1 &#23376;&#30697;&#38453; <code class="fold">@</code></dt>
<dd><p>&#32473;&#23450;&#19968;&#20010; <code>m * n</code> &#30340; 01 &#30697;&#38453;&#65292;&#27714;&#26368;&#22823;&#30340;&#20840; 1 &#23376;&#30697;&#38453;&#12290;</p>
<pre><code>&#36755;&#20837;

    &#36755;&#20837;&#21253;&#21547;&#22810;&#32452;&#27979;&#35797;&#29992;&#20363;&#12290;&#27599;&#32452;&#27979;&#35797;&#29992;&#20363;&#31532;&#19968;&#34892;&#21253;&#21547;&#20004;&#20010;&#25972;
    &#25968; m &#21644; n (1 &lt;= m,n &lt;= 2000)&#65292;&#25509;&#19979;&#26469;&#26159; m &#34892;&#25968;&#25454;&#65292;&#27599;
    &#34892; n &#20010;&#20803;&#32032;&#12290;

    2 2
    0 0
    0 0
    4 4
    0 0 0 0
    0 1 1 0
    0 1 1 0
    0 0 0 0
    8 8
    0   1   0   0   0   0   1   1
    1   1   1   0   0   0   1   1
    1   1   1   0   0   0   0   0
    1   1   1   0   1   1   1   1
    0   0   0   0   1   1   1   1
    0   0   0   0   1   1   1   1
    0   0   0   0   1   1   1   1
    0   0   0   0   1   1   1   1

&#36755;&#20986;

    &#23545;&#27599;&#20010;&#27979;&#35797;&#29992;&#20363;&#65292;&#36755;&#20986;&#26368;&#22823;&#20840; 1 &#23376;&#30697;&#38453;&#30340; 1 &#30340;&#20010;&#25968;&#12290;&#22914;
    &#26524;&#36755;&#20837;&#30340;&#30697;&#38453;&#26159;&#20840; 0&#65292;&#21017;&#36755;&#20986; 0.

    0
    4
    20</code></pre>
<p>&#27880;&#24847;&#65292;&#19978;&#19968;&#39064;&#31639;&#30340;&#26159;&#38754;&#31215;&#65292;&#36825;&#19968;&#39064;&#31639;&#30340;&#26159;&#20010;&#25968;&#65292;&#22312;&#26576;&#20123;&#32454;&#33410;&#19978;&#22788;&#29702;&#19981;&#21516;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> lagest_rectangle( vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; &amp;matrix, <span class="dt">int</span> m, <span class="dt">int</span> n ) {
    vector&lt;<span class="dt">int</span>&gt; H( n, <span class="dv">0</span> );                              <span class="co">// &#39640;&#24230;</span>
    vector&lt;<span class="dt">int</span>&gt; L( n, <span class="dv">0</span> );                              <span class="co">// &#24038;&#36793;&#30028;</span>
    vector&lt;<span class="dt">int</span>&gt; R( n, n );                              <span class="co">// &#21491;&#36793;&#30028;</span>

    <span class="dt">int</span> ret = <span class="dv">0</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; ++i ) {
        <span class="dt">int</span> left = <span class="dv">0</span>, right = n;
        <span class="co">// calculate L(i, j) from left to right</span>
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j ) {
            <span class="kw">if</span>( matrix[i][j] == <span class="dv">1</span> ) {
                ++H[j];
                L[j] = max( L[j], left );               <span class="co">// rightify L</span>
            } <span class="kw">else</span> {
                left = j + <span class="dv">1</span>;
                H[j] = <span class="dv">0</span>;
                L[j] = <span class="dv">0</span>;
                R[j] = n;
            }
        }
        <span class="co">// calculate R(i, j) from right to left</span>
        <span class="kw">for</span>( <span class="dt">int</span> j = n - <span class="dv">1</span>; j &gt;= <span class="dv">0</span>; --j ) {
            <span class="kw">if</span>( matrix[i][j] == <span class="dv">1</span> ) {
                R[j] = min( R[j], right );              <span class="co">// leftify R</span>
                ret = max( ret, H[j]*(R[j]-L[j]) );     <span class="co">// larger area</span>
            } <span class="kw">else</span> {
                right = j;
            }
        }
    }

    <span class="kw">return</span> ret;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> m, n;
    <span class="kw">while</span>( <span class="dv">2</span> == scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;m, &amp;n) ) {
        vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; matrix( m, vector&lt;<span class="dt">int</span>&gt;(n) );
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; ++i ) {
            <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j ) {
                scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;matrix[i][j] );
            }
        }
        printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, lagest_rectangle(matrix, m, n) );
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<pre><code>// ret = max( ret, H[j]*(R[j]-L[j]) );     // larger area

int area = H[j]*(R[j]-L[j]);
if( area &gt; ret ) {
    printf( &quot;Area: %d, j= %d, L[j]: %d, R[j]: %d, H[j]: %d\n&quot;,
            area, j, L[j], R[j], H[j] );
    ret = area;
}

8   8
0   1   0   0   0   0   1   1
1   1   1   0   0   0   1   1
1   1   1   0   0   0   0   0
1   1   1   0   1   1   1   1
0   0   0   0   1   1   1   1
0   0   0   0   1   1   1   1
0   0   0   0   1   1   1   1
0   0   0   0   1   1   1   1

Area: 2,    j= 7, L[j]: 6, R[j]: 8, H[j]: 1
Area: 4,    j= 7, L[j]: 6, R[j]: 8, H[j]: 2
Area: 6,    j= 2, L[j]: 0, R[j]: 3, H[j]: 2
Area: 9,    j= 2, L[j]: 0, R[j]: 3, H[j]: 3
Area: 12,   j= 7, L[j]: 4, R[j]: 8, H[j]: 3
Area: 16,   j= 7, L[j]: 4, R[j]: 8, H[j]: 4
Area: 20,   j= 7, L[j]: 4, R[j]: 8, H[j]: 5</code></pre>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>DAG &#19978;&#30340;&#21160;&#24577;&#35268;&#21010; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#21861;&#26159; DAG <code class="fold">@</code></dt>
<dd><p>In mathematics and computer science, a <strong>directed acyclic graph</strong> (DAG, <code>/d&#230;&#609;/</code>), is a finite directed graph with no directed cycles.</p>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">Directed acyclic graph - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#23567;&#32467;&#19982;&#24212;&#29992;&#20030;&#20363; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>9-1 UVa1025 A Spy in the Metro uva1025.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1025 A Spy in the Metro</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">50</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> maxt = <span class="dv">200</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;

<span class="co">// has_train[t][i]&#34920;&#31034;&#26102;&#21051;t&#65292;&#22312;&#36710;&#31449;i&#26159;&#21542;&#26377;&#24448;&#21491;&#24320;&#30340;&#28779;&#36710;</span>
<span class="dt">int</span> t[maxn], has_train[maxt][maxn];
<span class="dt">int</span> dp[maxt][maxn];

<span class="dt">int</span> main() {
    <span class="dt">int</span> kase = <span class="dv">0</span>, n, T;
    <span class="kw">while</span>(cin &gt;&gt; n &gt;&gt; T &amp;&amp; n) {
        <span class="dt">int</span> M1, M2, d;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n<span class="dv">-1</span>; i++) cin &gt;&gt; t[i];

        <span class="co">// &#39044;&#22788;&#29702;&#65292;&#35745;&#31639;has_train&#25968;&#32452;</span>
        memset(has_train, <span class="dv">0</span>, <span class="kw">sizeof</span>(has_train));
        cin &gt;&gt; M1;
        <span class="kw">while</span>(M1--) {
            cin &gt;&gt; d;
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= n<span class="dv">-1</span>; j++) {
                <span class="kw">if</span>(d &lt;= T) has_train[d][j] = <span class="dv">1</span>;
                d += t[j];
            }
        }
        cin &gt;&gt; M2;
        <span class="kw">while</span>(M2--) {
            cin &gt;&gt; d;
            <span class="kw">for</span>(<span class="dt">int</span> j = n<span class="dv">-1</span>; j &gt;= <span class="dv">1</span>; j--) {
                <span class="kw">if</span>(d &lt;= T) has_train[d][j<span class="dv">+1</span>] = <span class="dv">1</span>;
                d += t[j];
            }
        }

        <span class="co">// DP&#20027;&#36807;&#31243;</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n<span class="dv">-1</span>; i++) dp[T][i] = INF;
        dp[T][n] = <span class="dv">0</span>;

        <span class="kw">for</span>(<span class="dt">int</span> i = T<span class="dv">-1</span>; i &gt;= <span class="dv">0</span>; i--)
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= n; j++) {
                dp[i][j] = dp[i<span class="dv">+1</span>][j] + <span class="dv">1</span>; <span class="co">// &#31561;&#24453;&#19968;&#20010;&#21333;&#20301;</span>
                <span class="kw">if</span>(j &lt; n &amp;&amp; has_train[i][j] &amp;&amp; i+t[j] &lt;= T)
                    dp[i][j] = min(dp[i][j], dp[i+t[j]][j<span class="dv">+1</span>]); <span class="co">// &#21491;</span>
                <span class="kw">if</span>(j &gt; <span class="dv">1</span> &amp;&amp; has_train[i][j] &amp;&amp; i+t[j<span class="dv">-1</span>] &lt;= T)
                    dp[i][j] = min(dp[i][j], dp[i+t[j<span class="dv">-1</span>]][j<span class="dv">-1</span>]); <span class="co">// &#24038;</span>
            }

        <span class="co">// &#36755;&#20986;</span>
        cout &lt;&lt; <span class="st">&quot;Case Number &quot;</span> &lt;&lt; ++kase &lt;&lt; <span class="st">&quot;: &quot;</span>;
        <span class="kw">if</span>(dp &gt;= INF) cout &lt;&lt; <span class="st">&quot;impossible</span><span class="ch">\n</span><span class="st">&quot;</span>;
        <span class="kw">else</span> cout &lt;&lt; dp &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-2 UVa437 The Tower of Babylon UVa437.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa437 The Tower of Babylon</span>
<span class="co">// Rujia Liu</span>
<span class="co">// &#31639;&#27861;&#65306;DAG&#19978;&#30340;&#26368;&#38271;&#36335;&#65292;&#29366;&#24577;&#20026;(idx, k)&#65292;&#21363;&#24403;&#21069;&#39030;&#38754;&#20026;&#31435;&#26041;&#20307;idx&#65292;&#20854;&#20013;&#31532;k&#26465;&#36793;&#65288;&#25490;&#24207;&#21518;&#65289;&#20026;&#39640;</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#define REP(i,n) for(int i = 0; i &lt; (n); i++)</span>

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">30</span> + <span class="dv">5</span>;
<span class="dt">int</span> n, blocks[maxn], d[maxn];

<span class="dt">void</span> get_dimensions(<span class="dt">int</span>* v, <span class="dt">int</span> b, <span class="dt">int</span> dim) {
    <span class="dt">int</span> idx = <span class="dv">0</span>;
    REP(i,<span class="dv">3</span>) <span class="kw">if</span>(i != dim) v[idx++] = blocks[b][i];
}

<span class="dt">int</span> dp(<span class="dt">int</span> i, <span class="dt">int</span> j) {
    <span class="dt">int</span>&amp; ans = d[i][j];
    <span class="kw">if</span>(ans &gt; <span class="dv">0</span>) <span class="kw">return</span> ans;
    ans = <span class="dv">0</span>;
    <span class="dt">int</span> v, v2;
    get_dimensions(v, i, j);
    REP(a,n) REP(b,<span class="dv">3</span>) {
        get_dimensions(v2, a, b);
        <span class="kw">if</span>(v2 &lt; v &amp;&amp; v2 &lt; v) ans = max(ans, dp(a,b));
    }
    ans += blocks[i][j];
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> kase = <span class="dv">0</span>;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span> &amp;&amp; n) {
        REP(i,n) {
            REP(j,<span class="dv">3</span>) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;blocks[i][j]);
            sort(blocks[i], blocks[i]<span class="dv">+3</span>);
        }
        memset(d, <span class="dv">0</span>, <span class="kw">sizeof</span>(d));
        <span class="dt">int</span> ans = <span class="dv">0</span>;
        REP(i,n) REP(j,<span class="dv">3</span>) ans = max(ans, dp(i,j));
        printf(<span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">: maximum height = </span><span class="ch">%d\n</span><span class="st">&quot;</span>, ++kase, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-3 UVa1347 Tour uva1347.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1347 Tour</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">50</span> + <span class="dv">5</span>;
<span class="dt">double</span> x[maxn], y[maxn], dist[maxn][maxn], d[maxn][maxn];

<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span>) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++)
            scanf(<span class="st">&quot;</span><span class="ch">%lf%lf</span><span class="st">&quot;</span>, &amp;x[i], &amp;y[i]);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++)
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= n; j++)
                dist[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));

        <span class="kw">for</span>(<span class="dt">int</span> i = n<span class="dv">-1</span>; i &gt;= <span class="dv">2</span>; i--)
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt; i; j++) {
                <span class="kw">if</span>(i == n<span class="dv">-1</span>) d[i][j] = dist[i][n] + dist[j][n]; <span class="co">// &#36793;&#30028;</span>
                <span class="kw">else</span> d[i][j] = min(dist[i][i<span class="dv">+1</span>] + d[i<span class="dv">+1</span>][j], dist[j][i<span class="dv">+1</span>] + d[i<span class="dv">+1</span>][i]);
            }
        printf(<span class="st">&quot;</span><span class="ch">%.2lf\n</span><span class="st">&quot;</span>, dist + d);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#22810;&#38454;&#27573;&#20915;&#31574;&#38382;&#39064; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#22810;&#27573;&#22270;&#30340;&#26368;&#30701;&#36335; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>9-4 UVa116 Unidirectional TSP UVa116.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa116 Unidirectional TSP</span>
<span class="co">// Rujia Liu</span>
<span class="co">// &#31639;&#27861;&#65306;&#22810;&#27573;&#22270;&#30340;&#21160;&#24577;&#35268;&#21010;&#12290;&#22240;&#20026;&#35201;&#23383;&#20856;&#24207;&#26368;&#23567;&#65292;&#25152;&#20197;&#20498;&#30528;&#26469;&#65292;&#35774;d[i][j]&#20026;&#20174;(i,j)&#21040;&#26368;&#21518;&#19968;&#21015;&#30340;&#26368;&#23567;&#24320;&#38144;&#65292;&#21017;d[i][j]=a[i][j]+max(d[i+1][j+1],d[i-1][j+1])</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;
<span class="dt">int</span> m, n, a[maxn][maxn], d[maxn][maxn], next[maxn][maxn];

<span class="dt">int</span> main() {
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;m, &amp;n) == <span class="dv">2</span> &amp;&amp; m) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++)
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)
                scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;a[i][j]);

        <span class="dt">int</span> ans = INF, first = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> j = n<span class="dv">-1</span>; j &gt;= <span class="dv">0</span>; j--) {
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++) {
                <span class="kw">if</span>(j == n<span class="dv">-1</span>) d[i][j] = a[i][j];
                <span class="kw">else</span> {
                    <span class="dt">int</span> rows = {i, i<span class="dv">-1</span>, i<span class="dv">+1</span>};
                    <span class="kw">if</span>(i == <span class="dv">0</span>) rows = m<span class="dv">-1</span>;
                    <span class="kw">if</span>(i == m<span class="dv">-1</span>) rows = <span class="dv">0</span>;
                    sort(rows, rows<span class="dv">+3</span>);
                    d[i][j] = INF;
                    <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; <span class="dv">3</span>; k++) {
                        <span class="dt">int</span> v = d[rows[k]][j<span class="dv">+1</span>] + a[i][j];
                        <span class="kw">if</span>(v &lt; d[i][j]) { d[i][j] = v; next[i][j] = rows[k]; }
                    }
                }
                <span class="kw">if</span>(j == <span class="dv">0</span> &amp;&amp; d[i][j] &lt; ans) { ans = d[i][j]; first = i; }
            }
        }
        printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, first<span class="dv">+1</span>);
        <span class="kw">for</span>(<span class="dt">int</span> i = next[first], j = <span class="dv">1</span>; j &lt; n; i = next[i][j], j++) printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>, i<span class="dv">+1</span>);
        printf(<span class="st">&quot;</span><span class="ch">\n%d\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>0-1 &#32972;&#21253;&#38382;&#39064; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>9-5 UVa12563 Jin Ge Jin Qu [h]ao UVa12563.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12563 Jin Ge Jin Qu [h]ao</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">50</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;

<span class="co">// d[i][j]: maximal number of songs from first i songs, whose total length is exactly j</span>
<span class="dt">int</span> n, t, len[maxn], d[maxn*<span class="dv">180+678</span>];

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">for</span>(<span class="dt">int</span> kase = <span class="dv">1</span>; kase &lt;= T; kase++) {
        scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;t);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;len[i]);

        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; t; i++) d[i] = <span class="dv">-1</span>;
        d = <span class="dv">0</span>;

        <span class="dt">int</span> p = <span class="dv">1</span>, ans = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; t; j++) {
                d[p][j] = d[p^<span class="dv">1</span>][j];
                <span class="kw">if</span>(j &gt;= len[i] &amp;&amp; d[p^<span class="dv">1</span>][j - len[i]] &gt;= <span class="dv">0</span>)
                    d[p][j] = max(d[p][j], d[p^<span class="dv">1</span>][j - len[i]] + <span class="dv">1</span>);
                ans = max(ans, d[p][j]);
            }
            p ^= <span class="dv">1</span>;
        }
        <span class="kw">for</span>(<span class="dt">int</span> i = t<span class="dv">-1</span>; i &gt;= <span class="dv">0</span>; i--)
            <span class="kw">if</span>(d[p^<span class="dv">1</span>][i] == ans) {
                printf(<span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">: </span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, kase, ans + <span class="dv">1</span>, i + <span class="dv">678</span>);
                <span class="kw">break</span>;
            }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#26356;&#22810;&#32463;&#20856;&#27169;&#22411; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#32447;&#24615;&#32467;&#26500;&#19978;&#30340;&#21160;&#24577;&#35268;&#21010; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>9-6 UVa11400 Lighting System Design uva11400.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11400 Lighting System Design</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1000</span> + <span class="dv">5</span>;

<span class="kw">struct</span> Lamp {
    <span class="dt">int</span> v, k, c, l;
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Lamp&amp; rhs) <span class="dt">const</span> {
        <span class="kw">return</span> v &lt; rhs.v;
    }
} lamp[maxn];

<span class="dt">int</span> n, s[maxn], d[maxn];

<span class="dt">int</span> main() {
    <span class="kw">while</span>(cin &gt;&gt; n &amp;&amp; n) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++)
            cin &gt;&gt; lamp[i].v &gt;&gt; lamp[i].k &gt;&gt; lamp[i].c &gt;&gt; lamp[i].l;
        sort(lamp<span class="dv">+1</span>, lamp+n<span class="dv">+1</span>);
        s = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) s[i] = s[i<span class="dv">-1</span>] + lamp[i].l;
        d = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {
            d[i] = s[i] * lamp[i].c + lamp[i].k; <span class="co">// &#21069;i&#20010;&#28783;&#27873;&#20840;&#20080;&#31867;&#22411;i</span>
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= i; j++)
                d[i] = min(d[i], d[j] + (s[i] - s[j]) * lamp[i].c + lamp[i].k);
        }
        cout &lt;&lt; d[n] &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-7 UVa11584 Partitioning by Palindromes UVa11584.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11584 Partitioning by Palindromes</span>
<span class="co">// Rujia Liu</span>
<span class="co">// This code is slightly different from the book.</span>
<span class="co">// It uses memoization to judge whether s[i..j] is a palindrome.</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1000</span> + <span class="dv">5</span>;
<span class="dt">int</span> n, kase, vis[maxn][maxn], p[maxn][maxn], d[maxn];
<span class="dt">char</span> s[maxn];

<span class="dt">int</span> is_palindrome(<span class="dt">int</span> i, <span class="dt">int</span> j) {
    <span class="kw">if</span>(i &gt;= j) <span class="kw">return</span> <span class="dv">1</span>;
    <span class="kw">if</span>(s[i] != s[j]) <span class="kw">return</span> <span class="dv">0</span>;

    <span class="kw">if</span>(vis[i][j] == kase) <span class="kw">return</span> p[i][j];
    vis[i][j] = kase;
    p[i][j] = is_palindrome(i<span class="dv">+1</span>, j<span class="dv">-1</span>);
    <span class="kw">return</span> p[i][j];
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
    <span class="kw">for</span>(kase = <span class="dv">1</span>; kase &lt;= T; kase++) {
        scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, s<span class="dv">+1</span>);
        n = strlen(s<span class="dv">+1</span>);
        d = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {
            d[i] = i<span class="dv">+1</span>;
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; i; j++)
                <span class="kw">if</span>(is_palindrome(j<span class="dv">+1</span>, i)) d[i] = min(d[i], d[j] + <span class="dv">1</span>);
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, d[n]);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-8 UVa1625 Color Length UVa1625.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1625 Color Length</span>
<span class="co">// Rujia Liu</span>

<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">5000</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;

<span class="dt">char</span> p[maxn], q[maxn]; <span class="co">// starts from position 1</span>
<span class="dt">int</span> sp, sq, ep, eq; <span class="co">// sp[i] start positions of character i in p</span>
<span class="dt">int</span> d[maxn], c[maxn]; <span class="co">// c[i][j]: how many &quot;incomplete&quot; colors in the mixed sequence</span>

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%s%s</span><span class="st">&quot;</span>, p<span class="dv">+1</span>, q<span class="dv">+1</span>);

        <span class="dt">int</span> n = strlen(p<span class="dv">+1</span>);
        <span class="dt">int</span> m = strlen(q<span class="dv">+1</span>);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) p[i] -= <span class="st">&#39;A&#39;</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= m; i++) q[i] -= <span class="st">&#39;A&#39;</span>;

        <span class="co">// calculate s and e</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">26</span>; i++) { sp[i] = sq[i] = INF; ep[i] = eq[i] = <span class="dv">0</span>; }
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {
            sp[p[i]] = min(sp[p[i]], i);
            ep[p[i]] = i;
        }
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= m; i++) {
            sq[q[i]] = min(sq[q[i]], i);
            eq[q[i]] = i;
        }

        <span class="co">// dp</span>
        <span class="dt">int</span> t = <span class="dv">0</span>;
        memset(c, <span class="dv">0</span>, <span class="kw">sizeof</span>(c));
        memset(d, <span class="dv">0</span>, <span class="kw">sizeof</span>(d));
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= n; i++){
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= m; j++){
                <span class="kw">if</span>(!i &amp;&amp; !j) <span class="kw">continue</span>;

                <span class="co">// calculate d</span>
                <span class="dt">int</span> v1 = INF, v2 = INF;
                <span class="kw">if</span>(i) v1 = d[t^<span class="dv">1</span>][j] + c[t^<span class="dv">1</span>][j]; <span class="co">// remove from p</span>
                <span class="kw">if</span>(j) v2 = d[t][j - <span class="dv">1</span>] + c[t][j - <span class="dv">1</span>]; <span class="co">// remove from q</span>
                d[t][j] = min(v1, v2);

                <span class="co">// calculate c</span>
                <span class="kw">if</span>(i) {
                    c[t][j] = c[t^<span class="dv">1</span>][j];
                    <span class="kw">if</span>(sp[p[i]] == i &amp;&amp; sq[p[i]] &gt; j) c[t][j]++;
                    <span class="kw">if</span>(ep[p[i]] == i &amp;&amp; eq[p[i]] &lt;= j) c[t][j]--;
                } <span class="kw">else</span> <span class="kw">if</span>(j) {
                    c[t][j] = c[t][j - <span class="dv">1</span>];
                    <span class="kw">if</span>(sq[q[j]] == j &amp;&amp; sp[q[j]] &gt; i) c[t][j]++;
                    <span class="kw">if</span>(eq[q[j]] == j &amp;&amp; ep[q[j]] &lt;= i) c[t][j]--;
                }
            }
            t ^= <span class="dv">1</span>;
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, d[t^<span class="dv">1</span>][m]);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-9 UVa10003 Cutting Sticks UVa10003.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10003 Cutting Sticks</span>
<span class="co">// Rujia Liu</span>
<span class="co">// &#31639;&#27861;&#65306;&#35774;d[i][j]&#20026;&#20999;&#21106;&#23567;&#26408;&#26829;i~j&#30340;&#26368;&#20248;&#36153;&#29992;&#65292;&#21017;d[i][j]=min{d[i][k]+d[k][j]}+a[j]-a[i]&#12290;&#26368;&#21518;&#30340;a[j]-a[i]&#26159;&#31532;&#19968;&#20992;&#30340;&#36153;&#29992;&#12290;&#28982;&#21518;&#20998;&#25104;i~k&#21644;k~j&#20004;&#37096;&#20998;&#12290;</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">50</span> + <span class="dv">5</span>;
<span class="dt">int</span> n, L, a[maxn], vis[maxn][maxn], d[maxn][maxn];

<span class="dt">int</span> dp(<span class="dt">int</span> i, <span class="dt">int</span> j) {
    <span class="kw">if</span>(i &gt;= j - <span class="dv">1</span>) <span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">if</span>(vis[i][j]) <span class="kw">return</span> d[i][j];
    vis[i][j] = <span class="dv">1</span>;
    <span class="dt">int</span>&amp; ans = d[i][j];
    ans = <span class="dv">-1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> k = i<span class="dv">+1</span>; k &lt;= j<span class="dv">-1</span>; k++) {
        <span class="dt">int</span> v = dp(i,k) + dp(k,j) + a[j] - a[i];
        <span class="kw">if</span>(ans &lt; <span class="dv">0</span> || v &lt; ans) ans = v;
    }
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main() {
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;L, &amp;n) == <span class="dv">2</span> &amp;&amp; L) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;a[i]);
        a = <span class="dv">0</span>; a[n<span class="dv">+1</span>] = L;
        memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
        printf(<span class="st">&quot;The minimum cutting is </span><span class="ch">%d</span><span class="st">.</span><span class="ch">\n</span><span class="st">&quot;</span>, dp(<span class="dv">0</span>, n<span class="dv">+1</span>));
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-10 UVa1626 Brackets Sequence UVa1626.cpp -&lt; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// LA2451 Brackets Sequence</span>
<span class="co">// Rujia Liu</span>
<span class="co">// &#31639;&#27861;&#65306;&#24418;&#22914;(S)&#25110;&#32773;[S]&#65292;&#36716;&#31227;&#21040;d(S)&#65292;&#28982;&#21518;&#20998;&#25104;AB&#65292;&#36716;&#31227;&#21040;d(A)+d(B)&#12290;&#27880;&#24847;(S, [S, )S&#20043;&#31867;&#20840;&#37096;&#23646;&#20110;&#31532;&#20108;&#31181;&#36716;&#31227;&#12290;</span>
<span class="co">// &#27880;&#24847;&#36755;&#20837;&#26377;&#31354;&#34892;&#12290;</span>
<span class="co">// &#26412;&#31243;&#24207;&#26159;&#36882;&#25512;&#35299;&#27861;</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span> + <span class="dv">5</span>;
<span class="dt">char</span> S[maxn];
<span class="dt">int</span> n, d[maxn][maxn];

<span class="dt">bool</span> match(<span class="dt">char</span> a, <span class="dt">char</span> b) {
    <span class="kw">return</span> (a == <span class="st">&#39;(&#39;</span> &amp;&amp; b == <span class="st">&#39;)&#39;</span>) || (a == <span class="st">&#39;[&#39;</span> &amp;&amp; b == <span class="st">&#39;]&#39;</span>);
}

<span class="dt">void</span> dp() {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
        d[i<span class="dv">+1</span>][i] = <span class="dv">0</span>;
        d[i][i] = <span class="dv">1</span>;
    }
    <span class="kw">for</span>(<span class="dt">int</span> i = n<span class="dv">-2</span>; i &gt;= <span class="dv">0</span>; i--)
        <span class="kw">for</span>(<span class="dt">int</span> j = i<span class="dv">+1</span>; j &lt; n; j++) {
            d[i][j] = n;
            <span class="kw">if</span>(match(S[i], S[j])) d[i][j] = min(d[i][j], d[i<span class="dv">+1</span>][j<span class="dv">-1</span>]);
            <span class="kw">for</span>(<span class="dt">int</span> k = i; k &lt; j; k++)
                d[i][j] = min(d[i][j], d[i][k] + d[k<span class="dv">+1</span>][j]);
        }
}

<span class="dt">void</span> print(<span class="dt">int</span> i, <span class="dt">int</span> j) {
    <span class="kw">if</span>(i &gt; j) <span class="kw">return</span> ;
    <span class="kw">if</span>(i == j) {
        <span class="kw">if</span>(S[i] == <span class="st">&#39;(&#39;</span> || S[i] == <span class="st">&#39;)&#39;</span>) printf(<span class="st">&quot;()&quot;</span>);
        <span class="kw">else</span> printf(<span class="st">&quot;[]&quot;</span>);
        <span class="kw">return</span>;
    }
    <span class="dt">int</span> ans = d[i][j];
    <span class="kw">if</span>(match(S[i], S[j]) &amp;&amp; ans == d[i<span class="dv">+1</span>][j<span class="dv">-1</span>]) {
        printf(<span class="st">&quot;</span><span class="ch">%c</span><span class="st">&quot;</span>, S[i]); print(i<span class="dv">+1</span>, j<span class="dv">-1</span>); printf(<span class="st">&quot;</span><span class="ch">%c</span><span class="st">&quot;</span>, S[j]);
        <span class="kw">return</span>;
    }
    <span class="kw">for</span>(<span class="dt">int</span> k = i; k &lt; j; k++)
        <span class="kw">if</span>(ans == d[i][k] + d[k<span class="dv">+1</span>][j]) {
            print(i, k); print(k<span class="dv">+1</span>, j);
            <span class="kw">return</span>;
        }
}

<span class="dt">void</span> readline(<span class="dt">char</span>* S) {
    fgets(S, maxn, stdin);
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;

    readline(S);
    sscanf(S, <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    readline(S);

    <span class="kw">while</span>(T--) {
        readline(S);
        n = strlen(S) - <span class="dv">1</span>;
        memset(d, <span class="dv">-1</span>, <span class="kw">sizeof</span>(d));
        dp();
        print(<span class="dv">0</span>, n<span class="dv">-1</span>);
        printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">if</span>(T) printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
        readline(S);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-11 UVa1331 Minimax Triangulation UVa1331.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1331 Minimax Triangulation</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstdlib&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;queue&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">double</span> eps = <span class="fl">1e-10</span>;
<span class="dt">int</span> dcmp(<span class="dt">double</span> x) {
    <span class="kw">if</span>(fabs(x) &lt; eps) <span class="kw">return</span> <span class="dv">0</span>; <span class="kw">else</span> <span class="kw">return</span> x &lt; <span class="dv">0</span> ? <span class="dv">-1</span> : <span class="dv">1</span>;
}

<span class="kw">struct</span> Point {
    <span class="dt">double</span> x, y;
    Point(<span class="dt">double</span> x=<span class="dv">0</span>, <span class="dt">double</span> y=<span class="dv">0</span>):x(x),y(y) { }
};

<span class="kw">typedef</span> Point Vector;

Vector <span class="kw">operator</span> + (<span class="dt">const</span> Vector&amp; A, <span class="dt">const</span> Vector&amp; B) { <span class="kw">return</span> Vector(A.x+B.x, A.y+B.y); }
Vector <span class="kw">operator</span> - (<span class="dt">const</span> Point&amp; A, <span class="dt">const</span> Point&amp; B) { <span class="kw">return</span> Vector(A.x-B.x, A.y-B.y); }
Vector <span class="kw">operator</span> * (<span class="dt">const</span> Vector&amp; A, <span class="dt">double</span> p) { <span class="kw">return</span> Vector(A.x*p, A.y*p); }

<span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Point&amp; a, <span class="dt">const</span> Point&amp; b) {
    <span class="kw">return</span> a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);
}

<span class="dt">bool</span> <span class="kw">operator</span> == (<span class="dt">const</span> Point&amp; a, <span class="dt">const</span> Point &amp;b) {
    <span class="kw">return</span> dcmp(a.x-b.x) == <span class="dv">0</span> &amp;&amp; dcmp(a.y-b.y) == <span class="dv">0</span>;
}

<span class="dt">double</span> Dot(<span class="dt">const</span> Vector&amp; A, <span class="dt">const</span> Vector&amp; B) { <span class="kw">return</span> A.x*B.x + A.y*B.y; }
<span class="dt">double</span> Cross(<span class="dt">const</span> Vector&amp; A, <span class="dt">const</span> Vector&amp; B) { <span class="kw">return</span> A.x*B.y - A.y*B.x; }
<span class="dt">double</span> Length(Vector A) { <span class="kw">return</span> sqrt(Dot(A, A)); }

<span class="dt">bool</span> SegmentProperIntersection(<span class="dt">const</span> Point&amp; a1, <span class="dt">const</span> Point&amp; a2, <span class="dt">const</span> Point&amp; b1, <span class="dt">const</span> Point&amp; b2) {
    <span class="dt">double</span> c1 = Cross(a2-a1,b1-a1), c2 = Cross(a2-a1,b2-a1),
           c3 = Cross(b2-b1,a1-b1), c4=Cross(b2-b1,a2-b1);
    <span class="kw">return</span> dcmp(c1)*dcmp(c2)&lt;<span class="dv">0</span> &amp;&amp; dcmp(c3)*dcmp(c4)&lt;<span class="dv">0</span>;
}

<span class="dt">bool</span> OnSegment(<span class="dt">const</span> Point&amp; p, <span class="dt">const</span> Point&amp; a1, <span class="dt">const</span> Point&amp; a2) {
    <span class="kw">return</span> dcmp(Cross(a1-p, a2-p)) == <span class="dv">0</span> &amp;&amp; dcmp(Dot(a1-p, a2-p)) &lt; <span class="dv">0</span>;
}

<span class="kw">typedef</span> vector&lt;Point&gt; Polygon;

<span class="dt">int</span> isPointInPolygon(<span class="dt">const</span> Point&amp; p, <span class="dt">const</span> Polygon&amp; poly){
    <span class="dt">int</span> n = poly.size();
    <span class="dt">int</span> wn = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++){
        <span class="dt">const</span> Point&amp; p1 = poly[i];
        <span class="dt">const</span> Point&amp; p2 = poly[(i<span class="dv">+1</span>)%n];
        <span class="kw">if</span>(p1 == p || p2 == p || OnSegment(p, p1, p2)) <span class="kw">return</span> <span class="dv">-1</span>; <span class="co">// &#22312;&#36793;&#30028;&#19978;</span>
        <span class="dt">int</span> k = dcmp(Cross(p2-p1, p-p1));
        <span class="dt">int</span> d1 = dcmp(p1.y - p.y);
        <span class="dt">int</span> d2 = dcmp(p2.y - p.y);
        <span class="kw">if</span>(k &gt; <span class="dv">0</span> &amp;&amp; d1 &lt;= <span class="dv">0</span> &amp;&amp; d2 &gt; <span class="dv">0</span>) wn++;
        <span class="kw">if</span>(k &lt; <span class="dv">0</span> &amp;&amp; d2 &lt;= <span class="dv">0</span> &amp;&amp; d1 &gt; <span class="dv">0</span>) wn--;
    }
    <span class="kw">if</span> (wn != <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">1</span>; <span class="co">// &#20869;&#37096;</span>
    <span class="kw">return</span> <span class="dv">0</span>; <span class="co">// &#22806;&#37096;</span>
}

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span> + <span class="dv">5</span>;

<span class="dt">bool</span> isDiagonal(<span class="dt">const</span> Polygon&amp; poly, <span class="dt">int</span> a, <span class="dt">int</span> b) {
    <span class="dt">int</span> n = poly.size();
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
        <span class="kw">if</span>(i != a &amp;&amp; i != b &amp;&amp; OnSegment(poly[i], poly[a], poly[b])) <span class="kw">return</span> <span class="kw">false</span>; <span class="co">// &#20013;&#38388;&#19981;&#33021;&#26377;&#20854;&#20182;&#28857;</span>
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
        <span class="kw">if</span>(SegmentProperIntersection(poly[i], poly[(i<span class="dv">+1</span>)%n], poly[a], poly[b])) <span class="kw">return</span> <span class="kw">false</span>; <span class="co">// &#19981;&#33021;&#21644;&#22810;&#36793;&#24418;&#30340;&#36793;&#35268;&#33539;&#30456;&#20132;</span>
    Point midp = (poly[a] + poly[b]) * <span class="fl">0.5</span>;
    <span class="kw">return</span> (isPointInPolygon(midp, poly) == <span class="dv">1</span>); <span class="co">// &#25972;&#26465;&#32447;&#27573;&#22312;&#22810;&#36793;&#24418;&#20869;</span>
}

<span class="dt">const</span> <span class="dt">double</span> INF = <span class="fl">1e9</span>;
<span class="dt">double</span> d[maxn][maxn];

<span class="dt">double</span> solve(<span class="dt">const</span> Polygon&amp; poly) {
    <span class="dt">int</span> n = poly.size();

    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++) d[i][j] = <span class="dv">-1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = n<span class="dv">-2</span>; i &gt;= <span class="dv">0</span>; i--)
        <span class="kw">for</span>(<span class="dt">int</span> j = i<span class="dv">+1</span>; j &lt; n; j++) {
            <span class="kw">if</span>(i + <span class="dv">1</span> == j) d[i][j] = <span class="dv">0</span>;
            <span class="kw">else</span> <span class="kw">if</span>(!(i == <span class="dv">0</span> &amp;&amp; j == n<span class="dv">-1</span>) &amp;&amp; !isDiagonal(poly, i, j)) d[i][j] = INF;
            <span class="kw">else</span> {
                d[i][j] = INF;
                <span class="kw">for</span>(<span class="dt">int</span> k = i<span class="dv">+1</span>; k &lt; j; k++) {
                    <span class="dt">double</span> m = max(d[i][k], d[k][j]);
                    <span class="dt">double</span> area = fabs(Cross(poly[j]-poly[i], poly[k]-poly[i])) / <span class="fl">2.0</span>; <span class="co">// triangle i-j-k</span>
                    m = max(m, area);
                    d[i][j] = min(d[i][j], m);
                }
            }
        }
    <span class="kw">return</span> d[n<span class="dv">-1</span>];
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T, n;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        <span class="dt">double</span> x, y;
        Polygon poly;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) { scanf(<span class="st">&quot;</span><span class="ch">%lf%lf</span><span class="st">&quot;</span>, &amp;x, &amp;y); poly.push_back(Point(x,y)); }
        printf(<span class="st">&quot;</span><span class="ch">%.1lf\n</span><span class="st">&quot;</span>, solve(poly));
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#25968;&#19978;&#30340;&#21160;&#24577;&#35268;&#21010; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>9-12 UVa12186 Another Crisis uva12186.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12186 Another Crisis</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100000</span> + <span class="dv">5</span>;
<span class="dt">int</span> n, T;
vector&lt;<span class="dt">int</span>&gt; sons[maxn];

<span class="dt">int</span> dp(<span class="dt">int</span> u) {
    <span class="kw">if</span>(sons[u].empty()) <span class="kw">return</span> <span class="dv">1</span>;
    <span class="dt">int</span> k = sons[u].size();
    vector&lt;<span class="dt">int</span>&gt; d;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; k; i++)
        d.push_back(dp(sons[u][i]));
    sort(d.begin(), d.end());
    <span class="dt">int</span> c = (k*T - <span class="dv">1</span>) / <span class="dv">100</span> + <span class="dv">1</span>;
    <span class="dt">int</span> ans = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; c; i++) ans += d[i];
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> f;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;T) == <span class="dv">2</span> &amp;&amp; n) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= n; i++) sons[i].clear();
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;f);
            sons[f].push_back(i);
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, dp(<span class="dv">0</span>));
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-13 UVa1220 Party at Hali-Bula UVa1220.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1220 Party at Hali-Bula</span>
<span class="co">// Rujia Liu</span>
<span class="co">//</span>
<span class="co">// rev 2: fixed bug reported by EndlessCheng</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;string&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;map&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">200</span> + <span class="dv">5</span>;

<span class="dt">int</span> cnt;
vector&lt;<span class="dt">int</span>&gt; sons[maxn];
<span class="dt">int</span> n, d[maxn], f[maxn];

map&lt;string, <span class="dt">int</span>&gt; dict;
<span class="dt">int</span> ID(<span class="dt">const</span> string&amp; s) {
    <span class="kw">if</span>(!dict.count(s)) dict[s] = cnt++;
    <span class="kw">return</span> dict[s];
}

<span class="dt">int</span> dp(<span class="dt">int</span> u, <span class="dt">int</span> k) {
    f[u][k] = <span class="dv">1</span>;
    d[u][k] = k;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; sons[u].size(); i++) {
        <span class="dt">int</span> v = sons[u][i];
        <span class="kw">if</span>(k == <span class="dv">1</span>) {
            d[u] += dp(v, <span class="dv">0</span>);
            <span class="kw">if</span>(!f[v]) f[u] = <span class="dv">0</span>;
        } <span class="kw">else</span> {
            d[u] += max(dp(v, <span class="dv">0</span>), dp(v, <span class="dv">1</span>));
            <span class="kw">if</span>(d[v] == d[v]) f[u][k] = <span class="dv">0</span>;
            <span class="kw">else</span> <span class="kw">if</span>(d[v] &gt; d[v] &amp;&amp; !f[v]) f[u][k] = <span class="dv">0</span>;
            <span class="kw">else</span> <span class="kw">if</span>(d[v] &gt; d[v] &amp;&amp; !f[v]) f[u][k] = <span class="dv">0</span>;
        }
    }
    <span class="kw">return</span> d[u][k];
}

<span class="dt">int</span> main() {
    string s, s2;
    <span class="kw">while</span>(cin &gt;&gt; n &gt;&gt; s) {
        cnt = <span class="dv">0</span>;
        dict.clear();
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) sons[i].clear();

        ID(s);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n<span class="dv">-1</span>; i++) {
            cin &gt;&gt; s &gt;&gt; s2;
            sons[ID(s2)].push_back(ID(s));
        }
        printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, max(dp(<span class="dv">0</span>, <span class="dv">0</span>), dp(<span class="dv">0</span>, <span class="dv">1</span>)));
        <span class="dt">bool</span> unique = <span class="kw">false</span>;
        <span class="kw">if</span>(d &gt; d &amp;&amp; f) unique = <span class="kw">true</span>;
        <span class="kw">if</span>(d &gt; d &amp;&amp; f) unique = <span class="kw">true</span>;
        <span class="kw">if</span>(unique) printf(<span class="st">&quot;Yes</span><span class="ch">\n</span><span class="st">&quot;</span>); <span class="kw">else</span> printf(<span class="st">&quot;No</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-14 UVa1218 Perfect Service uva1218.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1218 Perfect Service</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">10000</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;

vector&lt;<span class="dt">int</span>&gt; G[maxn], vertices;
<span class="dt">int</span> p[maxn], d[maxn];

<span class="co">// build a rooted tree and dfs sequence</span>
<span class="dt">void</span> dfs(<span class="dt">int</span> u, <span class="dt">int</span> fa) {
    vertices.push_back(u);
    p[u] = fa;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[u].size(); i++) {
        <span class="dt">int</span> v = G[u][i];
        <span class="kw">if</span>(v != fa) dfs(v, u);
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span>) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) G[i].clear();
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n<span class="dv">-1</span>; i++) {
            <span class="dt">int</span> u, v;
            scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;u, &amp;v); u--; v--;
            G[u].push_back(v);
            G[v].push_back(u);
        }
        vertices.clear();
        dfs(<span class="dv">0</span>, <span class="dv">-1</span>);
        <span class="kw">for</span>(<span class="dt">int</span> i = vertices.size()<span class="dv">-1</span>; i &gt;= <span class="dv">0</span>; i--) {
            <span class="dt">int</span> u = vertices[i];
            d[u] = <span class="dv">1</span>; d[u] = <span class="dv">0</span>;
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; G[u].size(); j++) {
                <span class="dt">int</span> v = G[u][j];
                <span class="kw">if</span>(v == p[u]) <span class="kw">continue</span>;
                d[u] += min(d[v], d[v]); <span class="co">// u is server</span>
                d[u] += d[v]; <span class="co">// u is not server, u&#39;s father is server</span>
                <span class="kw">if</span>(d[u] &gt; INF) d[u] = INF; <span class="co">// avoid overflow!</span>
                <span class="kw">if</span>(d[u] &gt; INF) d[u] = INF;
            }
            d[u] = INF;
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; G[u].size(); j++) {
                <span class="dt">int</span> v = G[u][j];
                <span class="kw">if</span>(v == p[u]) <span class="kw">continue</span>;
                d[u] = min(d[u], d[u] - d[v] + d[v]); <span class="co">// neither u or father is server</span>
            }
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, min(d, d));
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n); <span class="co">// flag</span>
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#22797;&#26434;&#29366;&#24577;&#30340;&#21160;&#24577;&#35268;&#21010; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>9-15 UVa10817 Headmaster&#8217;s Headache uva10817.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10817 Headmaster&#39;s Headache</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;sstream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span> + <span class="dv">20</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> maxs = <span class="dv">8</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;
<span class="dt">int</span> m, n, s, c[maxn], st[maxn], d[maxn][<span class="dv">1</span>&lt;&lt;maxs][<span class="dv">1</span>&lt;&lt;maxs];

<span class="co">// s1&#26159;&#19968;&#20010;&#20154;&#25945;&#30340;&#31185;&#30446;&#38598;&#21512;&#65292;s2&#26159;&#20004;&#20010;&#20154;&#25945;&#30340;&#31185;&#30446;&#38598;&#21512;</span>
<span class="dt">int</span> dp(<span class="dt">int</span> i, <span class="dt">int</span> s0, <span class="dt">int</span> s1, <span class="dt">int</span> s2) {
    <span class="kw">if</span>(i == m+n) <span class="kw">return</span> s2 == (<span class="dv">1</span>&lt;&lt;s) - <span class="dv">1</span> ? <span class="dv">0</span> : INF;
    <span class="dt">int</span>&amp; ans = d[i][s1][s2];
    <span class="kw">if</span>(ans &gt;= <span class="dv">0</span>) <span class="kw">return</span> ans;

    ans = INF;
    <span class="kw">if</span>(i &gt;= m) ans = dp(i<span class="dv">+1</span>, s0, s1, s2); <span class="co">// &#19981;&#36873;</span>

    <span class="co">// &#36873;</span>
    <span class="dt">int</span> m0 = st[i] &amp; s0, m1 = st[i] &amp; s1;
    s0 ^= m0;
    s1 = (s1 ^ m1) | m0;
    s2 |= m1;
    ans = min(ans, c[i] + dp(i<span class="dv">+1</span>, s0, s1, s2));
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> x;
    string line;
    <span class="kw">while</span>(getline(cin, line)) {
        stringstream ss(line);
        ss &gt;&gt; s &gt;&gt; m &gt;&gt; n;
        <span class="kw">if</span>(s == <span class="dv">0</span>) <span class="kw">break</span>;

        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m+n; i++) {
            getline(cin, line);
            stringstream ss(line);
            ss &gt;&gt; c[i];
            st[i] = <span class="dv">0</span>;
            <span class="kw">while</span>(ss &gt;&gt; x) st[i] |= (<span class="dv">1</span> &lt;&lt; (x<span class="dv">-1</span>));
        }
        memset(d, <span class="dv">-1</span>, <span class="kw">sizeof</span>(d));
        cout &lt;&lt; dp(<span class="dv">0</span>, (<span class="dv">1</span>&lt;&lt;s)<span class="dv">-1</span>, <span class="dv">0</span>, <span class="dv">0</span>) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-16 UVa1252 Twenty Questions UVa1252.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1252 Twenty Questions</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;ctime&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="ot">#include&lt;cassert&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">128</span>;
<span class="dt">const</span> <span class="dt">int</span> maxm = <span class="dv">11</span>;

<span class="dt">int</span> kase, n, m;
<span class="dt">char</span> objects[maxn][maxm + <span class="dv">100</span>];

<span class="dt">int</span> vis[<span class="dv">1</span>&lt;&lt;maxm][<span class="dv">1</span>&lt;&lt;maxm], d[<span class="dv">1</span>&lt;&lt;maxm][<span class="dv">1</span>&lt;&lt;maxm];
<span class="dt">int</span> cnt[<span class="dv">1</span>&lt;&lt;maxm][<span class="dv">1</span>&lt;&lt;maxm]; <span class="co">// cnt[s][a]: how many object satisfies: Intersect(featureSet(i), s) = a</span>

<span class="co">// s: the set of features we already asked</span>
<span class="co">// a: subset of s that the object has</span>
<span class="dt">int</span> dp(<span class="dt">int</span> s, <span class="dt">int</span> a) {
    <span class="kw">if</span>(cnt[s][a] &lt;= <span class="dv">1</span>) <span class="kw">return</span> <span class="dv">0</span>;
    <span class="kw">if</span>(cnt[s][a] == <span class="dv">2</span>) <span class="kw">return</span> <span class="dv">1</span>;

    <span class="dt">int</span>&amp; ans = d[s][a];
    <span class="kw">if</span>(vis[s][a] == kase) <span class="kw">return</span> ans;
    vis[s][a] = kase;

    ans = m;
    <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; m; k++)
        <span class="kw">if</span>(!(s &amp; (<span class="dv">1</span>&lt;&lt;k))) { <span class="co">// haven&#39;t asked</span>
            <span class="dt">int</span> s2 = s|(<span class="dv">1</span>&lt;&lt;k), a2 = a|(<span class="dv">1</span>&lt;&lt;k);
            <span class="kw">if</span>(cnt[s2][a2] &gt;= <span class="dv">1</span> &amp;&amp; cnt[s2][a] &gt;= <span class="dv">1</span>) {
                <span class="dt">int</span> need = max(dp(s2, a2),     <span class="co">// the object has feature k</span>
                        dp(s2, a)) + <span class="dv">1</span>; <span class="co">// the object doesn&#39;t have feature k</span>
                ans = min(ans, need);
            }
        }
    <span class="kw">return</span> ans;
}

<span class="dt">void</span> init() {
    <span class="kw">for</span>(<span class="dt">int</span> s = <span class="dv">0</span>; s &lt; (<span class="dv">1</span>&lt;&lt;m); s++) {
        <span class="kw">for</span>(<span class="dt">int</span> a = s; a; a = (a<span class="dv">-1</span>)&amp;s)
            cnt[s][a] = <span class="dv">0</span>;
        cnt[s] = <span class="dv">0</span>;
    }
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
        <span class="dt">int</span> features = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> f = <span class="dv">0</span>; f &lt; m; f++)
            <span class="kw">if</span>(objects[i][f] == <span class="st">&#39;1&#39;</span>) features |= (<span class="dv">1</span>&lt;&lt;f);
        <span class="kw">for</span>(<span class="dt">int</span> s = <span class="dv">0</span>; s &lt; (<span class="dv">1</span>&lt;&lt;m); s++)
            cnt[s][s &amp; features]++;
    }
}


<span class="dt">int</span> main() {
    memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;m, &amp;n) == <span class="dv">2</span> &amp;&amp; n) {
        ++kase;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, objects[i]);
        init();
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, dp(<span class="dv">0</span>, <span class="dv">0</span>));
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-17 UVa1412 Fund Management uva1412.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1412 Fund Management</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;map&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">double</span> INF = <span class="fl">1e30</span>;
<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">8</span>;
<span class="dt">const</span> <span class="dt">int</span> maxm = <span class="dv">100</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> maxstate = <span class="dv">15000</span>;

<span class="dt">int</span> m, n, s[maxn], k[maxn], kk;
<span class="dt">double</span> c, price[maxn][maxm];
<span class="dt">char</span> name[maxn];

<span class="dt">double</span> d[maxm][maxstate];
<span class="dt">int</span> opt[maxm][maxstate], prev[maxm][maxstate];

<span class="dt">int</span> buy_next[maxstate][maxn], sell_next[maxstate][maxn];
vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; states;
map&lt;vector&lt;<span class="dt">int</span>&gt;, <span class="dt">int</span>&gt; ID;

<span class="dt">void</span> dfs(<span class="dt">int</span> stock, vector&lt;<span class="dt">int</span>&gt;&amp; lots, <span class="dt">int</span> totlot) {
    <span class="kw">if</span>(stock == n) {
        ID[lots] = states.size();
        states.push_back(lots);
    }
    <span class="kw">else</span> <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= k[stock] &amp;&amp; totlot + i &lt;= kk; i++) {
        lots[stock] = i;
        dfs(stock<span class="dv">+1</span>, lots, totlot + i);
    }
}

<span class="dt">void</span> init() {
    vector&lt;<span class="dt">int</span>&gt; lots(n);
    states.clear();
    ID.clear();
    dfs(<span class="dv">0</span>, lots, <span class="dv">0</span>);
    <span class="kw">for</span>(<span class="dt">int</span> s = <span class="dv">0</span>; s &lt; states.size(); s++) {
        <span class="dt">int</span> totlot = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) totlot += states[s][i];
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            buy_next[s][i] = sell_next[s][i] = <span class="dv">-1</span>;
            <span class="kw">if</span>(states[s][i] &lt; k[i] &amp;&amp; totlot &lt; kk) {
                vector&lt;<span class="dt">int</span>&gt; newstate = states[s];
                newstate[i]++;
                buy_next[s][i] = ID[newstate];
            }
            <span class="kw">if</span>(states[s][i] &gt; <span class="dv">0</span>) {
                vector&lt;<span class="dt">int</span>&gt; newstate = states[s];
                newstate[i]--;
                sell_next[s][i] = ID[newstate];
            }
        }
    }
}

<span class="dt">void</span> update(<span class="dt">int</span> day, <span class="dt">int</span> s, <span class="dt">int</span> s2, <span class="dt">double</span> v, <span class="dt">int</span> o) {
    <span class="kw">if</span>(v &gt; d[day<span class="dv">+1</span>][s2]) {
        d[day<span class="dv">+1</span>][s2] = v;
        opt[day<span class="dv">+1</span>][s2] = o;
        prev[day<span class="dv">+1</span>][s2] = s;
    }
}

<span class="dt">double</span> dp() {
    <span class="kw">for</span>(<span class="dt">int</span> day = <span class="dv">0</span>; day &lt;= m; day++)
        <span class="kw">for</span>(<span class="dt">int</span> s = <span class="dv">0</span>; s &lt; states.size(); s++) d[day][s] = -INF;

    d = c;
    <span class="kw">for</span>(<span class="dt">int</span> day = <span class="dv">0</span>; day &lt; m; day++)
        <span class="kw">for</span>(<span class="dt">int</span> s = <span class="dv">0</span>; s &lt; states.size(); s++) {
            <span class="dt">double</span> v = d[day][s];
            <span class="kw">if</span>(v &lt; <span class="dv">-1</span>) <span class="kw">continue</span>;

            update(day, s, s, v, <span class="dv">0</span>); <span class="co">// HOLD</span>
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
                <span class="kw">if</span>(buy_next[s][i] &gt;= <span class="dv">0</span> &amp;&amp; v &gt;= price[i][day] - <span class="fl">1e-3</span>)
                    update(day, s, buy_next[s][i], v - price[i][day], i<span class="dv">+1</span>); <span class="co">// BUY</span>
                <span class="kw">if</span>(sell_next[s][i] &gt;= <span class="dv">0</span>)
                    update(day, s, sell_next[s][i], v + price[i][day], -i<span class="dv">-1</span>); <span class="co">// SELL</span>
            }
        }
    <span class="kw">return</span> d[m];
}

<span class="dt">void</span> print_ans(<span class="dt">int</span> day, <span class="dt">int</span> s) {
    <span class="kw">if</span>(day == <span class="dv">0</span>) <span class="kw">return</span>;
    print_ans(day<span class="dv">-1</span>, prev[day][s]);
    <span class="kw">if</span>(opt[day][s] == <span class="dv">0</span>) printf(<span class="st">&quot;HOLD</span><span class="ch">\n</span><span class="st">&quot;</span>);
    <span class="kw">else</span> <span class="kw">if</span>(opt[day][s] &gt; <span class="dv">0</span>) printf(<span class="st">&quot;BUY </span><span class="ch">%s\n</span><span class="st">&quot;</span>, name[opt[day][s]<span class="dv">-1</span>]);
    <span class="kw">else</span> printf(<span class="st">&quot;SELL </span><span class="ch">%s\n</span><span class="st">&quot;</span>, name[-opt[day][s]<span class="dv">-1</span>]);
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> kase = <span class="dv">0</span>;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%lf%d%d%d</span><span class="st">&quot;</span>, &amp;c, &amp;m, &amp;n, &amp;kk) == <span class="dv">4</span>) {
        <span class="kw">if</span>(kase++ &gt; <span class="dv">0</span>) printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);

        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%s%d%d</span><span class="st">&quot;</span>, name[i], &amp;s[i], &amp;k[i]);
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; m; j++) { scanf(<span class="st">&quot;</span><span class="ch">%lf</span><span class="st">&quot;</span>, &amp;price[i][j]); price[i][j] *= s[i]; }
        }
        init();

        <span class="dt">double</span> ans = dp();
        printf(<span class="st">&quot;</span><span class="ch">%.2lf\n</span><span class="st">&quot;</span>, ans);
        print_ans(m, <span class="dv">0</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#31454;&#36187;&#39064;&#30446;&#36873;&#35762; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>9-18 UVa10618 Tango Tango Insurrection uva10618.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10618 Tango Tango Insurrection</span>
<span class="co">// Rujia Liu</span>
<span class="co">// Tricky case: .RDLU</span>
<span class="co">// Answer: RLRLR (yes, you TURNED around!)</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;cassert&gt;</span>

<span class="dt">const</span> <span class="dt">int</span> UP = <span class="dv">0</span>;
<span class="dt">const</span> <span class="dt">int</span> LEFT = <span class="dv">1</span>;
<span class="dt">const</span> <span class="dt">int</span> RIGHT = <span class="dv">2</span>;
<span class="dt">const</span> <span class="dt">int</span> DOWN = <span class="dv">3</span>;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">70</span> + <span class="dv">5</span>;

<span class="co">// d[i][a][b][s] means the minimal future energy when you already tapped i notes</span>
<span class="co">// your left foot at a, right foot at b, last foot is s</span>
<span class="dt">int</span> d[maxn];

<span class="co">// if the optimal strategy is to move foot f(0~2) to position t, action=f*4+t</span>
<span class="dt">int</span> action[maxn];

<span class="dt">char</span> seq[maxn], pos, footch[] = <span class="st">&quot;.LR&quot;</span>;

<span class="co">// energy needed to move a foot FOR THE SECOND TIME, from a to ta</span>
<span class="dt">int</span> energy(<span class="dt">int</span> a, <span class="dt">int</span> ta) {
    <span class="kw">if</span>(a == ta) <span class="kw">return</span> <span class="dv">3</span>;
    <span class="kw">if</span>(a + ta == <span class="dv">3</span>) <span class="kw">return</span> <span class="dv">7</span>; <span class="co">// across</span>
    <span class="kw">return</span> <span class="dv">5</span>; <span class="co">// adjacent</span>
}

<span class="dt">int</span> energy(<span class="dt">int</span> i, <span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> s, <span class="dt">int</span> f, <span class="dt">int</span> t, <span class="dt">int</span>&amp; ta, <span class="dt">int</span>&amp; tb) {
    ta = a; tb = b;
    <span class="kw">if</span>(f == <span class="dv">1</span>) ta = t;
    <span class="kw">else</span> <span class="kw">if</span>(f == <span class="dv">2</span>) tb = t;

    <span class="co">// check target arrows</span>
    <span class="kw">if</span>(ta == tb) <span class="kw">return</span> <span class="dv">-1</span>;
    <span class="kw">if</span>(ta == RIGHT &amp;&amp; tb == LEFT) <span class="kw">return</span> <span class="dv">-1</span>;
    <span class="kw">if</span>(a == RIGHT &amp;&amp; tb != b) <span class="kw">return</span> <span class="dv">-1</span>; <span class="co">// you can&#39;t move you right foot before your left foot comes back</span>
    <span class="kw">if</span>(b == LEFT  &amp;&amp; ta != a) <span class="kw">return</span> <span class="dv">-1</span>;

    <span class="co">// compute energy</span>
    <span class="dt">int</span> e;
    <span class="kw">if</span>(f == <span class="dv">0</span>) e = <span class="dv">0</span>; <span class="co">// no move</span>
    <span class="kw">else</span> <span class="kw">if</span>(f != s) e = <span class="dv">1</span>; <span class="co">// alternative foot, low energy</span>
    <span class="kw">else</span> {
        <span class="kw">if</span>(f == <span class="dv">1</span>) e = energy(a, ta);
        <span class="kw">else</span> e = energy(b, tb);
    }
    <span class="kw">return</span> e;
}

<span class="co">// update state (i,a,b,s). foot f is moved to t</span>
<span class="dt">void</span> update(<span class="dt">int</span> i, <span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> s, <span class="dt">int</span> f, <span class="dt">int</span> t) {
    <span class="dt">int</span> ta, tb;
    <span class="dt">int</span> e = energy(i, a, b, s, f, t, ta, tb);
    <span class="kw">if</span>(e &lt; <span class="dv">0</span>) <span class="kw">return</span>; <span class="co">// invalid</span>

    <span class="dt">int</span> cost = d[i<span class="dv">+1</span>][ta][tb][f] + e;
    <span class="dt">int</span>&amp; ans = d[i][a][b][s];
    <span class="kw">if</span>(cost &lt; ans) {
        ans = cost;
        action[i][a][b][s] = f * <span class="dv">4</span> + t;
    }
}

<span class="dt">int</span> main() {
    pos[<span class="st">&#39;U&#39;</span>] = <span class="dv">0</span>; pos[<span class="st">&#39;L&#39;</span>] = <span class="dv">1</span>; pos[<span class="st">&#39;R&#39;</span>] = <span class="dv">2</span>; pos[<span class="st">&#39;D&#39;</span>] = <span class="dv">3</span>;

    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, seq) == <span class="dv">1</span>) {
        <span class="kw">if</span>(seq == <span class="st">&#39;#&#39;</span>) <span class="kw">break</span>;
        <span class="dt">int</span> n = strlen(seq);
        memset(d, <span class="dv">0</span>, <span class="kw">sizeof</span>(d));
        <span class="kw">for</span>(<span class="dt">int</span> i = n<span class="dv">-1</span>; i &gt;= <span class="dv">0</span>; i--)
            <span class="kw">for</span>(<span class="dt">int</span> a = <span class="dv">0</span>; a &lt; <span class="dv">4</span>; a++)
                <span class="kw">for</span>(<span class="dt">int</span> b = <span class="dv">0</span>; b &lt; <span class="dv">4</span>; b++) <span class="kw">if</span>(a != b)
                    <span class="kw">for</span>(<span class="dt">int</span> s = <span class="dv">0</span>; s &lt; <span class="dv">3</span>; s++) {
                        d[i][a][b][s] = <span class="dv">10</span>*n;
                        <span class="kw">if</span>(seq[i] == <span class="st">&#39;.&#39;</span>) {
                            update(i, a, b, s, <span class="dv">0</span>, <span class="dv">0</span>); <span class="co">// no move</span>
                            <span class="kw">for</span>(<span class="dt">int</span> t = <span class="dv">0</span>; t &lt; <span class="dv">4</span>; t++) {
                                update(i, a, b, s, <span class="dv">1</span>, t); <span class="co">// move left foot</span>
                                update(i, a, b, s, <span class="dv">2</span>, t); <span class="co">// move right foot</span>
                            }
                        } <span class="kw">else</span> {
                            update(i, a, b, s, <span class="dv">1</span>, pos[seq[i]]); <span class="co">// move left foot</span>
                            update(i, a, b, s, <span class="dv">2</span>, pos[seq[i]]); <span class="co">// move right foot</span>
                        }
                    }

        <span class="co">// print solution</span>
        <span class="dt">int</span> a = LEFT, b = RIGHT, s = <span class="dv">0</span>; <span class="co">// d is out answer</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            <span class="dt">int</span> f = action[i][a][b][s] / <span class="dv">4</span>;
            <span class="dt">int</span> t = action[i][a][b][s] % <span class="dv">4</span>;
            printf(<span class="st">&quot;</span><span class="ch">%c</span><span class="st">&quot;</span>, footch[f]);
            s = f;
            <span class="kw">if</span>(f == <span class="dv">1</span>) a = t;
            <span class="kw">else</span> <span class="kw">if</span>(f == <span class="dv">2</span>) b = t;
        }
        printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-19 UVa1627 Team them up! UVa1627.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1627 Team them up!</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span> + <span class="dv">5</span>;

<span class="dt">int</span> n, G[maxn][maxn], color[maxn], diff[maxn], cc;
vector&lt;<span class="dt">int</span>&gt; team[maxn]; <span class="co">// team[cc][c] is the list of people in connected-component cc, color c</span>

<span class="co">// returns false if not bipartite graph</span>
<span class="dt">bool</span> dfs(<span class="dt">int</span> u, <span class="dt">int</span> c) {
    color[u] = c;
    team[cc][c<span class="dv">-1</span>].push_back(u);
    <span class="kw">for</span>(<span class="dt">int</span> v = <span class="dv">0</span>; v &lt; n; v++) {
        <span class="kw">if</span>(u != v &amp;&amp; !(G[u][v] &amp;&amp; G[v][u])) { <span class="co">// u and v must be in different groups</span>
            <span class="kw">if</span>(color[v] &gt; <span class="dv">0</span> &amp;&amp; color[v] == color[u]) <span class="kw">return</span> <span class="kw">false</span>;
            <span class="kw">if</span>(!color[v] &amp;&amp; !dfs(v, <span class="dv">3</span>-c)) <span class="kw">return</span> <span class="kw">false</span>;
        }
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="dt">bool</span> build_graph() {
    memset(color, <span class="dv">0</span>, <span class="kw">sizeof</span>(color));
    cc = <span class="dv">0</span>; <span class="co">// current connected-component</span>
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
        <span class="kw">if</span>(!color[i]) {
            team[cc].clear();
            team[cc].clear();
            <span class="kw">if</span>(!dfs(i, <span class="dv">1</span>)) <span class="kw">return</span> <span class="kw">false</span>;
            diff[cc] = team[cc].size() - team[cc].size();
            cc++;
        }

    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="co">// d[i][j+n] = 1 iff we can arrange first i cc so that team 1 has j more people than team 2.</span>
<span class="dt">int</span> d[maxn][maxn*<span class="dv">2</span>], teamno[maxn];

<span class="dt">void</span> print(<span class="dt">int</span> ans) {
    vector&lt;<span class="dt">int</span>&gt; team1, team2;
    <span class="kw">for</span>(<span class="dt">int</span> i = cc<span class="dv">-1</span>; i &gt;= <span class="dv">0</span>; i--) {
        <span class="dt">int</span> t;
        <span class="kw">if</span>(d[i][ans-diff[i]+n]) { t = <span class="dv">0</span>; ans -= diff[i]; }
        <span class="kw">else</span> { t = <span class="dv">1</span>; ans += diff[i]; }
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; team[i][t].size(); j++)
            team1.push_back(team[i][t][j]);
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; team[i][<span class="dv">1</span>^t].size(); j++)
            team2.push_back(team[i][<span class="dv">1</span>^t][j]);
    }
    printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, team1.size());
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; team1.size(); i++) printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>, team1[i]<span class="dv">+1</span>);
    printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);

    printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, team2.size());
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; team2.size(); i++) printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>, team2[i]<span class="dv">+1</span>);
    printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
}

<span class="dt">void</span> dp() {
    memset(d, <span class="dv">0</span>, <span class="kw">sizeof</span>(d));
    d[<span class="dv">0</span>+n] = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; cc; i++)
        <span class="kw">for</span>(<span class="dt">int</span> j = -n; j &lt;= n; j++) <span class="kw">if</span>(d[i][j+n]) {
            d[i<span class="dv">+1</span>][j+diff[i]+n] = <span class="dv">1</span>;
            d[i<span class="dv">+1</span>][j-diff[i]+n] = <span class="dv">1</span>;
        }
    <span class="kw">for</span>(<span class="dt">int</span> ans = <span class="dv">0</span>; ans &lt;= n; ans++) {
        <span class="kw">if</span>(d[cc][ans+n]) { print(ans); <span class="kw">return</span>; }
        <span class="kw">if</span>(d[cc][-ans+n]) { print(-ans); <span class="kw">return</span>; }
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    cin &gt;&gt; T;
    <span class="kw">while</span>(T--) {
        cin &gt;&gt; n;
        memset(G, <span class="dv">0</span>, <span class="kw">sizeof</span>(G));
        <span class="kw">for</span>(<span class="dt">int</span> u = <span class="dv">0</span>; u &lt; n; u++) {
            <span class="dt">int</span> v;
            <span class="kw">while</span>(cin &gt;&gt; v &amp;&amp; v) G[u][v<span class="dv">-1</span>] = <span class="dv">1</span>;
        }

        <span class="kw">if</span>(n == <span class="dv">1</span> || !build_graph()) cout &lt;&lt; <span class="st">&quot;No solution</span><span class="ch">\n</span><span class="st">&quot;</span>;
        <span class="kw">else</span> dp();

        <span class="kw">if</span>(T) cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-20 UVa10934 Dropping water balloons UVa10934.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10934 Dropping water balloons</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxk = <span class="dv">100</span>;
<span class="dt">const</span> <span class="dt">int</span> maxa = <span class="dv">63</span>;

<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> d[maxk<span class="dv">+1</span>][maxa<span class="dv">+1</span>];

<span class="dt">int</span> main() {
    memset(d, <span class="dv">0</span>, <span class="kw">sizeof</span>(d));
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= maxk; i++)
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= maxa; j++)
            d[i][j] = d[i<span class="dv">-1</span>][j<span class="dv">-1</span>] + <span class="dv">1</span> + d[i][j<span class="dv">-1</span>];

    <span class="dt">int</span> k;
    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> n;
    <span class="kw">while</span>(cin &gt;&gt; k &gt;&gt; n &amp;&amp; k) {
        <span class="dt">int</span> ans = <span class="dv">-1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= maxa; i++)
            <span class="kw">if</span>(d[k][i] &gt;= n) { ans = i; <span class="kw">break</span>; }
        <span class="kw">if</span>(ans &lt; <span class="dv">0</span>) cout &lt;&lt; <span class="st">&quot;More than &quot;</span> &lt;&lt; maxa &lt;&lt; <span class="st">&quot; trials needed.</span><span class="ch">\n</span><span class="st">&quot;</span>;
        <span class="kw">else</span> cout &lt;&lt; ans &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-21 UVa1336 Fixing the Great Wall UVa1336.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1336 Fixing the Great Wall</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="ot">#include&lt;cassert&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1000</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">double</span> INF = <span class="fl">1e30</span>;

<span class="kw">struct</span> Section {
    <span class="dt">double</span> x, c, dt;
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Section&amp; rhs) <span class="dt">const</span> {
        <span class="kw">return</span> x &lt; rhs.x;
    }
} s[maxn];

<span class="dt">int</span> kase, n;
<span class="dt">int</span> vis[maxn][maxn];
<span class="dt">double</span> v, x, d[maxn][maxn];
<span class="dt">double</span> psdt[maxn]; <span class="co">// prefix sum of dt</span>

<span class="co">// cost accumulated when walking from x1 and x2.</span>
<span class="co">// section[i~j] are already finished</span>
<span class="dt">double</span> cost(<span class="dt">double</span> x1, <span class="dt">double</span> x2, <span class="dt">int</span> i, <span class="dt">int</span> j) {
    <span class="dt">double</span> finished_dt = <span class="dv">0</span>;
    assert(i &lt;= j);
    <span class="kw">if</span>(i &gt;= <span class="dv">0</span> &amp;&amp; j &gt;= <span class="dv">0</span>) finished_dt += psdt[j] - psdt[i<span class="dv">-1</span>];
    <span class="kw">return</span> (psdt[n] - finished_dt) * fabs(x2 - x1) / v;
}

<span class="dt">double</span> dp(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span> p) {
    <span class="kw">if</span>(i == <span class="dv">1</span> &amp;&amp; j == n) <span class="kw">return</span> <span class="dv">0</span>;
    <span class="dt">double</span>&amp; ans = d[i][j][p];
    <span class="kw">if</span>(vis[i][j][p] == kase) <span class="kw">return</span> ans;
    vis[i][j][p] = kase;

    ans = INF;
    <span class="dt">double</span> x = (p == <span class="dv">0</span> ? s[i].x : s[j].x);
    <span class="kw">if</span>(i &gt; <span class="dv">1</span>) ans = min(ans, dp(i<span class="dv">-1</span>, j, <span class="dv">0</span>) + cost(x, s[i<span class="dv">-1</span>].x, i, j));
    <span class="kw">if</span>(j &lt; n) ans = min(ans, dp(i, j<span class="dv">+1</span>, <span class="dv">1</span>) + cost(x, s[j<span class="dv">+1</span>].x, i, j));
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main() {
    memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%lf%lf</span><span class="st">&quot;</span>, &amp;n, &amp;v, &amp;x) == <span class="dv">3</span> &amp;&amp; n) {
        ++kase;
        <span class="dt">double</span> sumc = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%lf%lf%lf</span><span class="st">&quot;</span>, &amp;s[i].x, &amp;s[i].c, &amp;s[i].dt);
            sumc += s[i].c;
        }
        sort(s<span class="dv">+1</span>, s+n<span class="dv">+1</span>); <span class="co">// in increasing order of position</span>

        psdt = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++)
            psdt[i] = psdt[i<span class="dv">-1</span>] + s[i].dt;

        s.x = -INF;
        s[n<span class="dv">+1</span>].x = INF;
        <span class="dt">double</span> ans = INF;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n<span class="dv">+1</span>; i++)
            <span class="kw">if</span>(x &gt; s[i<span class="dv">-1</span>].x &amp;&amp; x &lt; s[i].x) {
                <span class="kw">if</span>(i &gt; <span class="dv">1</span>) ans = min(ans, dp(i<span class="dv">-1</span>, i<span class="dv">-1</span>, <span class="dv">0</span>) + cost(x, s[i<span class="dv">-1</span>].x, <span class="dv">-1</span>, <span class="dv">-1</span>)); <span class="co">// move left</span>
                <span class="kw">if</span>(i &lt;= n) ans = min(ans, dp(i, i, <span class="dv">0</span>) + cost(x, s[i].x, <span class="dv">-1</span>, <span class="dv">-1</span>)); <span class="co">// move right</span>
                <span class="kw">break</span>;
            }
        printf(<span class="st">&quot;</span><span class="ch">%.0lf\n</span><span class="st">&quot;</span>, floor(ans + sumc));
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-22 UVa12105 Bigger is Better UVa12105.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12105 Bigger is Better</span>
<span class="co">// Rujia Liu</span>
<span class="co">// This solution is simpler than the one described in the book</span>

<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> maxm = <span class="dv">3000</span> + <span class="dv">5</span>;

<span class="co">// dp[i][j] is the maximal length of the integer whose remainder is j (with at most i matches)</span>
<span class="co">// p[i][j] is the maximal digit for state (i,j)</span>
<span class="dt">int</span> n, m, dp[maxn][maxm], p[maxn][maxm];

<span class="dt">int</span> needs[] = { <span class="dv">6</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">6</span> };

<span class="dt">int</span> main(){
    <span class="dt">int</span> kase = <span class="dv">0</span>;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m) == <span class="dv">2</span>) {
        printf(<span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">: &quot;</span>, ++kase);

        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= n; i++)
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; m; j++){
                <span class="dt">int</span>&amp; ans = dp[i][j];
                ans = p[i][j] = <span class="dv">-1</span>;
                <span class="kw">if</span> (j == <span class="dv">0</span>) ans = <span class="dv">0</span>;
                <span class="kw">for</span>(<span class="dt">int</span> d = <span class="dv">9</span>; d &gt;= <span class="dv">0</span>; d--)
                    <span class="kw">if</span> (i &gt;= needs[d]){
                        <span class="dt">int</span> t = dp[i - needs[d]][(j * <span class="dv">10</span> + d) % m];
                        <span class="kw">if</span> (t &gt;= <span class="dv">0</span> &amp;&amp; t + <span class="dv">1</span> &gt; ans){
                            ans = t + <span class="dv">1</span>;
                            p[i][j] = d;
                        }
                    }
            }

        <span class="kw">if</span> (p[n] &lt; <span class="dv">0</span>) printf(<span class="st">&quot;-1&quot;</span>);
        <span class="kw">else</span> {
            <span class="dt">int</span> i = n, j = <span class="dv">0</span>;
            <span class="kw">for</span>(<span class="dt">int</span> d = p[i][j]; d &gt;= <span class="dv">0</span>; d = p[i][j]){
                printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, d);
                i -= needs[d];
                j = (j * <span class="dv">10</span> + d) % m;
            }
        }
        printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-23 UVa1204 Fun Game UVa1204.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1204 Fun Game</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;string&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#define REP(i,n) for(int i = 0; i &lt; (n); i++)</span>

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">16</span>;
<span class="dt">const</span> <span class="dt">int</span> maxlen = <span class="dv">100</span> + <span class="dv">5</span>;

<span class="co">// the overlap length of a (left) and b (right)</span>
<span class="dt">int</span> calc_overlap(<span class="dt">const</span> string&amp; a, <span class="dt">const</span> string&amp; b) {
    <span class="dt">int</span> n1 = a.length();
    <span class="dt">int</span> n2 = b.length();
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; n1; i++) { <span class="co">// place b at position i</span>
        <span class="kw">if</span>(n2 + i &lt;= n1) <span class="kw">continue</span>; <span class="co">// b cannot extend to the right of a</span>
        <span class="dt">bool</span> ok = <span class="kw">true</span>;
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; i + j &lt; n1; j++)
            <span class="kw">if</span>(a[i+j] != b[j]) { ok = <span class="kw">false</span>; <span class="kw">break</span>; }
        <span class="kw">if</span>(ok) <span class="kw">return</span> n1 - i;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="kw">struct</span> Item {
    string s, rev;
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Item&amp; rhs) <span class="dt">const</span> {
        <span class="kw">return</span> s.length() &lt; rhs.s.length();
    }
};

<span class="dt">int</span> n;
string s[maxn];
<span class="dt">int</span> len[maxn];
<span class="dt">int</span> overlap[maxn][maxn];

<span class="dt">void</span> init() {
    <span class="co">// read input</span>
    Item tmp[maxn];
    REP(i,n) {
        cin &gt;&gt; tmp[i].s;
        tmp[i].rev = tmp[i].s;
        reverse(tmp[i].rev.begin(), tmp[i].rev.end());
    }

    <span class="co">// remove strings that are occurred in another string</span>
    <span class="dt">int</span> n2 = <span class="dv">0</span>;
    sort(tmp, tmp+n);
    REP(i,n) {
        <span class="dt">bool</span> need = <span class="kw">true</span>;
        <span class="kw">for</span>(<span class="dt">int</span> j = i<span class="dv">+1</span>; j &lt; n; j++) {
            <span class="kw">if</span>(tmp[j].s.find(tmp[i].s) != string::npos ||
                    tmp[j].rev.find(tmp[i].s) != string::npos) { need = <span class="kw">false</span>; <span class="kw">break</span>; }
        }
        <span class="kw">if</span>(need) {
            s[n2] = tmp[i].s; s[n2] = tmp[i].rev;
            len[n2] = tmp[i].s.length();
            n2++;
        }
    }
    n = n2;

    <span class="co">// calculate overlaps</span>
    REP(i,n) REP(j,n) REP(x,<span class="dv">2</span>) REP(y,<span class="dv">2</span>)
        overlap[i][j][x][y] = calc_overlap(s[i][x] , s[j][y]);
}

<span class="co">// d[s][i][x] is the minimal total length if we used set s and the last string is s[i][x]</span>
<span class="dt">int</span> d[<span class="dv">1</span>&lt;&lt;maxn][maxn];

<span class="kw">inline</span> <span class="dt">void</span> update(<span class="dt">int</span>&amp; x, <span class="dt">int</span> v) {
    <span class="kw">if</span>(x &lt; <span class="dv">0</span> || v &lt; x) x = v;
}

<span class="dt">void</span> solve() {
    <span class="co">// dp</span>
    memset(d, <span class="dv">-1</span>, <span class="kw">sizeof</span>(d));
    d = len; <span class="co">// always use string s first</span>
    <span class="dt">int</span> full = (<span class="dv">1</span>&lt;&lt;n) - <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> s = <span class="dv">1</span>; s &lt; full; s++) {
        REP(i,n) REP(x,<span class="dv">2</span>) <span class="kw">if</span>(d[s][i][x] &gt;= <span class="dv">0</span>)
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt; n; j++) <span class="co">// place j</span>
                <span class="kw">if</span>(!(s &amp; (<span class="dv">1</span>&lt;&lt;j)))
                    REP(y,<span class="dv">2</span>) update(d[s|(<span class="dv">1</span>&lt;&lt;j)][j][y], d[s][i][x]+len[j]-overlap[i][j][x][y]);
    }

    <span class="co">// find answer</span>
    <span class="dt">int</span> ans = <span class="dv">-1</span>;
    REP(i,n) REP(x,<span class="dv">2</span>) {
        <span class="kw">if</span>(d[full][i][x] &lt; <span class="dv">0</span>) <span class="kw">continue</span>;
        update(ans, d[full][i][x]-overlap[i][x]);
    }
    <span class="kw">if</span>(ans &lt;= <span class="dv">1</span>) ans = <span class="dv">2</span>; <span class="co">// problem said: at least two children</span>

    cout &lt;&lt; ans &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
}

<span class="dt">int</span> main() {
    <span class="kw">while</span>(cin &gt;&gt; n &amp;&amp; n) {
        init();
        solve();
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-24 UVa12099 Bookcase UVa12099.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12099 The Bookcase</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">70</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> maxw = <span class="dv">30</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;

<span class="kw">struct</span> Book {
    <span class="dt">int</span> h, w;
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Book&amp; rhs) <span class="dt">const</span> {
        <span class="kw">return</span> h &gt; rhs.h || (h == rhs.h &amp;&amp; w &gt; rhs.w);
    }
} books[maxn];

<span class="co">// We sort books in decreasing order of heights and place them one by one</span>
<span class="co">// So level 1&#39;s height is book 1&#39;s height</span>
<span class="co">// dp[i][j][k] is the minimal total heights of level 2 and 3 when we used i books, level 2 and 3&#39;s total widths are j and k,</span>
<span class="co">// level 1&#39;s width is (sumw[n] - j - k)</span>
<span class="dt">int</span> dp[maxn*maxw][maxn*maxw];
<span class="dt">int</span> sumw[maxn]; <span class="co">// sum[i] is the sum of widths of first i books. sum = 0.</span>

<span class="co">// increased height if you place a book with height h to a level with width w</span>
<span class="co">// if w == 0, that means the level if empty, so height is increased by h</span>
<span class="co">// otherwise, the height is unchanged because we&#39;re adding books in decreasing order of height</span>
<span class="kw">inline</span> <span class="dt">int</span> f(<span class="dt">int</span> w, <span class="dt">int</span> h) {
    <span class="kw">return</span> w == <span class="dv">0</span> ? h : <span class="dv">0</span>;
}

<span class="kw">inline</span> <span class="dt">void</span> update(<span class="dt">int</span>&amp; newd, <span class="dt">int</span> d) {
    <span class="kw">if</span>(newd &lt; <span class="dv">0</span> || d &lt; newd) newd = d;
}

<span class="dt">int</span> main () {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        <span class="dt">int</span> n;
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
            scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;books[i].h, &amp;books[i].w);
        sort(books, books+n);

        sumw = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++)
            sumw[i] = sumw[i<span class="dv">-1</span>] + books[i<span class="dv">-1</span>].w;

        dp = <span class="dv">0</span>;
        <span class="dt">int</span> t = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            <span class="co">// Don&#39;t use memset. It&#39;s too slow</span>
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= sumw[i<span class="dv">+1</span>]; j++)
                <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt;= sumw[i<span class="dv">+1</span>]-j; k++) dp[t^<span class="dv">1</span>][j][k] = <span class="dv">-1</span>;

            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= sumw[i]; j++)
                <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt;= sumw[i]-j; k++) <span class="kw">if</span>(dp[t][j][k] &gt;= <span class="dv">0</span>) {
                    update(dp[t^<span class="dv">1</span>][j][k], dp[t][j][k]); <span class="co">// level 1</span>
                    update(dp[t^<span class="dv">1</span>][j+books[i].w][k], dp[t][j][k] + f(j,books[i].h)); <span class="co">// level 2</span>
                    update(dp[t^<span class="dv">1</span>][j][k+books[i].w], dp[t][j][k] + f(k,books[i].h)); <span class="co">// level 3</span>
                }
            t ^= <span class="dv">1</span>;
        }

        <span class="dt">int</span> ans = INF;
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= sumw[n]; j++) <span class="co">// each level has at least one book</span>
            <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">1</span>; k &lt;= sumw[n]-j; k++) <span class="kw">if</span>(dp[t][j][k] &gt;= <span class="dv">0</span>) {
                <span class="dt">int</span> w = max(max(j, k), sumw[n]-j-k);
                <span class="dt">int</span> h = books.h + dp[t][j][k];
                ans = min(ans, w * h);
            }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-25 UVa12170 Easy Climb uva12170.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12170 Easy Climb</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> maxx = maxn*maxn*<span class="dv">2</span>;
<span class="dt">const</span> LL  INF = (<span class="dv">1LL</span> &lt;&lt; <span class="dv">60</span>);

LL h[maxn], x[maxx], dp[maxx];

<span class="dt">int</span> main () {
    <span class="dt">int</span> T;
    cin &gt;&gt; T;
    <span class="kw">while</span>(T--) {
        <span class="dt">int</span> n;
        LL d;
        cin &gt;&gt; n &gt;&gt; d;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) cin &gt;&gt; h[i];
        <span class="kw">if</span>(abs(h - h[n<span class="dv">-1</span>]) &gt; (n<span class="dv">-1</span>)*d) {
            cout &lt;&lt; <span class="st">&quot;impossible</span><span class="ch">\n</span><span class="st">&quot;</span>;
            <span class="kw">continue</span>;
        }

        <span class="co">// useful heights</span>
        <span class="dt">int</span> nx = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
            <span class="kw">for</span>(<span class="dt">int</span> j = -n<span class="dv">+1</span>; j &lt;= n<span class="dv">-1</span>; j++)
                x[nx++] = h[i] + j*d;
        sort(x, x+nx);
        nx = unique(x, x+nx) - x;

        <span class="co">// dp</span>
        <span class="dt">int</span> t = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nx; i++) {
            dp[i] = INF;
            <span class="kw">if</span>(x[i] == h) dp[i] = <span class="dv">0</span>;
        }
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; n; i++) {
            <span class="dt">int</span> k = <span class="dv">0</span>;
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; nx; j++) {
                <span class="kw">while</span>(k &lt; nx &amp;&amp; x[k] &lt; x[j]-d) k++;
                <span class="kw">while</span>(k<span class="dv">+1</span> &lt; nx &amp;&amp; x[k<span class="dv">+1</span>] &lt;= x[j]+d &amp;&amp; dp[t][k<span class="dv">+1</span>] &lt;= dp[t][k]) k++; <span class="co">// min in sliding window</span>
                <span class="kw">if</span>(dp[t][k] == INF) dp[t^<span class="dv">1</span>][j] = INF; <span class="co">// (t, k) is not reachable</span>
                <span class="kw">else</span> dp[t^<span class="dv">1</span>][j] = dp[t][k] + abs(x[j] - h[i]);
            }
            t ^= <span class="dv">1</span>;
        }
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nx; i++)
            <span class="kw">if</span>(x[i] == h[n<span class="dv">-1</span>]) cout &lt;&lt; dp[t][i] &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-26 UVa1380 A Scheduling Problem uva1380.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1380 A Scheduling Problem</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;string&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;sstream&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">200</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;

<span class="kw">struct</span> Edge {
    <span class="dt">int</span> u, v, d; <span class="co">// d=1 means u-&gt;v, d=2 means v-&gt;u, d=0 means u-v</span>
    Edge(<span class="dt">int</span> u=<span class="dv">0</span>, <span class="dt">int</span> v=<span class="dv">0</span>, <span class="dt">int</span> d=<span class="dv">0</span>):u(u),v(v),d(d){}
};

vector&lt;Edge&gt; edges[maxn];
<span class="dt">int</span> n, root, maxlen, f[maxn], g[maxn], have_father[maxn];

<span class="co">// maximal length of a DIRECTED path starting from u</span>
<span class="dt">int</span> dfs(<span class="dt">int</span> u) {
    <span class="dt">int</span> ans = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; edges[u].size(); i++) {
        <span class="dt">int</span> v = edges[u][i].v;
        <span class="kw">if</span>(edges[u][i].d == <span class="dv">1</span>)
            ans = max(ans, dfs(v)<span class="dv">+1</span>);
    }
    <span class="kw">return</span> ans;
}

<span class="dt">bool</span> read_data() {
    <span class="dt">bool</span> have_data = <span class="kw">false</span>;
    <span class="dt">int</span> a, b;
    n = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; maxn; i++) edges[i].clear();
    memset(have_father, <span class="dv">0</span>, <span class="kw">sizeof</span>(have_father));

    <span class="kw">while</span>(cin &gt;&gt; a &amp;&amp; a){
        string str;
        have_data = <span class="kw">true</span>;
        <span class="kw">if</span>(a &gt; n) n = a;
        <span class="kw">while</span>(cin &gt;&gt; str &amp;&amp; str != <span class="st">&quot;0&quot;</span>){
            <span class="dt">int</span> len = str.length();
            <span class="dt">char</span> dir = str[len<span class="dv">-1</span>];
            <span class="kw">if</span>(dir == <span class="st">&#39;d&#39;</span> || dir == <span class="st">&#39;u&#39;</span>) str = str.substr(<span class="dv">0</span>, len<span class="dv">-1</span>);
            stringstream ss(str);
            ss &gt;&gt; b; <span class="co">// b is a&#39;s son</span>
            <span class="kw">if</span>(b &gt; n) n = b;
            have_father[b] = <span class="dv">1</span>;
            <span class="kw">if</span>(dir == <span class="st">&#39;d&#39;</span>){
                edges[a].push_back(Edge(a, b, <span class="dv">1</span>)); <span class="co">// forward</span>
                edges[b].push_back(Edge(b, a, <span class="dv">2</span>)); <span class="co">// backward</span>
            }<span class="kw">else</span> <span class="kw">if</span>(dir == <span class="st">&#39;u&#39;</span>){
                edges[a].push_back(Edge(a, b, <span class="dv">2</span>));
                edges[b].push_back(Edge(b, a, <span class="dv">1</span>));
            }<span class="kw">else</span>{
                edges[a].push_back(Edge(a, b, <span class="dv">0</span>)); <span class="co">// it&#39;s a rooted tree, so we don&#39;t store edge to father</span>
            }
        }
    }
    <span class="kw">if</span>(have_data) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++)
            <span class="kw">if</span>(!have_father[i] &amp;&amp; !edges[i].empty()) { root = i; <span class="kw">break</span>; }
    }
    <span class="kw">return</span> have_data;
}

<span class="kw">struct</span> UndirectedSon {
    <span class="dt">int</span> w, f, g;
    UndirectedSon(<span class="dt">int</span> w=<span class="dv">0</span>, <span class="dt">int</span> f=<span class="dv">0</span>, <span class="dt">int</span> g=<span class="dv">0</span>):w(w),f(f),g(g){}
};

<span class="dt">bool</span> cmp_f(<span class="dt">const</span> UndirectedSon&amp; w1, <span class="dt">const</span> UndirectedSon&amp; w2) {
    <span class="kw">return</span> w1.f &lt; w2.f;
}

<span class="dt">bool</span> cmp_g(<span class="dt">const</span> UndirectedSon&amp; w1, <span class="dt">const</span> UndirectedSon&amp; w2) {
    <span class="kw">return</span> w1.g &lt; w2.g;
}

<span class="co">// calculate f[i] and g[i]</span>
<span class="co">// return true iff f[i] &lt; INF</span>
<span class="co">// f[i] is the minimal length of the longest &quot;-&gt;u&quot; path if all subtree paths have length &lt;= maxlen</span>
<span class="co">// g[i] is the minimal length of the longest &quot;u-&gt;&quot; path if all subtree paths have length &lt;= maxlen</span>
<span class="co">// f[i] = g[i] = INF if &quot;all subtree paths have length &lt;= maxlen&quot; cannot be satisfied</span>
<span class="dt">bool</span> dp(<span class="dt">int</span> i, <span class="dt">int</span> fa) {
    <span class="kw">if</span>(edges[i].empty()) {
        f[i] = g[i] = <span class="dv">0</span>;
        <span class="kw">return</span> <span class="kw">true</span>;
    }
    vector&lt;UndirectedSon&gt; sons;
    <span class="dt">int</span> f0 = <span class="dv">0</span>, g0 = <span class="dv">0</span>; <span class="co">// f&#39;[i] and g&#39;[i] for directed sons</span>

    <span class="co">// let f&#39;[i] = max{f[w] | w-&gt;i}+1, g&#39;[i] = max{g[w] | i-&gt;w}+1</span>
    <span class="co">// then we should change some undirected edges to -&gt;u or u-&gt; edges so that f&#39;[i]+g&#39;[i] &lt;= maxlen</span>
    <span class="co">// then f[i] is the minimal f&#39;[i] under this condition, and g[i] is the minimal g&#39;[i]</span>
    <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; edges[i].size(); k++) {
        <span class="dt">int</span> w = edges[i][k].v;
        <span class="kw">if</span>(w == fa) <span class="kw">continue</span>;
        dp(w, i);
        <span class="dt">int</span> d = edges[i][k].d;
        <span class="kw">if</span>(d == <span class="dv">0</span>) sons.push_back(UndirectedSon(w, f[w], g[w]));
        <span class="kw">else</span> <span class="kw">if</span>(d == <span class="dv">1</span>) g0 = max(g0, g[w]<span class="dv">+1</span>);
        <span class="kw">else</span> f0 = max(f0, f[w]<span class="dv">+1</span>);
    }
    <span class="co">// If there is no undirected edges, we&#39;re done</span>
    <span class="kw">if</span>(sons.empty()) {
        f[i] = f0; g[i] = g0;
        <span class="kw">if</span>(f[i] + g[i] &gt; maxlen) { f[i] = g[i] = INF; }
        <span class="kw">return</span> f[i] &lt; INF;
    }

    f[i] = g[i] = INF;

    <span class="co">// to calculate f[i], we sort f[w] of undirected sons in increasing order and make first p edges to w-&gt;i</span>
    <span class="co">// then we calculate f&#39;[i] and g&#39;[i], check for f&#39;[i]+g&#39;[i] &lt;= maxlen and update answer</span>
    <span class="dt">int</span> s = sons.size();
    sort(sons.begin(), sons.end(), cmp_f);
    <span class="dt">int</span> maxg[maxn]; <span class="co">// maxg[i] is max{sons[i].g, sons[i+1].g, ...}</span>
maxg[s<span class="dv">-1</span>] = sons[s<span class="dv">-1</span>].g;
<span class="kw">for</span>(<span class="dt">int</span> k = s<span class="dv">-2</span>; k &gt;= <span class="dv">0</span>; k--)
    maxg[k] = max(sons[k].g, maxg[k<span class="dv">+1</span>]);
<span class="kw">for</span>(<span class="dt">int</span> p = <span class="dv">0</span>; p &lt;= sons.size(); p++) {
    <span class="dt">int</span> ff = f0, gg = g0;
    <span class="kw">if</span>(p &gt; <span class="dv">0</span>) ff = max(ff, sons[p<span class="dv">-1</span>].f<span class="dv">+1</span>);
    <span class="kw">if</span>(p &lt; sons.size()) gg = max(gg, maxg[p]<span class="dv">+1</span>);
    <span class="kw">if</span>(ff + gg &lt;= maxlen) f[i] = min(f[i], ff);
}

<span class="co">// g[i] is similar</span>
sort(sons.begin(), sons.end(), cmp_g);
<span class="dt">int</span> maxf[maxn]; <span class="co">// maxf[i] is max{sons[i].f, sons[i+1].f, ...}</span>
maxf[s<span class="dv">-1</span>] = sons[s<span class="dv">-1</span>].f;
<span class="kw">for</span>(<span class="dt">int</span> k = s<span class="dv">-2</span>; k &gt;= <span class="dv">0</span>; k--)
maxf[k] = max(sons[k].f, maxf[k<span class="dv">+1</span>]);
<span class="kw">for</span>(<span class="dt">int</span> p = <span class="dv">0</span>; p &lt;= sons.size(); p++) {
    <span class="dt">int</span> ff = f0, gg = g0;
    <span class="kw">if</span>(p &gt; <span class="dv">0</span>) gg = max(gg, sons[p<span class="dv">-1</span>].g<span class="dv">+1</span>);
    <span class="kw">if</span>(p &lt; sons.size()) ff = max(ff, maxf[p]<span class="dv">+1</span>);
    <span class="kw">if</span>(ff + gg &lt;= maxlen) g[i] = min(g[i], gg);
}

<span class="kw">return</span> f[i] &lt; INF;
}

<span class="dt">int</span> main() {
    <span class="kw">while</span>(read_data()) {
        maxlen = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) maxlen = max(maxlen, dfs(i));
        <span class="co">// Note: the problem asks for the number of nodes in path, but all the &quot;lengths&quot; above mean &quot;number of edges&quot;</span>
        <span class="kw">if</span>(dp(root, <span class="dv">-1</span>)) cout &lt;&lt; maxlen<span class="dv">+1</span> &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
        <span class="kw">else</span> cout &lt;&lt; maxlen<span class="dv">+2</span> &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-27 UVa10559 Blocks UVa10559.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10559 Blocks</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">200</span> + <span class="dv">5</span>;
<span class="dt">int</span> n, A[maxn], d[maxn][maxn][maxn];

<span class="co">// blocks i~j, plus k blocks whose color is the same as block j</span>
<span class="dt">int</span> dp(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span> k) {
    <span class="kw">if</span>(i &gt; j) <span class="kw">return</span> <span class="dv">0</span>;
    <span class="dt">int</span>&amp; ans = d[i][j][k];
    <span class="kw">if</span>(ans &gt;= <span class="dv">0</span>) <span class="kw">return</span> ans;
    <span class="dt">int</span> p = j;
    <span class="kw">while</span>(p &gt;= i &amp;&amp; A[p] == A[j]) p--;
    p++; <span class="co">// leftmost position that block j&#39;s color can &quot;extend&quot; to</span>
    ans = dp(i, p<span class="dv">-1</span>, <span class="dv">0</span>) + (j-p+k<span class="dv">+1</span>)*(j-p+k<span class="dv">+1</span>); <span class="co">// click block j</span>
    <span class="kw">for</span>(<span class="dt">int</span> q = i; q &lt; p; q++)
        <span class="kw">if</span>(A[q] == A[j] &amp;&amp; A[q] != A[q<span class="dv">+1</span>]) <span class="co">// remove q+1~p-1 first</span>
            ans = max(ans, dp(q<span class="dv">+1</span>, p<span class="dv">-1</span>, <span class="dv">0</span>) + dp(i, q, j-p+k<span class="dv">+1</span>));
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">for</span>(<span class="dt">int</span> kase = <span class="dv">1</span>; kase &lt;= T; kase++) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;A[i]);
        memset(d, <span class="dv">-1</span>, <span class="kw">sizeof</span>(d));
        printf(<span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">: </span><span class="ch">%d\n</span><span class="st">&quot;</span>, kase, dp(<span class="dv">0</span>, n<span class="dv">-1</span>, <span class="dv">0</span>));
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-28 UVa1439 Exclusive Access 2 UVa1439.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1439 Exclusive Access 2</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// This is different from problem statement</span>
<span class="co">// Here n is the number of resources, m is the number of processes (n in the problem statement)</span>
<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">15</span>;
<span class="dt">const</span> <span class="dt">int</span> maxm = <span class="dv">100</span> + <span class="dv">5</span>;
<span class="dt">int</span> n, m, u[maxm], v[maxm], G[maxn][maxn];
<span class="dt">int</span> ind[<span class="dv">1</span>&lt;&lt;maxn], d[<span class="dv">1</span>&lt;&lt;maxn], best[<span class="dv">1</span>&lt;&lt;maxn], label[maxn];

<span class="dt">bool</span> independent(<span class="dt">int</span> mask) {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; maxn; i++) <span class="kw">if</span>(mask &amp; (<span class="dv">1</span>&lt;&lt;i))
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; maxn; j++) <span class="kw">if</span>(mask &amp; (<span class="dv">1</span>&lt;&lt;j))
            <span class="kw">if</span>(i != j &amp;&amp; G[i][j]) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="co">// How many colors are needed to color the set &#39;mask&#39;</span>
<span class="dt">int</span> dp(<span class="dt">int</span> mask) {
    <span class="dt">int</span>&amp; ans = d[mask];
    <span class="kw">if</span>(ans &gt;= <span class="dv">0</span>) <span class="kw">return</span> ans;
    <span class="kw">if</span>(mask == <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">0</span>;
    ans = maxn<span class="dv">+1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> s = mask; s; s = (s<span class="dv">-1</span>)&amp;mask)
        <span class="kw">if</span>(ind[s]) {
            <span class="dt">int</span> v = dp(mask^s) + <span class="dv">1</span>;
            <span class="kw">if</span>(v &lt; ans) { ans = v; best[mask] = s; }
        }
    <span class="kw">return</span> ans;
}

<span class="co">// mark the set &#39;mask&#39; with color c</span>
<span class="dt">void</span> mark(<span class="dt">int</span> mask, <span class="dt">int</span> c) {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; maxn; i++)
        <span class="kw">if</span>(mask &amp; (<span class="dv">1</span>&lt;&lt;i)) label[i] = c;
}

<span class="dt">int</span> main() {
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;m) == <span class="dv">1</span>) {
        memset(G, <span class="dv">0</span>, <span class="kw">sizeof</span>(G));
        <span class="dt">int</span> useful = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++) {
            <span class="dt">char</span> r1, r2;
            scanf(<span class="st">&quot;</span><span class="ch">%s%s</span><span class="st">&quot;</span>, r1, r2);
            u[i] = r1-<span class="st">&#39;L&#39;</span>, v[i] = r2-<span class="st">&#39;L&#39;</span>;
            G[u[i]][v[i]] = <span class="dv">1</span>;
            useful |= (<span class="dv">1</span>&lt;&lt;u[i]);
            useful |= (<span class="dv">1</span>&lt;&lt;v[i]);
        }

        <span class="co">// find the independent sets</span>
        memset(ind, <span class="dv">0</span>, <span class="kw">sizeof</span>(ind));
        <span class="kw">for</span>(<span class="dt">int</span> s = useful; s; s = (s<span class="dv">-1</span>)&amp;useful)
            <span class="kw">if</span>(independent(s)) ind[s] = <span class="kw">true</span>;

        <span class="co">// dp</span>
        memset(d, <span class="dv">-1</span>, <span class="kw">sizeof</span>(d));
        <span class="dt">int</span> ans = dp(useful);
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans<span class="dv">-2</span>);

        <span class="co">// construct the answer</span>
        <span class="dt">int</span> s = useful, k = <span class="dv">0</span>;
        <span class="kw">while</span>(s) {
            mark(s, k++);
            s ^= best[s];
        }
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++) {
            <span class="kw">if</span>(label[u[i]] &lt; label[v[i]]) swap(u[i], v[i]);
            printf(<span class="st">&quot;</span><span class="ch">%c</span><span class="st"> </span><span class="ch">%c\n</span><span class="st">&quot;</span>, <span class="st">&#39;L&#39;</span>+u[i], <span class="st">&#39;L&#39;</span>+v[i]);
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-29 UVa1228 Integer Transmission UVa1228.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1228 Integer Transmission</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">64</span>;

<span class="dt">int</span> n, d, K[maxn];
<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> f[maxn<span class="dv">+1</span>][maxn<span class="dv">+1</span>];

<span class="dt">int</span> zcnt = <span class="dv">0</span>, ocnt = <span class="dv">0</span>;
<span class="dt">int</span> Z[maxn], O[maxn]; <span class="co">// z[i] is the i-th zero from left (0-based)</span>

<span class="co">// now we received i zeros and j ones. Can we receive another zero at the next time?</span>
<span class="dt">bool</span> can_receive_zero(<span class="dt">int</span> i, <span class="dt">int</span> j) {
    <span class="kw">return</span> i<span class="dv">+1</span> &lt;= zcnt &amp;&amp; (j == ocnt || O[j]+d &gt;= Z[i]);
}

<span class="dt">bool</span> can_receive_one(<span class="dt">int</span> i, <span class="dt">int</span> j) {
    <span class="kw">return</span> j<span class="dv">+1</span> &lt;= ocnt &amp;&amp; (i == zcnt || Z[i]+d &gt;= O[j]);
}

<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> minv, maxv;

<span class="dt">void</span> greedy() {
    minv = maxv = <span class="dv">0</span>;
    <span class="dt">int</span> i = <span class="dv">0</span>, j = <span class="dv">0</span>;
    <span class="kw">while</span>(i &lt; zcnt || j &lt; ocnt) {
        <span class="kw">if</span>(can_receive_zero(i, j)) { i++; minv = minv * <span class="dv">2</span>; }
        <span class="kw">else</span> { j++; minv = minv * <span class="dv">2</span> + <span class="dv">1</span>; }
    }
    i = j = <span class="dv">0</span>;
    <span class="kw">while</span>(i &lt; zcnt || j &lt; ocnt) {
        <span class="kw">if</span>(can_receive_one(i, j)) { j++; maxv = maxv * <span class="dv">2</span> + <span class="dv">1</span>; }
        <span class="kw">else</span> { i++; maxv = maxv * <span class="dv">2</span>; }
    }
}

<span class="dt">void</span> solve() {
    <span class="co">// compute Z and O</span>
    ocnt = zcnt = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
        <span class="kw">if</span>(K[i] == <span class="dv">1</span>) O[ocnt++] = i;
        <span class="kw">else</span> Z[zcnt++] = i;

    <span class="co">// greedy to get minv, maxv</span>
    greedy();

    <span class="co">// dp</span>
    memset(f, <span class="dv">0</span>, <span class="kw">sizeof</span>(f));
    f = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= zcnt; i++)
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= ocnt; j++) {
            <span class="kw">if</span>(can_receive_zero(i, j)) f[i<span class="dv">+1</span>][j] += f[i][j];
            <span class="kw">if</span>(can_receive_one(i, j)) f[i][j<span class="dv">+1</span>] += f[i][j];
        }
    cout &lt;&lt; f[zcnt][ocnt] &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; minv &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; maxv &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> kase = <span class="dv">0</span>;
    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> k;
    <span class="kw">while</span>(cin &gt;&gt; n &gt;&gt; d &gt;&gt; k) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            K[n-i<span class="dv">-1</span>] = k % <span class="dv">2</span>; k /= <span class="dv">2</span>;
        }
        cout &lt;&lt; <span class="st">&quot;Case &quot;</span> &lt;&lt; ++kase &lt;&lt; <span class="st">&quot;: &quot;</span>;
        solve();
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-30 UVa1375 The Best Name for Your Baby uva1375.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1375 The Best Name for Your Baby</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;string&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;queue&gt;</span>
<span class="ot">#include&lt;map&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">50</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> maxlen = <span class="dv">20</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> maxs = <span class="dv">50</span>*<span class="dv">20</span> + <span class="dv">52</span> + <span class="dv">5</span>; <span class="co">// for a rule with right length x, we have x-1 symbols with length&gt;1</span>

<span class="dt">int</span> n, L, ns;
string rule[maxn];
string sym[maxs]; <span class="co">// symbols</span>
<span class="dt">int</span> car[maxs], cdr[maxs]; <span class="co">// lisp names for &quot;head&quot; and &quot;tail&quot; 8-)</span>
string dp[maxs][maxlen];

<span class="dt">bool</span> is_all_terminal(<span class="dt">const</span> string&amp; s) {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; s.length(); i++)
        <span class="kw">if</span>(!(s[i] &gt;= <span class="st">&#39;a&#39;</span> &amp;&amp; s[i] &lt;= <span class="st">&#39;z&#39;</span>)) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">return</span> <span class="kw">true</span>;
}

string min(<span class="dt">const</span> string&amp; a, <span class="dt">const</span> string&amp; b) {
    <span class="kw">if</span>(a == <span class="st">&quot;-&quot;</span>) <span class="kw">return</span> b;
    <span class="kw">return</span> a &lt; b ? a : b;
}

<span class="kw">struct</span> Node {
    <span class="dt">int</span> x;
    string s;
    Node(<span class="dt">int</span> x, string s):x(x),s(s){}
    <span class="co">// smaller string has higher priority, thus will be extracted earlier</span>
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Node&amp; rhs) <span class="dt">const</span> {
        <span class="kw">return</span> s &gt; rhs.s;
    }
};

<span class="kw">struct</span> Transform {
    <span class="dt">int</span> target, empty;
    Transform(<span class="dt">int</span> t, <span class="dt">int</span> e):target(t),empty(e){}
};

vector&lt;Transform&gt; <span class="fu">tr</span>[maxs];

<span class="dt">bool</span> vis[maxs];
<span class="co">// fill in other dp[?][len] reachable from existing dp[?][len] nodes via &quot;epsilon edges&quot;</span>
<span class="dt">void</span> search(<span class="dt">int</span> len) {
    memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
    priority_queue&lt;Node&gt; q;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; ns; i++)
        <span class="kw">if</span>(dp[i][len] != <span class="st">&quot;-&quot;</span>) {
            q.push(Node(i, dp[i][len]));
        }

    <span class="kw">while</span>(!q.empty()) {
        Node u = q.top(); q.pop();
        <span class="dt">int</span> x = u.x;
        string s = u.s;
        <span class="kw">if</span>(vis[x]) <span class="kw">continue</span>;
        vis[x] = <span class="kw">true</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="fu">tr</span>[x].size(); i++) {
            <span class="dt">int</span> target = <span class="fu">tr</span>[x][i].target;
            <span class="dt">int</span> empty = <span class="fu">tr</span>[x][i].empty;
            <span class="kw">if</span>(dp[empty] == <span class="st">&quot;&quot;</span> &amp;&amp; (dp[target][len] == <span class="st">&quot;-&quot;</span> || s &lt; dp[target][len])) {
                dp[target][len] = s;
                q.push(Node(target, s));
            }
        }
    }
}

map&lt;string,<span class="dt">int</span>&gt; sym2id;

<span class="dt">int</span> ID(<span class="dt">const</span> string&amp; s) {
    <span class="kw">if</span>(!sym2id.count(s)) {
        sym[ns] = s;
        sym2id[s] = ns++;
    }
    <span class="kw">return</span> sym2id[s];
}

<span class="co">// S=HT, if H can be empty, S and T can be transformed to each other</span>
<span class="co">// we say h can reach s via epsilon edge t, and t can reach s via epsilon edge h</span>
<span class="dt">void</span> add_intermediate_symbol(<span class="dt">const</span> string&amp; S) {
    <span class="dt">int</span> s = ID(S);
    <span class="kw">if</span>(S.length() &lt; <span class="dv">2</span>) <span class="kw">return</span>;
    <span class="dt">int</span> h = ID(S.substr(<span class="dv">0</span>,<span class="dv">1</span>));
    <span class="dt">int</span> t = ID(S.substr(<span class="dv">1</span>,S.length()<span class="dv">-1</span>));
    <span class="fu">tr</span>[h].push_back(Transform(s, t));
    <span class="fu">tr</span>[t].push_back(Transform(s, h));
    car[s] = h;
    cdr[s] = t;
}

<span class="dt">int</span> main() {
    <span class="kw">while</span>(cin &gt;&gt; n &gt;&gt; L &amp;&amp; n) {
        sym2id.clear();
        ns = <span class="dv">0</span>;

        ID(<span class="st">&quot;&quot;</span>); <span class="co">// make sure sym = &quot;&quot;</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; maxs; i++) <span class="fu">tr</span>[i].clear();

        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            cin &gt;&gt; rule[i]; <span class="co">// for example, rule[i]=&quot;S=AbC&quot;</span>
            <span class="dt">int</span> left = ID(rule[i].substr(<span class="dv">0</span>,<span class="dv">1</span>));
            <span class="dt">int</span> right = ID(rule[i].substr(<span class="dv">2</span>));
            <span class="fu">tr</span>[right].push_back(Transform(left, ID(<span class="st">&quot;&quot;</span>)));  <span class="co">// AbC can be transformed to S</span>
            <span class="dt">int</span> len = rule[i].length();
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">2</span>; j &lt; len; j++) <span class="co">// AbC, bC, C</span>
                add_intermediate_symbol(rule[i].substr(j));
        }

        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; ns; i++)
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= L; j++)
                dp[i][j] = <span class="st">&quot;-&quot;</span>; <span class="co">// impossible</span>
        dp = <span class="st">&quot;&quot;</span>; <span class="co">// dp[i][j] means the first string with len j that symbol i can be transformed into</span>

        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= L; j++) {
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; ns; i++) {
                <span class="kw">if</span>(sym[i].length() == j &amp;&amp; is_all_terminal(sym[i])) dp[i][j] = sym[i];
                <span class="kw">if</span>(sym[i].length() &lt; <span class="dv">2</span>) <span class="kw">continue</span>;
                <span class="dt">int</span> s1 = car[i], s2 = cdr[i];
                <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">1</span>; k &lt; j; k++) {
                    <span class="kw">if</span>(dp[s1][k] != <span class="st">&quot;-&quot;</span> &amp;&amp; dp[s2][j-k] != <span class="st">&quot;-&quot;</span>)
                        dp[i][j] = min(dp[i][j], dp[s1][k] + dp[s2][j-k]);
                }
            }
            search(j);
        }
        cout &lt;&lt; dp[ID(<span class="st">&quot;S&quot;</span>)][L] &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>9-31 UVa1628 Pizza Delivery UVa1628.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1628 Pizza Delivery</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span> + <span class="dv">5</span>;

<span class="dt">int</span> kase, n;
<span class="dt">int</span> p[maxn], v[maxn];
<span class="dt">int</span> d[maxn][maxn][maxn];
<span class="dt">int</span> vis[maxn][maxn][maxn];

<span class="co">// already considered s~e, still need to delivery to cnt people.</span>
<span class="co">// pos = 0 means at s, pos = 1 means at e</span>
<span class="dt">int</span> dp(<span class="dt">int</span> s, <span class="dt">int</span> e, <span class="dt">int</span> cnt, <span class="dt">int</span> pos) {
    <span class="kw">if</span>(cnt == <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">0</span>;

    <span class="dt">int</span> &amp;ans = d[s][e][cnt][pos];
    <span class="kw">if</span>(vis[s][e][cnt][pos] == kase) <span class="kw">return</span> ans;
    vis[s][e][cnt][pos] = kase;

    ans = <span class="dv">0</span>;
    <span class="kw">if</span>(!pos) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; s; i++)
            ans = max(ans, v[i] - cnt * abs(p[i] - p[s]) + dp(i, e, cnt - <span class="dv">1</span>, <span class="dv">0</span>));
        <span class="kw">for</span>(<span class="dt">int</span> i = e + <span class="dv">1</span>; i &lt; n; i++)
            ans = max(ans, v[i] - cnt * abs(p[i] - p[s]) + dp(s, i, cnt - <span class="dv">1</span>, <span class="dv">1</span>));
    }
    <span class="kw">else</span> {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; s; i++)
            ans = max(ans, v[i] - cnt * abs(p[i] - p[e]) + dp(i, e, cnt - <span class="dv">1</span>, <span class="dv">0</span>));
        <span class="kw">for</span>(<span class="dt">int</span> i = e + <span class="dv">1</span>; i &lt; n; i++)
            ans = max(ans, v[i] - cnt * abs(p[i] - p[e]) + dp(s, i, cnt - <span class="dv">1</span>, <span class="dv">1</span>));
    }
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;T);
    memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
    <span class="kw">for</span>(kase = <span class="dv">1</span>; kase &lt;= T; kase++) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;p[i]);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;v[i]);

        <span class="dt">int</span> ans = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">1</span>; k &lt;= n; k++)
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
                ans = max(ans, v[i] - k * abs(p[i]) + dp(i, i, k - <span class="dv">1</span>, <span class="dv">0</span>));
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>,ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/08/20 &#19978;&#21320; 9:30:00 6. &#38142;&#34920; Linked List <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#20171;&#32461; Dummy Node &#22312;&#38142;&#34920;&#38382;&#39064;&#20013;&#30340;&#36816;&#29992; Introduce Dummy Node in Linked List <code class="fold">@</code></dt>
<dd><p>Dummy node -&gt; sentinel node. <code>['s&#603;nt&#618;nl]</code>&#65292;&#21736;&#20853;&#12290;</p>
<dl>
<dt>Linked list <code class="fold">@</code></dt>
<dd><p>Advantages</p>
<ul>
<li>Linked lists are a <strong>dynamic data structure</strong>, which can grow and be pruned, allocating and deallocating memory while the program is running.</li>
<li><strong>Insertion and deletion</strong> node operations are easily implemented in a linked list.</li>
<li>Linear data structures such as stacks and queues are easily executed with a linked list.</li>
<li>They can reduce access time and may expand in real time <strong>without memory overhead</strong>.</li>
</ul>
<p>Disadvantages</p>
<ul>
<li>They use <strong>more memory than arrays</strong> because of the storage used by their pointers.</li>
<li>Nodes in a linked list must be read in order from the beginning as linked lists are <strong>inherently sequential access</strong>.</li>
<li>Nodes are <strong>stored incontiguously</strong>&#65288;&#19981;&#36830;&#32493;&#22320;&#65289;, greatly increasing the time required to access individual elements within the list, especially with a CPU cache.</li>
<li>Difficulties arise in linked lists when it comes to <strong>reverse traversing</strong>. For instance, singly linked lists are cumbersome to navigate backwards and while <strong>doubly linked lists are somewhat easier to read, memory is wasted in allocating space for a back-pointer</strong>.</li>
</ul>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/408px-Singly-linked-list.svg.png" alt="A singly linked list whose nodes contain two fields: an integer value and a link to the next node" />
<p class="caption">A singly linked list whose nodes contain two fields: an integer value and a link to the next node</p>
</div>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Doubly-linked-list.svg/610px-Doubly-linked-list.svg.png" alt="A doubly linked list whose nodes contain three fields: an integer value, the link forward to the next node, and the link backward to the previous node" />
<p class="caption">A doubly linked list whose nodes contain three fields: an integer value, the link forward to the next node, and the link backward to the previous node</p>
</div>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/Circularly-linked-list.svg/350px-Circularly-linked-list.svg.png" alt="A circular linked list" />
<p class="caption">A circular linked list</p>
</div>
</dd>
<dt>Sentinel nodes <code class="fold">@</code></dt>
<dd><p>In computer programming, a sentinel node is <strong>a specifically designated &#65288;&#25351;&#23450;&#65289;node</strong> used with linked lists and trees as a <strong>traversal path terminator</strong>. This type of node does not hold or reference any data managed by the data structure.</p>
<p>traversal, <code>[tr&#601;&#712;v&#601;rs(&#601;)l]</code></p>
<p>Sentinels are used as an alternative over using null as the path terminator in order to get one or more of the following benefits:</p>
<ul>
<li>Increased speed of operations</li>
<li>Reduced algorithmic complexity and code size</li>
<li>Increased data structure robustness (arguably)</li>
</ul>
<p>a singly linked list:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> sll_node {                           <span class="co">// one node of the singly linked list</span>
   <span class="dt">int</span> key;
   <span class="kw">struct</span> sll_node *next;                   <span class="co">// end-of-list indicator or -&gt; next node</span>
} sll, *first;</code></pre></div>
<p>First version using NULL as an end-of-list indicator</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// global initialization</span>
first = NULL;                               <span class="co">// before the first insertion (not shown)</span>

<span class="kw">struct</span> sll_node *Search(<span class="kw">struct</span> Node *first, <span class="dt">int</span> search_key) {
    <span class="kw">for</span> ( <span class="kw">struct</span> sll_node *node = first; node != NULL; node = node-&gt;next ) {
        <span class="kw">if</span> (node-&gt;key == search_key) { <span class="kw">return</span> node; }                   <span class="co">// found</span>
    }
    <span class="kw">return</span> NULL;                                                        <span class="co">// not found</span>
}</code></pre></div>
<p>Second version using a sentinel node:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// global variable</span>
sll_node Sentinel, *sentinel = &amp;Sentinel;
<span class="co">// global initialization</span>
sentinel-&gt;next = sentinel;
first = sentinel;                           <span class="co">// before the first insertion (not shown)</span>

<span class="kw">struct</span> sll_node *SearchWithSentinelnode(<span class="kw">struct</span> Node *first, <span class="dt">int</span> search_key) {
    <span class="kw">struct</span> sll_node *node;
    sentinel-&gt;key = search_key;
    <span class="kw">for</span> (node = first; node-&gt;key != search_key; node = node-&gt;next) {
    }
    <span class="kw">if</span> (node != sentinel)
        <span class="kw">return</span> node;                        <span class="co">// found</span>
    <span class="co">// not found</span>
    <span class="kw">return</span> NULL;
}</code></pre></div>
</dd>
</dl>
</dd>
</dl></li>
<li><p>sequential -&gt; array</p></li>
<li><p>linked -&gt; single linked, double linked, xunhuan danlianbao, xuanhuan double linked list</p></li>
<li><p>sequential+linked -&gt; static list</p></li>
<li><dl>
<dt>&#20320;&#24517;&#39035;&#30693;&#36947;&#30340;&#20960;&#28857; Linked List &#30340;&#24120;&#29992;&#25216;&#24039; Basic skills in Linked List you should know :TODO: <code class="fold">@</code></dt>
<dd><p>TODO</p>
</dd>
</dl></li>
<li><dl>
<dt>&#20004;&#26681;&#25351;&#38024;&#31639;&#27861; Two pointers <code class="fold">@</code></dt>
<dd><dl>
<dt>Splitting Linked List</dt>
<dd><p>Given a list, split it into two sublists &#8212; one for the front half, and one for the back half. If the number of elements is odd, the extra element should go in the front list. So FrontBackSplit() on the list <code>{2, 3, 5, 7, 11}</code> should yield the two lists <code>{2, 3, 5}</code> and <code>{7, 11}</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> FrontBackSplit( Node *head, Node **front, Node **back ) {
    <span class="kw">if</span> (!head) <span class="kw">return</span>;  <span class="co">// Handle empty list</span>
    Node *front_last_node, *slow, *fast;
    slow = fast = head;
    <span class="kw">while</span>( fast ) {
        front_last_node = slow;
        slow = slow-&gt;next;
        fast = (fast-&gt;next) ? fast-&gt;next-&gt;next : NULL;
    }
    front_last_node-&gt;next = NULL;               <span class="co">// ends the front sublist</span>
    *front = head;
    *back  = slow;
}</code></pre></div>
<pre><code>-----------------------------------------------
    2   3   5   7   11  #               s: slow
    ^                                   f: fast
   s,f
-----------------------------------------------
    2   3   5   7   11  #
        ^   ^
        s   f
-----------------------------------------------
    2   3   5   7   11  #
            ^       ^
            s       f
-----------------------------------------------
    2   3   5   7   11  #
                ^       ^
                s       f=0
-----------------------------------------------
    2-&gt; 3-&gt; 5-&gt; #

                7-&gt; 11  #
-----------------------------------------------
1   2   3   4
f       f       f
s   s   s

1   2   3   4   5
f       f       f   f
s   s   s   s</code></pre>
</dd>
<dt>Linked List Cycle <code class="fold">@</code></dt>
<dd><p>if there is a cycle in the list, then we can use two pointers travers the list. one pointer traverse one step each time, another one traverse two steps each time. so, those two pointers meet together, that means there must be a cycle inside the list.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> hasLoop(Node *head) {
    Node *slow = head, *fast = head;
    <span class="kw">while</span> (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
        <span class="kw">if</span> (slow == fast)
            <span class="kw">return</span> <span class="kw">true</span>;
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}</code></pre></div>
<p>This elegant algorithm is known as Floyd&#8217;s cycle finding algorithm, also called the Tortoise and hare algorithm.</p>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/linked-list-cycle/">Linked List Cycle | LeetCode OJ</a></li>
<li><a href="http://articles.leetcode.com/detecting-loop-in-singly-linked-list/">Detecting a Loop in a Singly Linked List &#8211; LeetCode</a></li>
</ul>
</dd>
<dt>Linked List Cycle II <code class="fold">@</code></dt>
<dd><p>So, the idea is:</p>
<ul>
<li><ol style="list-style-type: decimal">
<li>Using the cycle-chcking algorithm.</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>Once p1 and p1 meet, then reset p1 to head, and move p1 &amp; p2 synchronously until p1 and p2 meet again, that place is the cycle&#8217;s start-point</li>
</ol></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {

<span class="kw">private</span>:
    ListNode *p1, *p2;
<span class="kw">public</span>:
    <span class="dt">bool</span> hasCycle(ListNode *head) {
        <span class="kw">if</span> ( !head ) { <span class="kw">return</span> <span class="kw">false</span>; }
        p1 = p2 = head;
        <span class="kw">while</span> ( p1 &amp;&amp; p2 ){
            p1 = p1-&gt;next;
            <span class="kw">if</span> ( !p2-&gt;next ) <span class="kw">return</span> <span class="kw">false</span>;
            p2=p2-&gt;next-&gt;next;
            <span class="kw">if</span> (p1==p2) <span class="kw">return</span> <span class="kw">true</span>;
        }
        <span class="kw">return</span> <span class="kw">false</span>;
    }
    ListNode *detectCycle(ListNode *head) {
        <span class="kw">if</span> ( !hasCycle(head) ){ <span class="kw">return</span> NULL; }

        p1 = head;
        <span class="kw">while</span> (p1!=p2) {
            p1 = p1-&gt;next;
            p2 = p2-&gt;next;
        }
        <span class="kw">return</span> p1;
    }
};</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/linked-list-cycle-ii/">Linked List Cycle II | LeetCode OJ</a></li>
</ul>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>&#24120;&#35265;&#38382;&#39064;&#35762;&#35299; Frequent Questions :TODO: <code class="fold">@</code></dt>
<dd><p>TODO</p>
</dd>
</dl></li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Linked_list#Sentinel_nodes">Linked list - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sentinel_value">Sentinel value - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sentinel_node">Sentinel node - Wikipedia, the free encyclopedia</a></li>
<li><a href="http://articles.leetcode.com/splitting-linked-list/">Splitting Linked List &#8211; LeetCode</a></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/08/21 &#19978;&#21320; 9:30:00 7. &#25968;&#32452;&#19982;&#25968; Array &amp; Numbers <code class="fold">@</code></dt>
<dd><ul>
<li><p>&#26059;&#36716;&#25490;&#24207;&#25968;&#32452;&#30456;&#20851;&#38382;&#39064;&#19982;&#19977;&#27493;&#32763;&#36716;&#27861;&#30340;&#36816;&#29992; Rotated Sorted Array &amp; 3-step Reversion</p>
<p>just this picture:</p>
<div class="figure">
<img src="http://whudoc.qiniudn.com/2016/20141025161730953.png" />

</div></li>
<li><dl>
<dt>&#20004;&#20010;&#25490;&#24207;&#25968;&#32452;&#30340;&#20013;&#20301;&#25968; Median of Two Sorted Array <code class="fold">@</code></dt>
<dd><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be <code>O(log (m+n))</code>.</p>
<p>Example 1:</p>
<pre><code>nums1 = [1, 3]
nums2 =</code></pre>
<p>The median is 2.0</p>
<p>Example 2:</p>
<pre><code>nums1 = [1, 2]
nums2 = [3, 4]</code></pre>
<p>The median is (2 + 3)/2 = 2.5</p>
<pre><code>class Solution {
public:
    double findMedianSortedArrays(const vector&lt;int&gt;&amp; A, const vector&lt;int&gt;&amp; B) {
        const int m = A.size();
        const int n = B.size();
        int total = m + n;
        if (total &amp; 0x1)
            return find_kth(A.begin(), m, B.begin(), n, total / 2 + 1);
        else
            return (find_kth(A.begin(), m, B.begin(), n, total / 2)
                    + find_kth(A.begin(), m, B.begin(), n, total / 2 + 1)) / 2.0;
    }

private:
    static int find_kth(std::vector&lt;int&gt;::const_iterator A, int m,
            std::vector&lt;int&gt;::const_iterator B, int n, int k) {
        //always assume that m is equal or smaller than n
        if (m &gt; n) return find_kth(B, n, A, m, k);  // 0 &lt;= m &lt;= n
        if (m == 0) return *(B + k - 1);
        if (k == 1) return min(*A, *B);

        //divide k into two parts
        int ia = min(k / 2, m), ib = k - ia;
        if (*(A + ia - 1) &lt; *(B + ib - 1))
            return find_kth(A + ia, m - ia, B, n, k - ia);
        else if (*(A + ia - 1) &gt; *(B + ib - 1))
            return find_kth(A, m, B + ib, n - ib, k - ib);
        else
            return A[ia - 1];
    }
};</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">double</span> findMedianSortedArrays(vector&lt;<span class="dt">int</span>&gt; &amp;a, vector&lt;<span class="dt">int</span>&gt; &amp;b) {
        <span class="dt">int</span> m = a.size(), n = b.size(), i = <span class="dv">0</span>, j = <span class="dv">0</span>, k = m+n<span class="dv">-1</span> &gt;&gt; <span class="dv">1</span>;
        <span class="kw">while</span> (k &gt; <span class="dv">0</span>) {
            <span class="dt">int</span> p = k<span class="dv">-1</span> &gt;&gt; <span class="dv">1</span>;
            <span class="kw">if</span> (j+p &gt;= n || i+p &lt; m &amp;&amp; a[i+p] &lt; b[j+p])
                i += p<span class="dv">+1</span>;
            <span class="kw">else</span>
                j += p<span class="dv">+1</span>;
            k -= p<span class="dv">+1</span>;
        }
        <span class="dt">int</span> s = j &gt;= n || i &lt; m &amp;&amp; a[i] &lt; b[j] ? a[i++] : b[j++];
        <span class="kw">return</span> m+n &amp; <span class="dv">1</span> ? s : (j &gt;= n || i &lt; m &amp;&amp; a[i] &lt; b[j] ? s+a[i] : s+b[j]) * <span class="fl">0.5</span>;
    }
};</code></pre></div>
<p>TODO, leetcode tijie.</p>
<p>refs and see also</p>
<ul>
<li><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">Median of Two Sorted Arrays | LeetCode OJ</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#37325;&#22797;&#20803;&#32032; <code class="fold">@</code></dt>
<dd><dl>
<dt><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">Remove Duplicates from Sorted Array | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>&#19981;&#20801;&#35768;&#37325;&#22797;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> removeDuplicates(vector&lt;<span class="dt">int</span>&gt;&amp; nums) {
        <span class="dt">int</span> j = <span class="dv">0</span>;
        <span class="kw">for</span> (<span class="kw">auto</span> x: nums)
        <span class="kw">if</span> (!j || nums[j<span class="dv">-1</span>] != x)           <span class="co">// !j --&gt; j == 0</span>
            nums[j++] = x;
        <span class="kw">return</span> j;
    }
};</code></pre></div>
<p>STL:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> removeDuplicates( vector&lt;<span class="dt">int</span>&gt;&amp; nums ) {
        <span class="kw">return</span> distance( nums.begin(), unique(nums.begin(), nums.end()) );
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/">Remove Duplicates from Sorted Array II | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>&#20801;&#35768;&#26368;&#22810;&#20004;&#27425;&#37325;&#22797;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> removeDuplicates(vector&lt;<span class="dt">int</span>&gt; &amp;a) {
        <span class="dt">int</span> j = <span class="dv">0</span>;
        <span class="kw">for</span> (<span class="kw">auto</span> x: a)
            <span class="kw">if</span> (j &lt; <span class="dv">2</span> || a[j<span class="dv">-1</span>] != x || a[j<span class="dv">-2</span>] != x)
                a[j++] = x;
        <span class="kw">return</span> j;
    }
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> removeDuplicates(vector&lt;<span class="dt">int</span>&gt;&amp; nums) {
        <span class="kw">if</span> (nums.size() &lt;= <span class="dv">2</span>) { <span class="kw">return</span> nums.size(); }
        <span class="dt">int</span> index = <span class="dv">2</span>;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i &lt; nums.size(); i++){
            <span class="kw">if</span> (nums[i] != nums[index - <span class="dv">2</span>])
                nums[index++] = nums[i];
        }

        <span class="kw">return</span> index;
    }
};</code></pre></div>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>&#23376;&#25968;&#32452;&#30456;&#20851;&#38382;&#39064; SubArray <code class="fold">@</code></dt>
<dd><dl>
<dt>Maximum subarray <code class="fold">@</code></dt>
<dd><p>DP.</p>
<ul>
<li><code>f[j] = max( f[j-1]+S[j], S[j] ), j = 2..n, f = S</code></li>
<li><code>target = max{ f[j] }, j = 1..n</code></li>
</ul>
<p>&#20195;&#30721;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Time: O(n), Space: O(1)</span>
<span class="dt">int</span> maxSubArray( vector&lt;<span class="dt">int</span>&gt; &amp;nums ) {
    <span class="dt">int</span> result = INT_MIN, f = <span class="dv">0</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nums.size(); ++i ) {
        f = max( f+nums[i], nums[i] );
        result = max( f, result );
    }
    <span class="kw">return</span> result;
}</code></pre></div>
<p>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem">Maximum subarray problem - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://leetcode.com/problems/maximum-subarray/">Maximum Subarray | LeetCode OJ</a></li>
</ul>
</dd>
<dt>Subset sum problem <code class="fold">@</code></dt>
<dd><p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Subset_sum_problem">Subset sum problem - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>&#20004;&#26681;&#25351;&#38024;&#19982; x-sum &#38382;&#39064; Two Pointers &amp; x-sum :TODO: <code class="fold">@</code></dt>
<dd><p>TODO</p>
</dd>
</dl></li>
<li><p>&#20998;&#21106;&#25968;&#32452;&#30456;&#20851;&#38382;&#39064; Partition Array</p></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/08/27 &#19978;&#21320; 9:30:00 8. &#25968;&#25454;&#32467;&#26500; Data Structure <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#32447;&#24615;&#25968;&#25454;&#32467;&#26500; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#38431;&#21015;&#30340;&#21407;&#29702;&#12289;&#23454;&#29616;&#21644;&#36816;&#29992;, Queue <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>yangzi triangle <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="dt">void</span> yanghui_triangle(<span class="dt">const</span> <span class="dt">int</span> n);
<span class="dt">int</span> main() { yanghui_triangle( <span class="dv">5</span> ); }

<span class="dt">void</span> yanghui_triangle(<span class="dt">const</span> <span class="dt">int</span> n) {
    <span class="dt">int</span> i = <span class="dv">1</span>;
    queue&lt;<span class="dt">int</span>&gt; q;
    q.push(i);                                  <span class="co">// &#39044;&#20808;&#25918;&#20837;&#31532;&#19968;&#34892;&#30340; 1</span>

    <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt;= n; i++) {                   <span class="co">// &#36880;&#34892;&#22788;&#29702;</span>
        <span class="dt">int</span> j;
        <span class="dt">int</span> s = <span class="dv">0</span>;
        q.push(s);                              <span class="co">// &#22312;&#21508;&#34892;&#38388;&#25554;&#20837;&#19968;&#20010;0</span>

        <span class="kw">for</span>(j = <span class="dv">0</span>; j &lt; i<span class="dv">+2</span>; j++) {              <span class="co">// &#22788;&#29702;&#31532; i &#34892;&#30340; i+2 &#20010;&#31995;&#25968;&#65288;&#21253;&#25324;&#19968;&#20010; 0&#65289;</span>
            <span class="dt">int</span> t = q.front(); q.pop();
            q.push( t+s );
            s = t;                              <span class="co">// &#25171;&#21360;&#19968;&#20010;&#31995;&#25968;&#65292;&#31532; i+2 &#20010;&#26159; 0</span>
            <span class="kw">if</span>(j != i<span class="dv">+1</span>) {
                printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>,t);
            }
        }
        printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
}</code></pre></div>
<p>TODO</p>
<pre><code>                                        |   queue
----------------------------------------+---------------------------
i = 0, j = [0, i+2), push 2 times       |   1
push 0                                  |   1   0
withdraw t=1                            |
push( t=1 + s=0 )                       |   0   1
s=t=1                                   |
withdraw t=0                            |
push( t=0 + s=1 )                       |
                                        |   1   1
----------------------------------------+---------------------------
i = 1, j = [0, i+2), push 3 times       |   1   1
push 0                                  |   1   1   0
withdraw t=1, push(t=1+s=0)             |   1   0   1
s=t=1                                   |
withdraw t=1, push(t=1+s=1)             |   0   1   2
s=t=1                                   |
withdraw t=0, push(t=0+s=1)             |   1   2   1
----------------------------------------+---------------------------
i = 2, j = [0, i+2), push 4 times       |   1   2   1
push 0                                  |   1   2   1   0
t=1, push(t=1+s=0), s=1                 |   2   1   0   1
t=2, push(t=2+s=1), s=2                 |   1   0   1   3
t=1, push(t=1+s=2), s=1                 |   0   1   3   3
t=0, push(t=0+s=1), s=0                 |   1   3   3   1
----------------------------------------+---------------------------
i = 3, j = [0, i+2), push 5 times       |   1   3   3   1
push 0                                  |   1   3   3   1   0
t=1, push(t=1+s=0), s=1                 |   3   3   1   0   1
t=3, push(t=3+s=1), s=3                 |   3   1   0   1   4
t=3, push(t=3+s=3), s=3                 |   1   0   1   4   6
t=1, push(t=1+s=3), s=1                 |   0   1   4   6   4
t=0, push(t=0+s=1), s=0                 |   1   4   6   4   1
----------------------------------------+---------------------------
i = 4, j = [0, i+2), push 6 times       |   1   4   6   4   1
push 0                                  |   1   4   6   4   1   0
t=1, push(t=1+s=0), s=1                 |   4   6   4   1   0   1
t=4, push(t=4+s=1), s=4                 |   6   4   1   0   1   5
t=6, push(t=6+s=4), s=6                 |   4   1   0   1   5   10
t=4, push(t=4+s=6), s=4                 |   1   0   1   5   10  10
t=1, push(t=1+s=4), s=1                 |   0   1   5   10  10  5
t=0, push(t=0+s=1), s=0                 |   1   5   10  10  5   1
...

1                   i=0                 (a+b)^0 = 1
1 1                 i=1                 (a+b)^1 = a + b
1 2 1               i=2                 (a+b)^2 = a^2 + 2ab + b^2
1 3 3 1             i=3                 (a+b)^3 = a^3 + 3a^2b + 3ab^2 + b^3
1 4 6 4 1           i=4                 ...
1 5 10 10 5 1       i=6                 ...</code></pre>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#26632;&#30340;&#21407;&#29702;&#12289;&#23454;&#29616;&#21644;&#36816;&#29992;, Stack :TODO: <code class="fold">@</code></dt>
<dd><p>TODO</p>
</dd>
</dl></li>
<li><dl>
<dt>&#21704;&#24076;&#34920;&#30340;&#21407;&#29702;&#12289;&#23454;&#29616;&#21644;&#36816;&#29992;, HashMap <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>hash table <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt><a href="https://en.wikipedia.org/wiki/Open_addressing" class="featured">Open addressing - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p><strong>Open addressing</strong>, or <strong>closed hashing</strong>, is a method of <strong>collision resolution</strong> in hash tables. With this method a hash collision is resolved by probing, or searching through alternate locations in the array (the probe sequence) until either the target record is found, or an unused array slot is found, which indicates that there is no such key in the table. Well known probe sequences include:</p>
<pre><code>record pair { key, value }
var pair array slot[0..num_slots-1]

function find_slot(key)
    i := hash(key) modulo num_slots
    // search until we either find the key, or find an empty slot.
    while (slot[i] is occupied) and ( slot[i].key &#8800; key )
        i = (i + 1) modulo num_slots
    return i</code></pre>
<ul>
<li><dl>
<dt>Linear probing</dt>
<dd>in which the interval between probes is fixed&#8201;&#8212;&#8201;often at 1.
</dd>
</dl></li>
<li><dl>
<dt>Quadratic probing</dt>
<dd>in which the interval between probes increases linearly (hence, the indices are described by a quadratic function).
</dd>
</dl></li>
<li><dl>
<dt>Double hashing</dt>
<dd>in which the interval between probes is fixed for each record but is computed by another hash function.
</dd>
</dl></li>
</ul>
<p><strong>Open Addressing &#24605;&#24819;&#38750;&#24120;&#31616;&#21333;&#12290;&#22914;&#26524;&#31532;&#19968;&#27425; Hash &#23547;&#25214;&#21040;&#24471;&#20301;&#32622;&#22833;&#36133;&#65292;&#37027;&#23601;&#19981;&#26029;&#36827;&#34892;&#20301;&#31227;&#65292;&#30452;&#21040;&#25214;&#21040;&#28385;&#36275;&#26465;&#20214;&#30340;&#20301;&#32622;&#12290;</strong></p>
<dl>
<dt>Linear probing</dt>
<dd><ul>
<li>&#20248;&#28857;&#65306;&#24605;&#36335;&#31616;&#21333;&#65292;&#32780;&#19988;&#21482;&#35201; Hash &#34920;&#19981;&#28385;&#65292;&#24635;&#33021;&#25214;&#21040;&#28385;&#36275;&#26465;&#20214;&#30340;&#20301;&#32622;&#12290;</li>
<li>&#32570;&#28857;&#65306;&#23481;&#26131;&#20135;&#29983;<strong>&#20027;&#32858;&#21512;&#25928;&#24212;&#65288;primary clustering&#65289;</strong>&#12290;&#31616;&#21333;&#26469;&#35828;&#65292;&#23601;&#26159;&#25554;&#20837;&#30340;&#28857;&#23481;&#26131;&#32858;&#38598;&#21040;&#19968;&#22359;&#22320;&#26041;&#65292;&#20174;&#32780;&#20351;&#24471;&#31532;&#19968;&#27425; Hash &#21040;&#36825;&#22359;&#33539;&#22260;&#30340;&#25968;&#37117;&#24517;&#39035;&#39034;&#24207;&#25628;&#32034;&#36825;&#22359;&#33539;&#22260;&#12290;&#26681;&#25454;&#22797;&#26434;&#30340;&#35745;&#31639;&#65292;&#25105;&#20204;&#21487;&#20197;&#24471;&#21040;&#65292;&#24403; load factor&#65288;&#27492;&#27010;&#24565;&#22312;&#19978;&#19968;&#31456;&#20171;&#32461;&#65289;&#20026; 0.5 &#26102;&#65292;&#24179;&#22343;&#27599;&#27425;&#25554;&#20837;&#65288;&#31561;&#21516;&#20110;&#38750;&#25104;&#21151;&#23547;&#25214;&#65289;&#38656;&#35201;&#20301;&#31227; 2.5 &#27425;&#65292;&#24179;&#22343;&#27599;&#27425;&#25104;&#21151;&#23547;&#25214;&#38656;&#35201;&#20301;&#31227; 1.5 &#27425;&#12290;&#23558; load factor &#20445;&#35777;&#22312; 0.5 &#20197;&#19979;&#65292;&#37027;&#20040;&#26102;&#38388;&#26159;&#27604;&#36739;&#29702;&#24819;&#30340;&#12290;</li>
</ul>
</dd>
<dt>Linear probing</dt>
<dd><ul>
<li>&#39038;&#21517;&#24605;&#20041;&#65292;&#23601;&#26159; Function(i) = i^2&#12290;&#31616;&#21333;&#22320;&#35745;&#31639;&#21487;&#20197;&#24471;&#21040;&#65306;h(i+1)(x) = hi(x) + 2i -1. &#21478;&#22806;&#65292;&#21482;&#26377;&#24403; load factor &#23567;&#20110; 0.5 &#19988; Hash &#34920;&#22823;&#23567;&#20026;&#36136;&#25968;&#26102;&#65292;&#25165;&#33021;&#20445;&#35777;&#27599;&#27425;&#25554;&#20837;&#37117;&#25104;&#21151;&#65288;&#21487;&#20197;&#35777;&#26126;&#65292;&#36825;&#37324;&#30053;&#65289;&#12290;</li>
<li>&#20248;&#28857;&#65306;&#19981;&#20250;&#20135;&#29983;&#20027;&#32858;&#21512;&#25928;&#24212;&#12290;</li>
<li>&#32570;&#28857;&#65306;&#34429;&#28982; Quadratic &#26041;&#27861;&#19981;&#20250;&#20135;&#29983;&#20027;&#32858;&#21512;&#25928;&#24212;&#12290;&#20294;&#20250;&#20135;&#29983;<strong>&#27425;&#32858;&#21512;&#25928;&#24212;&#65288;secondary clustering&#65289;</strong>&#12290;&#21363;&#65292;&#31532;&#19968;&#27425; Hash &#21040;&#21516;&#19968;&#20010;&#20301;&#32622;&#30340;&#28857;&#65292;&#20182;&#20204;&#20043;&#21518;&#30340;&#25628;&#32034;&#36807;&#31243;&#37117;&#23436;&#20840;&#19968;&#26679;&#65292;&#38656;&#35201;&#37325;&#22797;&#12290;</li>
</ul>
</dd>
<dt>&#24310;&#36831;&#21024;&#38500;&#65288;lazy deletion&#65289;</dt>
<dd><p>&#22914;&#26524;&#25105;&#20204;&#38656;&#35201;&#21024;&#38500;&#19968;&#20010;&#20540;&#65292;&#19981;&#33021;&#31616;&#21333;&#30340;&#25226;&#37027;&#20010;&#20301;&#32622;&#30340;&#20540;&#21435;&#25481;&#12290;&#31616;&#21333;&#24605;&#32034;&#20415;&#21487;&#26126;&#30333;&#65292;&#22240;&#20026;&#36825;&#20010;&#28857;&#21518;&#38754;&#30340;&#20540;&#21487;&#33021;&#26159;&#36890;&#36807;&#20301;&#31227;&#36807;&#21435;&#30340;&#65292;&#22914;&#26524;&#36825;&#28857;&#34987;&#25366;&#31354;&#65292;&#37027;&#20040;&#25105;&#20204;&#24819;&#23547;&#25214;&#21518;&#38754;&#30340;&#20540;&#23601;&#21464;&#24471;&#19981;&#21487;&#33021;&#20102;&#12290;</p>
<p>&#22240;&#27492;&#65292;&#25105;&#20204;&#20351;&#29992;&#19968;&#20010;&#24310;&#36831;&#21024;&#38500;&#30340;&#25216;&#26415;&#12290;&#24605;&#24819;&#24456;&#31616;&#21333;&#65292;&#25105;&#20204;&#32473;&#27599;&#20010;&#28857;&#36171;&#20104;&#19968;&#20010;&#29366;&#24577;&#65292;&#20998;&#21035;&#26159;&#34987;&#21344;&#29992;&#65288;legitimate, <code>[l&#601;&#712;d&#658;&#618;t&#601;m&#618;t]</code>, &#21512;&#27861;&#30340;&#65307;&#27491;&#24403;&#30340;&#65289;&#65292;&#31354;&#65288;empty&#65289;&#65292;&#34987;&#21024;&#38500;&#65288;deleted&#65289;&#12290;&#21021;&#22987;&#26102;&#25152;&#26377;&#28857;&#37117;&#20026;&#31354;&#65292;&#24403;&#34987;&#25554;&#20837;&#19968;&#20010;&#20540;&#26102;&#23558;&#29366;&#24577;&#35774;&#20026;&#34987;&#21344;&#29992;&#65292;&#20294;&#34987;&#21024;&#38500;&#26102;&#29366;&#24577;&#35774;&#20026;&#34987;&#21024;&#38500;&#12290;&#36825;&#26679;&#30340;&#35805;&#65292;&#22914;&#26524;&#25105;&#20204;&#35201;&#23547;&#25214;&#19968;&#20010;&#28857;&#65292;&#21482;&#35201;&#25628;&#32034;&#36335;&#24452;&#19978;&#30340;&#28857;&#38750;&#31354;&#65292;&#19988;&#20854;&#20540;&#19982;&#25105;&#20204;&#24819;&#35201;&#25628;&#32034;&#30340;&#20540;&#19981;&#21516;&#65292;&#37027;&#20040;&#23601;&#19981;&#26029;&#25628;&#32034;&#19979;&#21435;&#65292;&#30452;&#21040;&#25214;&#21040;&#31354;&#28857;&#25110;&#32773;&#30456;&#21516;&#20540;&#24471;&#28857;&#12290;&#65288;&#22914;&#26524;&#35273;&#24471;&#25303;&#21475;&#65292;&#35831;&#30475;&#19979;&#38754;&#30340;&#20195;&#30721;&#65289;&#12290;</p>
</dd>
</dl>
<p>&#20551;&#35373;&#25972;&#20491; hash table &#30340;&#25976;&#25818;&#19981;&#22312; cache&#12290;&#22240;&#28858;&#26159;&#38283;&#25918;&#23563;&#22336;&#65292;&#27599;&#27425; collision &#35201;&#20877;&#36339;&#21040;&#21478;&#19968;&#20491; slot&#65288;&#21363; probing&#65289;&#65292;hash table &#36234;&#28415;&#23601;&#26371;&#26377;&#36234;&#22810;&#27425;&#36339;&#36681;&#65292;&#29986;&#29983;&#36611;&#22810; cache miss&#12290;</p>
<p>&#33509;&#25972;&#20491; hash table &#37117;&#33021;&#20786;&#23384;&#22312; cache&#65292;&#24590;&#27171;&#20570;&#37117;&#19981;&#26371;&#20986;&#29694; cache miss&#12290;</p>
<p>&#20294;&#32771;&#24942; hash table &#36960;&#22823;&#26044; cache &#22823;&#23567;&#26178;&#65292;&#21487;&#20197;&#29702;&#35299;&#28858;&#27599;&#27425;&#19981;&#21516;&#30340; hashing &#37117;&#26371; cache miss&#65292;collision &#21644; cache miss &#30340;&#27010;&#29575;&#25104;&#27491;&#27604;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://blog.csdn.net/jiangfan2014/article/details/46042747">&#12298;&#25968;&#25454;&#32467;&#26500;&#12299;&#23398;&#20064;&#8211; Hash(3) &#8211;Open Addressing - &#27743;&#39277; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
<li><a href="https://www.zhihu.com/question/22911718">&#20351;&#29992; open addressing &#30340; Hash &#34920;&#36733;&#33655;&#36807;&#39640;&#20026;&#20160;&#20040;&#20250;&#38477;&#20302; CPU &#30340;&#32531;&#23384;&#21629;&#20013;&#29575;&#65311; - &#30693;&#20046;</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>hash table <code class="fold">@</code></dt>
<dd><p>&#21704;&#24076;&#34920;&#22788;&#29702;&#20914;&#31361;&#26377;&#20004;&#31181;&#26041;&#24335;&#65292;&#24320;&#22320;&#22336;&#27861; (Open Addressing) &#21644;&#38381;&#22320;&#22336;&#27861; (Closed Addressing)&#12290;</p>
<p>&#38381;&#22320;&#22336;&#27861;&#20063;&#21363;&#25289;&#38142;&#27861; (Chaining)&#65292;&#27599;&#20010;&#21704;&#24076;&#22320;&#22336;&#37324;&#19981;&#20877;&#26159;&#19968;&#20010;&#20803;&#32032;&#65292;&#32780;&#26159;&#38142;&#34920;&#30340;&#39318;&#22320;&#22336;&#12290;</p>
<p>&#24320;&#22320;&#22336;&#27861;&#26377;&#24456;&#22810;&#26041;&#26696;&#65292;&#26377;&#32447;&#24615;&#25506;&#27979;&#27861; (Linear Probing)&#12289;&#20108;&#27425;&#25506;&#27979;&#27861; (Quadratic Probing) &#21644;&#21452;&#25955;&#21015;&#27861; (Double Hashing) &#31561;&#12290;</p>
<p>&#19979;&#38754;&#26159;&#25289;&#38142;&#27861;&#30340; C &#35821;&#35328;&#23454;&#29616;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> elem_t&gt;
<span class="dt">int</span> elem_hash(<span class="dt">const</span> elem_t &amp;e);

<span class="kw">template</span>&lt;<span class="kw">typename</span> elem_t&gt;
<span class="dt">bool</span> <span class="kw">operator</span>==(<span class="dt">const</span> elem_t &amp;e1, <span class="dt">const</span> elem_t &amp;e2);

<span class="kw">template</span>&lt;<span class="kw">typename</span> elem_t&gt;
<span class="kw">class</span> hash_set {
<span class="kw">public</span>:
    hash_set(<span class="dt">int</span> prime, <span class="dt">int</span> capacity);
    ~hash_set();
    <span class="dt">bool</span> find(<span class="dt">const</span> elem_t &amp;elem);                  <span class="co">// &#26597;&#25214;&#26576;&#20010;&#20803;&#32032;&#26159;&#21542;&#23384;&#22312;.</span>
    <span class="dt">bool</span> insert(<span class="dt">const</span> elem_t &amp;elem);                <span class="co">// &#28155;&#21152;&#19968;&#20010;&#20803;&#32032;&#65292;&#22914;&#26524;&#24050;&#23384;&#22312;&#21017;&#28155;&#21152;&#22833;&#36133;.</span>
<span class="kw">private</span>:
    <span class="dt">int</span> prime;                                      <span class="co">// &#21704;&#24076;&#34920;&#21462;&#27169;&#30340;&#36136;&#25968;&#65292;&#20063;&#21363;&#21704;&#24076;&#26742;&#30340;&#20010;&#25968;&#65292;&#23567;&#20110; capacity</span>
    <span class="dt">int</span> capacity;                                   <span class="co">// &#21704;&#24076;&#34920;&#23481;&#37327;&#65292;&#19968;&#23450;&#35201;&#22823;&#20110;&#20803;&#32032;&#26368;&#22823;&#20010;&#25968;</span>

    <span class="dt">int</span> *head;                                      <span class="co">// head[PRIME], &#39318;&#33410;&#28857;&#19979;&#26631;</span>

    <span class="kw">struct</span> node_t {
        elem_t elem;
        <span class="dt">int</span> next;
        node_t():next(<span class="dv">-1</span>) {}
    } *node;                                        <span class="co">// node[HASH_SET_CAPACITY], &#38745;&#24577;&#38142;&#34920;</span>

    <span class="dt">int</span> size;
};

<span class="kw">template</span>&lt;<span class="kw">typename</span> elem_t&gt;
hash_set&lt;elem_t&gt;::hash_set( <span class="dt">int</span> prime, <span class="dt">int</span> capacity ) {
    <span class="kw">this</span>-&gt;prime = prime;
    <span class="kw">this</span>-&gt;capacity = capacity;
    head = <span class="kw">new</span> <span class="dt">int</span>[prime];
    node = <span class="kw">new</span> node_t[capacity];
    fill( head, head + prime, <span class="dv">-1</span> );
    fill( node, node + capacity, node_t() );
    size = <span class="dv">0</span>;
}

<span class="kw">template</span>&lt;<span class="kw">typename</span> elem_t&gt;
hash_set&lt;elem_t&gt;::~hash_set() {
    <span class="kw">this</span>-&gt;prime = <span class="dv">0</span>;
    <span class="kw">this</span>-&gt;capacity = <span class="dv">0</span>;
    <span class="kw">delete</span>[] head;
    <span class="kw">delete</span>[] node;
    head = NULL;
    node = NULL;
    size = <span class="dv">0</span>;
}

<span class="kw">template</span>&lt;<span class="kw">typename</span> elem_t&gt;
<span class="dt">bool</span> hash_set&lt;elem_t&gt;::find(<span class="dt">const</span> elem_t &amp;elem) {
    <span class="kw">for</span>( <span class="dt">int</span> i = head[elem_hash(elem)]; i != <span class="dv">-1</span>; i = node[i].next ) {
        <span class="kw">if</span>( elem == node[i].elem ) { <span class="kw">return</span> <span class="kw">true</span>; }
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="kw">template</span>&lt;<span class="kw">typename</span> elem_t&gt;
<span class="dt">bool</span> hash_set&lt;elem_t&gt;::insert(<span class="dt">const</span> elem_t &amp;elem) {
    <span class="dt">const</span> <span class="dt">int</span> hash_code = elem_hash(elem);
    <span class="kw">if</span>( find(elem) ) { <span class="kw">return</span> <span class="kw">false</span>; }
    node[size].next = head[hash_code]; <span class="co">// &#19981;&#23384;&#22312;&#65292;&#21017;&#25554;&#20837;&#22312;&#39318;&#33410;&#28857;&#20043;&#21069;</span>
    node[size].elem = elem;
    head[hash_code] = size++;
    <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>babelfish (easy, use <code>dict.find</code>) <code class="fold">@</code></dt>
<dd><p>input:</p>
<pre><code>dog ogday
cat atcay
pig igpay
froot ootfray
loops oopslay

atcay
ittenkay
oopslay</code></pre>
<p>output:</p>
<pre><code>cat
eh
loops</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* POJ 2503 Babelfish , http://poj.org/problem?id=2503 */</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;map&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">/** </span>&#23383;&#31526;&#20018;&#26368;&#22823;&#38271;&#24230; */
<span class="dt">const</span> <span class="dt">int</span> MAX_WORD_LEN = <span class="dv">10</span>;

<span class="dt">int</span> main() {
    <span class="dt">char</span> line[MAX_WORD_LEN * <span class="dv">2</span> + <span class="dv">1</span>];
    <span class="dt">char</span> s1[MAX_WORD_LEN + <span class="dv">1</span>], s2[MAX_WORD_LEN + <span class="dv">1</span>];
    map&lt;string, string&gt; dict;

    <span class="kw">while</span> ( fgets(line, MAX_WORD_LEN*<span class="dv">2</span>, stdin ) &amp;&amp; (line != <span class="dv">0</span> &amp;&amp; line != <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>) ) {
        sscanf(line, <span class="st">&quot;</span><span class="ch">%s</span><span class="st"> </span><span class="ch">%s</span><span class="st">&quot;</span><span class="co">,</span> s1, s2);
        dict[s2] = s1;
    }

    <span class="kw">while</span> ( fgets(line, MAX_WORD_LEN*<span class="dv">2</span>, stdin ) ) {
        sscanf( line, <span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span><span class="co">,</span> s1 );
        <span class="co">// you should not use dict[s1].length() == 0</span>
        <span class="kw">if</span> ( dict.find(s1) != dict.end() ) {
            puts(<span class="st">&quot;eh&quot;</span><span class="co">)</span>;
        } <span class="kw">else</span> {
            printf(<span class="st">&quot;</span><span class="ch">%s\n</span><span class="st">&quot;</span><span class="co">,</span> dict[s1].c_str());
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cat</span> fish.txt <span class="kw">|</span> <span class="kw">./a.out</span></code></pre></div>
<p>c++ version, buggy&#8230;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;map&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;sstream&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main() {
    string line;
    map&lt;string, string&gt; dict;

    <span class="kw">while</span> ( getline( cin, line ) &amp;&amp; !line.empty() ) {
        stringstream ss( line );
        string s1, s2;
        ss &gt;&gt; s1 &gt;&gt; s2;
        dict[s2] = s1;
        <span class="co">// printf( &quot;s1: %s, s2: %s\n&quot;, s1.c_str(), s2.c_str() );</span>
    }

    <span class="kw">while</span> ( cin &gt;&gt; line &amp;&amp; !line.empty() ) {
        <span class="kw">if</span> ( dict.find(line) != dict.end() ) {
            cout &lt;&lt; <span class="st">&quot;eh&quot;</span> &lt;&lt; endl;
        } <span class="kw">else</span> {
            cout &lt;&lt; dict[line] &lt;&lt; endl;
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#26641;&#24418;&#25968;&#25454;&#32467;&#26500; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#22534;&#30340;&#21407;&#29702;&#12289;&#23454;&#29616;&#21644;&#36816;&#29992;, Heap <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt><a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">Heap (data structure) - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p>In computer science, a heap is a <strong>specialized tree-based data structure</strong> that satisfies the heap property: If A is a parent node of B then the key (the value) of node A is ordered with respect to the key of node B with the same ordering applying across the heap. A heap can be classified further as either a &#8220;<strong>max heap</strong>&#8221; or a &#8220;<strong>min heap</strong>&#8221;. In a max heap, the keys of parent nodes are always greater than or equal to those of the children and the highest key is in the root node. In a min heap, the keys of parent nodes are less than or equal to those of the children and the lowest key is in the root node. Heaps are crucial in several efficient graph algorithms such as Dijkstra&#8217;s algorithm, and in the sorting algorithm heapsort. <strong>A common implementation of a heap is the binary heap, in which the tree is a complete binary tree.</strong></p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/38/Max-Heap.svg/240px-Max-Heap.svg.png" alt="Example of a complete binary max-heap with node keys being integers from 1 to 100" />
<p class="caption">Example of a complete binary max-heap with node keys being integers from 1 to 100</p>
</div>
<p>When a heap is a <strong>complete binary tree</strong>, it has a smallest possible height&#8212;a heap with N nodes always has (logN) height. A heap is a useful data structure when you need to remove the object with the highest (or lowest) priority.</p>
</dd>
<dt><a href="https://en.wikipedia.org/wiki/Heapsort">Heapsort - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><pre><code>iParent(i)     = floor((i-1) / 2)
iLeftChild(i)  = 2*i + 1
iRightChild(i) = 2*i + 2

procedure heapsort(a, count) is
    input: an unordered array a of length count

    (Build the heap in array a so that largest
    value is at the root) heapify(a, count)

    (The following loop maintains the invariants
    that a[0:end] is a heap and every element
    beyond end is greater than everything before it
    (so a[end:count] is in sorted order))

    end &#8592; count - 1
    while end &gt; 0 do
        // a is the root and largest value. The
        // swap moves it in front of the sorted
        // elements.)
        swap(a[end], a)
        // the heap size is reduced by one
        end &#8592; end - 1
        // the swap ruined the heap property, so restore it
        siftDown(a, 0, end)</code></pre>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/4/4d/Heapsort-example.gif" />

</div>
</dd>
</dl></li>
<li><dl>
<dt>heap.c <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-45-26-create-binary-heap-Onlgn.gif" />

</div>
<div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-46-26-create-binary-heap-On.gif" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdlib.h&gt;                             </span><span class="co">// malloc</span>
<span class="ot">#include &lt;string.h&gt;                             </span><span class="co">// memcpy</span>
<span class="kw">typedef</span> <span class="kw">struct</span> heap_t {
    <span class="dt">int</span> size;
    <span class="dt">int</span> capacity;
    <span class="dt">int</span> *elems;
    <span class="dt">int</span> (*cmp)(<span class="dt">const</span> <span class="dt">int</span> *, <span class="dt">const</span> <span class="dt">int</span> *);       <span class="co">// compare function</span>
} heap_t;

<span class="dt">int</span> cmp_int( <span class="dt">const</span> <span class="dt">int</span> *x, <span class="dt">const</span> <span class="dt">int</span> *y ) {
    <span class="dt">int</span> sub = *x - *y;
    <span class="kw">return</span> sub &gt; <span class="dv">0</span> ? <span class="dv">1</span> : sub &lt; <span class="dv">0</span> ? <span class="dv">-1</span> : <span class="dv">0</span>;
}

heap_t * heap_create( <span class="dt">const</span> <span class="dt">int</span> capacity,
                      <span class="dt">int</span> (*cmp)(<span class="dt">const</span> <span class="dt">int</span> *, <span class="dt">const</span> <span class="dt">int</span> *) )
{
    heap_t *h = (heap_t*)malloc(<span class="kw">sizeof</span>(heap_t));
    h-&gt;size = <span class="dv">0</span>;
    h-&gt;capacity = capacity;
    h-&gt;elems = (<span class="dt">int</span> *)malloc(capacity * <span class="kw">sizeof</span>(<span class="dt">int</span>));
    h-&gt;cmp = cmp;
    <span class="kw">return</span> h;
}

<span class="dt">void</span> heap_destroy( heap_t *h ) {
    free( h-&gt;elems );
    free( h );
}

<span class="dt">int</span> heap_empty( <span class="dt">const</span> heap_t *h ) {
    <span class="kw">return</span> h-&gt;size == <span class="dv">0</span>;
}

<span class="dt">int</span> heap_size( <span class="dt">const</span> heap_t *h ) {
    <span class="kw">return</span> h-&gt;size;
}</code></pre></div>
<pre><code>sift down
---------

3   9   6   8   5   1   4   2   7           9   8   6   7   5   1   4   2   3
                                                       9
            /   \                                       /   \
           /      \                                    /      \
         9         6                                 8         6
        /  \       /  \                             /  \       /  \
      8     5     1    4                          7     5     1    4
     / \                                         / \
    2    7                                      2
                        tmp = h[j]

    (i)         can go down?
    /\
   /  \             j or j+1 ?
  /    \            h[i]    =   h[j]
(j)   (j+1)         h[i]    =   tmp</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> heap_sift_down( <span class="dt">const</span> heap_t *h, <span class="dt">const</span> <span class="dt">int</span> start ) {       <span class="co">// &#23567;&#26681;&#22534;&#30340;&#33258;&#19978;&#21521;&#19979;&#31579;&#36873;&#31639;&#27861;.</span>
    <span class="dt">int</span> i = start;
    <span class="dt">const</span> <span class="dt">int</span> tmp = h-&gt;elems[start];

    <span class="co">// 2*i+1: left child, 2*i+2: right child</span>
    <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">2</span>*i<span class="dv">+1</span>; j &lt; h-&gt;size; j = <span class="dv">2</span>*j<span class="dv">+1</span> ) {
        <span class="kw">if</span>( j<span class="dv">+1</span> &lt; h-&gt;size &amp;&amp; h-&gt;cmp(&amp;(h-&gt;elems[j]), &amp;(h-&gt;elems[j + <span class="dv">1</span>])) &gt; <span class="dv">0</span> ) {
            j++;                                    <span class="co">// sift towards j, j &#25351;&#21521;&#20004;&#23376;&#22899;&#20013;&#23567;&#32773;</span>
        }
        <span class="kw">if</span>( h-&gt;cmp(&amp;tmp, &amp;(h-&gt;elems[j])) &lt;= <span class="dv">0</span> ) {   <span class="co">// they are all big guys down there.</span>
            <span class="kw">break</span>;
        } <span class="kw">else</span> {
            h-&gt;elems[i] = h-&gt;elems[j];
            i = j;
        }
    }
    h-&gt;elems[i] = tmp;
}</code></pre></div>
<pre><code>                        tmp = h[j]

           (i)          can go up?
           /\
          /  \              h[j]    =   h[i]
         /    \             j       =   i
       (j)     *            i       =   (j-1)/2

</code></pre>
<pre><code>// &#23567;&#26681;&#22534;&#30340;&#33258;&#19979;&#21521;&#19978;&#31579;&#36873;&#31639;&#27861;.
void heap_sift_up( const heap_t *h, const int start ) {
    const int tmp = h-&gt;elems[start];
    int j = start;
    int i= (j - 1) / 2;                             // parent
    while( j &gt; 0 ) {
        if( h-&gt;cmp(&amp;(h-&gt;elems[i]), &amp;tmp) &lt;= 0 ) {   // parent is small enough
            break;
        } else {
            h-&gt;elems[j] = h-&gt;elems[i];
            j = i;
            i = (j-1)/2;
        }
    }
    h-&gt;elems[j] = tmp;
}

void heap_push( heap_t *h, const int x ) {
    if( h-&gt;size == h-&gt;capacity ) {
        h-&gt;capacity *= 2;
        int *tmp = (int *)realloc( h-&gt;elems, h-&gt;capacity*sizeof(int) );
        h-&gt;elems = tmp;
    }
    h-&gt;elems[h-&gt;size++] = x;                        // append
    heap_sift_up( h, h-&gt;size - 1 );                 // sift up last node
}

void heap_pop( heap_t *h ) {
    h-&gt;elems = h-&gt;elems[h-&gt;size - 1];
    --h-&gt;size;
    heap_sift_down( h, 0 );
}

int heap_top( const heap_t *h ) {
    return h-&gt;elems;
}</code></pre>
</dd>
</dl></li>
<li><dl>
<dt>Minimum N, (heap, priority_queue) &#9829;&#65039; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;functional&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> N;
<span class="dt">const</span> <span class="dt">int</span> MAXN = <span class="dv">100000</span>;
<span class="dt">int</span> a[MAXN], b[MAXN];

<span class="kw">typedef</span> <span class="kw">struct</span> node_t {
    <span class="dt">int</span> sum;
    <span class="dt">int</span> b;                                          <span class="co">// b is the index, init with 0, sum=a[i]+b[b=0]</span>
    <span class="dt">bool</span> <span class="kw">operator</span>&gt;( <span class="dt">const</span> node_t &amp;other ) <span class="dt">const</span> {   <span class="co">// std::greater&lt;node_t&gt;</span>
        <span class="kw">return</span> sum &gt; other.sum;
    }
} node_t;

<span class="dt">void</span> k_merge() {
    sort( a, a+N );
    sort( b, b+N );
    priority_queue&lt; node_t, vector&lt;node_t&gt;, greater&lt;node_t&gt; &gt; q;    <span class="co">// a min heap</span>

    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i ) {
        node_t tmp;
        tmp.b = <span class="dv">0</span>;
        tmp.sum = a[i]+b[tmp.b];
        q.push( tmp );
    }

    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i ) {
        node_t tmp = q.top(); q.pop();
        printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, tmp.sum);
        tmp.sum = tmp.sum - b[tmp.b] + b[tmp.b + <span class="dv">1</span>];
        ++tmp.b;
        q.push(tmp);
    }
}

<span class="dt">int</span> main() {
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;N );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i ) {
        scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;a[i] );
    }
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i ) {
        scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;b[i] );
    }
    k_merge();
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cat</span> input.txt
<span class="kw">5</span>
<span class="kw">1</span>   3   2   4   5
<span class="kw">6</span>   3   4   1   7

$ <span class="kw">cat</span> input.txt <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">2</span> 3 4 4 5</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#25968;&#23398;&#27010;&#24565;&#19982;&#26041;&#27861; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#25968;&#35770;&#21021;&#27493; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#27431;&#20960;&#37324;&#24503;&#31639;&#27861;&#21644;&#21807;&#19968;&#20998;&#35299;&#23450;&#29702; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#25467;&#36716;&#30456;&#38500;&#27861;</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> gcd( <span class="dt">int</span> a, <span class="dt">int</span> b ) {
    <span class="kw">return</span> b == <span class="dv">0</span> ? a : gcd( b, a%b );
}</code></pre></div>
</dd>
</dl>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li>&#35745;&#25968;&#19982;&#27010;&#29575;&#22522;&#30784;</li>
<li>&#20854;&#20182;&#25968;&#23398;&#19987;&#39064;</li>
<li>&#31454;&#36187;&#39064;&#30446;&#36873;&#35762;</li>
<li>&#35757;&#32451;&#21442;&#32771;</li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/08/28 &#19978;&#21320; 9:30:00 9. &#22270;&#19982;&#25628;&#32034; Graph &amp; Search <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#31264;&#23494;&#22270;&#36866;&#21512;&#29992;&#37051;&#25509;&#30697;&#38453;&#26469;&#34920;&#31034; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#39030;&#28857;&#25968;&#26368;&#22823;&#20540;</span>
<span class="dt">const</span> <span class="dt">int</span> MAX_NV = <span class="dv">100</span>;

<span class="co">// &#36793;&#30340;&#26435;&#20540;&#31867;&#22411;&#65292;&#21487;&#20197;&#20026; int, float, double.</span>
<span class="kw">typedef</span> <span class="dt">int</span> graph_weight_t;
<span class="dt">const</span> graph_weight_t GRAPH_INF = INT_MAX;

<span class="co">// &#22270;&#65292;&#29992;&#37051;&#25509;&#30697;&#38453; (Adjacency Matrix).</span>
<span class="kw">struct</span> graph_t {
    <span class="dt">int</span> nv;                                         <span class="co">// &#39030;&#28857;&#25968;</span>
    <span class="dt">int</span> ne;                                         <span class="co">// &#36793;&#25968;</span>
    graph_weight_t matrix[MAX_NV][MAX_NV];          <span class="co">// &#37051;&#25509;&#30697;&#38453;&#65292;&#23384;&#25918;&#36793;&#30340;&#20449;&#24687;&#65292;&#22914;&#26435;&#37325;&#31561;</span>
};</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#31232;&#30095;&#22270;&#36866;&#21512;&#29992;&#37051;&#25509;&#34920;&#26469;&#34920;&#31034; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#36793;&#30340;&#26435;&#20540;&#31867;&#22411;&#65292;&#21487;&#20197;&#20026; int, float, double</span>
<span class="kw">typedef</span> <span class="dt">int</span> graph_weight_t;

<span class="co">// &#39030;&#28857;&#30340;&#32534;&#21495;&#65292;&#21487;&#20197;&#20026; char, int, string &#31561;</span>
<span class="kw">typedef</span> <span class="dt">char</span> graph_vertex_id_t;

<span class="co">// &#22270;&#65292;&#29992;&#37051;&#25509;&#34920; (Adjacency List).</span>
<span class="kw">struct</span> graph_t {
    <span class="dt">int</span> nv;                                         <span class="co">// &#39030;&#28857;&#25968;</span>
    <span class="dt">int</span> ne;                                         <span class="co">// &#36793;&#25968;</span>
    map&lt;
        graph_vertex_id_t,
        map&lt;graph_vertex_id_t, graph_weight_t&gt;
    &gt; matrix;                                       <span class="co">// &#37051;&#25509;&#34920;&#65292;&#23384;&#25918;&#36793;&#30340;&#20449;&#24687;&#65292;&#22914;&#26435;&#37325;&#31561;</span>
};</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#22270;&#30340;&#28145;&#25628; DFS <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#22270;&#30340; DFS, &#25628;&#32034;&#36793; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//  &#22270;&#30340;&#28145;&#24230;&#20248;&#20808;&#25628;&#32034;&#20195;&#30721;&#26694;&#26550;&#65292;&#25628;&#32034;&#36793;.</span>
<span class="co">//  g &#22270;</span>
<span class="co">//  u &#20986;&#21457;&#39030;&#28857;</span>
<span class="co">//  visited &#36793;&#30340;&#35775;&#38382;&#21382;&#21490;&#35760;&#24405;</span>
<span class="dt">void</span> dfs( <span class="dt">const</span> graph_t &amp;g, <span class="dt">int</span> u, <span class="dt">bool</span> visited[][MAX_NV] ) {
    <span class="kw">for</span>( <span class="dt">int</span> v = <span class="dv">0</span>;  v &lt; g.nv; ++v ) {
        <span class="kw">if</span>( g.matrix[u][v] &amp;&amp; !visited[u][v] ) {
            visited[u][v] = visited[v][u] = <span class="kw">true</span>;   <span class="co">// &#26080;&#21521;&#22270;&#29992;&#36825;&#21477;</span>
            <span class="co">// visited[u][v] = true;                // &#26377;&#21521;&#22270;&#29992;&#36825;&#21477;</span>
            dfs( g, v, visited );
            <span class="co">// &#36825;&#37324;&#20889;&#36923;&#36753;&#20195;&#30721;, e.g. printf(&quot;%d %d\n&quot;, u, v);</span>
        }
    }
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#22270;&#30340; DFS, &#25628;&#32034;&#39030;&#28857; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//  &#22270;&#30340;&#28145;&#24230;&#20248;&#20808;&#25628;&#32034;&#20195;&#30721;&#26694;&#26550;&#65292;&#25628;&#32034;&#39030;&#28857;.</span>
<span class="co">//  g &#22270;</span>
<span class="co">//  u &#20986;&#21457;&#39030;&#28857;</span>
<span class="co">//  visited &#39030;&#28857;&#30340;&#35775;&#38382;&#21382;&#21490;&#35760;&#24405;</span>
<span class="dt">void</span> dfs( <span class="dt">const</span> graph_t &amp;g, <span class="dt">int</span> u, <span class="dt">bool</span> visited[MAX_NV] ) {
    visited[u] = <span class="kw">true</span>;
    <span class="kw">for</span>( <span class="dt">int</span> v = <span class="dv">0</span>;  v &lt; g.nv; ++v ) {
        <span class="kw">if</span>( g.matrix[u][v] &amp;&amp; !visited[v] ) {
            dfs(g, v, visited);
            <span class="co">// &#36825;&#37324;&#20889;&#36923;&#36753;&#20195;&#30721;, e.g. printf(&quot;%d %d\n&quot;, u, v);</span>
        }
    }
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Satellite Photographs <code class="fold">@</code></dt>
<dd><p>Farmer John purchased satellite photos of <code>W * H</code> pixels of his farm (1 &lt;= W &lt;= 80, 1 &lt;= H &lt;= 1000) and wishes to determine the largest &#8216;contiguous&#8217; (connected) pasture. Pastures are contiguous when any pair of pixels in a pasture can be connected by traversing adjacent vertical or horizontal pixels that are part of the pasture. (It is easy to create pastures with very strange shapes, even circles that surround other circles.)</p>
<p>Each photo has been digitally enhanced to show pasture area as an asterisk (<code>*</code>) and non-pasture area as a period (<code>.</code>). Here is a 10x5 sample satellite photo:</p>
<pre><code>..*.....**
.**..*****
.*...*....
..****.***
..****.***</code></pre>
<p>This photo shows three contiguous pastures of 4, 16, and 6 pixels. Help FJ find the largest contiguous pasture in each of his satellite photos.</p>
<pre><code>&#36755;&#20837;

    Line  1:        Two space-separated integers: W and H
    Lines 2..H+1:   Each line contains W &quot;*&quot; or &quot;.&quot;
                    characters representing one raster line of
                    a satellite photograph.

    10 5
    ..*.....**
    .**..*****
    .*...*....
    ..****.***
    ..****.***

&#36755;&#20986;

    Line 1:         The size of the largest contiguous field in the satellite photo.

    16</code></pre>
<p>&#36825;&#26159;&#19968;&#20010;&#24179;&#38754;&#30340;&#20108;&#32500;&#22320;&#22270;&#65292;&#25226;&#22320;&#22270;&#19978;&#30340;&#27599;&#20010;&#28857;&#24403;&#25104;&#38544;&#24335;&#22270;&#19978;&#30340;&#19968;&#20010;&#39030;&#28857;&#65292;&#27599;&#20010;&#39030;&#28857;&#26377;&#19978;&#19979;&#24038;&#21491;&#22235;&#20010;&#37051;&#25509;&#28857;&#12290;&#22312;&#36825;&#20010;&#38544;&#24335;&#22270;&#19978;&#36827;&#34892;&#28145;&#25628;&#12290;</p>
<p>too easy&#8230;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// POJ 3051 Satellite Photographs, http://poj.org/problem?id=3051</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">void</span> dfs( vector&lt;vector&lt;<span class="dt">char</span>&gt; &gt; &amp;map, <span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> &amp;count ) {
    <span class="kw">if</span>( map[x][y] == <span class="st">&#39;.&#39;</span> ) { <span class="kw">return</span>; }  <span class="co">// &#21152;&#20102;&#19968;&#22280; &#39;.&#39; &#21487;&#20197;&#38450;&#27490;&#36234;&#30028;&#65292;&#22240;&#27492;&#19981;&#38656;&#35201;&#21028;&#26029;&#36234;&#30028;</span>

    map[x][y] = <span class="st">&#39;.&#39;</span>;                    <span class="co">// &#26631;&#35760; (x,y) &#24050;&#35775;&#38382;&#36807;&#65292;&#36215;&#21040;&#21435;&#37325;&#20316;&#29992;</span>
    ++count;
    dfs( map, x<span class="dv">+1</span>, y,   count );
    dfs( map, x<span class="dv">-1</span>, y,   count );
    dfs( map, x,   y<span class="dv">+1</span>, count );
    dfs( map, x,   y<span class="dv">-1</span>, count );
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> W, H;
    <span class="kw">while</span>( <span class="dv">2</span> == scanf( <span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;W, &amp;H ) ) {
        vector&lt;vector&lt;<span class="dt">char</span>&gt; &gt; map( H<span class="dv">+2</span>, vector&lt;<span class="dt">char</span>&gt;(W<span class="dv">+2</span>, <span class="st">&#39;.&#39;</span>) );
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= H; ++i ) {
            <span class="dt">char</span> line[<span class="dv">100</span>];
            scanf( <span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, line );
            strncpy( &amp;map[i][<span class="dv">1</span>], line, W ); <span class="co">// will not append &#39;\0&#39;</span>
        }

        <span class="dt">int</span> ret = <span class="dv">0</span>;
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= H; ++i ) {
            <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= W; ++j ) {
                <span class="dt">int</span> count = <span class="dv">0</span>;
                <span class="kw">if</span>( map[i][j] == <span class="st">&#39;*&#39;</span> ) {
                    dfs( map, i, j, count );
                }
                ret = max( ret, count );
            }
        }
        printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ret );
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>John&#8217;s trip <code class="fold">@</code></dt>
<dd><p>Little Johnny has got a new car. He decided to drive around the town to visit his friends. Johnny wanted to visit all his friends, but there was many of them. In each street he had one friend. He started thinking how to make his trip as short as possible. Very soon he realized that the best way to do it was to travel through each street of town only once. Naturally, he wanted to finish his trip at the same place he started, at his parents&#8217; house.</p>
<p>The streets in Johnny&#8217;s town were named by integer numbers from 1 to n, n &lt; 1995. The junctions were independently named by integer numbers from 1 to m, m &lt;= 44. No junction connects more than 44 streets. All junctions in the town had different numbers. Each street was connecting exactly two junctions. No two streets in the town had the same number. He immediately started to plan his round trip. If there was more than one such round trip, he would have chosen the one which, when written down as a sequence of street numbers is lexicographically the smallest. But Johnny was not able to find even one such round trip.</p>
<p>Help Johnny and write a program which finds the desired shortest round trip. If the round trip does not exist the program should write a message. Assume that Johnny lives at the junction ending the street appears first in the input with smaller number. All streets in the town are two way. There exists a way from each street to another street in the town. The streets in the town are very narrow and there is no possibility to turn back the car once he is in the street.</p>
<pre><code>Input

    Input file consists of several blocks. Each block describes one town. Each
    line in the block contains three integers x, y, z, where x &gt; 0 and y &gt; 0
    are the numbers of junctions which are connected by the street number z.
    The end of the block is marked by the line containing x = y = 0. At the end
    of the input file there is an empty block, x = y = 0.

    1 2 1
    2 3 2
    3 1 6
    1 2 5
    2 3 3
    3 1 4
    0 0
    1 2 1
    2 3 2
    1 3 3
    2 4 4
    0 0
    0 0

Output

    Output one line of each block contains the sequence of street numbers
    (single members of the sequence are separated by space) describing Johnny&#39;s
    round trip. If the round trip cannot be found the corresponding output
    block contains the message &quot;Round trip does not exist.&quot;

    1 2 3 5 4 6
    Round trip does not exist.</code></pre>
<dl>
<dt>&#20998;&#26512;</dt>
<dd><p>&#27431;&#25289;&#22238;&#36335;&#12290;</p>
<p>&#22914;&#26524;&#33021;&#20174;&#22270;&#30340;&#26576;&#19968;&#39030;&#28857;&#20986;&#21457;&#65292;&#27599;&#26465;&#36793;&#24688;&#22909;&#32463;&#36807;&#19968;&#27425;&#65292;&#36825;&#26679;&#30340;&#36335;&#32447;&#31216;&#20026;<strong>&#27431;&#25289;&#36947;&#36335; (Eulerian Path)</strong>&#12290;&#22914;&#26524;&#36824;&#33021;&#22815;&#22238;&#21040;&#36215;&#28857;&#65292;&#36825;&#26679;&#30340;&#36335;&#32447;&#31216;&#20026;<strong>&#27431;&#25289;&#22238;&#36335; (Eulerian Circuit)</strong>&#12290;</p>
<p>&#23545;&#20110;&#26080;&#21521;&#22270; G&#65292;&#24403;&#19988;&#20165;&#24403; G &#26159;&#36830;&#36890;&#30340;&#65292;&#19988;&#26368;&#22810;&#26377;&#20004;&#20010;&#22855;&#28857;&#65292;&#21017;&#23384;&#22312;&#27431;&#25289;&#36947;&#36335;&#12290;&#22914;&#26524;&#26377;&#20004;&#20010;&#22855;&#28857;&#65292;&#21017;&#24517;&#39035;&#20174;&#20854;&#20013;&#19968;&#20010;&#22855;&#28857;&#20986;&#21457;&#65292;&#21040;&#21478;&#19968;&#20010;&#22855;&#28857;&#32456;&#27490;&#12290;</p>
<p>&#22914;&#26524;&#27809;&#26377;&#22855;&#28857;&#65292;&#21017;&#19968;&#23450;&#23384;&#22312;&#19968;&#26465;&#27431;&#25289;&#22238;&#36335;&#12290;</p>
<p>&#23545;&#20110;&#26377;&#21521;&#22270; G&#65292;&#24403;&#19988;&#20165;&#24403; G &#26159;&#36830;&#36890;&#30340;&#65292;&#19988;&#27599;&#20010;&#28857;&#30340;&#20837;&#24230;&#31561;&#20110;&#20986;&#24230;&#65292;&#21017;&#23384;&#22312;&#27431;&#25289;&#22238;&#36335;&#12290;</p>
<p>&#22914;&#26524;&#26377;&#20004;&#20010;&#39030;&#28857;&#30340;&#20837;&#24230;&#19982;&#20986;&#24230;&#19981;&#30456;&#31561;&#65292;&#19988;&#19968;&#20010;&#39030;&#28857;&#30340;&#20837;&#24230;&#27604;&#20986;&#24230;&#23567; 1&#65292;&#21478;&#19968;&#20010;&#39030;&#28857;&#30340;&#20837;&#24230;&#27604;&#20986;&#24230;&#22823; 1&#65292;&#27492;&#26102;&#65292;&#23384;&#22312;&#19968;&#26465;&#27431;&#25289;&#36947;&#36335;&#65292;&#20197;&#21069;&#19968;&#20010;&#39030;&#28857;&#20026;&#36215;&#28857;&#65292;&#20197;&#21518;&#19968;&#20010;&#39030;&#28857;&#20026;&#32456;&#28857;&#12290;</p>
</dd>
</dl>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// POJ 1041 John&#39;s trip, http://poj.org/problem?id=1041</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;stack&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> MAX_NV = <span class="dv">45</span>;
<span class="dt">const</span> <span class="dt">int</span> MAX_NE = <span class="dv">1996</span>;

<span class="kw">struct</span> graph_t {
    <span class="dt">int</span> nv;
    <span class="dt">int</span> ne;
    <span class="dt">int</span> matrix[MAX_NV][MAX_NE];     <span class="co">// G[&#28857;][&#36793;] = &#28857;&#65292;&#36825;&#26679;&#26159;&#20026;&#20102;&#33021;&#26041;&#20415;&#35753;&#36793; lexicographically &#36755;&#20986;</span>
} G;

<span class="dt">bool</span> visited[MAX_NE];               <span class="co">// &#36793;&#26159;&#21542;&#24050;&#35775;&#38382;</span>
<span class="dt">int</span>  degree[MAX_NV];                <span class="co">// &#28857;&#30340;&#24230;</span>

stack&lt;<span class="dt">int</span>&gt; s;                       <span class="co">// &#26632;&#65292;&#29992;&#20110;&#36755;&#20986;</span>

<span class="dt">void</span> stack_print( stack&lt;<span class="dt">int</span>&gt; &amp;s ) {
    <span class="kw">while</span>( !s.empty() ) {
        cout &lt;&lt; s.top() &lt;&lt; <span class="st">&quot; &quot;</span>;
        s.pop();
    }
    cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
}

<span class="dt">void</span> euler( <span class="dt">int</span> u ) {
    <span class="kw">for</span>( <span class="dt">int</span> e = <span class="dv">1</span>; e &lt;= G.ne; ++e ) {
        <span class="kw">if</span>( !visited[e] &amp;&amp; G.matrix[u][e] ) {
            visited[e] = <span class="kw">true</span>;
            euler( G.matrix[u][e] );
            s.push( e );
        }
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> x, y, z, start;
    <span class="kw">while</span>( (cin &gt;&gt; x &gt;&gt; y) &amp;&amp; x &amp;&amp; y ) {
        memset( visited,    <span class="kw">false</span>,  <span class="kw">sizeof</span>(visited) );
        memset( degree,     <span class="dv">0</span>,      <span class="kw">sizeof</span>(degree)  );
        memset( &amp;G,         <span class="dv">0</span>,      <span class="kw">sizeof</span>(G)       );

        start = x &lt; y ? x : y;
        cin &gt;&gt; z;
        G.ne = max( G.ne, z );
        G.nv = max( G.nv, max(x, y) );
                                        <span class="co">// input: x (node), y (node), z (edge)</span>
        G.matrix[x][z] = y;             <span class="co">// x ---z---&gt; y</span>
        G.matrix[y][z] = x;             <span class="co">// y ---z---&gt; x</span>
        ++degree[x];
        ++degree[y];

        <span class="kw">while</span>( (cin &gt;&gt; x &gt;&gt; y) &amp;&amp; x &amp;&amp; y ) {
            cin &gt;&gt; z;
            G.ne = max( G.ne, z );
            G.nv = max( G.nv, max(x, y) );
            G.matrix[x][z] = y;
            G.matrix[y][z] = x;
            ++degree[x];
            ++degree[y];
        }

        <span class="co">// &#27431;&#25289;&#22238;&#36335;&#24418;&#25104;&#30340;&#26465;&#20214;&#20043;&#19968;&#65292;&#21028;&#26029;&#32467;&#28857;&#30340;&#24230;&#26159;&#21542;&#20026;&#20598;&#25968;</span>
        <span class="dt">bool</span> valid = <span class="kw">true</span>;
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= G.nv; ++i ) {
            <span class="kw">if</span>( degree[i] &amp; <span class="dv">1</span> ) {
                valid = <span class="kw">false</span>;
                <span class="kw">break</span>;
            }
        }

        <span class="kw">if</span>( !valid ) {
            cout &lt;&lt; <span class="st">&quot;Round trip does not exist.</span><span class="ch">\n</span><span class="st">&quot;</span>;
        } <span class="kw">else</span> {
            euler( start );
            stack_print(s);
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Abbott &#30340;&#22797;&#20167; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// d[r][c][dir] &#23384;&#20648;&#20174;&#21021;&#22987;&#29366;&#24577;&#21040; (r,c,dir) &#30340;&#26368;&#30701;&#38271;&#24230;&#65292;&#20854;&#29238;&#33410;&#28857;&#20445;&#23384;&#22312;</span>
<span class="co">// p[r][c][dir]</span>
<span class="co">// has_edge[r][c][dir][turn], now at (r,c,dir), can `turn`?</span>
<span class="co">//  inside(r, c), inside the map</span>

<span class="dt">const</span> <span class="dt">char</span> *dirs  = <span class="st">&quot;NESW&quot;</span>; <span class="co">// north, east, south, west</span>
<span class="dt">const</span> <span class="dt">char</span> *turns = <span class="st">&quot;FLR&quot;</span>;  <span class="co">// forward, left, right</span>
<span class="dt">int</span> dir_id(  <span class="dt">char</span> c ) { <span class="kw">return</span> strchr(dirs, c) - dirs; }
<span class="dt">int</span> turn_id( <span class="dt">char</span> c ) { <span class="kw">return</span> strchr(turns, c) - turns; }

<span class="co">//   clockwise :    N   E   S   W           //          +-----------&gt; y (col-wise)</span>
<span class="dt">const</span> <span class="dt">int</span> dr[] = { <span class="dv">-1</span>,  <span class="dv">0</span>,  <span class="dv">1</span>,  <span class="dv">0</span> };        <span class="co">//          |</span>
<span class="dt">const</span> <span class="dt">int</span> dc[] = {  <span class="dv">0</span>,  <span class="dv">1</span>,  <span class="dv">0</span>, <span class="dv">-1</span> };        <span class="co">//          |</span>
                                            <span class="co">//          | x (row-wise)</span>
                                            <span class="co">//          V</span>

Node walk( <span class="dt">const</span> Node &amp;u, <span class="dt">int</span> turn ) {
    <span class="dt">int</span> dir = u.dir;                        <span class="co">// turn = 0, forward</span>
    <span class="kw">if</span>( turn == <span class="dv">1</span> ) { dir = (dir<span class="dv">+3</span>)%<span class="dv">4</span>; }    <span class="co">// turn = 1, left, counter clockwise</span>
    <span class="kw">if</span>( turn == <span class="dv">2</span> ) { dir = (dir<span class="dv">+1</span>)%<span class="dv">4</span>; }    <span class="co">// turn = 2, right, clockwise</span>
    <span class="kw">return</span> Node( u.r + dr[dir], u.c + dc[dir], dir );
}

<span class="dt">void</span> solve() {
    queue&lt;Node&gt; q;
    memset( d, <span class="dv">-1</span>, <span class="kw">sizeof</span>(d) );             <span class="co">// reset to -1</span>
    Node u( r1, c1, dir );                  <span class="co">// start pos</span>
    d[u.r][u.c][u.dir] = <span class="dv">0</span>;                 <span class="co">// init distance</span>
    q.push( u );
    <span class="kw">while</span>( !q.empty() ) {
        Node u = q.front(); q.pop();
        <span class="kw">if</span>( u.r == r2 &amp;&amp; r.c == c2 ) { print_ans(u); <span class="kw">return</span>; }
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; ++i ) {      <span class="co">// enum turns</span>
            Node v = walk( u, i );
            <span class="kw">if</span>( has_edge[u.r][u.c][u.dir][i] &amp;&amp;
                inside(v.r, v.c) &amp;&amp;
                d[v.r][v.c][v.dir] &lt; <span class="dv">0</span> ) {  <span class="co">// &#20197;&#21069;&#27809;&#26377;&#22788;&#20110;&#36825;&#20010;&#23039;&#24577;</span>
                <span class="co">// advance</span>
                d[v.r][v.c][v.dir] = d[u.r][u.c][u.dir] + <span class="dv">1</span>;
                p[v.r][v.c][v.dir] = u;
                q.push( v );                <span class="co">// &#24403;&#21069;&#20301;&#32622;&#24635;&#26159;&#20877; stack &#39030;&#31471;&#23384;&#30528;</span>
            }
        }
    }
    printf( <span class="st">&quot;No Solution Possible.</span><span class="ch">\n</span><span class="st">&quot;</span> );
}

<span class="dt">void</span> print_ans( Node u ) {
    vector&lt;Node&gt; nodes;
    <span class="kw">for</span>( ;; ) {
        nodes.push_back( u );                   <span class="co">// &#19968;&#36335;&#23384;&#36215;&#26469;</span>
        <span class="kw">if</span>( d[u.r][u.c][u.dir] == <span class="dv">0</span> ) <span class="kw">break</span>;    <span class="co">// origin</span>
        u = p[u.r][u.c][u.dir];                 <span class="co">// backtrace</span>
    }
    nodes.push_back( Node(r1, c1, dir) );       <span class="co">// origin: r0, c0</span>

    <span class="dt">int</span> cnt = <span class="dv">0</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = nodes.size()<span class="dv">-1</span>; i &gt;= <span class="dv">0</span>; --i ) {
        <span class="kw">if</span>( cnt % <span class="dv">10</span> == <span class="dv">0</span> ) { printf( <span class="st">&quot; &quot;</span> ); }
        printf( <span class="st">&quot; (</span><span class="ch">%d</span><span class="st">, </span><span class="ch">%d</span><span class="st">)&quot;</span>, nodes[i].r, nodes[i].c );
        <span class="kw">if</span>( ++cnt % <span class="dv">10</span> == <span class="dv">0</span> ) {
            printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
        }
    }
    <span class="kw">if</span>( nodes.size() % <span class="dv">10</span> != <span class="dv">0</span> ) { printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> ); }
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>The Necklace buggy? <code class="fold">@</code></dt>
<dd><p>My little sister had a beautiful necklace made of colorful beads. Two successive beads in the necklace shared a common color at their meeting point. The figure below shows a segment of the necklace:</p>
<pre><code>   +-----------+   +-----------+   +-------------+   +------------+
---| green|red |---| red|white |---| white|green |---| green|blue |---
   +-----------+   +-----------+   +-------------+   +------------+</code></pre>
<p>But, alas! One day, the necklace was torn and the beads were all scattered over the floor. My sister did her best to recollect all the beads from the floor, but she is not sure whether she was able to collect all of them. Now, she has come to me for help. She wants to know whether it is possible to make a necklace using all the beads she has in the same way her original necklace was made and if so in which order the bids must be put.</p>
<p>Please help me write a program to solve the problem.</p>
<pre><code>Input

    The input contains T test cases. The first line of the
    input contains the integer T.

    The first line of each test case contains an integer N
    (5 &lt;= N &lt;= 1000) giving the number of beads my sister
    was able to collect. Each of the next N lines contains
    two integers describing the colors of a bead. Colors
    are represented by integers ranging from 1 to 50.

    2
    5
    1 2
    2 3
    3 4
    4 5
    5 6
    5
    2 1
    2 2
    3 4
    3 1
    2 4

Output

    For each test case in the input first output the test
    case number as shown in the sample output. Then if you
    apprehend that some beads may be lost just print the
    sentence ``some beads may be lost&quot; on a line by itself.
    Otherwise, print N lines with a single bead description
    on each line. Each bead description consists of two
    integers giving the colors of its two ends.
    For 1 &lt;= i &lt;= N_1, the second integer on line i must be
    the same as the first integer on line i + 1.
    Additionally, the second integer on line N must be
    equal to the first integer on line 1. Since there are
    many solutions, any one of them is acceptable.

    Print a blank line between two successive test cases.

    Case #1
    some beads may be lost

    Case #2
    2 1
    1 3
    3 4
    4 2
    2 2</code></pre>
<p>&#27431;&#25289;&#22238;&#36335;&#12290;</p>
<p>&#27880;&#24847;&#39030;&#28857;&#21487;&#20197;&#26377;&#33258;&#29615;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="ot">#define MAXN 51                         </span><span class="co">// &#39030;&#28857;&#26368;&#22823;&#20010;&#25968;</span>

<span class="dt">int</span> G[MAXN][MAXN];
<span class="dt">int</span> visited[MAXN];
<span class="dt">int</span> count[MAXN];                        <span class="co">// &#39030;&#28857;&#30340;&#24230;</span>

<span class="dt">void</span> dfs( <span class="dt">int</span> u ) {
    visited[u] = <span class="dv">1</span>;
    <span class="kw">for</span>( <span class="dt">int</span> v = <span class="dv">0</span>;  v &lt; MAXN; ++v ) {
        <span class="kw">if</span>( G[u][v] &amp;&amp; !visited[v] ) {
            dfs(v);
        }
    }
}

<span class="co">// &#27431;&#25289;&#22238;&#36335;&#65292;&#20801;&#35768;&#33258;&#29615;&#21644;&#37325;&#22797;&#36793;</span>
<span class="dt">void</span> euler( <span class="dt">int</span> u ) {
    <span class="kw">for</span>( <span class="dt">int</span> v = <span class="dv">0</span>; v &lt; MAXN; ++v ) {
        <span class="kw">if</span>( G[u][v] ) {
            --G[u][v]; --G[v][u];       <span class="co">// &#36825;&#20010;&#25216;&#24039;&#65292;&#21363;&#26377; visited &#30340;&#21151;&#33021;&#65292;&#21448;&#20801;&#35768;&#37325;&#22797;&#36793;</span>
            printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, u, v );  <span class="co">// &#36870;&#21521;&#25171;&#21360;&#65292;&#25110;&#32773;&#23384;&#21040;&#26632;&#37324;&#20877;&#25171;&#21360;</span>
            euler(v);
        }
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> cases = <span class="dv">0</span>, T;
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T );
    <span class="kw">while</span>( T-- ) {
        <span class="dt">bool</span> validGraph = <span class="kw">true</span>;         <span class="co">// &#32467;&#28857;&#30340;&#24230;&#26159;&#21542;&#20026;&#20598;&#25968;</span>
        <span class="dt">bool</span> connected  = <span class="kw">true</span>;         <span class="co">// &#22270;&#26159;&#21542;&#26159;&#36830;&#36890;&#30340;</span>
        memset( G,      <span class="dv">0</span>, <span class="kw">sizeof</span>(G)    );
        memset( count,  <span class="dv">0</span>, <span class="kw">sizeof</span>(count));

        <span class="dt">int</span> N;
        scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;N );
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; ++i ) {
            <span class="dt">int</span> a, b;
            scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;a, &amp;b );
            ++G[a][b];
            ++G[b][a];
            ++count[a];
            ++count[b];
        }

        printf( <span class="st">&quot;Case #</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ++cases );

        <span class="co">// &#27431;&#25289;&#22238;&#36335;&#24418;&#25104;&#30340;&#26465;&#20214;&#20043;&#19968;&#65292;&#21028;&#26029;&#32467;&#28857;&#30340;&#24230;&#26159;&#21542;&#20026;&#20598;&#25968;</span>
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; MAXN; ++i ) {
            <span class="kw">if</span>( count[i] &amp; <span class="dv">1</span> ) {
                validGraph = <span class="kw">false</span>;
                <span class="kw">break</span>;
            }
        }
        <span class="co">// &#26816;&#26597;&#22270;&#26159;&#21542;&#36830;&#36890;</span>
        <span class="kw">if</span>( validGraph ) {
            memset( visited, <span class="dv">0</span>, <span class="kw">sizeof</span>(visited) );
            <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; MAXN; ++i ) {
                <span class="kw">if</span>( count[i] ) {
                    dfs(i);
                    <span class="kw">break</span>;
                }
            }
            <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; MAXN; ++i ) {
                <span class="kw">if</span>( count[i] &amp;&amp; !visited[i] ) {
                    connected = <span class="kw">false</span>;
                    <span class="kw">break</span>;
                }
            }
        }
        <span class="kw">if</span>( validGraph &amp;&amp; connected ) {
            <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; MAXN; ++i ) {
                <span class="kw">if</span>( count[i] ) {
                    euler(i);
                    <span class="kw">break</span>;
                }
            }
        } <span class="kw">else</span> {
            printf( <span class="st">&quot;some beads may be lost</span><span class="ch">\n</span><span class="st">&quot;</span> );
        }

        <span class="kw">if</span>( T &gt; <span class="dv">0</span> ) { printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>); }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cat</span> input.txt
<span class="kw">2</span>
<span class="kw">5</span>
<span class="kw">1</span> 2
<span class="kw">2</span> 3
<span class="kw">3</span> 4
<span class="kw">4</span> 5
<span class="kw">5</span> 6
<span class="kw">5</span>
<span class="kw">2</span> 1
<span class="kw">2</span> 2
<span class="kw">3</span> 4
<span class="kw">3</span> 1
<span class="kw">2</span> 4

$ <span class="kw">cat</span> input.txt <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">Case</span> <span class="co">#1</span>
<span class="kw">some</span> beads may be lost

<span class="kw">Case</span> <span class="co">#2</span>
<span class="kw">1</span> 2
<span class="kw">2</span> 2
<span class="kw">2</span> 4
<span class="kw">4</span> 3
<span class="kw">3</span> 1</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><p>&#22270;&#19978;&#30340;&#23485;&#24230;&#20248;&#20808;&#25628;&#32034; Graph BFS</p></li>
<li><dl>
<dt>&#26368;&#23567;&#29983;&#25104;&#26641; <code class="fold">@</code></dt>
<dd><p>&#26500;&#36896;&#26368;&#23567;&#29983;&#25104;&#26641; (Minimum Spanning Tree, MST) &#26377;&#22810;&#31181;&#31639;&#27861;&#12290;&#20854;&#20013;&#22810;&#25968;&#31639;&#27861;&#21033;&#29992;&#20102;&#26368;&#23567;&#29983;&#25104;&#26641;&#30340;&#19968;&#20010;&#24615;&#36136;&#65288;&#31616;&#31216;&#20026; MST &#24615;&#36136;&#65289;&#65306;&#20551;&#35774; N = (V, E) &#26159;&#19968;&#20010;&#36830;&#36890;&#32593;&#65292;U &#26159;&#39030;&#28857;&#38598; V &#30340;&#19968;&#20010;&#38750;&#31354;&#23376;&#38598;&#12290;&#33509; (u, v) &#26159;&#19968;&#26465;&#20855;&#26377;&#26368;&#23567;&#26435;&#20540;&#30340;&#36793;&#65292;&#20854;&#20013; u &#8712; {U}, v &#8712; {V-U}&#65292;&#21017;&#24517;&#23384;&#22312;&#19968;&#39063;&#21253;&#21547;&#36793; (u, v) &#30340;&#26368;&#23567;&#29983;&#25104;&#26641;&#12290;</p>
<p>Prim &#31639;&#27861;&#21644; Kruskal &#31639;&#27861;&#26159;&#20004;&#20010;&#21033;&#29992; MST &#24615;&#36136;&#26500;&#36896;&#26368;&#23567;&#29983;&#25104;&#26641;&#30340;&#31639;&#27861;&#12290;<strong>&#23427;&#20204;&#37117;&#23646;&#20110;&#36138;&#24515;&#27861;&#12290;</strong></p>
<ul>
<li><dl>
<dt>Prim &#31639;&#27861; <code class="fold">@</code></dt>
<dd><p>&#20551;&#35774; N = (V, E) &#26159;&#19968;&#20010;&#36830;&#36890;&#32593;&#65292;TE &#26159; N &#19978;&#26368;&#23567;&#29983;&#25104;&#26641;&#20013;&#36793;&#30340;&#38598;&#21512;&#12290;&#31639;&#27861;&#20174; U = u<sub>0</sub> (u<sub>0</sub> &#8712; V), TE = {} &#24320;&#22987;&#65292;&#37325;&#22797;&#25191;&#34892;&#19979;&#36848;&#25805;&#20316;&#65306;&#22312;&#25152;&#26377; u &#8712; U, v &#8712; V-U &#30340;&#36793; (u, v) &#8712; E &#20013;&#25214;&#19968;&#26465;&#20195;&#20215;&#26368;&#23567;&#30340;&#36793; (u<sub>0</sub>, v<sub>0</sub>) &#24182;&#20837;&#38598;&#21512; TE&#65292;&#21516;&#26102; v<sub>0</sub> &#24182;&#20837; U&#65292;&#30452;&#33267; U = V &#20026;&#27490;&#12290;&#27492;&#26102; TE &#20013;&#24517;&#26377; n-1 &#26465;&#36793;&#65292;&#21017; T = (V, TE) &#20026; N &#30340;&#26368;&#23567;&#29983;&#25104;&#26641;&#12290;&#20026;&#23454;&#29616;&#36825;&#20010;&#31639;&#27861;&#38656;&#38468;&#35774;&#19968;&#20010;&#25968;&#32452; closedge&#65292;&#20197;&#35760;&#24405;&#20174; U &#21040; V-U &#20855;&#26377;&#26368;&#23567;&#20195;&#20215;&#30340;&#36793;&#12290;&#23545;&#27599;&#20010;&#39030;&#28857; v<sub>i</sub> &#8712;V-U&#65292;&#22312;&#36741;&#21161;&#25968;&#32452;&#20013;&#23384;&#22312;&#19968;&#20010;&#30456;&#24212;&#20998;&#37327; <code>closedge[i-1]</code>&#65292;&#23427;&#21253;&#25324;&#20004;&#20010;&#22495;&#65292;&#20854;&#20013; lowcost &#23384;&#20648;&#35813;&#36793;&#19978;&#30340;&#26435;&#12290;&#26174;&#28982;&#65292;<code>closedge[i].lowcost</code> = min{ cost(u, v<sub>i</sub>), u &#8712; U }&#12290; adjvex &#22495;&#23384;&#20648;&#35813;&#36793;&#20381;&#38468;&#30340;&#22312; U &#20013;&#30340;&#39030;&#28857;&#12290;</p>
<p>TODO, add picture url.</p>
<pre><code>+-----------------------+-----------------------+-------------------------------+-----------------------------------+
|       \               |                       |                               |                                   |
|          \       i    |                       |                               |                                   |
|             \         |   v1  v2  v3  v4  v5  |   U                           |   V-U                             |
|                \      |                       |                               |                                   |
|       closedge    \   |                       |                               |                                   |
+-----------------------+-----------------------+-------------------------------+-----------------------------------+
|       adjvex          |   v0  v0  v0          |   v0                          |   {v1, v2, v3, v4, v5}            |
|       lowcost         |   6   1   5           |                               |                                   |
|                       |       ^               |                               |                                   |
+-----------------------+-----------------------+-------------------------------+-----------------------------------+
|       adjvex          |   v2      v1  v2  v3  |   v0, v2                      |   {v1, v3, v4, v5}                |
|       lowcost         |   5   0   5   6   4   |                               |                                   |
|                       |                   ^   |                               |                                   |
+-----------------------+-----------------------+-------------------------------+-----------------------------------+
|       adjvex          |   v2      v5  v2      |   v0, v2, v5                  |   {v1,v3, v4}                     |
|       lowcost         |   5   0   2   6   0   |                               |                                   |
|                       |           ^           |                               |                                   |
+-----------------------+-----------------------+-------------------------------+-----------------------------------+
|       adjvex          |   v2          v2      |   v0, v2, v5, v3              |   {v1, v4}                        |
|       lowcost         |   5   0   0   6   0   |                               |                                   |
|                       |   ^                   |                               |                                   |
+-----------------------+-----------------------+-------------------------------+-----------------------------------+
|       adjvex          |               v1      |   v0, v2, v5, v3, v1          |   {v4}                            |
|       lowcost         |   0   0   0   3   0   |                               |                                   |
|                       |               ^       |                               |                                   |
+-----------------------+-----------------------+-------------------------------+-----------------------------------+
|       adjvex          |                       |   v0, v2, v5, v3, v1, v4      |   {}                              |
|       lowcost         |   0   0   0   0   0   |                               |                                   |
+-----------------------+-----------------------+-------------------------------+-----------------------------------+</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;climits&gt;                          </span><span class="co">// INT_MAX</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> MAX_NV = <span class="dv">100</span>;

<span class="kw">typedef</span> <span class="dt">int</span> graph_weight_t;
<span class="dt">const</span> graph_weight_t GRAPH_INF = INT_MAX;

<span class="co">// &#22270;&#65292;&#29992;&#37051;&#25509;&#30697;&#38453;(Adjacency Matrix).</span>
<span class="kw">struct</span> graph_t {
    <span class="dt">int</span> nv;
    <span class="dt">int</span> ne;
    graph_weight_t matrix[MAX_NV][MAX_NV];
};

graph_t g;

<span class="kw">struct</span> closedge_t {
    <span class="dt">int</span> adjvex;                             <span class="co">// &#24359;&#22836;&#65292;&#23646;&#20110; U</span>
    graph_weight_t lowcost;                 <span class="co">// distance: adjvex -&gt; [cur], -GRAPH_INF &#34920;&#31034;&#24050;&#32463;&#21152;&#20837; U</span>
};

<span class="co">// &#22312; V-E &#38598;&#21512;&#20013;&#23547;&#25214;&#26368;&#23567;&#30340;&#36793;</span>
<span class="co">// closedge:    MST &#20013;&#30340;&#36793;&#65292;&#36215;&#28857;&#20026; adjvex&#65292;&#32456;&#28857;&#20026;&#26412;&#19979;&#26631;</span>
<span class="co">// n:           closedge &#25968;&#32452;&#30340;&#38271;&#24230;</span>

<span class="co">// return:      &#25214;&#21040;&#20102;&#21017;&#36820;&#22238;&#24359;&#23614;&#30340;&#19979;&#26631;&#65292;V-U &#20026;&#31354;&#38598;&#21017;&#36820;&#22238; -1&#65292;&#34920;&#31034;&#32456;&#27490;</span>
<span class="dt">int</span> min_element( <span class="dt">const</span> closedge_t closedge[], <span class="dt">int</span> n ) {
    <span class="dt">int</span> min_value = GRAPH_INF;
    <span class="dt">int</span> min_pos = <span class="dv">-1</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i )
        <span class="kw">if</span>( closedge[i].lowcost &gt; -GRAPH_INF ) {            <span class="co">// not in U</span>
            <span class="kw">if</span>( min_value &gt; closedge[i].lowcost ) {
                min_value = closedge[i].lowcost;
                min_pos = i;
            }
        }
    <span class="kw">return</span> min_pos;
}

<span class="co">// Prim &#31639;&#27861;&#65292;&#27714;&#22270;&#30340;&#26368;&#23567;&#29983;&#25104;&#26641;.</span>
<span class="co">// return:      MST &#30340;&#36793;&#30340;&#26435;&#20540;&#20043;&#21644;</span>
graph_weight_t prim( <span class="dt">const</span> graph_t &amp;g ) {
    graph_weight_t sum = <span class="dv">0</span>;                 <span class="co">// &#26435;&#20540;&#20043;&#21644;</span>
    <span class="dt">const</span> <span class="dt">int</span> n = g.nv;
    <span class="dt">int</span> u = <span class="dv">0</span>;                              <span class="co">// &#20174; 0 &#21495;&#39030;&#28857;&#20986;&#21457;</span>

    <span class="co">// closedge[n]&#65292;&#35760;&#24405;&#20174;&#39030;&#28857;&#38598; U &#21040; V-U &#30340;&#36793;</span>
    closedge_t *closedge = <span class="kw">new</span> closedge_t[n];

    <span class="co">// &#36741;&#21161;&#25968;&#32452;&#21021;&#22987;&#21270;</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
        <span class="kw">if</span>( i == u ) { <span class="kw">continue</span>; }
        closedge[i].adjvex = u;
        closedge[i].lowcost = g.matrix[u][i];
    }
    closedge[u].lowcost = -GRAPH_INF;       <span class="co">// &#21021;&#22987;, U = {u}</span>

    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
        <span class="kw">if</span>( i == u ) { <span class="kw">continue</span>; }
        <span class="co">// &#20854;&#20313;&#30340; n-1 &#20010;&#39030;&#28857;</span>
        <span class="co">// &#27714;&#20986; TE &#30340;&#19979;&#19968;&#20010;&#39030;&#28857; k</span>
        <span class="dt">int</span> k = min_element( closedge, n );
        <span class="co">// &#36755;&#20986;&#27492;&#36793; closedge[k].adjvex --&gt; k</span>
        printf( <span class="st">&quot;</span><span class="ch">%c</span><span class="st"> - </span><span class="ch">%c</span><span class="st">: </span><span class="ch">%d\n</span><span class="st">&quot;</span>, <span class="st">&#39;A&#39;</span>+closedge[k].adjvex, <span class="st">&#39;A&#39;</span>+k, g.matrix[closedge[k].adjvex][k] );

        sum += g.matrix[closedge[k].adjvex][k];         <span class="co">// sum += closedge[k].lowcost;</span>

        closedge[k].lowcost = -GRAPH_INF;               <span class="co">// &#39030;&#28857; k &#24182;&#20837; U&#65292;&#34920;&#31034;&#27492;&#36793;&#21152;&#20837; TE</span>
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j ) {                  <span class="co">// &#26356;&#26032; k &#30340;&#37051;&#25509;&#28857;&#30340;&#20540;</span>
            <span class="dt">const</span> graph_weight_t &amp;w = g.matrix[k][j];
            <span class="kw">if</span>( w &lt; closedge[j].lowcost ) {
                closedge[j].adjvex  = k;
                closedge[j].lowcost = w;
            }
        }
    }
    <span class="kw">delete</span>[] closedge;
    <span class="kw">return</span> sum;
}

<span class="co">// &#35835;&#21462;&#36755;&#20837;&#65292;&#26500;&#24314;&#22270;.</span>
<span class="dt">void</span> read_graph() {
    <span class="dt">int</span> m, n;
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;m, &amp;n );               <span class="co">// #vertex, #edge</span>
    g.nv = m;
    g.ne = n;

    <span class="co">// &#21021;&#22987;&#21270;&#22270;&#65292;&#25152;&#26377;&#33410;&#28857;&#38388;&#36317;&#31163;&#20026;&#26080;&#31351;&#22823;</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; m; ++j ) {
            g.matrix[i][j] = GRAPH_INF;
        }
    }

    <span class="co">// &#35835;&#21462;&#36793;&#20449;&#24687;</span>
    <span class="kw">for</span>( <span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; ++k ) {
        <span class="dt">char</span> chx[<span class="dv">5</span>], chy[<span class="dv">5</span>];
        <span class="dt">int</span> w;
        scanf( <span class="st">&quot;</span><span class="ch">%s</span><span class="st"> </span><span class="ch">%s</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, chx, chy, &amp;w );
        <span class="dt">int</span> i = chx[<span class="dv">0</span>] - <span class="st">&#39;A&#39;</span>;
        <span class="dt">int</span> j = chy[<span class="dv">0</span>] - <span class="st">&#39;A&#39;</span>;
        g.matrix[i][j] = w;
        g.matrix[j][i] = w;
    }
}

<span class="dt">int</span> main() {
    read_graph();
    printf( <span class="st">&quot;Total: </span><span class="ch">%d\n</span><span class="st">&quot;</span>, prim(g) );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cat</span> input.txt
<span class="kw">7</span> 11
<span class="kw">A</span> B 7
<span class="kw">A</span> D 5
<span class="kw">B</span> C 8
<span class="kw">B</span> D 9
<span class="kw">B</span> E 7
<span class="kw">C</span> E 5
<span class="kw">D</span> E 15
<span class="kw">D</span> F 6
<span class="kw">E</span> F 8
<span class="kw">E</span> G 9
<span class="kw">F</span> G 11

$ <span class="kw">cat</span> input.txt <span class="kw">|</span> <span class="kw">./tmp</span>
<span class="kw">A</span> - D: 5
<span class="kw">D</span> - F: 6
<span class="kw">A</span> - B: 7
<span class="kw">B</span> - E: 7
<span class="kw">E</span> - C: 5
<span class="kw">E</span> - G: 9
<span class="kw">Total</span>: 39</code></pre></div>
<p><strong>&#31639;&#27861;&#20998;&#26512;</strong></p>
<p>&#20551;&#35774;&#32593;&#20013;&#26377; n &#20010;&#39030;&#28857;&#65292;&#21017;&#31532;&#19968;&#20010;&#36827;&#34892;&#21021;&#22987;&#21270;&#30340;&#24490;&#29615;&#35821;&#21477;&#30340;&#39057;&#24230;&#20026; n&#65292;&#31532;&#20108;&#20010;&#24490;&#29615;&#35821;&#21477;&#30340;&#39057;&#24230;&#20026; n-1&#12290;&#20854;&#20013;&#26377;&#20004;&#20010;&#20869;&#24490;&#29615;&#65306;&#20854;&#19968;&#26159;&#22312; <code>closedge[v].lowcost</code> &#20013;&#27714;&#26368;&#23567;&#20540;&#65292;&#20854;&#39057;&#24230;&#20026; n-1&#65307;&#20854;&#20108;&#26159;&#37325;&#26032;&#36873;&#25321;&#20855;&#26377;&#26368;&#23567;&#20195;&#20215;&#30340;&#36793;&#65292;&#20854;&#39057;&#24230;&#20026; n&#12290;<strong>&#22240;&#27492; Prim &#31639;&#27861;&#30340;&#26102;&#38388;&#22797;&#26434;&#24230;&#20026; O(n<sup>2</sup>)&#65292;&#19982;&#32593;&#20013;&#36793;&#25968;&#26080;&#20851;&#65292;&#22240;&#27492;&#36866;&#29992;&#20110;&#27714;&#36793;&#31264;&#23494;&#30340;&#22270;&#30340;&#26368;&#23567;&#29983;&#25104;&#26641;&#12290;</strong></p>
<p>Prim &#31639;&#27861;&#30340;&#21478;&#19968;&#31181;&#23454;&#29616;&#26159;&#20351;&#29992;&#23567;&#26681;&#22534;&#65292;&#20854;&#27969;&#31243;&#26159;&#65306;&#23567;&#26681;&#22534;&#20013;&#23384;&#20648;&#19968;&#20010;&#31471;&#28857;&#22312;&#29983;&#25104;&#26641;&#20013;&#65292;&#21478;&#19968;&#20010;&#31471;&#28857;&#19981;&#22312;&#29983;&#25104;&#26641;&#30340;&#36793;&#65292;&#27599;&#27425;&#20174;&#23567;&#26681;&#22534;&#30340;&#22534;&#39030;&#21487;&#36873;&#20986;&#26435;&#20540;&#26368;&#23567;&#30340;&#36793; (u, v)&#65292;&#23558;&#20854;&#20174;&#22534;&#20013;&#25512;&#20986;&#65292;&#21152;&#20837;&#29983;&#25104;&#26641;&#20013;&#12290;&#28982;&#21518;&#23558;&#26032;&#20986;&#29616;&#30340;&#25152;&#26377;&#19968;&#20010;&#31471;&#28857;&#22312;&#29983;&#25104;&#26641;&#20013;&#65292;&#19968;&#20010;&#31471;&#28857;&#19981;&#22312;&#29983;&#25104;&#26641;&#30340;&#36793;&#37117;&#25554;&#20837;&#23567;&#26681;&#22534;&#20013;&#12290;&#19979;&#19968;&#36718;&#36845;&#20195;&#20013;&#65292;&#19979;&#19968;&#26465;&#28385;&#36275;&#35201;&#27714;&#30340;&#36793;&#21448;&#19978;&#21319;&#21040;&#22534;&#39030;&#12290;&#22914;&#27492;&#37325;&#22797; n-1 &#27425;&#65292;&#26368;&#21518;&#24314;&#31435;&#36215;&#35813;&#22270;&#30340;&#26368;&#23567;&#29983;&#25104;&#26641;&#12290;&#35813;&#31639;&#27861;&#30340;C &#20195;&#30721;&#23454;&#29616;&#22914;&#19979;&#12290;</p>
<p>```cpp #include <iostream> #include <climits> // INT_MAX #include <queue> #include <vector> #include <algorithm></p>
<p>using namespace std;</p>
<p>const int MAX_NV = 100;</p>
<p>typedef int graph_weight_t; const graph_weight_t GRAPH_INF = INT_MAX;</p>
<p>// &#22270;&#65292;&#29992;&#37051;&#25509;&#30697;&#38453; (Adjacency Matrix). struct graph_t { int nv; int ne; graph_weight_t matrix[MAX_NV][MAX_NV]; };</p>
<p>graph_t g;</p>
<p>// &#36793; struct edge_t { int u; // from int v; // to graph_weight_t w; // &#26435;&#20540; bool operator&gt;( const edge_t &amp;other ) const { return w &gt; other.w; } };</p>
<p>// Prim &#31639;&#27861;&#65292;&#27714;&#22270;&#30340;&#26368;&#23567;&#29983;&#25104;&#26641;. // return: MST &#30340;&#36793;&#30340;&#26435;&#20540;&#20043;&#21644; int prim( const graph_t &amp;g ){ graph_weight_t sum = 0; // &#26435;&#20540;&#20043;&#21644; priority_queue&lt;edge_t, vector<edge_t>, greater<edge_t> &gt; pq; const int n = g.nv; vector<int> used( n, 0 ); // &#21028;&#26029;&#39030;&#28857;&#26159;&#21542;&#24050;&#32463;&#21152;&#20837;&#26368;&#23567;&#29983;&#25104;&#26641;</p>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
<p>char <em> strncpy(char </em>dest, const char *src, size_t n) { size_t i;</p>
<pre><code>   for (i = 0; i &lt; n &amp;&amp; src[i] != &#39;\0&#39;; i++)
       dest[i] = src[i];
   for ( ; i &lt; n; i++)
       dest[i] = &#39;\0&#39;;

   return dest;</code></pre>
<p>} int u = 0; // &#20174; 0 &#21495;&#39030;&#28857;&#20986;&#21457; used[u] = 1; int count = 1; // MLE &#24403;&#21069;&#30340;&#36793;&#25968;</p>
<pre><code>                // &#24320;&#22987;&#39030;&#28857;&#21152;&#20837; U (&#25152;&#20197; count &#21021;&#22987;&#20026; 1)
                while( count &lt; n ) {
                    for( int v = 0; v &lt; n; ++v ) {
                        if( !used[v] ) {
                            edge_t e = {u, v, g.matrix[u][v]};  // &#33509; v &#19981;&#22312;&#29983;&#25104;&#26641;&#65292;(u,v) &#21152;&#20837;&#22534;
                            pq.push(e);
                        }
                    }
                    while( !pq.empty() &amp;&amp; count &lt; n ) {
                        edge_t e = pq.top(); pq.pop();          // &#20174;&#22534;&#20013;&#36864;&#20986;&#26368;&#23567;&#26435;&#20540;&#36793;&#65292;&#23384;&#20837; e
                        if( used[e.v] ) { continue; }

                        printf( &quot;%c - %c: %d\n&quot;, &#39;A&#39;+e.u, &#39;A&#39;+e.v, g.matrix[e.u][e.v] );
                        sum += g.matrix[e.u][e.v];
                        u = e.v;
                        used[u] = 1;                            // u &#24182;&#20837;&#21040;&#29983;&#25104;&#26641;&#30340;&#39030;&#28857;&#38598;&#21512; U
                        ++count;
                        break;

                    }
                }

                return sum;
            }

            // &#35835;&#21462;&#36755;&#20837;&#65292;&#26500;&#24314;&#22270;.
            void read_graph() {
                int m, n;
                scanf( &quot;%d %d&quot;, &amp;m, &amp;n );                       // #vertex, #edge
                g.nv = m;
                g.ne = n;

                // &#21021;&#22987;&#21270;&#22270;&#65292;&#25152;&#26377;&#33410;&#28857;&#38388;&#36317;&#31163;&#20026;&#26080;&#31351;&#22823;
                for( int i = 0; i &lt; m; ++i ) {
                    for( int j = 0; j &lt; m; ++j ) {
                        g.matrix[i][j] = GRAPH_INF;
                    }
                }

                // &#35835;&#21462;&#36793;&#20449;&#24687;
                for( int k = 0; k &lt; n; ++k ) {
                    char chx[5], chy[5];
                    int w;
                    scanf( &quot;%s %s %d&quot;, chx, chy, &amp;w );
                    int i = chx[0] - &#39;A&#39;;
                    int j = chy[0] - &#39;A&#39;;
                    g.matrix[i][j] = w;
                    g.matrix[j][i] = w;
                }
            }

            int main() {
                read_graph();
                printf( &quot;Total: %d\n&quot;, prim(g) );
                return 0;
            }
            ```

            &#35813;&#31639;&#27861;&#36845;&#20195;&#27425;&#25968;&#20026; O(n)&#65292;&#27599;&#27425;&#36845;&#20195;&#23558;&#24179;&#22343; e/n &#26465;&#36793;&#25554;&#20837;&#26368;&#23567;
            &#22534;&#20013;&#65292;e &#26465;&#36793;&#20174;&#22534;&#20013;&#21024;&#38500;&#65292;&#22534;&#30340;&#25554;&#20837;&#21644;&#21024;&#38500;&#25805;&#20316;&#26102;&#38388;&#22797;&#26434;&#24230;&#22343;
            &#20026; O(log~2~e)&#65292;&#21017;&#24635;&#30340;&#26102;&#38388;&#22797;&#26434;&#24230;&#20026; O(e*log~2~e)&#12290;

    -   Kruskal &#31639;&#27861; `@`{.fold}

        :   &#20551;&#35774;&#36830;&#36890;&#32593; N = {V, E}&#65292;&#21017;&#20196;&#26368;&#23567;&#29983;&#25104;&#26641;&#30340;&#21021;&#22987;&#29366;&#24577;&#20026;&#21482;&#26377; n
            &#20010;&#39030;&#28857;&#32780;&#26080;&#36793;&#30340;&#38750;&#36830;&#36890;&#22270; T = (V, {})&#65292;&#22270;&#20013;&#27599;&#20010;&#39030;&#28857;&#33258;&#25104;&#19968;
            &#20010;&#36830;&#36890;&#20998;&#37327;&#12290;&#22312; E &#20013;&#36873;&#25321;&#20195;&#20215;&#26368;&#23567;&#30340;&#36793;&#65292;&#33509;&#35813;&#36793;&#20381;&#38468;&#30340;&#39030;&#28857;&#33853;
            &#22312; T &#20013;&#19981;&#21516;&#30340;&#36830;&#36890;&#20998;&#37327;&#19978;&#65292;&#21017;&#23558;&#27492;&#36793;&#21152;&#20837;&#21040; T &#20013;&#65292;&#21542;&#21017;&#33293;&#21435;&#27492;
            &#36793;&#32780;&#36873;&#25321;&#19979;&#19968;&#26465;&#20195;&#20215;&#26368;&#23567;&#30340;&#36793;&#12290;&#20381;&#27425;&#31867;&#25512;&#65292;&#30452;&#33267; T &#20013;&#25152;&#26377;&#39030;&#28857;
            &#37117;&#22312;&#21516;&#19968;&#36830;&#36890;&#20998;&#37327;&#19978;&#20026;&#27490;&#12290;

            ```cpp
            #include &lt;iostream&gt;
            #include &lt;queue&gt;
            #include &lt;algorithm&gt;
            #include &lt;stdlib.h&gt;

            using namespace std;

            struct edge_t{
                int u, v, w;
                bool operator&gt;( const edge_t &amp;other ) const {
                    return w &gt; other.w;
                }
            };

            const int MAX_NV = 11;
            const int MAX_NE = 100;
            edge_t edges[MAX_NE];

            // union-find set
            struct UFS {
                explicit UFS( int n ) { arr = vector&lt;int&gt;(n, -1); }
                int Find( int idx ) {
                    int oldidx = idx;
                    while( arr[idx] &gt;= 0 ) { idx = arr[idx]; }
                    while( oldidx != idx ) {
                        int next = arr[oldidx];
                        arr[oldidx] = idx;
                        oldidx = next;
                    }
                    return idx;
                }
                void Union( int a, int b ) {
                    int ra = Find(a), rb = Find(b);
                    if( ra == rb ) { return; }
                    arr[ra] += arr[rb];
                    arr[rb] = ra;
                }
                int Size( int a ) { return -arr[Find(a)]; }
                vector&lt;int&gt; arr;
            };

            // Kruskal &#31639;&#27861;&#65292;&#22534; + &#24182;&#26597;&#38598;.
            // edges:       &#36793;&#30340;&#25968;&#32452;
            // n:           &#36793;&#25968;&#65292;&#19968;&#23450;&#35201;&#22823;&#20110;&#25110;&#31561;&#20110; (&#39030;&#28857;&#25968; -1)
            // m:           &#39030;&#28857;&#25968;
            // return:      MST&#30340;&#36793;&#30340;&#26435;&#20540;&#20043;&#21644;
            int kruskal( const edge_t edges[], int n, int m ) {
                if( n &lt; m - 1 ) { return -1; }
                int sum = 0;
                priority_queue&lt;edge_t, vector&lt;edge_t&gt;, greater&lt;edge_t&gt; &gt; pq;
                // &#25226;&#25152;&#26377;&#36793;&#25554;&#20837;&#22534;&#20013;
                for( int i = 0; i &lt; n; ++i ) {
                    pq.push( edges[i] );
                }
                UFS ufs( MAX_NV );
                for( int i = 0; i &lt; n; ++i ) {
                    edge_t e = pq.top(); pq.pop();      // &#20174;&#22534;&#20013;&#36864;&#20986;&#26368;&#23567;&#26435;&#20540;&#36793;
                    // &#21462;&#20004;&#39030;&#28857;&#25152;&#22312;&#38598;&#21512;&#30340;&#26681;
                    int u = ufs.Find( e.u );
                    int v = ufs.Find( e.v );
                    if( u != v ) {                      // &#19981;&#26159;&#21516;&#19968;&#38598;&#21512;&#65292;&#35828;&#26126;&#19981;&#36830;&#36890;
                        ufs.Union( u, v );              // &#21512;&#24182;&#65292;&#36830;&#36890;&#25104;&#19968;&#20010;&#20998;&#37327;
                        // &#36755;&#20986;&#29983;&#25104;&#26641; TE &#30340;&#36793;&#65292;&#21363;&#27492;&#36793;&#21152;&#20837; TE
                        printf( &quot;%c - %c: %d\n&quot;, &#39;A&#39;+e.u, &#39;A&#39;+e.v, e.w );
                        sum += e.w;
                    }
                }
                return sum;
            }

            int main() {
                int m, n;
                scanf( &quot;%d %d&quot;, &amp;m, &amp;n );                       // #vertex, #edge
                for (int i = 0; i &lt; n; i++) {                   // &#35835;&#21462;&#36793;&#20449;&#24687;
                    char chx[5], chy[5];
                    int w;
                    scanf( &quot;%s %s %d&quot;, chx, chy, &amp;w );
                    int u = chx[0] - &#39;A&#39;;
                    int v = chy[0] - &#39;A&#39;;
                    edges[i].u = u;
                    edges[i].v = v;
                    edges[i].w = w;
                }
                // &#27714;&#35299;&#26368;&#23567;&#29983;&#25104;&#26641;
                printf( &quot;Total: %d\n&quot;, kruskal(edges, n, m) );
                return 0;
            }
            ```

            sort + union-find set

            :   ```cpp
                // for std::sort
                bool operator&lt;( const edge_t &amp;e1, const edge_t &amp;e2 ) {
                    return e1.w &lt; e2.w;
                }

                // Kruskal &#31639;&#27861;&#65292;&#24555;&#25490; + &#24182;&#26597;&#38598;
                int kruskal2( edge_t edges[], int n, int m ) {
                    if( n &lt; m - 1) { return -1; }
                    int sum = 0;
                    std::sort( edges, edges + n );
                    UFS ufs( MAX_NV );
                    for( int i = 0; i &lt; n; ++i ) {
                        edge_t &amp;e = edges[i];
                        int u = ufs.Find( e.u );
                        int v = ufs.Find( e.v );
                        if( u != v ) {
                            ufs.Union( u, v );
                            printf( &quot;%c - %c: %d\n&quot;, &#39;A&#39;+e.u, &#39;A&#39;+e.v, e.w );
                            sum += e.w;
                        }
                    }
                    return sum;
                }
                ```

                &#22914;&#26524;&#37319;&#29992;&#37051;&#25509;&#30697;&#38453;&#20316;&#20026;&#22270;&#30340;&#23384;&#20648;&#32467;&#26500;&#65292;&#21017;&#22312;&#24314;&#31435;&#23567;&#26681;&#22534;&#26102;
                &#38656;&#35201;&#26816;&#27979;&#22270;&#30340;&#37051;&#25509;&#30697;&#38453;&#65292;&#36825;&#38656;&#35201; O(n^2^) &#30340;&#26102;&#38388;&#12290;&#27492;&#22806;&#65292;
                &#38656;&#35201;&#23558; e &#26465;&#36793;&#32452;&#25104;&#21021;&#22987;&#30340;&#23567;&#26681;&#22534;&#12290;&#22914;&#26524;&#30452;&#25509;&#20174;&#31354;&#22534;&#24320;&#22987;&#65292;
                &#20381;&#27425;&#25554;&#20837;&#21508;&#36793;&#65292;&#38656;&#35201; O(e*log~2~e) &#30340;&#26102;&#38388;&#12290;&#22312;&#26500;&#36896;&#26368;&#23567;
                &#29983;&#25104;&#26641;&#30340;&#36807;&#31243;&#20013;&#65292;&#38656;&#35201;&#36827;&#34892; O(e) &#27425;&#20986;&#22534;&#25805;&#20316;
                `heap_remove()`&#12289;2e &#27425;&#24182;&#26597;&#38598;&#30340; `ufs.Find()` &#25805;&#20316;&#20197;
                &#21450; n-1 &#27425;`ufs.Union()` &#25805;&#20316;&#65292;&#35745;&#31639;&#26102;&#38388;&#20998;&#21035;&#20026;
                O(e*log~2~e)&#12289;O(log~2~n) &#21644; O(n)&#65292;&#25152;&#20197;&#24635;&#26102;&#38388;&#20026;
                O(n^2^+e*log~2~e)&#12290;

                &#22914;&#26524;&#37319;&#29992;&#37051;&#25509;&#34920;&#20316;&#20026;&#22270;&#30340;&#23384;&#20648;&#32467;&#26500;&#65292;&#21017;&#22312;&#24314;&#31435;&#23567;&#26681;&#22534;&#26102;&#38656;
                &#35201;&#26816;&#27979;&#22270;&#30340;&#37051;&#25509;&#34920;&#65292;&#36825;&#38656;&#35201; O(n+e) &#30340;&#26102;&#38388;&#12290;&#20026;&#24314;&#25104;&#21021;&#22987;
                &#30340;&#23567;&#26681;&#22534;&#65292;&#38656;&#35201; O(e*log~2~e) &#30340;&#26102;&#38388;&#12290;&#22312;&#26500;&#36896;&#26368;&#23567;&#29983;&#25104;
                &#26641;&#30340;&#36807;&#31243;&#20013;&#65292;&#38656;&#35201;&#36827;&#34892; O(e) &#27425;&#20986;&#22534;&#25805;&#20316;`heap_remove()`
                &#12289;2e &#27425;&#24182;&#26597;&#38598;&#30340; `ufs.Find()` &#25805;&#20316;&#20197;&#21450; n-1 &#27425;
                `ufs.Union()` &#25805;&#20316;&#65292;&#35745;&#31639;&#26102;&#38388;&#20998;&#21035;&#20026; O(e*log~2~e)&#12289;
                O(e*log~2~n) &#21644; O(n)&#65292;&#25152;&#20197;&#24635;&#26102;&#38388;&#20026; O(n+e*log~2~e)&#12290;

    -   Highways `@`{.fold}

        :   &#19968;&#20010;&#21517;&#21483; Flatopia &#30340;&#23707;&#22269;&#22320;&#21183;&#38750;&#24120;&#24179;&#22374;&#12290;&#19981;&#24184;&#30340;&#26159; Flatopia
            &#30340;&#20844;&#20849;&#39640;&#36895;&#20844;&#36335;&#31995;&#32479;&#24456;&#24046;&#21170;&#12290;Flatopia &#30340;&#25919;&#24220;&#20063;&#24847;&#35782;&#21040;&#20102;&#36825;&#20010;
            &#38382;&#39064;&#65292;&#24050;&#32463;&#24314;&#36896;&#20102;&#35768;&#22810;&#39640;&#36895;&#20844;&#36335;&#29992;&#26469;&#36830;&#25509;&#27604;&#36739;&#37325;&#35201;&#30340;&#22478;&#38215;&#12290;&#19981;
            &#36807;&#65292;&#20173;&#28982;&#26377;&#19968;&#20123;&#22478;&#38215;&#27809;&#26377;&#25509;&#20837;&#39640;&#36895;&#20844;&#36335;&#12290;&#22240;&#27492;&#65292;&#24456;&#26377;&#24517;&#35201;&#24314;&#36896;
            &#26356;&#22810;&#30340;&#39640;&#36895;&#20844;&#36335;&#65292;&#35753;&#20219;&#24847;&#20004;&#20010;&#22478;&#38215;&#20043;&#38388;&#21487;&#20197;&#36890;&#36807;&#39640;&#36895;&#20844;&#36335;&#36830;&#25509;&#12290;

            Flatopia &#30340;&#22478;&#38215;&#20174; 1 &#21040; N &#32534;&#21495;&#65292;&#22478;&#38215; i &#30340;&#20301;&#32622;&#30001;&#31515;&#21345;&#23572;&#22352;
            &#26631; (x~i~, y~i~) &#34920;&#31034;&#12290;&#27599;&#26465;&#39640;&#36895;&#20844;&#36335;&#20165;&#36830;&#25509;&#20004;&#20010;&#22478;&#38215;&#12290;&#25152;&#26377;
            &#30340;&#39640;&#36895;&#20844;&#36335;&#37117;&#26159;&#30452;&#32447;&#65292;&#22240;&#27492;&#23427;&#20204;&#30340;&#38271;&#24230;&#23601;&#31561;&#20110;&#20004;&#20010;&#22478;&#38215;&#20043;&#38388;&#30340;
            &#27431;&#27663;&#36317;&#31163;&#12290;&#25152;&#26377;&#30340;&#39640;&#36895;&#20844;&#36335;&#26159;&#21452;&#21521;&#30340;&#65292;&#39640;&#36895;&#20844;&#36335;&#20043;&#38388;&#21487;&#20197;&#30456;&#20132;&#65292;
            &#20294;&#26159;&#21496;&#26426;&#21482;&#33021;&#22312;&#20844;&#36335;&#30340;&#31471;&#28857;&#65288;&#20063;&#21363;&#22478;&#38215;&#65289;&#25442;&#36947;&#12290;

            Flatopia &#25919;&#24220;&#24076;&#26395;&#33021;&#26368;&#23567;&#21270;&#24314;&#36896;&#39640;&#36895;&#20844;&#36335;&#30340;&#20195;&#20215;&#12290;&#30001;&#20110;
            Flatopia &#22320;&#21183;&#24179;&#22374;&#65292;&#19968;&#26465;&#39640;&#36895;&#20844;&#36335;&#30340;&#20195;&#20215;&#27491;&#27604;&#20110;&#23427;&#30340;&#38271;&#24230;&#12290;&#22240;
            &#27492;&#65292;&#24212;&#35813;&#35753;&#39640;&#36895;&#20844;&#36335;&#30340;&#24635;&#38271;&#24230;&#26368;&#23567;&#12290;

            ```
            &#36755;&#20837;

                &#36755;&#20837;&#30001;&#20004;&#37096;&#20998;&#32452;&#25104;&#12290;
                &#31532;&#19968;&#37096;&#20998;&#25551;&#36848;&#25152;&#26377;&#30340;&#22478;&#38215;&#65292;
                &#31532;&#20108;&#37096;&#20998;&#25551;&#36848;&#25152;&#26377;&#24050;&#32463;&#24314;&#36896;&#22909;&#30340;&#39640;&#36895;&#20844;&#36335;&#12290;

                &#31532;&#19968;&#34892;&#21253;&#21547;&#19968;&#20010;&#25972;&#25968; N (1 &lt;= N &lt;= 750)&#65292;&#34920;&#31034;&#22478;&#38215;&#30340;&#25968;&#30446;&#12290;
                &#25509;&#19979;&#26469;&#30340; N &#34892;&#27599;&#34892;&#21253;&#21547;&#19968;&#23545;&#25972;&#25968;&#65292;x_i &#21644; y_i&#65292;&#30001;&#31354;&#26684;&#38548;&#24320;&#65292;
                &#34920;&#31034;&#31532; i &#20010;&#22478;&#38215;&#30340;&#22352;&#26631;&#12290;&#22352;&#26631;&#30340;&#32477;&#23545;&#20540;&#19981;&#20250;&#36229;&#36807; 10000&#12290;
                &#27599;&#20010;&#22478;&#38215;&#30340;&#22352;&#26631;&#37117;&#19981;&#37325;&#21472;&#12290;

                &#25509;&#19979;&#26469;&#19968;&#34892;&#21253;&#21547;&#19968;&#20010;&#25972;&#25968; M (0 &lt;= M &lt;= 1000)&#65292;&#34920;&#31034;&#24050;&#32463;&#23384;&#22312;&#30340;&#39640;&#36895;&#20844;&#36335;&#30340;&#25968;&#30446;&#12290;
                &#25509;&#19979;&#26469;&#30340; M &#34892;&#27599;&#34892;&#21253;&#21547;&#19968;&#23545;&#25972;&#25968;&#65292;&#32473;&#20986;&#20102;&#19968;&#23545;&#22478;&#38215;&#32534;&#21495;&#65292;&#34920;&#31034;&#36825;&#20004;&#20010;&#22478;&#38215;&#34987;&#19968;&#26465;&#39640;&#36895;&#20844;&#36335;&#36830;&#25509;&#36215;&#26469;&#12290;
                &#27599;&#20004;&#20010;&#22478;&#38215;&#20043;&#38388;&#26368;&#22810;&#34987;&#19968;&#26465;&#39640;&#36895;&#20844;&#36335;&#36830;&#25509;&#12290;

                9
                1 5
                0 0
                3 2
                4 5
                5 1
                0 4
                5 2
                1 2
                5 3
                3
                1 3
                9 7
                1 2

            &#36755;&#20986;

                &#36755;&#20986;&#25152;&#26377;&#38656;&#35201;&#26032;&#24314;&#30340;&#39640;&#36895;&#20844;&#36335;&#12290;&#27599;&#34892;&#19968;&#20010;&#39640;&#36895;&#20844;&#36335;&#65292;&#29992;&#19968;&#23545;&#22478;&#38215;&#32534;&#21495;&#34920;&#31034;&#12290;
                &#22914;&#26524;&#19981;&#38656;&#35201;&#26032;&#24314;&#39640;&#36895;&#20844;&#36335;&#65292;&#36755;&#20986;&#20026;&#31354;&#12290;

                1 6
                3 7
                4 9
                5 7
                8 3
            ```

            &#24456;&#26126;&#26174;&#65292;&#26368;&#23567;&#29983;&#25104;&#26641;&#12290;

            **&#39064;&#20013;&#30340;&#32593;&#32476;&#26159;&#19968;&#20010;&#23436;&#20840;&#22270;&#65292;&#20219;&#24847;&#20004;&#20010;&#22478;&#38215;&#20043;&#38388;&#37117;&#26377;&#36793;&#65292;&#26435;&#20540;&#26159;
            &#20004;&#28857;&#38388;&#30340;&#36317;&#31163;&#12290;&#22240;&#27492; Prim &#31639;&#27861;&#27604; Kruskal &#31639;&#27861;&#25928;&#29575;&#26356;&#39640;&#12290;**

            &#23545;&#20110;&#24050;&#32463;&#23384;&#22312;&#30340;&#39640;&#36895;&#20844;&#36335;&#65292;&#20196;&#23427;&#20204;&#26435;&#20540;&#20026; 0&#65292;&#21487;&#20197;&#20445;&#35777;&#23427;&#20204;&#19968;&#23450;&#20250;&#34987;&#36873;&#20013;&#12290;

            &#22240;&#20026;&#39064;&#30446;&#21482;&#38656;&#35201;&#36755;&#20986;&#26032;&#24314;&#30340;&#39640;&#36895;&#20844;&#36335;&#30340;&#20004;&#20010;&#31471;&#28857;&#65292;&#19981;&#38656;&#35201;&#36755;&#20986;
            &#26368;&#23567;&#29983;&#25104;&#26641;&#30340;&#38271;&#24230;&#65292;&#25152;&#20197;&#35745;&#31639;&#36317;&#31163;&#30340;&#26102;&#20505;&#19981;&#29992; sqrt&#65292;&#20063;&#23601;&#19981;&#29992; double &#20102;&#12290;

            ```cpp
            #include &lt;cstdio&gt;
            #include &lt;queue&gt;
            #include &lt;vector&gt;

            using namespace std;

            const int MAX_NV = 750;
            int n, m, x[MAX_NV], y[MAX_NV];

            struct graph_t {
                int nv, ne;
                int matrix[MAX_NV][MAX_NV];
            };
            graph_t g;

            struct edge_t {
                int u, v, w;
                bool operator&gt;( const edge_t &amp;other ) const { return w &gt; other.w; }
            };

            int u;                                              // &#20174; u &#21495;&#39030;&#28857;&#20986;&#21457;

            void prim( const graph_t &amp;g ){
                priority_queue&lt;edge_t, vector&lt;edge_t&gt;, greater&lt;edge_t&gt; &gt; pq;
                const int n = g.nv;
                vector&lt;int&gt; used( n, 0 );                       // &#21028;&#26029;&#39030;&#28857;&#26159;&#21542;&#24050;&#32463;&#21152;&#20837;&#26368;&#23567;&#29983;&#25104;&#26641;

                used[u] = 1;
                int count = 1;                                  // MLE &#24403;&#21069;&#30340;&#36793;&#25968;

                // &#24320;&#22987;&#39030;&#28857;&#21152;&#20837; U (&#25152;&#20197; count &#21021;&#22987;&#20026; 1)
                while( count &lt; n ) {
                    for( int v = 0; v &lt; n; ++v ) {
                        if( !used[v] ) {
                            edge_t e = {u, v, g.matrix[u][v]};  // &#33509; v &#19981;&#22312;&#29983;&#25104;&#26641;&#65292;(u,v) &#21152;&#20837;&#22534;
                            pq.push(e);
                        }
                    }
                    while( !pq.empty() &amp;&amp; count &lt; n ) {
                        edge_t e = pq.top(); pq.pop();          // &#20174;&#22534;&#20013;&#36864;&#20986;&#26368;&#23567;&#26435;&#20540;&#36793;&#65292;&#23384;&#20837; e
                        if( used[e.v] ) { continue; }
                        if( g.matrix[e.u][e.v] &gt; 0 ) {
                            printf( &quot;%d %d\n&quot;, e.u+1, e.v+1 );
                        }
                        used[u=e.v] = 1;                        // u &#24182;&#20837;&#21040;&#29983;&#25104;&#26641;&#30340;&#39030;&#28857;&#38598;&#21512; U
                        ++count;
                        break;
                    }
                }
            }

            int main() {
                // &#35835;&#21462;&#36755;&#20837;&#65292;&#26500;&#24314;&#22270;.
                scanf( &quot;%d&quot;, &amp;n );
                g.nv = n;
                g.ne = n*(n-1)/2;
                for( int i = 0; i &lt; n; ++i ) { scanf( &quot;%d %d&quot;, &amp;x[i], &amp;y[i] ); }
                for( int i = 0; i &lt; n; ++i ) {
                    for( int j = 0; j &lt; n; ++j  ) {
                        g.matrix[i][j] = g.matrix[j][i] = (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);
                    }
                }
                scanf( &quot;%d&quot;, &amp;m );
                for( int i = 0; i &lt; m; ++i ) {
                    int a, b;
                    scanf( &quot;%d %d&quot;, &amp;a, &amp;b );
                    g.matrix[a-1][b-1] = g.matrix[b-1][a-1] = 0;
                    u = a;
                }

                prim( g );
                return 0;
            }
            ```

            &#25105;&#30340;&#36755;&#20986;&#20026;:

            ```
            1 6
            3 7
            7 5
            3 8
            9 4
            ```

            &#39034;&#24207;&#19981;&#19968;&#26679;, &#20294;&#26159;&#22478;&#24066;&#26159;&#19968;&#26679;&#30340;.

    -   &#26368;&#20248;&#24067;&#32447;&#38382;&#39064; `@`{.fold}

        :   &#23398;&#26657;&#38656;&#35201;&#23558; n &#21488;&#35745;&#31639;&#26426;&#36830;&#25509;&#36215;&#26469;&#65292;&#19981;&#21516;&#30340; 2 &#21488;&#35745;&#31639;&#26426;&#20043;&#38388;&#30340;
            &#36830;&#25509;&#36153;&#29992;&#21487;&#33021;&#26159;&#19981;&#21516;&#30340;&#12290;&#20026;&#20102;&#33410;&#30465;&#36153;&#29992;&#65292;&#25105;&#20204;&#32771;&#34385;&#37319;&#29992;&#38388;&#25509;&#25968;
            &#25454;&#20256;&#36755;&#32467;&#26463;&#65292;&#23601;&#26159;&#19968;&#21488;&#35745;&#31639;&#26426;&#21487;&#20197;&#38388;&#25509;&#22320;&#36890;&#36807;&#20854;&#20182;&#35745;&#31639;&#26426;&#23454;&#29616;
            &#21644;&#21478;&#22806;&#19968;&#21488;&#35745;&#31639;&#26426;&#36830;&#25509;&#12290;

            &#20026;&#20102;&#20351;&#24471;&#20219;&#24847;&#20004;&#21488;&#35745;&#31639;&#26426;&#20043;&#38388;&#37117;&#26159;&#36830;&#36890;&#30340;&#65288;&#19981;&#31649;&#26159;&#30452;&#25509;&#36824;&#26159;&#38388;
            &#25509;&#30340;&#65289;&#65292;&#38656;&#35201;&#22312;&#33509;&#24178;&#21488;&#35745;&#31639;&#26426;&#20043;&#38388;&#29992;&#32593;&#32447;&#30452;&#25509;&#36830;&#25509;&#65292;&#29616;&#22312;&#24819;&#20351;
            &#24471;&#24635;&#30340;&#36830;&#25509;&#36153;&#29992;&#26368;&#30465;&#65292;&#35753;&#20320;&#32534;&#31243;&#35745;&#31639;&#36825;&#20010;&#26368;&#23567;&#30340;&#36153;&#29992;&#12290;

            ```
            &#36755;&#20837;

                &#36755;&#20837;&#31532;&#19968;&#34892;&#20026;&#20004;&#20010;&#25972;&#25968; n,m (2 &lt;= n &lt;= 100000, 2 &lt;= m &lt;= 100000)&#65292;
                &#34920;&#31034;&#35745;&#31639;&#26426;&#24635;&#25968;&#65292;&#21644;&#21487;&#20197;&#20114;&#30456;&#24314;&#31435;&#36830;&#25509;&#30340;&#36830;&#25509;&#20010;&#25968;&#12290;&#25509;&#19979;
                &#26469; m &#34892;&#65292;&#27599;&#34892;&#19977;&#20010;&#25972;&#25968; a,b,c &#34920;&#31034;&#22312;&#26426;&#22120; a &#21644;&#26426;&#22120; b
                &#20043;&#38388;&#24314;&#31435;&#36830;&#25509;&#30340;&#35805;&#36153;&#26159; c&#12290;(&#39064;&#30446;&#20445;&#35777;&#19968;&#23450;&#23384;&#22312;&#21487;&#34892;&#30340;&#36830;&#36890;
                &#26041;&#26696;, &#25968;&#25454;&#20013;&#21487;&#33021;&#23384;&#22312;&#26435;&#20540;&#19981;&#19968;&#26679;&#30340;&#37325;&#36793;&#65292;&#20294;&#26159;&#20445;&#35777;&#27809;&#26377;
                &#33258;&#29615;)

                3 3
                1 2 1
                1 3 2
                2 3 1

            &#36755;&#20986;

                &#36755;&#20986;&#21482;&#26377;&#19968;&#34892;&#19968;&#20010;&#25972;&#25968;&#65292;&#34920;&#31034;&#26368;&#30465;&#30340;&#24635;&#36830;&#25509;&#36153;&#29992;&#12290;

                2
            ```

            &#26412;&#39064;&#26159;&#38750;&#24120;&#30452;&#30333;&#30340; kruskal &#31639;&#27861;&#65292;&#21487;&#20197;&#30452;&#25509;&#20351;&#29992; kruskal &#33410;&#30340;&#26679;&#20363;&#20195;&#30721;&#12290;

            ```cpp
            #include &lt;cstdio&gt;
            #include &lt;queue&gt;

            using namespace std;

            struct edge_t {
                int u, v, w;
                bool operator&gt;( const edge_t &amp;other ) const { return w &gt; other.w; }
            };
            const int MAX_NV = 100001;
            const int MAX_NE = 100000;
            edge_t edges[MAX_NE];

            struct UFS {
                explicit UFS( int n ) { arr = vector&lt;int&gt;(n, -1); }
                int Find( int idx ) {
                    int oldidx = idx;
                    while( arr[idx] &gt;= 0 ) { idx = arr[idx]; }
                    while( oldidx != idx ) {
                        int next = arr[oldidx];
                        arr[oldidx] = idx;
                        oldidx = next;
                    }
                    return idx;
                }
                void Union( int a, int b ) {
                    int ra = Find(a), rb = Find(b);
                    if( ra == rb ) { return; }
                    arr[ra] += arr[rb];
                    arr[rb] = ra;
                }
                int Size( int a ) { return -arr[Find(a)]; }
                vector&lt;int&gt; arr;
            };

            long long kruskal( const edge_t edges[], int n, int m ) {
                if( n &lt; m - 1 ) { return -1; }
                long long sum = 0LL;
                priority_queue&lt;edge_t, vector&lt;edge_t&gt;, greater&lt;edge_t&gt; &gt; pq;
                for( int i = 0; i &lt; n; ++i ) { pq.push( edges[i] ); }
                UFS ufs( MAX_NV );
                for( int i = 0; i &lt; n; ++i ) {
                    edge_t e = pq.top(); pq.pop();
                    int u = ufs.Find( e.u );
                    int v = ufs.Find( e.v );
                    if( u != v ) {
                        ufs.Union( u, v );
                        sum += e.w;
                    }
                }
                return sum;
            }

            int main() {
                int n, m;
                scanf( &quot;%d %d&quot;, &amp;n, &amp;m );
                for( int i = 0; i &lt; m; ++i ) {
                    scanf( &quot;%d %d %d&quot;, &amp;edges[i].u, &amp;edges[i].v, &amp;edges[i].w );
                }
                printf( &quot;%lld\n&quot;, kruskal(edges, n, m) );
                return 0;
            }
            ```</code></pre>
<ul>
<li><dl>
<dt>&#26368;&#30701;&#36335;&#24452; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#21333;&#28304;&#26368;&#30701;&#36335;&#24452; &#8212; Dijkstra &#31639;&#27861; <code class="fold">@</code></dt>
<dd><p>&#20551;&#35774; S &#20026;&#24050;&#27714;&#24471;&#26368;&#30701;&#36335;&#24452;&#30340;&#28857;&#30340;&#38598;&#21512;&#65292;&#21017;&#21487;&#35777;&#26126;&#65306;&#19979;&#19968;&#26465;&#26368;&#30701;&#36335;&#24452;&#65288;&#35774;&#20854;&#32456;&#28857;&#20026; x&#65289;&#25110;&#32773;&#26159;&#24359; (v, x)&#65292;&#25110;&#32773;&#26159;&#20013;&#38388;&#21482;&#32463;&#36807; S &#20013;&#30340;&#39030;&#28857;&#32780;&#26368;&#21518;&#21040;&#36798;&#39030;&#28857; x &#30340;&#36335;&#24452;&#12290;</p>
<p>Dijkstra &#31639;&#27861;&#27969;&#31243;&#22914;&#19979;&#65306;</p>
<ol style="list-style-type: decimal">
<li><p>S &#20026;&#24050;&#25214;&#21040;&#20174; v &#20986;&#21457;&#30340;&#26368;&#30701;&#36335;&#24452;&#30340;&#32456;&#28857;&#30340;&#38598;&#21512;&#65292;&#23427;&#30340;&#21021;&#22987;&#29366;&#24577;&#20026;&#31354;&#38598;&#12290;<code>dist[i]</code> &#23384;&#25918;&#30340;&#26159; v &#21040; v<sub>i</sub> &#30340;&#26368;&#30701;&#36335;&#24452;&#38271;&#24230;&#65292;&#26681;&#25454;&#21069;&#38754;&#25152;&#36848;&#24615;&#36136;&#65292;</p>
<p><code>dist[i]</code> = min{ <code>dist[i]</code>, weight(v, v<sub>i</sub>) }&#12290;</p>
<p><code>path[i]</code> &#23384;&#25918;&#30340;&#26159;&#26368;&#30701;&#36335;&#24452;&#19978;&#25351;&#21521; v<sub>i</sub> &#30340;&#24359;&#23614;&#39030;&#28857;&#12290;&#37027;&#20040;&#20174; v &#20986;&#21457;&#21040;&#22270;&#19978;&#20854;&#20313; v<sub>i</sub> &#30340;&#26368;&#30701;&#36335;&#24452;&#38271;&#24230;&#30340;&#21021;&#20540;&#20026;&#65306;</p>
<p><code>dist[i]</code> = weight(v, v<sub>i</sub>), v<sub>i</sub> &#8712; V</p></li>
<li><p>&#36873;&#25321; v<sub>j</sub>&#65292;&#20351;&#24471;</p>
<p><code>dist[j]</code> = min{ <code>dist[j]</code>, weight(v, v<sub>j</sub>) | v<sub>j</sub> &#8712; V-S };</p>
<p>&#23558; v<sub>j</sub> &#21152;&#20837;&#21040; S&#65292;</p>
<p>S = S &#8746; v<sub>j</sub></p></li>
<li><p>&#20462;&#25913;&#20174; v &#20986;&#21457;&#21040;&#38598;&#21512; V-S &#19978;&#20219;&#19968;&#39030;&#28857; v<sub>k</sub> &#21487;&#36798;&#30340;&#26368;&#30701;&#36335;&#24452;&#38271;&#24230;&#65292;&#24182;&#35760;&#24405;&#19979;&#36825;&#26465;&#36793;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span>( dist[j] + weight(j,k) &lt; dist[k] ) {
    dist[k] = dist[j] + weight(j,k);
    path[k] = j;
}</code></pre></div></li>
<li><p>&#37325;&#22797; 2&#65292;3 &#20849; n-1 &#27425;&#12290;</p></li>
</ol>
<p>TODO, add pic url.</p>
<pre><code>End Point           i=1         i=2         i=3         i=4         i=5
-----------------------------------------------------------------------
    v1              inf         inf         inf         inf         inf
-----------------------------------------------------------------------
    v2              10
                 (v0,v2)
-----------------------------------------------------------------------
    v3              inf         60          50
                            (v0,v2,v3)  (v0,v4,v5)
-----------------------------------------------------------------------
    v4              30          30
                 (v0,v4)     (v0,v4)
-----------------------------------------------------------------------
    v5             100         100          90          60
                 (v0,v5)     (v0,v5)    (v0,v4,v5)  (v0,v4,v3,v5)
-----------------------------------------------------------------------
    vj              v2          v4          v3          v5
    S            (v0,v2)    (v0,v2,v4)  (v0,v2,v3,v4)   (v0,v2,v3,v4,v5)</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;map&gt;</span>
<span class="ot">#include &lt;utility&gt;</span>
<span class="ot">#include &lt;climits&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// &#22270;&#65292;&#29992;&#37051;&#25509;&#34920; (Adjacency List).</span>
<span class="kw">struct</span> graph_t {
    <span class="dt">int</span> nv, ne;
    map&lt;<span class="dt">char</span>, map&lt;<span class="dt">char</span>, <span class="dt">int</span>&gt; &gt; matrix;
};

<span class="co">// Dijkstra &#31639;&#27861;&#27714;&#21333;&#28304;&#26368;&#30701;&#36335;&#24452;.</span>
<span class="co">// g:           &#22270;</span>
<span class="co">// start:       &#36215;&#28857;</span>
<span class="co">// dist:        dist[v] &#23384;&#25918;&#30340;&#26159;&#36215;&#28857;&#21040; v &#30340;&#26368;&#30701;&#36335;&#24452;&#38271;&#24230;</span>
<span class="co">// father:      father[v] &#23384;&#25918;&#30340;&#26159;&#26368;&#30701;&#36335;&#24452;&#19978;&#25351;&#21521; v &#30340;&#19978;&#19968;&#20010;&#39030;&#28857;</span>
<span class="dt">void</span> dijkstra( <span class="dt">const</span> graph_t &amp;g, <span class="dt">char</span> start, map&lt;<span class="dt">char</span>, <span class="dt">int</span>&gt; &amp;distance, map&lt;<span class="dt">char</span>, <span class="dt">char</span>&gt; &amp;father ) {
    <span class="kw">typedef</span> pair&lt;<span class="dt">int</span>, <span class="dt">char</span>&gt; to_dist_t;
    priority_queue&lt;to_dist_t, vector&lt;to_dist_t&gt;, greater&lt;to_dist_t&gt; &gt; pq;
    pq.push( to_dist_t( distance[start]=<span class="dv">0</span>, start ) );
    <span class="kw">while</span>( !pq.empty() ) {
        to_dist_t u = pq.top(); pq.pop();
        <span class="dt">char</span> &amp;vj = u.second;
        <span class="kw">if</span>( !g.matrix.count(vj) ) { <span class="kw">continue</span>; }
        <span class="kw">for</span>( <span class="kw">auto</span> <span class="dt">const</span> p : g.matrix.at(vj) ) {
            <span class="dt">const</span> <span class="dt">char</span> &amp;vk  = p.first;
            <span class="dt">const</span> <span class="dt">int</span>  &amp;wjk = p.second;
            <span class="co">//    vk not in S       or    there&#39;s a shorter path to vk</span>
            <span class="kw">if</span>( !distance.count(vk) || distance[vj] + wjk &lt; distance[vk] ) {
                distance[ vk  ]     =  distance[vj] + wjk;
                father[   vk  ]     =  vj;
                pq.push( to_dist_t(distance[vk], vk) );
            }
        }
    }
}

<span class="dt">void</span> print_path( <span class="dt">const</span> map&lt;<span class="dt">char</span>, <span class="dt">char</span>&gt; &amp;father, <span class="dt">char</span> end ) {
    <span class="kw">if</span>( !father.count(end) ) {
        printf( <span class="st">&quot;</span><span class="ch">%c</span><span class="st">&quot;</span>, end );
    } <span class="kw">else</span> {
        print_path( father, father.at(end) );
        printf( <span class="st">&quot;-&gt;</span><span class="ch">%c</span><span class="st">&quot;</span>, end );
    }
}

<span class="dt">int</span> main() {
    graph_t g;

    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;g.ne );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; g.ne; ++i ) {
        <span class="dt">char</span> u[<span class="dv">5</span>], v[<span class="dv">5</span>];
        <span class="dt">int</span> w;
        scanf( <span class="st">&quot;</span><span class="ch">%s</span><span class="st"> </span><span class="ch">%s</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, u, v, &amp;w );
        g.matrix[*u][*v] = w;
    }

    map&lt;<span class="dt">char</span>, <span class="dt">int</span>&gt; distance;
    map&lt;<span class="dt">char</span>, <span class="dt">char</span>&gt; father;
    dijkstra( g, <span class="st">&#39;A&#39;</span>, distance, father );

    <span class="kw">for</span>( <span class="dt">const</span> <span class="kw">auto</span> p : father ) {
        <span class="kw">if</span>( p.first != <span class="st">&#39;A&#39;</span> ) {
            print_path( father, p.first );
            printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<pre><code>$ cat input.txt
8
A C 10
A E 30
A F 100
B C 5
C D 50
D F 10
E D 20
E F 60

$ cat input.txt | ./tmp
A-&gt;C
A-&gt;E-&gt;D
A-&gt;E
A-&gt;E-&gt;D-&gt;F</code></pre>
<dl>
<dt>&#31639;&#27861;&#20998;&#26512;</dt>
<dd><p>&#35813;&#31639;&#27861;&#21253;&#21547;&#20102;&#20004;&#20010;&#24182;&#21015;&#30340; for &#24490;&#29615;&#65292;&#31532;&#19968;&#20010; for &#24490;&#29615;&#20570;&#36741;&#21161;&#25968;&#32452;&#30340;&#21021;&#22987;&#21270;&#24037;&#20316;&#65292;&#35745;&#31639;&#26102;&#38388;&#20026; O(n)&#65292;&#31532;&#20108;&#20010; for &#24490;&#29615;&#26159;&#20108;&#37325;&#23884;&#22871;&#24490;&#29615;&#65292;&#36827;&#34892;&#26368;&#30701;&#36335;&#24452;&#30340;&#27714;&#35299;&#24037;&#20316;&#65292;&#30001;&#20110;&#23545;&#22270;&#20013;&#20960;&#20046;&#27599;&#20010;&#39030;&#28857;&#37117;&#35201;&#20570;&#35745;&#31639;&#65292;&#27599;&#20010;&#39030;&#28857;&#30340;&#21448;&#35201;&#23545;&#38598;&#21512; S &#20869;&#30340;&#39030;&#28857;&#36827;&#34892;&#26816;&#27979;&#65292;&#23545;&#38598;&#21512; V-S &#20869;&#20013;&#30340;&#39030;&#28857;&#36827;&#34892;&#20462;&#25913;&#65292;&#25152;&#20197;&#36816;&#31639;&#26102;&#38388;&#22797;&#26434;&#24230;&#20026; O(n<sup>2</sup>)&#12290;&#31639;&#27861;&#24635;&#30340;&#26102;&#38388;&#22797;&#26434;&#24230;&#20026; O(n<sup>2</sup>)&#12290;</p>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>&#27599;&#28857;&#26368;&#30701;&#36335;&#24452; &#8212; Floyd &#31639;&#27861; <code class="fold">@</code></dt>
<dd><dl>
<dt>shit <code class="fold">@</code></dt>
<dd><pre><code>\subsection{&#27599;&#28857;&#26368;&#30701;&#36335;&#24452;&#8212;&#8212;Floyd&#31639;&#27861;}
Floyd&#31639;&#27861;&#30340;&#22522;&#26412;&#24605;&#24819;&#26159;&#65306;&#20551;&#35774;&#27714;&#20174;&#23450;&#28857;$v_i$&#21040;$v_j$&#30340;&#26368;&#30701;&#36335;
&#24452;&#12290;&#21021;&#22987;&#26102;&#65292;&#33509;$v_i$&#19982;$v_j$&#20043;&#38388;&#23384;&#22312;&#36793;&#65292;&#21017;&#26368;&#30701;&#36335;&#24452;&#38271;&#24230;&#20026;
&#27492;&#36793;&#30340;&#26435;&#20540;&#65307;&#33509;&#19981;&#23384;&#22312;&#36793;&#65292;&#21017;&#26368;&#30701;&#36335;&#24452;&#38271;&#24230;&#20026;&#26080;&#31351;&#22823;&#12290;&#20197;&#21518;&#36880;
&#27493;&#22312;&#36335;&#24452;&#20013;&#21152;&#20837;&#39030;&#28857;$k(k=0,1,...,n-1)$&#20316;&#20026;&#20013;&#38388;&#39030;&#28857;&#65292;&#22914;&#26524;
&#21152;&#20837;&#20013;&#38388;&#39030;&#28857;&#21518;&#65292;&#24471;&#21040;&#30340;&#36335;&#24452;&#27604;&#21407;&#26469;&#30340;&#36335;&#24452;&#38271;&#24230;&#20943;&#23569;&#20102;&#65292;&#21017;&#20197;
&#26032;&#36335;&#24452;&#20195;&#26367;&#21407;&#36335;&#24452;&#12290;

&#39318;&#20808;&#27604;&#36739;$(v_i,v_j)$&#21644;$(v_i,v_0,v_j)$&#30340;&#36335;&#24452;&#38271;&#24230;&#65292;&#21462;&#36739;&#30701;
&#32773;&#20026;&#20174;$v_i$&#21040;$v_j$&#30340;&#20013;&#38388;&#39030;&#28857;&#30340;&#24207;&#21495;&#19981;&#22823;&#20110;0&#30340;&#26368;&#30701;&#36335;&#24452;&#12290;&#22914;
&#26524;$(v_i,v_0,v_j)$&#36739;&#30701;&#65292;&#21017;&#21462;$(v_i,v_0,v_j)$&#20316;&#20026;&#26368;&#30701;&#36335;&#24452;
&#12290;&#20551;&#22914;&#22312;&#36335;&#24452;&#19978;&#20877;&#22686;&#21152;&#19968;&#20010;&#39030;&#28857;$v_1$&#65292;&#20063;&#23601;&#26159;&#35828;&#65292;&#22914;&#26524;
$(v_i,...,v_1)$&#21644;$(v_1,...,v_j)$&#20998;&#21035;&#26159;&#24403;&#21069;&#25214;&#21040;&#30340;&#20013;&#38388;&#23450;
&#28857;&#30340;&#24207;&#21495;&#19981;&#22823;&#20110;0&#30340;&#26368;&#30701;&#36335;&#24452;&#65292;&#37027;&#20040;$(vi,...,v1,...,vj)$&#23601;&#26377;
&#21487;&#33021;&#26159;&#20174;$v_i$&#21040;$v_j$&#30340;&#20013;&#38388;&#39030;&#28857;&#30340;&#24207;&#21495;&#19981;&#22823;&#20110;1&#30340;&#26368;&#30701;&#36335;&#24452;&#65292;
&#23558;&#23427;&#21644;&#24050;&#32463;&#24471;&#21040;&#30340;&#20174;$v_i$&#21040;$v_j$&#30340;&#20013;&#38388;&#39030;&#28857;&#30340;&#24207;&#21495;&#19981;&#22823;&#20110;0&#30340;
&#26368;&#30701;&#36335;&#24452;&#30456;&#27604;&#36739;&#65292;&#36873;&#20986;&#36739;&#30701;&#32773;&#20316;&#20026;&#20174;$v_i$&#21040;$v_j$&#30340;&#20013;&#38388;&#39030;&#28857;
&#30340;&#24207;&#21495;&#19981;&#22823;&#20110;1&#30340;&#26368;&#30701;&#36335;&#24452;&#12290;&#20877;&#22686;&#21152;&#19968;&#20010;&#39030;&#28857;$v_2$&#65292;&#32487;&#32493;&#36827;&#34892;
&#35797;&#25506;&#65292;&#20381;&#27492;&#31867;&#25512;&#12290;&#19968;&#33324;&#30340;&#65292;&#33509;$(v_i,...,v_k)$&#21644;
$(v_k,...,v_j)$&#20998;&#21035;&#26159;&#20174;$v_i$&#21040;$v_k$&#21644;&#20174;$v_k$&#21040;$v_j$&#30340;&#20013;
&#38388;&#23450;&#28857;&#30340;&#24207;&#21495;&#19981;&#22823;&#20110;$k-1$&#30340;&#26368;&#30701;&#36335;&#24452;&#65292;&#21017;&#23558;
$(v_i,...,v_k,...,v_j)$&#21644;&#24050;&#32463;&#24471;&#21040;&#30340;&#20174;$v_i$&#21040;$v_j$&#30340;&#20013;&#38388;
&#39030;&#28857;&#30340;&#24207;&#21495;&#19981;&#22823;&#20110;$k-1$&#30340;&#26368;&#30701;&#36335;&#24452;&#30456;&#27604;&#65292;&#36739;&#30701;&#32773;&#20415;&#26159;&#20174;$v_i$
&#21040;$v_j$&#30340;&#20013;&#38388;&#39030;&#28857;&#30340;&#24207;&#21495;&#19981;&#22823;&#20110;$k$&#30340;&#26368;&#30701;&#36335;&#24452;&#12290;&#36825;&#26679;&#65292;&#22312;&#32463;
&#36807;$n$&#27425;&#27604;&#36739;&#21518;&#65292;&#26368;&#21518;&#27714;&#24471;&#30340;&#24517;&#26159;&#20174;$v_i$&#21040;$v_j$&#30340;&#26368;&#30701;&#36335;&#24452;&#12290;

&#29616;&#23450;&#20041;&#19968;&#20010;$n$&#38454;&#26041;&#38453;&#24207;&#21015;&#65292;
$$
D^{(-1)}, D^{(0)} , D^{(1)},..., , D^{(k)},..., , D^{(n-1)}
$$
&#20854;&#20013;&#65292;
\begin{eqnarray}
D^{(-1)}[i][j] &amp;=&amp; \text{g-&gt;matrix}[i][j],  \nonumber \\
D^{(k)}[i][j] &amp;=&amp; \min\left\{D^{(k-1)}[i][j], D^{(k-1)}[i][k] + D^{(k-1)}[k][j]\right\},0 \leq k \leq n-1 \nonumber
\end{eqnarray}

&#19978;&#36848;&#20844;&#24335;&#20013;&#65292;$D^{(k)}[i][j]$&#26159;&#20174;$v_i$&#21040;$v_j$&#30340;&#20013;&#38388;&#39030;&#28857;&#30340;&#24207;&#21495;&#19981;&#22823;&#20110;$k$&#30340;&#26368;&#30701;&#36335;&#24452;&#30340;&#38271;&#24230;&#65307;$D^{(n-1)}[i][j]$&#26159;&#20174;$v_i$&#21040;$v_j$&#30340;&#26368;&#30701;&#36335;&#24452;&#30340;&#38271;&#24230;&#12290;

&#20363;&#22914;&#65292;&#23545;&#22270;\ref{fig:floyd}&#25152;&#31034;&#30340;&#26377;&#21521;&#22270;&#21450;&#20854;&#37051;&#25509;&#30697;&#38453;&#36816;&#34892;Floyd&#31639;&#27861;&#65292;

\begin{center}
\includegraphics[width=180pt]{floyd.png}\\
\figcaption{&#26377;&#21521;&#22270;&#21450;&#20854;&#37051;&#25509;&#30697;&#38453;}\label{fig:floyd}
\end{center}

&#36816;&#31639;&#36807;&#31243;&#20013;&#30697;&#38453;D&#30340;&#21464;&#21270;&#22914;&#34920;\ref{tab:floyd}&#25152;&#31034;&#12290;

\begin{center}
\tabcaption{Floyd&#31639;&#27861;&#36807;&#31243;&#20013;&#26041;&#38453;&#21644;&#26368;&#30701;&#36335;&#24452;&#30340;&#21464;&#21270;}
\label{tab:floyd}
\begin{tabular}{|c|ccc|ccc|ccc|ccc|}
\hline
\multirow{2}{*}{$\mathbf{D}$} &amp;
\multicolumn{3}{|c|}{$\mathbf{D^{(0)}}$} &amp;
\multicolumn{3}{|c|}{$\mathbf{D^{(1)}}$} &amp;
\multicolumn{3}{|c|}{$\mathbf{D^{(2)}}$} &amp;
\multicolumn{3}{|c|}{$\mathbf{D^{(3)}}$} \\
 &amp; 0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 \\
\hline
0 &amp; 0 &amp; 4 &amp; 11 &amp; 0 &amp; 4 &amp; 11 &amp; 0 &amp; 4 &amp; 6 &amp; 0 &amp; 4 &amp; 6 \\
1 &amp; 6 &amp; 0 &amp; 2 &amp; 6 &amp; 0 &amp; 2 &amp; 6 &amp; 0 &amp; 2 &amp; 5 &amp; 0 &amp; 2 \\
2 &amp; 3 &amp; $\infty$ &amp; 0 &amp; 3 &amp; 7 &amp; 0 &amp; 3 &amp; 7 &amp; 0 &amp; 3 &amp; 7 &amp; 0 \\
\hline
\multirow{2}{*}{$\mathbf{P}$} &amp;
\multicolumn{3}{|c|}{$\mathbf{P^{(0)}}$} &amp;
\multicolumn{3}{|c|}{$\mathbf{P^{(1)}}$} &amp;
\multicolumn{3}{|c|}{$\mathbf{P^{(2)}}$} &amp;
\multicolumn{3}{|c|}{$\mathbf{P^{(3)}}$} \\
 &amp; 0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 \\
\hline
\multirow{2}{*}{0} &amp; &amp; A &amp; A &amp; &amp; AB &amp; A &amp; &amp; AB &amp; AB &amp; &amp; AB &amp; AB \\
                   &amp; &amp; B &amp; C &amp; &amp; &amp; C &amp; &amp; &amp; C &amp; &amp; &amp; C \\
\hline
\multirow{2}{*}{1} &amp; B &amp; &amp; B &amp; B &amp; &amp; B &amp; B &amp; &amp; BC &amp; BC &amp; &amp; BC \\
                   &amp; A &amp; &amp; C &amp; A &amp; &amp; C &amp; A &amp; &amp; &amp; A &amp; &amp; \\
\hline
\multirow{2}{*}{2} &amp; C &amp; &amp; &amp; C &amp; CA &amp; &amp; C &amp; CA &amp; &amp; CA &amp; CA &amp; \\
                   &amp; A &amp; &amp; &amp; A &amp; B &amp; &amp; A &amp; B &amp; &amp; &amp; B &amp; \\
\hline
\end{tabular}
\end{center}</code></pre>
</dd>
<dt>Floyd &#31639;&#27861;&#30340; C &#35821;&#35328;&#23454;&#29616; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;climits&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> MAX_NV = <span class="dv">100</span>;
<span class="dt">const</span> <span class="dt">int</span> GRAPH_INF = INT_MAX / <span class="dv">2</span>;              <span class="co">// &#30830;&#20445;&#21152;&#27861;&#19981;&#28322;&#20986;</span>

<span class="kw">struct</span> graph_t {
    <span class="dt">int</span> nv, ne;
    <span class="dt">int</span> matrix[MAX_NV][MAX_NV];
};

graph_t g;

<span class="dt">int</span> dist[MAX_NV][MAX_NV];                       <span class="co">// dist[i][j] &#26159;&#39030;&#28857; i &#21644; j &#20043;&#38388;&#26368;&#30701;&#36335;&#24452;&#38271;&#24230;</span>
<span class="dt">int</span> path[MAX_NV][MAX_NV];                       <span class="co">// path[i][j] &#26159;&#26368;&#30701;&#36335;&#24452;&#19978; i &#21644; j &#20043;&#38388;&#30340;&#39030;&#28857;</span>

<span class="co">// Floyd &#31639;&#27861;&#27714;&#27599;&#28857;&#20043;&#38388;&#26368;&#30701;&#36335;&#24452;.</span>
<span class="co">// dist:        dist[i][j] &#26159;&#39030;&#28857; i &#21644; j &#20043;&#38388;&#26368;&#30701;&#36335;&#24452;&#38271;&#24230;</span>
<span class="co">// path:        path[i][j] &#26159;&#26368;&#30701;&#36335;&#24452;&#19978; i &#21644; j &#20043;&#38388;&#30340;&#39030;&#28857;</span>
<span class="dt">void</span> floyd( <span class="dt">const</span> graph_t &amp;g, <span class="dt">int</span> dist[][MAX_NV], <span class="dt">int</span> path[][MAX_NV] ) {
    <span class="dt">const</span> <span class="dt">int</span> n = g.nv;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j ) {
            <span class="kw">if</span>( i != j ) {
                dist[i][j] = g.matrix[i][j];
                path[i][j] = i;
            } <span class="kw">else</span> {
                dist[i][j] =  <span class="dv">0</span>;
                path[i][j] = <span class="dv">-1</span>;
            }
        }
    }
    <span class="kw">for</span>( <span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; ++k ) {
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
            <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j ) {
                <span class="co">// i &#21040; j &#30340;&#36335;&#24452;&#19978;&#21152;&#20837;&#39030;&#28857; k &#21487;&#20197;&#32553;&#30701;&#36335;&#24452;&#38271;&#24230;</span>
                <span class="kw">if</span>( dist[i][k] + dist[k][j] &lt; dist[i][j] ) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    path[i][j] = k;
                }
            }
        }
    }
}

<span class="co">// &#25171;&#21360;&#20174; u &#21040; v &#30340;&#26368;&#30701;&#36335;&#24452;</span>
<span class="dt">static</span> <span class="dt">void</span> print_path_r( <span class="dt">int</span> u, <span class="dt">int</span> v, <span class="dt">const</span> <span class="dt">int</span> path[][MAX_NV] ) {
    <span class="kw">if</span>( path[u][v] == <span class="dv">-1</span> ) {
        printf( <span class="st">&quot;</span><span class="ch">%c</span><span class="st">&quot;</span>, <span class="st">&#39;A&#39;</span>+u );
    } <span class="kw">else</span> {
        print_path_r( u, path[u][v], path );
        printf( <span class="st">&quot;-&gt;</span><span class="ch">%c</span><span class="st">&quot;</span>, <span class="st">&#39;A&#39;</span>+v );
    }
}

<span class="co">// &#25171;&#21360; u &#21040;&#20854;&#20182;&#25152;&#26377;&#28857;&#30340;&#26368;&#30701;&#36335;&#24452;</span>
<span class="dt">void</span> print_path( <span class="dt">const</span> graph_t &amp;g, <span class="dt">const</span> <span class="dt">int</span> path[][MAX_NV] ) {
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; g.nv; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; g.nv; ++j ) {
            <span class="kw">if</span>( i != j ) {
                print_path_r( i, j, path );
                printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
            }
        }
        printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
    }
}

<span class="dt">int</span> main() {
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;g.nv, &amp;g.ne );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; g.nv; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; g.nv; ++j ) {
            g.matrix[i][j] = GRAPH_INF;
        }
    }
    <span class="kw">for</span>( <span class="dt">int</span> k = <span class="dv">0</span>; k &lt; g.ne; ++k ) {
        <span class="dt">char</span> chx[<span class="dv">5</span>], chy[<span class="dv">5</span>];
        <span class="dt">int</span> w;
        scanf( <span class="st">&quot;</span><span class="ch">%s</span><span class="st"> </span><span class="ch">%s</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, chx, chy, &amp;w );
        g.matrix[*chx-<span class="st">&#39;A&#39;</span>][*chy-<span class="st">&#39;A&#39;</span>] = w;
    }

    floyd( g, dist, path );
    print_path( g, path  );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<pre><code>input:

    3 5
    A B 4
    A C 11
    B A 6
    B C 2
    C A 3

output:

    A-&gt;B
    A-&gt;B-&gt;C

    B-&gt;C-&gt;A
    B-&gt;C

    C-&gt;A
    C-&gt;A-&gt;B</code></pre>
</dd>
<dt>&#31639;&#27861;&#20998;&#26512; <code class="fold">@</code></dt>
<dd><p>&#35813;&#31639;&#27861;&#20013;&#26377;&#20004;&#20010;&#24182;&#21015;&#30340; for &#24490;&#29615;&#65292;&#31532;&#19968;&#20010;&#24490;&#29615;&#26159;&#20010;&#20108;&#37325;&#24490;&#29615;&#65292;&#29992;&#20110;&#21021;&#22987;&#21270;&#26041;&#38453; D&#65307;&#31532;&#20108;&#20010;&#24490;&#29615;&#26159;&#20010;&#19977;&#37325;&#24490;&#29615;&#65292;&#36880;&#27493;&#29983;&#25104; D<sup>(0)</sup>, D<sup>(1)</sup>, &#8230;, D<sup>(n-1)</sup>&#12290;&#25152;&#20197;&#31639;&#27861;&#24635;&#30340;&#26102;&#38388;&#22797;&#26434;&#24230;&#20026; O(n<sup>3</sup>)&#12290;</p>
</dd>
</dl>
<p>Dijkstra &#31639;&#27861;&#26435;&#20540;&#19981;&#33021;&#20026;&#36127;&#65292;Floyd &#26435;&#20540;&#21487;&#20197;&#20026;&#36127;&#65292;&#20294;&#29615;&#36335;&#20043;&#21644;&#19981;&#33021;&#20026;&#36127;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>HDU 2544 &#26368;&#30701;&#36335; <code class="fold">@</code></dt>
<dd><p>&#22312;&#27599;&#24180;&#30340;&#26657;&#36187;&#37324;&#65292;&#25152;&#26377;&#36827;&#20837;&#20915;&#36187;&#30340;&#21516;&#23398;&#37117;&#20250;&#33719;&#24471;&#19968;&#20214;&#24456;&#28418;&#20142;&#30340; t-shirt&#12290;&#20294;&#26159;&#27599;&#24403;&#25105;&#20204;&#30340;&#24037;&#20316;&#20154;&#21592;&#25226;&#19978;&#30334;&#20214;&#30340;&#34915;&#26381;&#20174;&#21830;&#24215;&#36816;&#22238;&#21040;&#36187;&#22330;&#30340;&#26102;&#20505;&#65292;&#21364;&#26159;&#38750;&#24120;&#32047;&#30340;&#65281;&#25152;&#20197;&#29616;&#22312;&#20182;&#20204;&#24819;&#35201;&#23547;&#25214;&#26368;&#30701;&#30340;&#20174;&#21830;&#24215;&#21040;&#36187;&#22330;&#30340;&#36335;&#32447;&#65292;&#20320;&#21487;&#20197;&#24110;&#21161;&#20182;&#20204;&#21527;&#65311;</p>
<pre><code>&#36755;&#20837;

    &#36755;&#20837;&#21253;&#25324;&#22810;&#32452;&#25968;&#25454;&#12290;&#27599;&#32452;&#25968;&#25454;&#31532;&#19968;&#34892;&#26159;&#20004;&#20010;&#25972;&#25968; N, M (N &lt;= 100, M &lt;= 10000)&#65292;
    N &#34920;&#31034;&#25104;&#37117;&#30340;&#22823;&#34903;&#19978;&#26377;&#20960;&#20010;&#36335;&#21475;&#65292;&#26631;&#21495;&#20026; 1 &#30340;&#36335;&#21475;&#26159;&#21830;&#24215;&#25152;&#22312;&#22320;&#65292;&#26631;&#21495;&#20026; N &#30340;&#36335;&#21475;&#26159;&#36187;&#22330;&#25152;&#22312;&#22320;&#65292;
    M &#21017;&#34920;&#31034;&#22312;&#25104;&#37117;&#26377;&#20960;&#26465;&#36335;&#12290;N=M=0 &#34920;&#31034;&#36755;&#20837;&#32467;&#26463;&#12290;
    &#25509;&#19979;&#26469; M &#34892;&#65292;&#27599;&#34892;&#21253;&#25324; 3 &#20010;&#25972;&#25968; A,B,C (1 &lt;= A,B &lt;= N, 1 &lt;= C &lt;= 1000),
    &#34920;&#31034;&#22312;&#36335;&#21475; A &#19982;&#36335;&#21475; B &#20043;&#38388;&#26377;&#19968;&#26465;&#36335;&#65292;&#25105;&#20204;&#30340;&#24037;&#20316;&#20154;&#21592;&#38656;&#35201; C &#20998;&#38047;&#30340;&#26102;&#38388;&#36208;&#36807;&#36825;&#26465;&#36335;&#12290;

    &#36755;&#20837;&#20445;&#35777;&#33267;&#23569;&#23384;&#22312; 1 &#26465;&#21830;&#24215;&#21040;&#36187;&#22330;&#30340;&#36335;&#32447;&#12290;

    2 1
    1 2 3
    3 3
    1 2 5
    2 3 5
    3 1 2
    0 0

&#36755;&#20986;

    &#23545;&#20110;&#27599;&#32452;&#36755;&#20837;&#65292;&#36755;&#20986;&#19968;&#34892;&#65292;&#34920;&#31034;&#24037;&#20316;&#20154;&#21592;&#20174;&#21830;&#24215;&#36208;&#21040;&#36187;&#22330;&#30340;&#26368;&#30701;&#26102;&#38388;

    3
    2</code></pre>
<p>&#21333;&#28304;&#26368;&#30701;&#36335;&#24452;&#65292;&#29992; Dijkstra &#31639;&#27861;&#65292;&#23558; dijkstra &#33410;&#20013;&#30340;&#20195;&#30721;&#31245;&#21152;&#20462;&#25913;&#21363;&#21487;&#12290;</p>
<p>&#27880;&#24847;&#65292;&#34903;&#36947;&#26159;&#21452;&#21521;&#30340;&#65292;&#25152;&#20197;&#32473;&#36793;&#36171;&#20540;&#26102;&#35201;&#23545;&#31216;&#36171;&#20540;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;map&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> graph_t {
    <span class="dt">int</span> nv, ne;
    map&lt;<span class="dt">int</span>, map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; &gt; matrix;
};

<span class="dt">void</span> dijkstra( <span class="dt">const</span> graph_t &amp;g, <span class="dt">int</span> start, map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; &amp;distance, map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; &amp;father ) {
    <span class="kw">typedef</span> pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; to_dist_t;
    priority_queue&lt;to_dist_t, vector&lt;to_dist_t&gt;, greater&lt;to_dist_t&gt; &gt; pq;
    pq.push( to_dist_t( distance[start]=<span class="dv">0</span>, start ) );
    <span class="kw">while</span>( !pq.empty() ) {
        to_dist_t u = pq.top(); pq.pop();
        <span class="dt">int</span> &amp;vj = u.second;
        <span class="kw">if</span>( !g.matrix.count(vj) ) { <span class="kw">continue</span>; }
        <span class="kw">for</span>( <span class="kw">auto</span> <span class="dt">const</span> p : g.matrix.at(vj) ) {
            <span class="dt">const</span> <span class="dt">int</span>  &amp;vk  = p.first;
            <span class="dt">const</span> <span class="dt">int</span>  &amp;wjk = p.second;
            <span class="co">//    vk not in S       or    there&#39;s a shorter path to vk</span>
            <span class="kw">if</span>( !distance.count(vk) || distance[vj] + wjk &lt; distance[vk] ) {
                distance[ vk  ]     =  distance[vj] + wjk;
                father[   vk  ]     =  vj;
                pq.push( to_dist_t(distance[vk], vk) );
            }
        }
    }
}

<span class="dt">void</span> print_path( <span class="dt">const</span> map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; &amp;father, <span class="dt">int</span> end ) {
    <span class="kw">if</span>( !father.count(end) ) {
        printf( <span class="st">&quot;</span><span class="ch">%c</span><span class="st">&quot;</span>, end );
    } <span class="kw">else</span> {
        print_path( father, father.at(end) );
        printf( <span class="st">&quot;-&gt;</span><span class="ch">%c</span><span class="st">&quot;</span>, end );
    }
}

<span class="dt">int</span> main() {
    graph_t g;
    <span class="kw">while</span>( <span class="dv">2</span> == scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;g.nv, &amp;g.ne ) &amp;&amp; g.nv &amp;&amp; g.ne ) {
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; g.ne; ++i ) {
            <span class="dt">int</span> u, v, w;
            scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;u, &amp;v, &amp;w );
            g.matrix[u][v] = g.matrix[v][u] = w;
        }
        map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; distance;
        map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; father;
        dijkstra( g, <span class="dv">1</span>, distance, father );
        printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, distance[g.nv]   );
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>POJ 1125 Stockbroker Grapevine :TODO: <code class="fold">@</code></dt>
<dd><p>TODO</p>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#25299;&#25169;&#25490;&#24207; <code class="fold">@</code></dt>
<dd><p>&#30001;&#26576;&#20010;&#38598;&#21512;&#19978;&#30340;&#19968;&#20010;&#20559;&#24207;&#24471;&#21040;&#35813;&#38598;&#21512;&#19978;&#30340;&#19968;&#20010;&#20840;&#24207;&#65292;&#36825;&#20010;&#25805;&#20316;&#31216;&#20026;<strong>&#25299;&#25169;&#25490;&#24207;</strong>&#12290;</p>
<p>&#25299;&#25169;&#24207;&#21015;&#30340;&#29305;&#28857;&#26159;&#65306;&#33509;&#26377;&#21521;&#36793; (V<sub>i</sub>, V<sub>j</sub>) &#26159;&#36884;&#20013;&#30340;&#24359;&#65292;&#21017;&#22312;&#24207;&#21015;&#20013;&#39030;&#28857; V<sub>i</sub> &#24517;&#39035;&#25490;&#22312;&#39030;&#28857; V<sub>j</sub> &#20043;&#21069;&#12290;</p>
<p>&#22914;&#26524;&#29992;&#26377;&#21521;&#22270;&#34920;&#31034;&#19968;&#20010;&#24037;&#31243;&#65292;&#39030;&#28857;&#34920;&#31034;&#27963;&#21160;&#65292;&#29992;&#26377;&#21521;&#36793; (V<sub>i</sub>, V<sub>j</sub>) &#34920;&#31034;&#27963;&#21160;&#24517;&#39035;&#20808;&#20110;&#27963;&#21160;&#36827;&#34892;&#12290;&#36825;&#31181;&#26377;&#21521;&#22270;&#21483;&#20570;&#39030;&#28857;&#34920;&#31034;&#27963;&#21160;&#30340;&#32593;&#32476; (Activity On Vertext Network)&#65292;&#31616;&#31216; AOV &#32593;&#32476;&#12290;</p>
<p>&#26816;&#27979; AOV &#32593;&#32476;&#26159;&#21542;&#23384;&#22312;&#29615;&#30340;&#26041;&#27861;&#26159;&#23545; AOV &#32593;&#32476;&#26500;&#36896;&#20854;&#39030;&#28857;&#30340;&#25299;&#25169;&#26377;&#24207;&#24207;&#21015;&#12290;&#25299;&#25169;&#25490;&#24207;&#30340;&#22522;&#26412;&#27493;&#39588;&#26159;&#65306;</p>
<ul>
<li>&#22312;&#26377;&#21521;&#22270;&#20013;&#36873;&#19968;&#20010;&#27809;&#26377;&#21069;&#39537;&#30340;&#39030;&#28857;&#19988;&#36755;&#20986;&#20043;&#65307;</li>
<li>&#20174;&#22270;&#20013;&#21024;&#38500;&#35813;&#39030;&#28857;&#21644;&#25152;&#26377;&#20197;&#23427;&#20026;&#31471;&#28857;&#30340;&#24359;&#32447;&#12290;</li>
</ul>
<p>&#37325;&#22797;&#20197;&#19978;&#20004;&#27493;&#65292;&#30452;&#33267; 1) &#20840;&#37096;&#39030;&#28857;&#36755;&#20986;&#65292;&#25110; 2) &#24403;&#21069;&#22270;&#20013;&#19981;&#23384;&#22312;&#26080;&#21069;&#39537;&#30340;&#39030;&#28857;&#65288;&#36825;&#31181;&#24773;&#20917;&#35828;&#26126;&#22270;&#20013;&#23384;&#22312;&#29615;&#65289;&#12290;</p>
<dl>
<dt>C++ code <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;climits&gt;</span>
<span class="ot">#include &lt;stack&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> MAX_NV = <span class="dv">100</span>;
<span class="dt">const</span> <span class="dt">int</span> GRAPH_INF = INT_MAX;

<span class="kw">struct</span> graph_t {
    <span class="dt">int</span> nv, ne;
    <span class="dt">int</span> matrix[MAX_NV][MAX_NV];
};

graph_t g;

<span class="dt">int</span> topological[MAX_NV];                        <span class="co">// &#25299;&#25169;&#25490;&#24207;&#30340;&#32467;&#26524;</span>

<span class="co">// &#25299;&#25169;&#25490;&#24207;.</span>
<span class="co">// &#26080;&#29615;&#36820;&#22238; true&#65292;&#26377;&#29615;&#36820;&#22238; false</span>
<span class="dt">bool</span> topo_sort( <span class="dt">const</span> graph_t &amp;g, <span class="dt">int</span> topological[] ) {
    <span class="dt">const</span> <span class="dt">int</span> n = g.nv;
    vector&lt;<span class="dt">int</span>&gt; in_degree( n, <span class="dv">0</span> );              <span class="co">// in_degree[i] &#26159;&#39030;&#28857; i &#30340;&#20837;&#24230;</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j ) {
            <span class="kw">if</span>( g.matrix[i][j] &lt; GRAPH_INF ) { ++in_degree[j]; }
        }
    }

    stack&lt;<span class="dt">int</span>&gt; s;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
        <span class="kw">if</span>( !in_degree[i] ) { s.push(i); }
    }

    <span class="dt">int</span> count = <span class="dv">0</span>;                              <span class="co">// &#25299;&#25169;&#24207;&#21015;&#30340;&#20803;&#32032;&#20010;&#25968;</span>
    <span class="kw">while</span>( !s.empty() ) {
        <span class="dt">int</span> u = s.top(); s.pop();
        topological[count++] = u;
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
            <span class="kw">if</span>( g.matrix[u][i] &lt; GRAPH_INF ) {
                <span class="kw">if</span>( --in_degree[i] == <span class="dv">0</span> ) { s.push(i); }
            }
        }
    }

    <span class="kw">if</span>( count != n ) {                          <span class="co">// &#26377;&#29615;</span>
        <span class="kw">return</span> <span class="kw">false</span>;
    } <span class="kw">else</span> {                                    <span class="co">// &#26080;&#29615;</span>
        <span class="kw">return</span> <span class="kw">true</span>;
    }
}

<span class="dt">int</span> main() {
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;g.nv, &amp;g.ne );
    <span class="co">// &#21021;&#22987;&#21270;&#22270;&#65292;&#25152;&#26377;&#33410;&#28857;&#38388;&#36317;&#31163;&#20026;&#26080;&#31351;&#22823;</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; g.nv; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; g.nv; ++j ) {
            g.matrix[i][j] = GRAPH_INF;
        }
    }
    <span class="co">// &#35835;&#21462;&#36793;&#20449;&#24687;</span>
    <span class="kw">for</span>( <span class="dt">int</span> k = <span class="dv">0</span>; k &lt; g.ne; ++k ) {
        <span class="dt">char</span> chx[<span class="dv">5</span>], chy[<span class="dv">5</span>];
        <span class="dt">int</span> w;
        scanf( <span class="st">&quot;</span><span class="ch">%s</span><span class="st"> </span><span class="ch">%s</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, chx, chy, &amp;w );
        g.matrix[*chx-<span class="st">&#39;A&#39;</span>][*chy-<span class="st">&#39;A&#39;</span>] = w;
    }

    topo_sort( g, topological );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; g.nv; ++i ) {
        printf( <span class="st">&quot;</span><span class="ch">%c</span><span class="st"> &quot;</span>, <span class="st">&#39;A&#39;</span>+topological[i] );
    }
    printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<pre><code>input:

    6 8
    A C 10
    A E 30
    A F 100
    B C 5
    C D 50
    D 5 10
    E D 20
    E F 60

output:

    B A E F C D</code></pre>
</dd>
</dl>
<p>&#23545;&#26377; n &#20010;&#39030;&#28857;&#21644; e &#26465;&#36793;&#30340; AOV &#32593;&#32476;&#32780;&#35328;&#65292;&#27714;&#21508;&#39030;&#28857;&#30340;&#20837;&#24230;&#25152;&#38656;&#26102;&#38388;&#20026; O(e)&#65292;&#24314;&#31435;&#38646;&#20837;&#24230;&#39030;&#28857;&#26632;&#25152;&#38656;&#26102;&#38388;&#20026; O(n)&#65307;&#22312;&#25299;&#25169;&#25490;&#24207;&#36807;&#31243;&#20013;&#65292;&#33509;&#26377;&#21521;&#22270;&#26080;&#29615;&#65292;&#27599;&#20010;&#39030;&#36827;&#19968;&#27425;&#26632;&#20986;&#19968;&#27425;&#26632;&#65292;&#39030;&#28857;&#20837;&#24230;&#20943; 1 &#30340;&#25805;&#20316;&#20849;&#25191;&#34892;&#20102; e &#27425;&#12290;&#25152;&#20197;&#24635;&#30340;&#26102;&#38388;&#22797;&#26434;&#24230;&#20026; O(n+e)&#12290;</p>
<p>&#24403;&#26377;&#21521;&#22270;&#20013;&#26080;&#29615;&#26102;&#65292;&#20063;&#21487;&#20197;&#21033;&#29992;&#28145;&#24230;&#20248;&#20808;&#25628;&#32034;&#36827;&#34892;&#25299;&#25169;&#25490;&#24207;&#12290;&#22240;&#20026;&#22270;&#20013;&#26080;&#29615;&#65292;&#28145;&#24230;&#20248;&#20808;&#36941;&#21382;&#19981;&#20250;&#27515;&#24490;&#29615;&#12290;&#36827;&#34892;&#28145;&#24230;&#20248;&#20808;&#36941;&#21382;&#26102;&#65292;&#26368;&#20808;&#36864;&#20986; DFS &#20989;&#25968;&#30340;&#39030;&#28857;&#21363;&#20026;&#20986;&#24230;&#20026;&#38646;&#30340;&#39030;&#28857;&#65292;&#26159;&#25299;&#25169;&#26377;&#24207;&#24207;&#21015;&#30340;&#26368;&#21518;&#19968;&#20010;&#39030;&#28857;&#12290;&#30001;&#27492;&#65292;&#25353;&#36864;&#20986; DFS &#20989;&#25968;&#30340;&#20808;&#21518;&#27425;&#24207;&#35760;&#24405;&#19979;&#26469;&#30340;&#39030;&#28857;&#24207;&#21015;&#21363;&#20026;&#36870;&#21521;&#30340;&#25299;&#25169;&#26377;&#24207;&#24207;&#21015;&#12290;</p>
<ul>
<li><dl>
<dt>POJ 1094 Sorting It All Out <code class="fold">@</code></dt>
<dd><p>An ascending sorted sequence of distinct values is one in which some form of a less-than operator is used to order the elements from smallest to largest. For example, the sorted sequence A, B, C, D implies that A &lt; B, B &lt; C and C &lt; D. in this problem, we will give you a set of relations of the form A &lt; B and ask you to determine whether a sorted order has been specified or not.</p>
<pre><code>&#36755;&#20837;

    Input consists of multiple problem instances. Each
    instance starts with a line containing two positive
    integers n and m. the first value indicated the
    number of objects to sort, where 2 &lt;= n &lt;= 26.  The
    objects to be sorted will be the first n characters
    of the uppercase alphabet. The second value m
    indicates the number of relations of the form A &lt; B
    which will be given in this problem instance. Next
    will be m lines, each containing one such relation
    consisting of three characters: an uppercase
    letter, the character &quot;&lt;&quot; and a second uppercase
    letter. No letter will be outside the range of the
    first n letters of the alphabet.  Values of n = m = 0
    indicate end of input.

    4 6
    A&lt;B
    A&lt;C
    B&lt;C
    C&lt;D
    B&lt;D
    A&lt;B
    3 2
    A&lt;B
    B&lt;A
    26 1
    A&lt;Z
    6 6
    A&lt;F
    B&lt;D
    C&lt;E
    F&lt;D
    D&lt;E
    E&lt;F
    0 0

&#36755;&#20986;

    For each problem instance, output consists of one
    line.  This line should be one of the following three:

    -   Sorted sequence determined after xxx relations: yyy...y.
    -   Sorted sequence cannot be determined.
    -   Inconsistency found after xxx relations.

    where xxx is the number of relations processed at
    the time either a sorted sequence is determined or
    an inconsistency is found, whichever comes first,
    and yyy...y is the sorted, ascending sequence.

    Sorted sequence determined after 4 relations: ABCD.
    Inconsistency found after 2 relations.
    Sorted sequence cannot be determined.
    Inconsistency found after 6 relations.</code></pre>
<p>&#26681;&#25454;&#39064;&#30446;&#30340;&#35201;&#27714;&#65292;&#25105;&#20204;&#35201;&#27599;&#36755;&#20837;&#19968;&#27425;&#23601;&#35201;&#36827;&#34892;&#19968;&#27425;&#25299;&#25169;&#25490;&#24207; <code>topological_sort()</code>&#65292;&#36825;&#26679;&#25165;&#33021;&#20570;&#21040;&#19981;&#25104;&#21151;&#65288;&#21363;&#21457;&#29616;&#26377;&#29615;&#65289;&#26102;&#65292;&#33021;&#30693;&#36947;&#26159;&#21738;&#27493;&#19981;&#25104;&#21151;&#65292;&#24182;&#19988;&#32473;&#20986;&#36755;&#20986;&#12290;</p>
<p>&#36824;&#26377;&#35201;&#27880;&#24847;&#30340;&#23601;&#26159;&#22914;&#26524;&#25105;&#20204;&#21487;&#20197;&#25552;&#21069;&#21028;&#26029;&#32467;&#26524;&#20102;&#65292;&#20294;&#21518;&#38754;&#36824;&#26377;&#36755;&#20837;&#27809;&#23436;&#25104;&#65292;&#37027;&#20040;&#25105;&#20204;&#24517;&#39035;&#32487;&#32493;&#23436;&#25104;&#36755;&#20837;&#65292;&#19981;&#28982;&#21097;&#19979;&#30340;&#36755;&#20837;&#20250;&#24433;&#21709;&#19979;&#19968;&#27425; case &#30340;&#36755;&#20837;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// POJ 1094 Sorting It All Out, http://poj.org/problem?id=1094</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;climits&gt;</span>
<span class="ot">#include &lt;stack&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> MAX_NV  = <span class="dv">26</span>;
<span class="dt">const</span> <span class="dt">int</span> GRAPH_INF = INT_MAX;

<span class="kw">struct</span> graph_t {
    <span class="dt">int</span> nv, ne;
    <span class="dt">int</span> matrix[MAX_NV][MAX_NV];
};

graph_t g;

<span class="dt">int</span> topological[MAX_NV];

<span class="dt">int</span> topo_sort( <span class="dt">const</span> graph_t *g, <span class="dt">int</span> topological[] ) {
    <span class="dt">const</span> <span class="dt">int</span> n = g-&gt;nv;
    vector&lt;<span class="dt">int</span>&gt; in_degree( n, <span class="dv">0</span> );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j ) {
            <span class="kw">if</span>( g-&gt;matrix[i][j] &lt; GRAPH_INF ) {
                ++in_degree[j];
            }
        }
    }

    stack&lt;<span class="dt">int</span>&gt; s;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
        <span class="kw">if</span>( !in_degree[i] ) { s.push(i); }
    }

    <span class="dt">int</span> count = <span class="dv">0</span>;
    <span class="dt">bool</span> insufficient = <span class="kw">false</span>;
    <span class="kw">while</span>( !s.empty() ) {
        <span class="kw">if</span>( s.size() &gt; <span class="dv">1</span> ) { insufficient = <span class="kw">true</span>; }
        <span class="dt">int</span> u = s.top(); s.pop();                       <span class="co">// &#21024;&#38500;&#39030;&#28857; u</span>
        topological[count++] = u;
        --in_degree[u];                                 <span class="co">// &#21464;&#25104; -1&#65292;&#34920;&#31034;&#24050;&#32463;&#36755;&#20986;</span>
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {                  <span class="co">// &#26356;&#26032;&#20837;&#24230;</span>
            <span class="kw">if</span>( g-&gt;matrix[u][i] &lt; GRAPH_INF ) {
                --in_degree[i];
            }
        }
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {                  <span class="co">// &#36873;&#25321;&#20837;&#24230;&#20026; 0 &#30340;&#39030;&#28857;</span>
            <span class="kw">if</span>( g-&gt;matrix[u][i] &lt; GRAPH_INF ) {
                <span class="kw">if</span>( !in_degree[i] ) { s.push(i); }
            }
        }
    }

    <span class="kw">if</span>( count &lt; n ) {
        <span class="kw">return</span> <span class="dv">0</span>;
    } <span class="kw">else</span> {
        <span class="kw">if</span>( insufficient ) {                            <span class="co">// &#26377;&#23396;&#31435;&#28857;&#65292;&#35828;&#26126;&#26465;&#20214;&#19981;&#36275;</span>
            <span class="kw">return</span> <span class="dv">-1</span>;
        } <span class="kw">else</span> {
            <span class="kw">return</span> <span class="dv">1</span>;
        }
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> m;                                              <span class="co">// m &#19981;&#19968;&#23450;&#26159;&#36793;&#30340;&#25968;&#30446;&#65292;&#22240;&#20026;&#36755;&#20837;&#36793;&#21487;&#33021;&#26377;&#37325;&#22797;</span>

    <span class="kw">while</span>( <span class="dv">2</span> == scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;g.nv, &amp;m ) &amp;&amp; g.nv &amp;&amp; m ) {
        <span class="dt">bool</span> finished = <span class="kw">false</span>;                          <span class="co">// &#25490;&#24207;&#23436;&#25104;&#65292;&#32467;&#26463;&#65292;&#21457;&#29616;&#26377;&#29615;&#65292;&#21487;&#20197;&#25552;&#21069;&#32467;&#26463;</span>
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; g.nv; ++i ) {               <span class="co">// &#21021;&#22987;&#21270;&#22270;&#65292;&#25152;&#26377;&#33410;&#28857;&#38388;&#36317;&#31163;&#20026;&#26080;&#31351;&#22823;</span>
            <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; g.nv; ++j ) {
                g.matrix[i][j] = GRAPH_INF;
            }
        }
        <span class="kw">for</span>( <span class="dt">int</span> k = <span class="dv">0</span>; k &lt; m; ++k ) {                  <span class="co">// &#35835;&#21462;&#36793;&#20449;&#24687;</span>
            <span class="dt">char</span> s[<span class="dv">5</span>];
            scanf( <span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, s );
            g.matrix[s[<span class="dv">0</span>]-<span class="st">&#39;A&#39;</span>][s[<span class="dv">2</span>]-<span class="st">&#39;A&#39;</span>] = <span class="dv">1</span>;
            <span class="kw">if</span>( finished ) { <span class="kw">continue</span>; }                <span class="co">// &#23436;&#25104;&#65292;&#21017; continue&#65292;&#28040;&#32791;&#36755;&#20837;</span>

            <span class="co">// &#26159;&#21542;&#26377;&#29615;&#65292;0 &#34920;&#31034;&#26377;&#29615;</span>
            <span class="dt">const</span> <span class="dt">int</span> ok = topo_sort( &amp;g, topological );

            <span class="kw">if</span>( ok == <span class="dv">0</span> ) {                             <span class="co">// &#26377;&#29615;&#23384;&#22312;</span>
                printf( <span class="st">&quot;Inconsistency found after </span><span class="ch">%d</span><span class="st"> relations.</span><span class="ch">\n</span><span class="st">&quot;</span>, k<span class="dv">+1</span> );
                finished = <span class="kw">true</span>;                        <span class="co">// &#25552;&#21069;&#32467;&#26463;&#65292;&#35760;&#20303;&#35201;&#32487;&#32493;&#28040;&#32791;&#36755;&#20837;</span>
            }
            <span class="kw">if</span>( ok == <span class="dv">1</span> &amp;&amp; k ) {
                printf( <span class="st">&quot;Sorted sequence determined after </span><span class="ch">%d</span><span class="st"> relations: &quot;</span>, k<span class="dv">+1</span> );
                <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; g.nv; ++i ) {
                    printf( <span class="st">&quot;</span><span class="ch">%c</span><span class="st">&quot;</span>, <span class="st">&#39;A&#39;</span>+topological[i] );
                }
                printf( <span class="st">&quot;.</span><span class="ch">\n</span><span class="st">&quot;</span> );
                finished = <span class="kw">true</span>;
            }
            <span class="co">// ok == -1, continue</span>
        }
        <span class="kw">if</span>( !finished ) {
            printf( <span class="st">&quot;Sorted sequence cannot be determined.</span><span class="ch">\n</span><span class="st">&quot;</span> );
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#20851;&#38190;&#36335;&#24452; <code class="fold">@</code></dt>
<dd><p>&#29992;&#26377;&#21521;&#36793;&#19978;&#30340;&#26435;&#20540;&#34920;&#31034;&#27963;&#21160;&#30340;&#25345;&#32493;&#26102;&#38388;&#65292;&#29992;&#39030;&#28857;&#34920;&#31034;&#26102;&#38388;&#65292;&#36825;&#26679;&#30340;&#26377;&#21521;&#22270;&#21483;&#20570;&#36793;&#34920;&#31034;&#30340;&#27963;&#21160;&#32593;&#32476; (Activity On Edge Network)&#65292;&#31616;&#31216; <strong>AOE &#32593;&#32476;</strong>&#12290;</p>
<p>&#36335;&#24452;&#26368;&#38271;&#30340;&#36335;&#24452;&#21483;&#20570;<strong>&#20851;&#38190;&#36335;&#24452; (Critical Path)</strong>&#12290;&#20551;&#35774;&#24320;&#22987;&#28857;&#20026; v<sub>1</sub>&#65292;&#20174; v<sub>1</sub> &#21040; v<sub>i</sub> &#30340;&#26368;&#38271;&#36335;&#24452;&#38271;&#24230;&#21483;&#20570;&#20107;&#20214; v<sub>i</sub> &#30340;&#26368;&#26089;&#21457;&#29983;&#26102;&#38388;&#12290;&#36825;&#20010;&#20107;&#20214;&#20915;&#23450;&#20102;&#25152;&#26377;&#20197; v<sub>i</sub> &#20026;&#31471;&#28857;&#30340;&#24359;&#25152;&#34920;&#31034;&#30340;&#27963;&#21160;&#30340;&#26368;&#26089; (earliest) &#24320;&#22987;&#26102;&#38388;&#12290;&#25105;&#20204;&#29992; e(i) &#34920;&#31034;&#27963;&#21160; a<sub>i</sub> &#30340;&#26368;&#26089;&#24320;&#22987;&#26102;&#38388;&#12290;&#36824;&#21487;&#20197;&#23450;&#20041;&#19968;&#20010;&#27963;&#21160;&#30340;&#26368;&#36831; (latest) &#24320;&#22987;&#26102;&#38388; l(i)&#65292;&#36825;&#26159;&#22312;&#19981;&#25512;&#36831;&#25972;&#20010;&#24037;&#31243;&#23436;&#25104;&#30340;&#21069;&#25552;&#19979;&#65292;&#27963;&#21160; a<sub>i</sub> &#26368;&#36831;&#24517;&#39035;&#24320;&#22987;&#36827;&#34892;&#30340;&#26102;&#38388;&#12290;&#20004;&#32773;&#20043;&#24046; l(i)-e(i) &#24847;&#21619;&#30528;&#23436;&#25104;&#27963;&#21160; a<sub>i</sub> &#30340;&#26102;&#38388;&#20313;&#37327;&#12290;&#25105;&#20204;&#25226; l(i) = e(i) &#30340;&#27963;&#21160;&#21483;&#20570;&#20851;&#38190;&#27963;&#21160;&#12290;</p>
<p>&#35774;&#27963;&#21160; a<sub>i</sub> &#30001;&#24359; &lt;j, k&gt; &#34920;&#31034;&#65292;&#20026;&#20102;&#27714;&#24471;&#27963;&#21160;&#30340; e(i) &#21644; l(i)&#65292;&#39318;&#20808;&#24212;&#27714;&#24471;&#20107;&#20214;&#30340;&#26368;&#26089;&#21457;&#29983;&#26102;&#38388; ve(j) &#21644;&#26368;&#36831;&#21457;&#29983;&#26102;&#38388; vl(j)&#65292;&#20854;&#25345;&#32493;&#26102;&#38388;&#35760;&#20026; dut(&lt;j, k&gt;)&#65292;&#21017;&#26377;&#22914;&#19979;&#20851;&#31995;</p>
<ul>
<li>e(i) = ve(j)</li>
<li>l(i) = vl(k) - dut(&lt;j, k&gt;)</li>
</ul>
<p>&#27714; ve(j) &#21644; vl(k) &#38656;&#20998;&#20004;&#27493;&#36827;&#34892;&#65306;</p>
<ol style="list-style-type: decimal">
<li><p>&#20174; ve(0) = 0 &#24320;&#22987;&#21521;&#21069;&#36882;&#25512;</p>
<p>ve(j) = max{ ve(i)+dut(&lt;i, j&gt;) }, &lt;i, j&gt; &#8712; T</p>
<p>&#20854;&#20013; T &#26159;&#25152;&#26377;&#20197;&#39030;&#28857; j &#20026;&#24359;&#22836;&#30340;&#36793;&#30340;&#38598;&#21512;&#12290;</p></li>
<li><p>&#20174; vl(n-1) = ve(n-1) &#36215;&#21521;&#21518;&#36882;&#25512;</p>
<p>vl(j) = min{ vl(k)-dut(&lt;j, k&gt;) }, &lt;j, k&gt; &#8712; S</p>
<p>&#20854;&#20013; S &#26159;&#25152;&#26377;&#20197;&#39030;&#28857; j &#20026;&#24359;&#23614;&#30340;&#36793;&#30340;&#38598;&#21512;&#12290;</p></li>
</ol>
<p><a href="criticalpath.png">&#26377;&#21521;&#22270;&#21450;&#20854;&#37051;&#25509;&#30697;&#38453;</a></p>
<pre><code>(a) &#25152;&#31034; AOE &#32593;&#32476;&#30340;&#20851;&#38190;&#36335;&#24452;&#30340;&#35745;&#31639;&#36807;&#31243;}

Vertex      ve          vl         |    Activity    e           l           l-e
-----------------------------------+-------------------------------------------
v1          0           0          |    a1          0           1           1
v2          3     |     4     ^    |    a2          0           0           0
v3          2     |     2    /|\   |    a3          3           4           1
v4          6    \|/    6     |    |    a4          3           4           1
v5          6     V     7     |    |    a5          2           2           0
v6          8           8          |    a6          2           5           3
                                   |    a7          6           6           0
                                   |    a8          6           7           1</code></pre>
<pre><code>input:

    6 8
    A B 3
    A C 2
    C D 4
    B D 2
    C F 3
    B E 3
    E F 1
    D F 2

output:

    A C D F</code></pre>
<dl>
<dt>&#37051;&#25509;&#30697;&#38453;&#19978;&#30340;&#20851;&#38190;&#36335;&#24452;&#30340; C &#35821;&#35328;&#23454;&#29616; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;climits&gt;</span>
<span class="ot">#include &lt;stack&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> MAX_NV = <span class="dv">100</span>;
<span class="dt">const</span> <span class="dt">int</span> GRAPH_INF = INT_MAX;

<span class="kw">struct</span> graph_t {
    <span class="dt">int</span> nv, ne;
    <span class="dt">int</span> matrix[MAX_NV][MAX_NV];
};

graph_t g;

<span class="dt">int</span> topological[MAX_NV];
<span class="dt">int</span> path[MAX_NV];

<span class="co">// &#25353;&#29031;&#25299;&#25169;&#25490;&#24207;&#30340;&#39034;&#24207;&#65292;&#35745;&#31639;&#25152;&#26377;&#39030;&#28857;&#30340;&#26368;&#26089;&#21457;&#29983;&#26102;&#38388; ve.</span>
<span class="co">// return:  &#26080;&#29615;&#36820;&#22238; true&#65292;&#26377;&#29615;&#36820;&#22238; false</span>
<span class="dt">bool</span> toposort_ve( <span class="dt">const</span> graph_t &amp;g, <span class="dt">int</span> topological[], <span class="dt">int</span> ve[] ) {
    <span class="dt">const</span> <span class="dt">int</span> n = g.nv;
    vector&lt;<span class="dt">int</span>&gt; in_degree( n, <span class="dv">0</span> );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j ) {
            <span class="kw">if</span>( g.matrix[i][j] &lt; GRAPH_INF ) {
                ++in_degree[j];
            }
        }
    }
    stack&lt;<span class="dt">int</span>&gt; s;
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
        <span class="kw">if</span>( !in_degree[i] ) { s.push(i); }
    }
    fill( ve, ve + n, <span class="dv">0</span> );

    <span class="dt">int</span> count = <span class="dv">0</span>;
    <span class="kw">while</span>( !s.empty() ) {
        <span class="dt">int</span> u = s.top(); s.pop();
        topological[count++] = u;
        --in_degree[u];
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
            <span class="kw">if</span>( g.matrix[u][i] &lt; GRAPH_INF ) {
                --in_degree[i];
            }
        }
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
            <span class="kw">if</span>( g.matrix[u][i] &lt; GRAPH_INF &amp;&amp; ve[i] &lt; ve[u] + g.matrix[u][i] ) {
                ve[i] = ve[u] + g.matrix[u][i];
            }
        }
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
            <span class="kw">if</span>( g.matrix[u][i] &lt; GRAPH_INF &amp;&amp; !in_degree[i] ) {
                s.push(i);
            }
        }
    }

    <span class="kw">if</span>( count &lt; n ) {
        <span class="kw">return</span> <span class="kw">false</span>;
    } <span class="kw">else</span> {
        <span class="kw">return</span> <span class="kw">true</span>;
    }
}

<span class="co">// &#27714;&#20851;&#38190;&#36335;&#24452;&#65292;&#31532;&#19968;&#20010;&#39030;&#28857;&#20026;&#36215;&#28857;&#65292;&#26368;&#21518;&#19968;&#20010;&#39030;&#28857;&#20026;&#32456;&#28857;.</span>
<span class="co">// ve:      &#25152;&#26377;&#20107;&#20214;&#30340;&#26368;&#26089;&#21457;&#29983;&#26102;&#38388;</span>
<span class="co">// path:    &#20851;&#38190;&#36335;&#24452;</span>
<span class="co">// return:  &#26080;&#29615;&#36820;&#22238;&#20851;&#38190;&#36335;&#24452;&#30340;&#39030;&#28857;&#20010;&#25968;&#65292;&#26377;&#29615;&#36820;&#22238; 0</span>
<span class="dt">int</span> critical_path( <span class="dt">const</span> graph_t &amp;g, <span class="dt">int</span> path[MAX_NV] ) {
    <span class="dt">int</span> count = <span class="dv">0</span>;
    vector&lt;<span class="dt">int</span>&gt; ve( g.nv );
    vector&lt;<span class="dt">int</span>&gt; vl( g.nv );

    <span class="kw">if</span>( !toposort_ve(g, topological, &amp;ve[<span class="dv">0</span>]) ) {        <span class="co">// &#26377;&#29615;</span>
        <span class="kw">return</span> <span class="dv">0</span>;
    }

    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; MAX_NV; ++i ) {
        path[i] = <span class="dv">-1</span>;
    }
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; g.nv; ++i ) {
        vl[i] = ve[g.nv<span class="dv">-1</span>];                         <span class="co">// &#21021;&#22987;&#21270; vl &#20026;&#26368;&#22823;</span>
    }

    <span class="co">// &#36870;&#24207;&#35745;&#31639; vl</span>
    <span class="kw">for</span>( <span class="dt">int</span> i = g.nv<span class="dv">-1</span>; i &gt;=<span class="dv">0</span>; i-- ) {
        <span class="dt">int</span> k = topological[i];
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; g.nv; ++j ) {
            <span class="kw">if</span>( g.matrix[j][k] &lt; GRAPH_INF &amp;&amp; vl[j] &gt; vl[k] - g.matrix[j][k] ) {
                vl[j] = vl[k] - g.matrix[j][k];
            }
        }
    }
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; g.nv; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; g.nv; ++j ) {
            <span class="dt">int</span> e = ve[i];
            <span class="dt">int</span> l = vl[j] - g.matrix[i][j];
            <span class="kw">if</span>( e == l ) {
                <span class="kw">if</span>( i == <span class="dv">0</span> ) {
                    path[count++] = i;
                    path[count++] = j;
                } <span class="kw">else</span> {
                    path[count++] = j;
                }
            }
        }
    }

    <span class="kw">return</span> count;
}

<span class="dt">int</span> main() {
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;g.nv, &amp;g.ne );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; g.nv; ++i ) {
        <span class="kw">for</span>( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; g.nv; ++j ) {
            g.matrix[i][j] = GRAPH_INF;
        }
    }
    <span class="kw">for</span>( <span class="dt">int</span> k = <span class="dv">0</span>; k &lt; g.ne; ++k ) {
        <span class="dt">char</span> chx[<span class="dv">5</span>], chy[<span class="dv">5</span>];
        <span class="dt">int</span> w;
        scanf( <span class="st">&quot;</span><span class="ch">%s</span><span class="st"> </span><span class="ch">%s</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, chx, chy, &amp;w );
        g.matrix[*chx-<span class="st">&#39;A&#39;</span>][*chy-<span class="st">&#39;A&#39;</span>] = w;
    }

    <span class="dt">int</span> count = critical_path( g, path );
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; count; ++i ) {
        printf( <span class="st">&quot;</span><span class="ch">%c</span><span class="st"> &quot;</span>, <span class="st">&#39;A&#39;</span>+path[i] );
    }
    printf( <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl>
<p>&#19968;&#27425;&#27491;&#21521;&#65292;&#22797;&#26434;&#24230;&#20026; O(n<sup>2</sup>)&#65292;&#19968;&#27425;&#36870;&#21521;&#65292;&#22797;&#26434;&#24230;&#20026; O(n<sup>2</sup>)&#65292;&#22240;&#27492;&#65292;&#35813;&#31639;&#27861;&#30340;&#22797;&#26434;&#24230;&#20026; O(n<sup>2</sup>)&#12290;</p>
</dd>
</dl></li>
<li><p>&#32452;&#21512;&#31867;&#28145;&#24230;&#20248;&#20808;&#25628;&#32034; Combination Related DFS</p></li>
<li><p>&#25490;&#21015;&#31867;&#28145;&#24230;&#20248;&#20808;&#25628;&#32034; Permutation Related DFS</p></li>
</ul>
</dd>
</dl>
<p>&#12304;&#19979;&#38754;&#26159;&#24378;&#21270;&#29677;&#20869;&#23481;&#12305;</p>
<dl>
<dt>&#9986;&#65039; 2016/08/21 &#19978;&#21320; 7:00:00 FLAG &#31639;&#27861;&#38754;&#35797;&#38590;&#24230;&#25552;&#39640;&#65311;&#22914;&#20309;&#20934;&#22791;&#65311;&#12304;&#20813;&#36153;&#35797;&#21548;&#12305; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>HR &#38754;&#35797;&#36825;&#19968;&#29615;&#21487;&#33021;&#20250;&#38382;&#21040;&#30340;&#38382;&#39064; <code class="fold">@</code></dt>
<dd><p><strong>What are your strengths?</strong></p>
<ul>
<li>I&#8217;m passionate about programming and I can write high quality code. Besides, I have solid mathematical foundation and know a little about machine learning.</li>
<li>I&#8217;m a quick learner and I love programming. Because I love it, I&#8217;m willing to spend my time, money, and energy into it.</li>
</ul>
<p><strong>What is your greatest weakness?</strong></p>
<p>I live in campus for a little long time, so I haven&#8217;t write as much code as people at my age. Compared to people who started to work immediately after graduation, I have less real experience in production environment.</p>
<p><strong>Why should I hire you?</strong></p>
<p>My technical skills match Facebook</p>
<p><strong>Five year plan?</strong></p>
<p>I aims to become a world class topnotch developer in (Programming Lagnuage Design, Distributed system, Machine Learning, Data Mining etc).</p>
<p>I want to solve hardcore technical problems with smart guys.</p>
<p>I want to have a small and smart team, to build some world class tools. I tend to be more satisfied and happy when people can fully appreciate my work, so instead of user products, personally I prefer developer oriented tools/platforms, such as storage systems like HBase and Hive, or significant improvement of existing language implementations (for example, Facebook&#8217;s HipHop for PHP, Google&#8217;s V8 for JavaScript, Delvik for Java on mobile platform).</p>
<p><strong>why Google?</strong></p>
<p>In my opinion, Google is the most innovative company on the Earth. It created many successful products, for example web search engine, Android, Gmail. But it doesn&#8217;t stop, it creates many products that sounds incredible, like Google driveless car, Google Glass etc.</p>
<p>That&#8217;s why I want to join Google and take part in making fantastic products.</p>
<p><strong>why Facebook?</strong></p>
<p>First, Facebook is a cool company, which has strong geek culture. The CEO, Mark Zuckerberg is a geek, and he recognises the value of engineers, today Facebook is still dominated by engineers, not product managers. Second, Facebook is the world&#8217;s biggest social network website, in there my code will serve billions of people, which makes me feel a big sense of achievement.</p>
<p><strong>Any questions?</strong></p>
<p>Facebook</p>
<p>There is a saying often said: Facebook and Google gathered a bunch of smartest people in the world, but they are just thinking day and night to attempt people to click all their ads! This sounds sad but it&#8217;s somewhat true. I don&#8217;t like ads, and I&#8217;m a big fan of adblock. How do you and Facebook engineers think about this saying?</p>
<p>Is there any projects related to language design and implementation other than HipHop in Facebook? I heard that Facebook is actively developing a new PHP virtual machine, can I have some detail information?</p>
<p>Is Facebook chat still powered by Erlang? What&#8217;s the most challenging part of Facebook chat? How do you deal with spamming?</p>
<p>Amazon</p>
<p>Google has developed Spanner and F1, is Amazon developing its own large scale RDBMS? If not, why?</p>
<p>When I worked in Baidu, all SDE must keep their mobile phone online 7x24, and be ready to be called at any time in case of online accidents. What&#8217;s the process in Amazon to handle emergent online accidents? What&#8217;s the division of labour?</p>
<p>AeroFS</p>
<p>Would please tell me something about your tool chain?</p>
<p>Take LinkedIn as an example, free users&#8217; data are exactly the thing that commercial users want. Although AeroFS is quite different, do you have any idea to make your commercial users benifit from your free users?</p>
<p>Dropbox turned to online music area, how do you think about this? Is this a signal that indicating personal cloud storage is not profitable enough?</p>
<p>refs and see also</p>
<ul>
<li><a href="http://humanresourcesblog.in/2012/09/26/top-10-hr-interview-questions-how-to-answer-them/">Top 10 HR Interview Questions &amp; How To Answer Them | Human Resources Blog | Top HR Blog</a></li>
<li><a href="https://github.com/soulmachine/acm-cheat-sheet/wiki/HR%E9%9D%A2%E8%AF%95%E8%BF%99%E4%B8%80%E7%8E%AF%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%97%AE%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">HR &#38754;&#35797;&#36825;&#19968;&#29615;&#21487;&#33021;&#20250;&#38382;&#21040;&#30340;&#38382;&#39064; &#183; soulmachine/acm-cheat-sheet Wiki &#183; GitHub</a></li>
</ul>
</dd>
</dl></li>
<li>&#21508;&#31867; IT &#20225;&#19994;&#30340;&#38754;&#35797;&#31639;&#27861;&#38590;&#24230;&#21450;&#39118;&#26684;</li>
<li>&#22914;&#20309;&#35299;&#20915;&#20013;&#31561;&#38590;&#24230;&#20197;&#19978;&#30340;&#31639;&#27861;&#39064;</li>
<li>&#22914;&#20309;&#35299;&#20915; follow up &#38382;&#39064;</li>
<li><dl>
<dt>Two sum <code class="fold">@</code></dt>
<dd><p>&#25490;&#24207;&#20877;&#22841;&#36924;&#12290;&#20294;&#26159;&#36820;&#22238;&#30340;&#26159; index&#65281;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    vector&lt;<span class="dt">int</span>&gt; twoSum(vector&lt;<span class="dt">int</span>&gt; &amp;nums, <span class="dt">int</span> target) {
        unordered_map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; mapping;
        vector&lt;<span class="dt">int</span>&gt; result;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nums.size(); i++) {
            mapping[nums[i]] = i;                                                   <span class="co">// &#23545;&#24212;&#21040; index</span>
        }
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nums.size(); i++) {
            <span class="dt">const</span> <span class="dt">int</span> gap = target - nums[i];
            <span class="kw">if</span> (mapping.find(gap) != mapping.end() &amp;&amp; mapping[gap] &gt; i) {           <span class="co">// &#23545;&#27599;&#20010;&#20803;&#32032;&#23581;&#35797;&#25214;&#21040;&#21305;&#37197;</span>
                result.push_back(i + <span class="dv">1</span>);
                result.push_back(mapping[gap] + <span class="dv">1</span>);
                <span class="kw">break</span>;
            }
        }
        <span class="kw">return</span> result;
    }
};</code></pre></div>
<p>&#25110;&#32773;&#29992;&#19968;&#31181;&#24039;&#22937;&#22320;&#22841;&#36924;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    vector&lt;<span class="dt">int</span>&gt; twoSum(vector&lt;<span class="dt">int</span>&gt; &amp;a, <span class="dt">int</span> s) {
        vector&lt;<span class="dt">int</span>&gt; r(a.size());
        iota(r.begin(), r.end(), <span class="dv">0</span>);
        <span class="co">// &#23384;&#20648; index&#65292;&#28982;&#21518;&#25226;  index &#25490;&#24207;&#12290;&#32467;&#26524;&#26159; a[r[i]] &#21319;&#24207;&#25490;&#21015;&#65288;for i = [0,n)&#65289;&#12290;</span>
        sort(r.begin(), r.end(), [&amp;](<span class="dt">int</span> x, <span class="dt">int</span> y) { <span class="kw">return</span> a[x] &lt; a[y]; });
        <span class="kw">for</span> (size_t i = <span class="dv">0</span>, j = a.size()<span class="dv">-1</span>; i &lt; j; i++) {        <span class="co">// i &#22312;&#24038;&#65292;j &#22312;&#21491;&#65292;i &#29992; for &#24490;&#29615;</span>
            <span class="kw">while</span> (j &gt; i<span class="dv">+1</span> &amp;&amp; a[r[i]]+a[r[j]] &gt; s) j--;         <span class="co">// j &#19981;&#26029;&#19979;&#35843;</span>
            <span class="kw">if</span> (a[r[i]]+a[r[j]] == s) {
                <span class="dt">int</span> x = r[i], y = r[j];
                r.clear();  <span class="co">// &#36824;&#29992; r &#26469;&#23384;&#36755;&#20986;&#32467;&#26524;&#8230;&#8230;</span>
                <span class="kw">if</span> (x &gt; y) swap(x, y);
                r.push_back(x);
                r.push_back(y);
                <span class="kw">break</span>;
            }
        }
        <span class="kw">return</span> r;
    }
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    vector&lt;<span class="dt">int</span>&gt; twoSum(vector&lt;<span class="dt">int</span>&gt; &amp;nums, <span class="dt">int</span> target) {
        unordered_map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; mapping;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nums.size(); i++) {
            mapping[nums[i]] = i;
        }
        sort( nums.begin(), nums.end() );
        <span class="dt">int</span> lo = <span class="dv">0</span>, hi = nums.size()<span class="dv">-1</span>;
        <span class="kw">while</span>( lo &lt; hi ) {
            <span class="kw">if</span>( nums[lo]+nums[hi] == target ) {
                <span class="kw">break</span>;
            } <span class="kw">else</span> <span class="kw">if</span>( nums[lo]+nums[hi] &lt; target) {
                ++lo;
            } <span class="kw">else</span> {
                --hi;
            }
        }

        vector&lt;<span class="dt">int</span>&gt; result;
        <span class="kw">if</span>( lo &lt; hi ) {
            <span class="dt">int</span> x = mapping[nums[lo]];
            <span class="dt">int</span> y = mapping[nums[hi]];
            <span class="kw">if</span>( x &gt; y ) { swap(x,y); }
            result.push_back( x );
            result.push_back( y );
        }
        <span class="kw">return</span> result;
    }
};</code></pre></div>
<p>&#25105;&#30340;&#36825;&#20010;&#29256;&#26412;&#23621;&#28982;&#38169;&#22312;&#20102;&#8230;&#8230;&#19968;&#20010;&#34507;&#30140;&#30340;&#20363;&#23376;&#65306;</p>
<pre><code>Input:      [0,4,3,0]
            0
Output:     [3,3]
Expected:   [0,3]</code></pre>
<ul>
<li><ol style="list-style-type: decimal">
<li>Two sum follow up I <code class="fold">@</code></li>
</ol>
<p>: &#22914;&#26524; array &#26159;&#25490;&#24207;&#22909;&#30340;&#21602;&#65311;</p>
<pre><code>[Two Sum II - Input array is sorted | LeetCode OJ](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) `@`{.fold}

:   &#39064;&#35774;&#20445;&#35777;&#20102;&#26377;&#21807;&#19968;&#35299;&#12290;

    ```
    class Solution {
    public:
        vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;a, int target) {
            int i = 0, j = a.size()-1;
            while (i &lt; j) {
                if (a[i]+a[j] &lt; target)
                    i++;
                else if (a[i]+a[j] &gt; target)
                    j--;
                else
                    break;
            }
            return {i+1, j+1};
        }
    };
    ```

    &#21520;&#27133;&#65306;two sum &#30340;&#39064;&#65292;&#25226; index &#25913;&#25104;&#20102; zero-based&#65292;&#32780;&#36825;&#37324;&#65292;&#23621;&#28982;&#36824;&#26159; one-based&#12290;

[3Sum | LeetCode OJ](https://leetcode.com/problems/3sum/) `@`{.fold}

:   &#21487;&#33021;&#26377;&#22810;&#32452;&#35299;&#12290;&#19977;&#20010;&#25968;&#21512;&#20026; 0&#12290;

    ```cpp
    class Solution {
    public:
        vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;a) {
            int n = a.size();
            vector&lt;vector&lt;int&gt;&gt; r;
            sort(a.begin(), a.end());
            for (int i = 0; i &lt; n; ) {
                int j = i+1, k = n-1, s = -a[i], old;   // &#23545;&#27599;&#20010; i&#65292;&#22841;&#36924;&#23581;&#35797; j&#12289;k&#12290;
                while (j &lt; k) {
                    if (a[j]+a[k] &lt; s) j++;
                    else if (a[j]+a[k] &gt; s) k--;
                    else {
                        r.push_back(vector&lt;int&gt;{a[i], a[j], a[k]});
                        old = a[j];
                        while (++j &lt; k &amp;&amp; a[j] == old);
                        k--;
                    }
                }
                old = a[i];
                while (++i &lt; n &amp;&amp; a[i] == old);
            }
            return r;
        }
    };
    ```

[3Sum Closest | LeetCode OJ](https://leetcode.com/problems/3sum-closest/) `@`{.fold}

:   &#21644;&#21018;&#25165;&#30340;&#24773;&#20917;&#31867;&#20284;&#12290;

    ```cpp
    #define REP(i, n) for (int i = 0; i &lt; (n); i++)

    class Solution {
    public:
        int threeSumClosest(vector&lt;int&gt; &amp;a, int target) {
            int n = a.size(), opt = INT_MAX, opts;
            sort(a.begin(), a.end());
            REP(i, n) {
                int j = i+1, k = n-1, t = target-a[i];
                while (j &lt; k) {
                    if (a[j]+a[k] &lt; t) {
                        if (t-a[j]-a[k] &lt; opt) {
                            opt = t-a[j]-a[k];
                            opts = a[i]+a[j]+a[k];
                        }
                        j++;
                    } else if (a[j]+a[k] &gt; t) {
                        if (a[j]+a[k]-t &lt; opt) {
                            opt = a[j]+a[k]-t;
                            opts = a[i]+a[j]+a[k];
                        }
                        k--;
                    } else
                        return target;
                }
            }
            return opts;
        }
    };
    ```

[4Sum | LeetCode OJ](https://leetcode.com/problems/4sum/) `@`{.fold}

:   ```cpp
    class Solution {
    public:
        vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;a, int target) {
            int n = a.size(), old;
            multimap&lt;int, int&gt; m;
            vector&lt;vector&lt;int&gt;&gt; r;
            sort(a.begin(), a.end());
            for (int i = 0; i &lt; n; ) {
                // a &lt;= b &lt; c &lt;= d
                for (int j = i+1; j &lt; n; ) {
                    int t = target-a[i]-a[j];
                    auto it = m.equal_range(t);
                    for (; it.first != it.second; ++it.first) {
                        vector&lt;int&gt; b{it.first-&gt;second, t-it.first-&gt;second, a[i], a[j]};
                        r.push_back(b);
                    }
                    old = a[j];
                    while (++j &lt; n &amp;&amp; a[j] == old);
                }
                // a &lt; b = b &lt;= c
                if (i+1 &lt; n &amp;&amp; a[i] == a[i+1]) {
                    for (int j = i+2; j &lt; n; ) {
                        int t = target-a[i]*2-a[j];
                        auto it = lower_bound(a.begin(), a.begin()+i, t);
                        if (it != a.begin()+i &amp;&amp; *it == t) {
                            vector&lt;int&gt; b{*it, a[i], a[i], a[j]};
                            r.push_back(b);
                        }
                        old = a[j];
                        while (++j &lt; n &amp;&amp; a[j] == old);
                    }
                }
                // a = a = a &lt;= b
                if (i+2 &lt; n &amp;&amp; a[i] == a[i+2]) {
                    int t = target-a[i]*3;
                    auto it = lower_bound(a.begin()+i+3, a.end(), t);
                    if (it != a.end() &amp;&amp; *it == t) {
                        vector&lt;int&gt; b{a[i], a[i], a[i], t};
                        r.push_back(b);
                    }
                }
                old = a[i];
                while (i+1 &lt; n &amp;&amp; a[i+1] == old)
                    i++;
                for (int j = 0; j &lt; i; ) {
                    m.insert(make_pair(a[j]+a[i], a[j]));
                    old = a[j];
                    while (++j &lt; n &amp;&amp; a[j] == old);
                }
                i++;
            }
            return r;
        }
    };
    ```</code></pre></li>
<li><ol start="2" style="list-style-type: decimal">
<li>Two sum follow up II - Triangle count <code class="fold">@</code></li>
</ol></li>
</ul>
</dd>
</dl></li>
<li>Kth largest element
<ul>
<li><ol style="list-style-type: decimal">
<li>&#31532; k &#22823;&#20803;&#32032;&#30340;&#19977;&#23618;&#36882;&#36827;&#38754;&#35797;&#32771;&#23519;.</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>&#22914;&#20309;&#36890;&#36807;&#19968;&#36947;&#39064;&#21306;&#20998; 3 &#31867;&#38754;&#35797;&#32773;</li>
</ol></li>
<li><ol start="3" style="list-style-type: decimal">
<li>&#21078;&#26512;&#38754;&#35797;&#23448;&#38754;&#35797;&#30340;&#24605;&#36335;</li>
</ol></li>
</ul></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/08/28 &#19978;&#21320; 7:00:00 &#25968;&#25454;&#32467;&#26500; Data Structure (&#19978;) <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#24182;&#26597;&#38598; <code class="fold">@</code></dt>
<dd><dl>
<dt>basics ideas <code class="fold">@</code></dt>
<dd><ul>
<li>&#24182;&#26597;&#38598;&#30340;&#22522;&#26412;&#21407;&#29702;</li>
<li>&#24182;&#26597;&#38598;&#30340;&#30456;&#20851;&#36816;&#29992;</li>
<li>&#24182;&#26597;&#38598;&#30340;&#25299;&#23637;&#65288;&#24102;&#36335;&#24452;&#21387;&#32553;&#65289;</li>
<li>&#24182;&#26597;&#38598;&#30340;&#36816;&#29992;</li>
</ul>
<p>&#24182;&#26597;&#38598;&#21448;&#31216;&#19981;&#30456;&#20132;&#38598;&#65292;&#26377;&#20004;&#20010;&#21517;&#23383;&#30340;&#21407;&#22240;&#22312;&#20110;&#23427;&#21407;&#23601;&#26377;&#20004;&#20010;&#19981;&#21516;&#30340;&#33521;&#25991;&#21517;&#23383;&#65292;Disjoint sets&#21644;Union-find set&#12290;&#26356;&#20934;&#30830;&#28857;&#24212;&#35813;&#35828;&#24182;&#26597;&#38598;&#26159;&#29992;&#26469;&#25805;&#20316;&#19981;&#30456;&#20132;&#38598;&#30340;&#25968;&#25454;&#32467;&#26500;&#12290;&#31639;&#27861; &#23548;&#35770;&#19978;&#36825;&#19968;&#31456;&#23601;&#21483;&#29992;&#20110;&#19981;&#30456;&#20132;&#38598;&#21512;&#30340;&#25968;&#25454;&#32467;&#26500;&#65288;Data Structures for Disjoint Sets&#65289;&#12290; &#32500;&#22522;&#30334;&#31185;&#19978;&#20063;&#35828;&#65306;</p>
<p>In computer science, a disjoint-set data structure, also called a union&#8211;find data structure or merge&#8211;find set, is a data structure that keeps track of a set of elements partitioned into a number of disjoint (nonoverlapping) subsets. It supports two useful operations:</p>
<ul>
<li>Find: Determine which subset a particular element is in. Find typically returns an item from this set that serves as its &#8220;representative&#8221;; by comparing the result of two Find operations, one can determine whether two elements are in the same subset.</li>
<li>Union: Join two subsets into a single subset.</li>
</ul>
<p>&#20294;&#19968;&#33324;&#35828; Disjoint Sets &#23601;&#25351;&#30340;&#26159;Data Structures for Disjoint Sets&#12290;</p>
</dd>
<dt>Disjoint-set data structure <code class="fold">@</code></dt>
<dd><dl>
<dt>Disjoint-set forests</dt>
<dd><p>In a disjoint-set forest, the representative of each set is the root of that set&#8217;s tree. Find follows parent nodes until it reaches the root. Union combines two trees into one by attaching the root of one to the root of the other. One way of implementing these might be:</p>
<pre><code>function MakeSet(x)
    x.parent := x

function Find(x)
    if x.parent == x
       return x
    else
       return Find(x.parent)

function Union(x, y)
    xRoot := Find(x)
    yRoot := Find(y)
    xRoot.parent := yRoot</code></pre>
<p>the tree it creates can be <strong>highly unbalanced</strong> -&gt; two ways to solve.</p>
<pre><code>function MakeSet(x)
    x.parent := x
    x.rank   := 0

function Union(x, y)
    xRoot := Find(x)
    yRoot := Find(y)
    if xRoot == yRoot
        return

    // x and y are not already in same set. Merge them.
    if xRoot.rank &lt; yRoot.rank
        xRoot.parent := yRoot
    else if xRoot.rank &gt; yRoot.rank
        yRoot.parent := xRoot
    else
        yRoot.parent := xRoot
        xRoot.rank := xRoot.rank + 1

function Find(x)
    if x.parent != x
       x.parent := Find(x.parent)
    return x.parent</code></pre>
</dd>
</dl>
</dd>
<dt>Union-Find Sets, c code <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>ufs.c <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdlib.h&gt;</span>

<span class="kw">typedef</span> <span class="kw">struct</span> ufs_t {
    <span class="dt">int</span> *p;                         <span class="co">// &#26641;&#30340;&#21452;&#20146;&#34920;&#31034;&#27861;</span>
    <span class="dt">int</span> size;
} ufs_t;

ufs_t* ufs_create( <span class="dt">int</span> n ) {
    ufs_t *ufs = (ufs_t *)malloc(<span class="kw">sizeof</span>(ufs_t));
    ufs-&gt;p = (<span class="dt">int</span>*)malloc(n * <span class="kw">sizeof</span>(<span class="dt">int</span>));
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
        ufs-&gt;p[i] = <span class="dv">-1</span>;             <span class="co">// init to disjoint, every node is root</span>
    }
    <span class="kw">return</span> ufs;
}

<span class="dt">void</span> ufs_destroy( ufs_t *ufs ) {
    free( ufs-&gt;p );
    free( ufs );
}

<span class="co">// &#24102;&#36335;&#24452;&#21387;&#32553;&#65292;&#36882;&#24402;&#29256;, return index</span>
<span class="dt">int</span> ufs_find( ufs_t *ufs, <span class="dt">int</span> x ) {
    <span class="kw">if</span>( ufs-&gt;p[x] &lt; <span class="dv">0</span> ) { <span class="kw">return</span> x; }
    <span class="kw">return</span> ufs-&gt;p[x] = ufs_find( ufs, ufs-&gt;p[x] );      <span class="co">// parent</span>
}

<span class="co">// &#26420;&#32032;&#29256;, deprecated</span>
<span class="dt">static</span> <span class="dt">int</span> ufs_find_naive( ufs_t *ufs, <span class="dt">int</span> x ) {
    <span class="kw">while</span>( ufs-&gt;p[x] &gt;= <span class="dv">0</span> ) {
        x = ufs-&gt;p[x];
    }
    <span class="kw">return</span> x;
}

<span class="co">// &#24102;&#36335;&#24452;&#21387;&#32553;&#65292;&#36845;&#20195;&#29256;</span>
<span class="dt">static</span> <span class="dt">int</span> ufs_find_iterative( ufs_t *ufs, <span class="dt">int</span> x ) {
    <span class="dt">int</span> oldx = x;
    <span class="kw">while</span>( ufs-&gt;p[x] &gt;= <span class="dv">0</span> ) {
        x = ufs-&gt;p[x];              <span class="co">// log the parent</span>
    }
    <span class="kw">while</span>( oldx != x ) {
        <span class="dt">int</span> temp = ufs-&gt;p[oldx];    <span class="co">// go up, up and up. assign the x.</span>
        ufs-&gt;p[oldx] = x;
        oldx = temp;
    }
    <span class="kw">return</span> x;
}

<span class="dt">int</span> ufs_union( ufs_t *ufs, <span class="dt">int</span> x, <span class="dt">int</span> y ) {
    <span class="dt">const</span> <span class="dt">int</span> rx = ufs_find(ufs, x);
    <span class="dt">const</span> <span class="dt">int</span> ry = ufs_find(ufs, y);
    <span class="kw">if</span>( rx == ry ) { <span class="kw">return</span> <span class="dv">-1</span>; }

    ufs-&gt;p[rx] += ufs-&gt;p[ry];
    ufs-&gt;p[ry] = rx;
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> ufs_set_size( ufs_t *ufs, <span class="dt">int</span> x ) {
    <span class="dt">const</span> <span class="dt">int</span> rx = ufs_find(ufs, x);
    <span class="kw">return</span> -ufs-&gt;p[rx];
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>infected student <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="ot">#define MAXN 30000</span>

<span class="ot">#include &quot;ufs.c&quot;</span>

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, m, k;
    <span class="kw">while</span>( scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m) &amp;&amp; n &gt; <span class="dv">0</span> ) {
        ufs_t *ufs = ufs_create(MAXN);
        <span class="kw">while</span>( m-- ) {
            <span class="dt">int</span> x, y;                           <span class="co">// two students</span>
            <span class="dt">int</span> rx, ry;                         <span class="co">// x, y &#25152;&#23646;&#30340;&#38598;&#21512;&#30340;&#26681;</span>
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;k);

            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;x); k--;
            rx = ufs_find(ufs, x);
            <span class="kw">while</span>( k-- ) {
                scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;y);
                ry = ufs_find( ufs, y );
                ufs_union( ufs, rx, ry );       <span class="co">// merge y to x</span>
            }
        }
        printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ufs_set_size(ufs, <span class="dv">0</span>) );
        ufs_destroy(ufs);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cat</span> input.txt
<span class="kw">100</span> 4
<span class="kw">2</span> 1 2
<span class="kw">5</span> 10 13 11 12 14
<span class="kw">2</span> 0 1
<span class="kw">2</span> 99 2

<span class="kw">200</span> 2
<span class="kw">1</span> 5
<span class="kw">5</span> 1 2 3 4 5

<span class="kw">1</span> 0
<span class="kw">0</span> 0

$ <span class="kw">cat</span> input.txt <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">4</span>
<span class="kw">1</span>
<span class="kw">1</span></code></pre></div>
<p>C++ Version:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;cstdio&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> UFS {
    <span class="kw">explicit</span> UFS( <span class="dt">int</span> n ) {
        arr = vector&lt;<span class="dt">int</span>&gt;(n, <span class="dv">-1</span>);
    }
    <span class="dt">int</span> _find( <span class="dt">int</span> idx ) {
        <span class="dt">int</span> oldidx = idx;
        <span class="kw">while</span>( arr[idx] &gt;= <span class="dv">0</span> ) { idx = arr[idx]; }
        <span class="kw">while</span>( oldidx != idx ) {
            <span class="dt">int</span> next = arr[oldidx];
            arr[oldidx] = idx;
            oldidx = next;
        }
        <span class="kw">return</span> idx;
    }
    <span class="dt">void</span> _union( <span class="dt">int</span> a, <span class="dt">int</span> b ) {
        <span class="dt">int</span> ra = _find(a);
        <span class="dt">int</span> rb = _find(b);
        <span class="kw">if</span>( ra == rb ) { <span class="kw">return</span>; }  <span class="co">// !!!</span>
        arr[ra] += arr[rb];
        arr[rb] = ra;
    }
    <span class="dt">int</span> _size( <span class="dt">int</span> a ) {
        <span class="kw">return</span> -arr[_find(a)];
    }
    vector&lt;<span class="dt">int</span>&gt; arr;
};

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, m, k;
    <span class="kw">while</span>( scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m) &amp;&amp; n &gt; <span class="dv">0</span> ) {
        UFS ufs(n);
        <span class="kw">while</span>( m-- ) {
            <span class="dt">int</span> x, y;                           <span class="co">// two students</span>
            <span class="dt">int</span> rx, ry;                         <span class="co">// x, y &#25152;&#23646;&#30340;&#38598;&#21512;&#30340;&#26681;</span>
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;k);

            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;x); k--;
            rx = ufs._find(x);
            <span class="kw">while</span>( k-- ) {
                scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;y);
                ufs._union( rx, y );
            }
        }
        printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ufs._size(<span class="dv">0</span>) );
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#39135;&#29289;&#38142; <code class="fold">@</code></dt>
<dd><p>&#21160;&#29289;&#29579;&#22269;&#20013;&#26377;&#19977;&#31867;&#21160;&#29289; A,B,C&#65292;&#36825;&#19977;&#31867;&#21160;&#29289;&#30340;&#39135;&#29289;&#38142;&#26500;&#25104;&#20102;&#26377;&#36259;&#30340;&#29615;&#24418;&#12290;A &#21507; B&#65292; B &#21507; C&#65292;C &#21507; A&#12290; &#29616;&#26377; N &#20010;&#21160;&#29289;&#65292;&#20174; 1 &#21040; N &#32534;&#21495;&#12290;&#27599;&#20010;&#21160;&#29289;&#37117;&#26159; A,B,C &#20013;&#30340;&#19968;&#31181;&#65292;&#20294;&#26159;&#25105;&#20204;&#24182;&#19981;&#30693;&#36947;&#23427;&#21040;&#24213;&#26159;&#21738;&#19968;&#31181;&#12290;</p>
<p>&#26377;&#20154;&#29992;&#20004;&#31181;&#35828;&#27861;&#23545;&#36825; N &#20010;&#21160;&#29289;&#25152;&#26500;&#25104;&#30340;&#39135;&#29289;&#38142;&#20851;&#31995;&#36827;&#34892;&#25551;&#36848;&#65306;</p>
<ul>
<li>&#31532;&#19968;&#31181;&#35828;&#27861;&#26159;&#8220;1 X Y&#8221;&#65292;&#34920;&#31034;X&#21644;Y&#26159;&#21516;&#31867;&#12290;</li>
<li>&#31532;&#20108;&#31181;&#35828;&#27861;&#26159;&#8220;2 X Y&#8221;&#65292;&#34920;&#31034;X&#21507;Y&#12290;</li>
</ul>
<p>&#27492;&#20154;&#23545; N &#20010;&#21160;&#29289;&#65292;&#29992;&#19978;&#36848;&#20004;&#31181;&#35828;&#27861;&#65292;&#19968;&#21477;&#25509;&#19968;&#21477;&#22320;&#35828;&#20986; K &#21477;&#35805;&#65292;&#36825; K &#21477;&#35805;&#26377;&#30340;&#26159;&#30495;&#30340;&#65292;&#26377;&#30340;&#26159;&#20551;&#30340;&#12290;&#24403;&#19968;&#21477;&#35805;&#28385;&#36275;&#19979;&#21015;&#19977;&#26465;&#20043;&#19968;&#26102;&#65292;&#36825;&#21477;&#35805;&#23601;&#26159;&#20551;&#35805;&#65292;&#21542;&#21017;&#23601;&#26159;&#30495;&#35805;&#12290;</p>
<ul>
<li>&#24403;&#21069;&#30340;&#35805;&#19982;&#21069;&#38754;&#30340;&#26576;&#20123;&#30495;&#30340;&#35805;&#20914;&#31361;&#65292;&#23601;&#26159;&#20551;&#35805;&#65307;</li>
<li>&#24403;&#21069;&#30340;&#35805;&#20013; X &#25110; Y &#27604; N &#22823;&#65292;&#23601;&#26159;&#20551;&#35805;&#65307;</li>
<li>&#24403;&#21069;&#30340;&#35805;&#34920;&#31034; X &#21507; X&#65292;&#23601;&#26159;&#20551;&#35805;&#12290;</li>
</ul>
<p>&#20320;&#30340;&#20219;&#21153;&#26159;&#26681;&#25454;&#32473;&#23450;&#30340; N(1 &lt; N &lt; 50,000) &#21644; K &#21477;&#35805; (0 &lt;= K &lt;=100,000 )&#65292;&#36755;&#20986;&#20551;&#35805;&#30340;&#24635;&#25968;&#12290;</p>
<p>&#36755;&#20986;&#21482;&#26377;&#19968;&#20010;&#25972;&#25968;&#65292;&#34920;&#31034;&#20551;&#35805;&#30340;&#25968;&#30446;&#12290;</p>
<pre><code>input:

    &#31532;&#19968;&#34892;&#26159;&#20004;&#20010;&#25972;&#25968; N &#21644; K&#65292;&#20197;&#19968;&#20010;&#31354;&#26684;&#20998;&#38548;&#12290;

    &#20197;&#19979; K &#34892;&#27599;&#34892;&#26159;&#19977;&#20010;&#27491;&#25972;&#25968; D&#65292;X&#65292;Y&#65292;&#20004;&#25968;&#20043;&#38388;&#29992;&#19968;&#20010;&#31354;&#26684;&#38548;&#24320;&#65292;&#20854;&#20013; D &#34920;&#31034;&#35828;&#27861;&#30340;&#31181;&#31867;&#12290;

    -   &#33509; D=1&#65292;&#21017;&#34920;&#31034; X &#21644; Y &#26159;&#21516;&#31867;&#12290;
    -   &#33509; D=2&#65292;&#21017;&#34920;&#31034; X &#21507; Y&#12290;

    100 7
    1 101 1
    2 1 2
    2 2 3
    2 3 3
    1 1 3
    2 3 1
    1 5 5

output:

    3</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* POJ 1182 &#39135;&#29289;&#38142;, Catch them, http://poj.org/problem?id=1182 */</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>

<span class="kw">typedef</span> <span class="kw">struct</span> ufs_t {
    <span class="dt">int</span> *p;
    <span class="dt">int</span> *dist;                          <span class="co">// &#34920;&#31034; x &#19982;&#29238;&#33410;&#28857; p[x] &#30340;&#20851;&#31995;&#65292;0 &#34920;&#31034; x &#19982; p[x] &#26159;&#21516;&#31867;&#65292;1 &#34920;&#31034; x &#21507; p[x]&#65292;2 &#34920;&#31034; p[x] &#21507; x</span>
    <span class="dt">int</span> size;
} ufs_t;

ufs_t* ufs_create(<span class="dt">int</span> n) {
    ufs_t *ufs = (ufs_t*)malloc(<span class="kw">sizeof</span>(ufs_t));
    ufs-&gt;p = (<span class="dt">int</span>*)malloc(n * <span class="kw">sizeof</span>(<span class="dt">int</span>));
    ufs-&gt;dist = (<span class="dt">int</span>*)malloc(n * <span class="kw">sizeof</span>(<span class="dt">int</span>));
    <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
        ufs-&gt;p[i] = <span class="dv">-1</span>;
        ufs-&gt;dist[i] = <span class="dv">0</span>;               <span class="co">// &#33258;&#24049;&#19982;&#33258;&#24049;&#26159;&#21516;&#31867;</span>
    }
    <span class="kw">return</span> ufs;
}

<span class="dt">void</span> ufs_destroy( ufs_t *ufs ) {
    free( ufs-&gt;p );
    free( ufs-&gt;dist );
    free( ufs );
}

<span class="dt">int</span> ufs_find( ufs_t *ufs, <span class="dt">int</span> x ) {
    <span class="kw">if</span>( ufs-&gt;p[x] &lt; <span class="dv">0</span> ) { <span class="kw">return</span> x; }

    <span class="dt">const</span> <span class="dt">int</span> parent = ufs-&gt;p[x];
    ufs-&gt;p[x] = ufs_find( ufs, ufs-&gt;p[x] );
    ufs-&gt;dist[x] = (ufs-&gt;dist[x] + ufs-&gt;dist[parent]) % <span class="dv">3</span>;  <span class="co">// ???</span>
    <span class="kw">return</span> ufs-&gt;p[x];
}

<span class="dt">int</span> ufs_union( ufs_t *ufs, <span class="dt">int</span> root1, <span class="dt">int</span> root2 ) {
    <span class="kw">if</span>( root1 == root2 ) { <span class="kw">return</span> <span class="dv">-1</span>; }
    ufs-&gt;p[root1] += ufs-&gt;p[root2];
    ufs-&gt;p[root2] = root1;
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">void</span> ufs_add_relation( ufs_t *ufs, <span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> relation ) {
    <span class="dt">const</span> <span class="dt">int</span> rx = ufs_find(ufs, x);
    <span class="dt">const</span> <span class="dt">int</span> ry = ufs_find(ufs, y);
    ufs_union( ufs, ry, rx );                               <span class="co">// &#27880;&#24847;&#39034;&#24207;&#65281;</span>
    <span class="co">// rx &#19982; x &#20851;&#31995; + x &#19982; y &#30340;&#20851;&#31995; + y &#19982; ry &#30340;&#20851;&#31995; = rx &#19982; ry &#30340;&#20851;&#31995;</span>
    ufs-&gt;dist[rx] = (ufs-&gt;dist[y] - ufs-&gt;dist[x] + <span class="dv">3</span> + relation) % <span class="dv">3</span>;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> result = <span class="dv">0</span>;                                         <span class="co">// &#20551;&#35805;&#30340;&#25968;&#30446;</span>

    ufs_t *ufs;
    <span class="dt">int</span> n, k;
    scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;k);
    ufs = ufs_create(n + <span class="dv">1</span>);

    <span class="kw">while</span>( k-- ) {
        <span class="dt">int</span> d, x, y;
        scanf(<span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, &amp;d, &amp;x, &amp;y);

        <span class="kw">if</span> (x &gt; n || y &gt; n || (d == <span class="dv">2</span> &amp;&amp; x == y)) {
            result++;
        } <span class="kw">else</span> {
            <span class="dt">const</span> <span class="dt">int</span> rx = ufs_find(ufs, x);
            <span class="dt">const</span> <span class="dt">int</span> ry = ufs_find(ufs, y);

            <span class="kw">if</span> (rx == ry) {                                 <span class="co">// &#33509;&#22312;&#21516;&#19968;&#20010;&#38598;&#21512;&#21017;&#21487;&#30830;&#23450;x&#21644;y&#30340;&#20851;&#31995;</span>
                <span class="kw">if</span>((ufs-&gt;dist[x] - ufs-&gt;dist[y] + <span class="dv">3</span>) % <span class="dv">3</span> != d - <span class="dv">1</span>)
                    result++;
            } <span class="kw">else</span> {
                ufs_add_relation(ufs, x, y, d<span class="dv">-1</span>);
            }
        }
    }

    printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, result);
    ufs_destroy( ufs );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://www.algorithmist.com/index.php/Union_Find">Union Find - Algorithmist</a></li>
<li><a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">Disjoint-set data structure - Wikipedia, the free encyclopedia</a></li>
<li><a href="http://blog.csdn.net/dm_vincent/article/details/7655764">&#24182;&#26597;&#38598; (Union-Find) &#31639;&#27861;&#20171;&#32461; - dm_vincent &#30340;&#19987;&#26639; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
<li><a href="http://www.roading.org//algorithm/introductiontoalgorithm/Disjoint_set.html">&#24182;&#26597;&#38598;(Disjoint Set)</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Trie &#26641; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>Trie &#29702;&#35770;&#30693;&#35782; <code class="fold">@</code></dt>
<dd><p>In computer science, a trie(<code>/&#712;tra&#618;/</code>, as &#8220;try&#8221;), also called <strong>digital tree</strong> and sometimes <strong>radix tree</strong> or <strong>prefix tree</strong> (as they can be searched by prefixes), is a kind of search tree&#8212;an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings. Unlike a binary search tree, no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the string associated with that node, and the root is associated with the empty string. Values are not necessarily associated with every node. Rather, values tend only to be associated with leaves, and with some inner nodes that correspond to keys of interest. For the space-optimized presentation of prefix tree, see compact prefix tree.</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/375px-Trie_example.svg.png" alt="A trie for keys A,to, tea, ted, ten, i, in, and inn." />
<p class="caption">A trie for keys &#8220;A&#8221;,&#8220;to&#8221;, &#8220;tea&#8221;, &#8220;ted&#8221;, &#8220;ten&#8221;, &#8220;i&#8221;, &#8220;in&#8221;, and &#8220;inn&#8221;.</p>
</div>
<p>a trie has a number of advantages over binary search trees. A trie can also be used to replace a hash table, over which it has the following advantages:</p>
<ul>
<li>Looking up data in a trie is <strong>faster in the worst case</strong>, O(m) time (where m is the length of a search string), compared to an imperfect hash table. An imperfect hash table can have <strong>key collisions</strong>. A key collision is the hash function mapping of different keys to the same position in a hash table. The worst-case lookup speed in an imperfect hash table is O(N) time, but far more typically is O(1), with O(m) time spent evaluating the hash.</li>
<li>There are <strong>no collisions</strong> of different keys in a trie.</li>
<li>Buckets in a trie, which are analogous to hash table buckets that store key collisions, are necessary only if a single key is associated with more than one value.</li>
<li>There is <strong>no need to provide a hash function or to change hash functions as more keys are added to a trie</strong>.</li>
<li>A trie can provide an alphabetical ordering of the entries by key.</li>
</ul>
<p>Tries do have some drawbacks as well:</p>
<ul>
<li>Tries can be <strong>slower in some cases than hash tables for looking up data</strong>, especially if the data is directly accessed on a hard disk drive or some other secondary storage device where the random-access time is high compared to main memory.</li>
<li>Some keys, such as floating point numbers, can lead to <strong>long chains and prefixes that are not particularly meaningful</strong>. Nevertheless, a bitwise trie can handle standard IEEE single and double format floating point numbers.</li>
<li>Some tries can <strong>require more space</strong> than a hash table, as memory may be allocated for each character in the search string, rather than a single chunk of memory for the whole entry, as in most hash tables.</li>
</ul>
<dl>
<dt>Suffix tree <code class="fold">@</code></dt>
<dd><p>In computer science, a suffix tree (also called PAT tree or, in an earlier form, position tree) is a compressed trie containing all the suffixes of the given text as their keys and positions in the text as their values. Suffix trees allow particularly fast implementations of many important string operations.</p>
</dd>
<dt>doubly chained tree <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5d/Pointer_implementation_of_a_trie.svg/330px-Pointer_implementation_of_a_trie.svg.png" alt="A trie implemented as a doubly chained tree: vertical arrows are child pointers, dashed horizontal arrows are next pointers. The set of strings stored in this trie is {baby, bad, bank, box, dad, dance}. The lists are sorted to allow traversal in lexicographic order." />
<p class="caption">A trie implemented as a doubly chained tree: vertical arrows are child pointers, dashed horizontal arrows are next pointers. The set of strings stored in this trie is {baby, bad, bank, box, dad, dance}. The lists are sorted to allow traversal in lexicographic order.</p>
</div>
<p><strong>Every multi-way or k-ary tree structure studied in computer science admits a representation as a binary tree</strong>, which goes by various names including &#12304;child-sibling representation&#12305;, &#12304;left-child, right-sibling binary tree&#12305;, &#12304;doubly chained tree&#12305; or &#12304;filial-heir chain&#12305;(<code>['f&#618;l&#618;&#601;l]</code>).</p>
<div class="figure">
<img src="https://en.wikipedia.org/wiki/File:N-ary_to_binary.svg" alt="6-ary tree represented as a binary tree" />
<p class="caption">6-ary tree represented as a binary tree</p>
</div>
<p>The process of converting from a <strong>k-ary tree</strong> to an <strong>LC-RS binary tree</strong> is sometimes called the &#12304;Knuth transform&#12305;.</p>
<pre><code>       1                       1                          1
      /|\                     /                          /
     / | \                   /                          2
    /  |  \                 /                          / \
   2   3   4               2---3---4                  5   3
  / \      |              /       /                    \   \
 5   6     7             5---6   7                      6   4
          / \                   /                          /
         8   9                 8---9                      7
                                                         /
                                                        8
                                                         \
                                                          9</code></pre>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Trie">Trie - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Suffix_tree">Suffix tree - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Left-child_right-sibling_binary_tree">Left-child right-sibling binary tree - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
</dl></li>
<li><p>Trie &#26641;&#30340;&#30456;&#20851;&#36816;&#29992;</p></li>
<li><dl>
<dt>Trie tree <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>trie_tree.c <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>

<span class="ot">#define MAXN 10000</span>
<span class="ot">#define CHAR_COUNT  10                      </span><span class="co">// &#23383;&#31526;&#30340;&#31181;&#31867;&#65292;&#20063;&#21363;&#21333;&#20010;&#33410;&#28857;&#30340;&#23376;&#26641;&#30340;&#26368;&#22823;&#20010;&#25968;</span>
<span class="ot">#define MAX_CODE_LEN 10</span>
<span class="ot">#define MAX_NODE_COUNT  (MAXN * MAX_CODE_LEN + 1)  /** </span>&#23383;&#20856;&#26641;&#30340;&#26368;&#22823;&#33410;&#28857;&#20010;&#25968;. */
                   <span class="co">/* &#22914;&#26524;&#27809;&#26377;&#25351;&#23450; MAXN&#65292;&#21017;&#26159; CHAR_COUNT^(MAX_CODE_LEN+1)-1 */</span>

<span class="kw">typedef</span> <span class="kw">struct</span> trie_node_t {
    <span class="kw">struct</span> trie_node_t* next[CHAR_COUNT];
    <span class="dt">bool</span> is_tail;                           <span class="co">// &#24403;&#21069;&#23383;&#31526;&#26159;&#21542;&#20301;&#20110;&#26576;&#20010;&#20018;&#30340;&#23614;&#37096;</span>
} trie_node_t;

<span class="kw">typedef</span> <span class="kw">struct</span> trie_tree_t {
    trie_node_t *root;                      <span class="co">/** </span>&#26641;&#30340;&#26681;&#33410;&#28857; */
    <span class="dt">int</span> size;
    trie_node_t nodes[MAX_NODE_COUNT];
} trie_tree_t;

trie_tree_t* trie_tree_create(<span class="dt">void</span>) {
    trie_tree_t *tree = (trie_tree_t*)malloc(<span class="kw">sizeof</span>(trie_tree_t));
    tree-&gt;root = tree-&gt;nodes;
    memset(tree-&gt;nodes, <span class="dv">0</span>, <span class="kw">sizeof</span>(tree-&gt;nodes));
    tree-&gt;size = <span class="dv">1</span>;
    <span class="kw">return</span> tree;
}

<span class="dt">void</span> trie_tree_destroy(trie_tree_t *tree) {
    free(tree);
    tree = NULL;                            <span class="co">// not necessary</span>
}

<span class="dt">void</span> trie_tree_clear(trie_tree_t *tree) {
    memset(tree-&gt;nodes, <span class="dv">0</span>, <span class="kw">sizeof</span>(tree-&gt;nodes));
    tree-&gt;size = <span class="dv">1</span>;                         <span class="co">// &#28165;&#31354;&#26102;&#19968;&#23450;&#35201;&#27880;&#24847;&#36825;&#19968;&#27493;&#65281;</span>
}

<span class="dt">bool</span> trie_tree_insert(trie_tree_t *tree, <span class="dt">char</span> *word) {
    <span class="dt">int</span> i;
    trie_node_t *p = tree-&gt;root;
    <span class="kw">while</span> (*word) {
        <span class="dt">int</span> curword = *word - <span class="st">&#39;0&#39;</span>;
        <span class="kw">if</span> (p-&gt;next[curword] == NULL) {
            p-&gt;next[curword] = &amp;(tree-&gt;nodes[tree-&gt;size++]);
        }
        p = p-&gt;next[curword];
        <span class="kw">if</span> (p-&gt;is_tail) {
            <span class="kw">return</span> <span class="kw">false</span>;                   <span class="co">// &#26576;&#20018;&#26159;&#24403;&#21069;&#20018;&#30340;&#21069;&#32512;</span>
        }
        ++word;
    }

    p-&gt;is_tail = <span class="kw">true</span>;                      <span class="co">// &#26631;&#35760;&#24403;&#21069;&#20018;&#24050;&#26159;&#32467;&#23614;</span>

    <span class="co">// &#21028;&#26029;&#24403;&#21069;&#20018;&#26159;&#21542;&#26159;&#26576;&#20010;&#20018;&#30340;&#21069;&#32512;</span>
    <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; CHAR_COUNT; i++) {
        <span class="kw">if</span> (p-&gt;next[i] != NULL) {
            <span class="kw">return</span> <span class="kw">false</span>;
        }
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>immediate decodebility <code class="fold">@</code></dt>
<dd><p>POJ 1056 IMMEDIATE DECODABILITY, <a href="http://poj.org/problem?id=1056" class="uri">http://poj.org/problem?id=1056</a></p>
<p>An encoding of a set of symbols is said to be immediately decodable if no code for one symbol is the prefix of a code for another symbol. We will assume for this problem that all codes are in binary, that no two codes within a set of codes are the same, that each code has at least one bit and no more than ten bits, and that each set has at least two codes and no more than eight.</p>
<p>Examples: Assume an alphabet that has symbols <code>{A, B, C, D}</code>.</p>
<p>The following code is immediately decodable:</p>
<pre><code>A:01 B:10 C:0010 D:0000</code></pre>
<p>but this one is not:</p>
<pre><code>A:01 B:10 C:010 D:0000 (Note that A is a prefix of C)</code></pre>
<p>&#36755;&#20837;</p>
<p>Write a program that accepts as input a series of groups of records from standard input. Each record in a group contains a collection of zeroes and ones representing a binary code for a different symbol. Each group is followed by a single separator record containing a single 9; the separator records are not part of the group. Each group is independent of other groups; the codes in one group are not related to codes in any other group (that is, each group is to be processed independently).</p>
<p>&#36755;&#20986;</p>
<p>For each group, your program should determine whether the codes in that group are immediately decodable, and should print a single output line giving the group number and stating whether the group is, or is not, immediately decodable.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;trie_tree.c&quot;</span>

<span class="dt">int</span> main() {
    <span class="dt">int</span> T = <span class="dv">0</span>;
    <span class="dt">char</span> line[MAX_NODE_COUNT];
    trie_tree_t *trie_tree = trie_tree_create();
    <span class="dt">bool</span> islegal = <span class="kw">true</span>;

    <span class="kw">while</span> ( scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, line) != EOF ) {
        <span class="kw">if</span> (strcmp(line, <span class="st">&quot;9&quot;</span>) == <span class="dv">0</span>) {
            <span class="kw">if</span> (islegal) {
                printf(<span class="st">&quot;Set </span><span class="ch">%d</span><span class="st"> is immediately decodable</span><span class="ch">\n</span><span class="st">&quot;</span>, ++T);
            } <span class="kw">else</span> {
                printf(<span class="st">&quot;Set </span><span class="ch">%d</span><span class="st"> is not immediately decodable</span><span class="ch">\n</span><span class="st">&quot;</span>, ++T);
            }
            trie_tree_clear(trie_tree);
            islegal = <span class="kw">true</span>;
        } <span class="kw">else</span> {
            <span class="kw">if</span> (islegal) {
                islegal = trie_tree_insert(trie_tree, line);
            }
        }
    }
    trie_tree_destroy(trie_tree);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<pre><code>01
10
0010
0000
9
01
10
010
0000
9</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cat</span> input.txt <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">Set</span> 1 is immediately decodable
<span class="kw">Set</span> 2 is not immediately decodable</code></pre></div>
<p>compiled, and okay.</p>
<p>C++ version:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> TrieTree {

    <span class="kw">explicit</span> TrieTree() { clear(); }

    <span class="dt">const</span> <span class="dt">static</span> <span class="dt">int</span> CHARCOUNT = <span class="dv">10</span>;
    <span class="dt">const</span> <span class="dt">static</span> <span class="dt">int</span> NODECOUNT = <span class="dv">10</span>*<span class="dv">100</span>;
    <span class="kw">struct</span> TrieTreeNode {
        <span class="dt">bool</span> isTail;
        TrieTreeNode *next[CHARCOUNT];
        TrieTreeNode() : isTail(<span class="kw">false</span>) { fill( next, next+CHARCOUNT, (TrieTreeNode *)<span class="dv">0</span> ); }
    } *root;
    <span class="dt">int</span> size;
    vector&lt;TrieTreeNode&gt; nodes;

    <span class="dt">void</span> clear() {
        size  = <span class="dv">1</span>;
        nodes = vector&lt;TrieTreeNode&gt;( NODECOUNT, TrieTreeNode() );
        root  = &amp;nodes[<span class="dv">0</span>];
    }

    <span class="dt">bool</span> insert( <span class="dt">const</span> string &amp;word ) {
        <span class="dt">int</span> n = word.size();
        TrieTreeNode *p = root;
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
            <span class="dt">int</span> idx = word[i] - <span class="st">&#39;0&#39;</span>;
            <span class="kw">if</span>( !p-&gt;next[idx] ) {
                p-&gt;next[idx] = &amp;nodes[size++];
            }
            p = p-&gt;next[idx];
            <span class="kw">if</span>( p-&gt;isTail ) { <span class="kw">return</span> <span class="kw">false</span>; }
        }
        p-&gt;isTail = <span class="kw">true</span>;
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i&lt; CHARCOUNT; ++i ) {
            <span class="kw">if</span>( p-&gt;next[i] ) {
                <span class="kw">return</span> <span class="kw">false</span>;
            }
        }
        <span class="kw">return</span> <span class="kw">true</span>;
    }
};

<span class="dt">int</span> main() {

    <span class="dt">bool</span> islegal = <span class="kw">true</span>;
    TrieTree tt;
    string line;
    <span class="dt">int</span> T = <span class="dv">0</span>;

    <span class="kw">while</span>( getline( cin, line ) ) {
        <span class="kw">if</span>( line == <span class="st">&quot;9&quot;</span> ) {
            printf( <span class="st">&quot;Set </span><span class="ch">%d</span><span class="st"> is </span><span class="ch">%s</span><span class="st">immediately decodable</span><span class="ch">\n</span><span class="st">&quot;</span>, ++T, islegal ? <span class="st">&quot;&quot;</span> : <span class="st">&quot;not &quot;</span> );
            tt.clear();
            islegal = <span class="kw">true</span>;
        } <span class="kw">else</span> {
            <span class="kw">if</span> (islegal) { islegal = tt.insert( line ); }
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>TODO: <code>Node *next[CHARCOUNT]</code> -&gt; <code>int next[CHARCOUNT]</code>, see Hardwood Species for <em>HOWTO</em>.</p>
</dd>
</dl></li>
<li><dl>
<dt>Hardwood Species <code class="fold">@</code></dt>
<dd><dl>
<dt>input <code class="fold">@</code></dt>
<dd><pre><code>Red Alder
Ash
Aspen
Basswood
Ash
Beech
Yellow Birch
Ash
Cherry
Cottonwood
Ash
Cypress
Red Elm
Gum
Hackberry
White Oak
Hickory
Pecan
Hard Maple
White Oak
Soft Maple
Red Oak
Red Oak
White Oak
Poplan
Sassafras
Sycamore
Black Walnut
Will</code></pre>
</dd>
<dt>output <code class="fold">@</code></dt>
<dd><pre><code>Ash 13.7931
Aspen 3.4483
Basswood 3.4483
Beech 3.4483
Black Walnut 3.4483
Cherry 3.4483
Cottonwood 3.4483
Cypress 3.4483
Gum 3.4483
Hackberry 3.4483
Hard Maple 3.4483
Hickory 3.4483
Pecan 3.4483
Poplan 3.4483
Red Alder 3.4483
Red Elm 3.4483
Red Oak 6.8966
Sassafras 3.4483
Soft Maple 3.4483
Sycamore 3.4483
White Oak 10.3448
Willow 3.4483
Yellow Birch 3.4483</code></pre>
</dd>
<dt>code.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> TrieTree {

    <span class="kw">explicit</span> TrieTree() { clear(); }

    <span class="dt">const</span> <span class="dt">static</span> <span class="dt">int</span> CHARCOUNT = <span class="dv">128</span>;                           <span class="co">// ascii code</span>
    <span class="dt">const</span> <span class="dt">static</span> <span class="dt">int</span> NODECOUNT = <span class="dv">128</span>*<span class="dv">100</span>;
    <span class="kw">struct</span> TrieTreeNode {
        <span class="dt">int</span> next[CHARCOUNT];                                    <span class="co">// actually we can save count into next[0]</span>
        <span class="dt">int</span> count;
        TrieTreeNode() : count(<span class="dv">0</span>) { fill( next, next+CHARCOUNT, <span class="dv">0</span> ); }
    };

    <span class="dt">void</span> insert( <span class="dt">const</span> string &amp;word ) {
        <span class="dt">int</span> n = word.size();
        <span class="dt">int</span> p = <span class="dv">0</span>;
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i ) {
            <span class="dt">int</span> idx = word[i];
            <span class="kw">if</span>( !nodes[p].next[idx] ) {
                nodes[p].next[idx] = nodes.size();
                nodes.push_back( TrieTreeNode() );
            }
            p = nodes[p].next[idx];
        }
        ++nodes[p].count;
    }

    <span class="dt">void</span> dfs( <span class="dt">int</span> r, <span class="dt">const</span> <span class="dt">int</span> n ) {
        <span class="kw">if</span>( nodes[r].count ) {
            word[pos] = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>;
            printf( <span class="st">&quot;</span><span class="ch">%s</span><span class="st"> </span><span class="ch">%0.4f\n</span><span class="st">&quot;</span>, word, ((<span class="dt">float</span>)nodes[r].count * <span class="dv">100</span>) / n );
        }
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; CHARCOUNT; ++i ) {
            <span class="kw">if</span>( nodes[r].next[i] ) {
                word[pos] = i;
                ++pos;
                dfs( nodes[r].next[i], n );
                --pos;
            }
        }
    }

    <span class="dt">void</span> clear() {
        nodes = vector&lt;TrieTreeNode&gt;( <span class="dv">1</span>, TrieTreeNode() );
    }
    <span class="dt">void</span> reset() { pos = <span class="dv">0</span>; }

    vector&lt;TrieTreeNode&gt; nodes;
    <span class="dt">char</span> word[<span class="dv">50</span>];
    <span class="dt">int</span> pos;
};

<span class="dt">int</span> main() {

    TrieTree tt;
    string line;

    <span class="dt">int</span> n = <span class="dv">0</span>;
    <span class="kw">while</span>( getline( cin, line ) ) {
        tt.insert( line );
        ++n;
    }
    tt.reset();
    tt.dfs( <span class="dv">0</span>, n );
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li>&#25195;&#25551;&#32447;&#31639;&#27861;
<ul>
<li><ol style="list-style-type: decimal">
<li>&#25195;&#25551;&#32447;&#30340;&#24120;&#35268;&#39064;&#30446;</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>&#25195;&#25551;&#32447;&#21644;&#20854;&#20182;&#25968;&#25454;&#32467;&#26500;&#32467;&#21512;&#30340;&#25299;&#23637;</li>
</ol></li>
<li><dl>
<dt>Interval Tree <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>balanced line up <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;limits.h&gt;</span>

<span class="ot">#define MAXN 50001                          </span><span class="co">// 0 &#20301;&#32622;&#26410;&#29992;</span>
<span class="ot">#define max(a,b) ((a)&gt;(b)?(a):(b))</span>
<span class="ot">#define min(a,b) ((a)&lt;(b)?(a):(b))</span>
<span class="ot">#define L(a) ((a)&lt;&lt;1)</span>
<span class="ot">#define R(a) (((a)&lt;&lt;1)+1)</span>

<span class="kw">typedef</span> <span class="kw">struct</span> node_t {
    <span class="dt">int</span> left, right;
    <span class="dt">int</span> max, min;
} node_t;

<span class="dt">int</span> A[MAXN];

<span class="co">// &#23436;&#20840;&#20108;&#21449;&#26641;&#65292;&#32467;&#28857;&#32534;&#21495;&#20174; 1 &#24320;&#22987;&#65292;&#23618;&#27425;&#20174; 1 &#24320;&#22987;.</span>
<span class="co">// &#29992;&#19968;&#32500;&#25968;&#32452;&#23384;&#20648;&#23436;&#20840;&#20108;&#21449;&#26641;&#65292;&#31354;&#38388;&#32422;&#20026; 4N&#65292;</span>
<span class="co">// &#21442;&#32771; http://comzyh.tk/blog/archives/479/</span>
node_t node[MAXN * <span class="dv">4</span>];

<span class="dt">int</span> minx, maxx;                             <span class="co">// &#23384;&#25918;&#26597;&#35810;&#30340;&#32467;&#26524;</span>

<span class="dt">void</span> init() { memset(node, <span class="dv">0</span>, <span class="kw">sizeof</span>(node)); }

<span class="co">// &#20197; t &#20026;&#26681;&#32467;&#28857;&#65292;&#20026;&#21306;&#38388; A[l,r] &#24314;&#31435;&#32447;&#27573;&#26641;</span>
<span class="dt">void</span> build(<span class="dt">int</span> t, <span class="dt">int</span> l, <span class="dt">int</span> r) {
    node[t].left = l, node[t].right = r;
    <span class="kw">if</span> (l == r) {
        node[t].max = node[t].min = A[l];
        <span class="kw">return</span>;
    }
    <span class="dt">const</span> <span class="dt">int</span> mid = (l + r) / <span class="dv">2</span>;
    build(L(t), l, mid);
    build(R(t), mid + <span class="dv">1</span>, r);
    node[t].max = max( node[L(t)].max, node[R(t)].max );
    node[t].min = min( node[L(t)].min, node[R(t)].min );
}

<span class="co">// &#26597;&#35810;&#26681;&#32467;&#28857;&#20026; t&#65292;&#21306;&#38388;&#20026; A[l,r] &#30340;&#26368;&#22823;&#20540;&#21644;&#26368;&#23567;&#20540;</span>
<span class="dt">void</span> query(<span class="dt">int</span> t, <span class="dt">int</span> l, <span class="dt">int</span> r) {
    <span class="kw">if</span> (node[t].left == l &amp;&amp; node[t].right == r) {
        <span class="kw">if</span> (maxx &lt; node[t].max)
            maxx = node[t].max;
        <span class="kw">if</span> (minx &gt; node[t].min)
            minx = node[t].min;
        <span class="kw">return</span>;
    }
    <span class="dt">const</span> <span class="dt">int</span> mid = (node[t].left + node[t].right) / <span class="dv">2</span>;
    <span class="kw">if</span> (l &gt; mid) {
        query(R(t), l, r);
    } <span class="kw">else</span> <span class="kw">if</span> (r &lt;= mid) {
        query(L(t), l, r);
    } <span class="kw">else</span> {
        query(L(t), l, mid);
        query(R(t), mid + <span class="dv">1</span>, r);
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, q, i;

    scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;q);
    <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt;= n; i++) scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;A[i]);

    init();
    <span class="co">// &#24314;&#31435;&#20197; tree &#20026;&#26681;&#32467;&#28857;&#65292;&#21306;&#38388;&#20026; A[1,n] &#30340;&#32447;&#27573;&#26641;</span>
    build(<span class="dv">1</span>, <span class="dv">1</span>, n);

    <span class="kw">while</span> (q--) {
        <span class="dt">int</span> a, b;
        scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;a, &amp;b);
        maxx = <span class="dv">0</span>;
        minx = INT_MAX;
        query(<span class="dv">1</span>, a, b);                 <span class="co">// &#26597;&#35810;&#21306;&#38388; A[a,b] &#30340;&#26368;&#22823;&#20540;&#21644;&#26368;&#23567;&#20540;</span>
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, maxx - minx);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>input:</p>
<pre><code>6   3
1
7
3
4
2
5
1   5
4   6
2   2</code></pre>
<p>C++ Version:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> IntervalTree {
    <span class="kw">struct</span> Node {
        <span class="dt">int</span> left, right, max, min;
        Node( <span class="dt">int</span> l = <span class="dv">0</span>, <span class="dt">int</span> r = <span class="dv">0</span>, <span class="dt">int</span> ma = <span class="dv">0</span>, <span class="dt">int</span> mi = <span class="dv">0</span> ) : left(l), right(r), max(ma), min(mi) {}
    };
    <span class="kw">explicit</span> IntervalTree( <span class="dt">int</span> n ) : n(n) {
        arr     =   vector&lt;<span class="dt">int</span>&gt;( n<span class="dv">+1</span> );
        node    =   vector&lt;Node&gt;( <span class="dv">4</span>*(n<span class="dv">+1</span>), Node() );
    }
    <span class="dt">void</span> build( <span class="dt">int</span> root, <span class="dt">int</span> left, <span class="dt">int</span> right ) {
        Node &amp;r = node[root];
        r.left  = left;
        r.right = right;
        <span class="kw">if</span>( left == right ) {
            r.max = r.min = arr[left];
            <span class="kw">return</span>;
        }
        <span class="dt">int</span> mid = (left+right)/<span class="dv">2</span>;
        build( <span class="dv">2</span>*root,      left,       mid     );
        build( <span class="dv">2</span>*root<span class="dv">+1</span>,    mid<span class="dv">+1</span>,      right   );
        r.max = max( node[<span class="dv">2</span>*root].max, node[<span class="dv">2</span>*root<span class="dv">+1</span>].max );
        r.min = min( node[<span class="dv">2</span>*root].min, node[<span class="dv">2</span>*root<span class="dv">+1</span>].min );
    }
    <span class="dt">void</span> print() {
        printf( <span class="st">&quot;A: [ &quot;</span> );
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i ) {
            printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, arr[i] );
        }
        printf( <span class="st">&quot;].</span><span class="ch">\n</span><span class="st">&quot;</span> );
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= <span class="dv">4</span>*n; ++i ) {
            Node &amp;n = node[i];
            <span class="kw">if</span>( !n.left || !n.right ) { <span class="kw">continue</span>; }
            printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">: [l: </span><span class="ch">%d</span><span class="st">, r: </span><span class="ch">%d</span><span class="st">, min: </span><span class="ch">%d</span><span class="st">, max: </span><span class="ch">%d</span><span class="st">]</span><span class="ch">\n</span><span class="st">&quot;</span>, i, n.left, n.right, n.min, n.max );
        }
    }

    <span class="dt">void</span> query( <span class="dt">int</span> root, <span class="dt">int</span> left, <span class="dt">int</span> right, <span class="dt">int</span> &amp;maxx, <span class="dt">int</span> &amp;minx ) {
        Node &amp;r = node[root];
        <span class="kw">if</span>( r.left == left &amp;&amp; r.right == right ) {
            maxx = max( maxx, r.max );
            minx = min( minx, r.min );
            <span class="kw">return</span>;
        }
        <span class="dt">int</span> mid = (r.left + r.right)/<span class="dv">2</span>;
        <span class="kw">if</span>( left &gt; mid ) {
            query( <span class="dv">2</span>*root<span class="dv">+1</span>,    left,   right,  maxx,   minx    );
        } <span class="kw">else</span> <span class="kw">if</span>( right &lt;= mid ) {
            query( <span class="dv">2</span>*root,      left,   right,  maxx,   minx    );
        } <span class="kw">else</span> {
            query( <span class="dv">2</span>*root,      left,   mid,    maxx,   minx    );
            query( <span class="dv">2</span>*root<span class="dv">+1</span>,    mid<span class="dv">+1</span>,  right,  maxx,   minx    );
        }
    }

    <span class="dt">int</span> n;
    vector&lt;Node&gt; node;
    vector&lt;<span class="dt">int</span>&gt; arr;
};

<span class="dt">int</span> main() {

    <span class="dt">int</span> n, q;
    <span class="kw">while</span>( <span class="dv">2</span> == scanf( <span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;q ) ) {

        IntervalTree it(n);
        <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i ) { scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;it.arr[i] ); }
        it.build( <span class="dv">1</span>, <span class="dv">1</span>, n );
        it.print();
        <span class="kw">while</span> ( q-- ) {
            <span class="dt">int</span> a, b;
            scanf( <span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;a, &amp;b );
            <span class="dt">int</span> maxx = <span class="dv">-1</span>, minx = <span class="bn">0x7FFFFFFF</span>;
            it.query( <span class="dv">1</span>, a, b, maxx, minx );
            printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, maxx - minx );
        }
    }

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>compile &amp; run:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># compile</span>
$ <span class="kw">g++</span> main.cpp
$ <span class="kw">cat</span> input.txt <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">A</span>: [ 1 7 3 4 2 5 ].
<span class="kw">1</span>: [l: 1, r: 6, min: 1, max: 7]
<span class="kw">2</span>: [l: 1, r: 3, min: 1, max: 7]
<span class="kw">3</span>: [l: 4, r: 6, min: 2, max: 5]
<span class="kw">4</span>: [l: 1, r: 2, min: 1, max: 7]
<span class="kw">5</span>: [l: 3, r: 3, min: 3, max: 3]
<span class="kw">6</span>: [l: 4, r: 5, min: 2, max: 4]
<span class="kw">7</span>: [l: 6, r: 6, min: 5, max: 5]
<span class="kw">8</span>: [l: 1, r: 1, min: 1, max: 1]
<span class="kw">9</span>: [l: 2, r: 2, min: 7, max: 7]
<span class="kw">12</span>: [l: 4, r: 4, min: 4, max: 4]
<span class="kw">13</span>: [l: 5, r: 5, min: 2, max: 2]
<span class="kw">6</span>
<span class="kw">3</span>
<span class="kw">0</span></code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="http://stackoverflow.com/questions/17466218/what-are-the-differences-between-segment-trees-interval-trees-binary-indexed-t">algorithm - What are the differences between segment trees, interval trees, binary indexed trees and range trees? - Stack Overflow</a></li>
<li><a href="http://www.dgp.toronto.edu/people/JamesStewart/378notes/22intervals/">CSC378: Interval Trees</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>exercise 1 <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> IntervalTree {
    <span class="kw">struct</span> Node {
        Node( <span class="dt">int</span> l = <span class="dv">0</span>, <span class="dt">int</span> r = <span class="dv">0</span>, <span class="dt">int</span> s = <span class="dv">0</span> ) : left(l), right(r), sum(s) {}
        <span class="dt">int</span> left, right, sum;
    };
    <span class="kw">explicit</span> IntervalTree( <span class="dt">int</span> n ) : n(n) {
        arr     =   vector&lt;<span class="dt">int</span>&gt;( n<span class="dv">+1</span> );
        node    =   vector&lt;Node&gt;( <span class="dv">4</span>*(n<span class="dv">+1</span>), Node() );
    }
    <span class="dt">void</span> build( <span class="dt">int</span> root, <span class="dt">int</span> left, <span class="dt">int</span> right ) {
        Node &amp;r = node[root];
        r.left  = left;
        r.right = right;
        <span class="kw">if</span>( left == right ) {
            r.sum = arr[left];
            <span class="kw">return</span>;
        }
        <span class="dt">int</span> mid = (left+right)/<span class="dv">2</span>;
        build( <span class="dv">2</span>*root,      left,       mid     );
        build( <span class="dv">2</span>*root<span class="dv">+1</span>,    mid<span class="dv">+1</span>,      right   );
        r.sum = node[<span class="dv">2</span>*root].sum + node[<span class="dv">2</span>*root<span class="dv">+1</span>].sum;
    }

    <span class="dt">void</span> update( <span class="dt">int</span> root, <span class="dt">int</span> left, <span class="dt">int</span> right, <span class="dt">int</span> pos, <span class="dt">int</span> delta ) {
        Node &amp;r = node[root];
        <span class="kw">if</span>( r.left &gt; pos || r.right &lt; pos ) { <span class="kw">return</span>; }
        <span class="kw">if</span>( r.left == r.right ) {
            r.sum += delta;
            <span class="kw">return</span>;
        }
        <span class="dt">int</span> mid = (r.left+r.right)/<span class="dv">2</span>;
        <span class="kw">if</span>( left &gt; mid ) {
            update( <span class="dv">2</span>*root<span class="dv">+1</span>,   left,   right,  pos,    delta   );
        } <span class="kw">else</span> <span class="kw">if</span>( right &lt;= mid ) {
            update( <span class="dv">2</span>*root,     left,   right,  pos,    delta   );
        } <span class="kw">else</span> {
            update( <span class="dv">2</span>*root,     left,   mid,    pos,    delta   );
            update( <span class="dv">2</span>*root<span class="dv">+1</span>,   mid<span class="dv">+1</span>,  right,  pos,    delta   );
        }
        r.sum = node[<span class="dv">2</span>*root].sum + node[<span class="dv">2</span>*root<span class="dv">+1</span>].sum;
    }

    <span class="dt">int</span> query( <span class="dt">int</span> root, <span class="dt">int</span> left, <span class="dt">int</span> right ) {
        Node &amp;r = node[root];
        <span class="kw">if</span>( r.left == left &amp;&amp; r.right == right ) {
            <span class="kw">return</span> r.sum;
        }
        <span class="dt">int</span> mid = (r.left + r.right)/<span class="dv">2</span>;
        <span class="kw">if</span>( left &gt; mid ) {
            <span class="kw">return</span> query( <span class="dv">2</span>*root<span class="dv">+1</span>, left, right );
        } <span class="kw">else</span> <span class="kw">if</span>( right &lt;= mid ) {
            <span class="kw">return</span> query( <span class="dv">2</span>*root,   left, right );
        } <span class="kw">else</span> {
            <span class="kw">return</span> query( <span class="dv">2</span>*root, left, mid ) + query( <span class="dv">2</span>*root<span class="dv">+1</span>, mid<span class="dv">+1</span>, right );
        }
    }

    <span class="dt">int</span> n;
    vector&lt;Node&gt; node;
    vector&lt;<span class="dt">int</span>&gt; arr;
};

<span class="dt">int</span> main() {

    <span class="dt">int</span> n, q;
    <span class="kw">while</span>( <span class="dv">1</span> == scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n ) ) {

        IntervalTree it(n);
        <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i ) { scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;it.arr[i] ); }
        it.build( <span class="dv">1</span>, <span class="dv">1</span>, n );

        scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;q );
        <span class="kw">while</span> ( q-- ) {
            <span class="dt">int</span> cmd, a, b;
            scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;cmd, &amp;a, &amp;b );
            <span class="kw">if</span>( cmd == <span class="dv">2</span> ) {
                printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, it.query(<span class="dv">1</span>,a,b) );
            } <span class="kw">else</span> {
                <span class="kw">if</span>( b ) {
                    it.update( <span class="dv">1</span>, <span class="dv">1</span>, n, a, b );
                }
            }
        }
    }

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>input.txt:</p>
<pre><code>6
4   5   6   2   1   3
4
1   3   5
2   1   4
1   1   9
2   2   6</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">g++</span> main.cpp
$ <span class="kw">cat</span> input.txt <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">22</span>
<span class="kw">22</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>A Simple Problem with Integers <code class="fold">@</code></dt>
<dd><pre><code>C   a   b   c           -&gt;      A[i] += c, for i=[a..b]
Q   a   b               -&gt;      sum of A[a..b]</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> IntervalTree {
    <span class="kw">struct</span> Node {
        Node( <span class="dt">int</span> l = <span class="dv">0</span>, <span class="dt">int</span> r = <span class="dv">0</span>, <span class="dt">int</span> s = <span class="dv">0</span>, <span class="dt">int</span> i = <span class="dv">0</span> ) : left(l), right(r), sum(s), inc(i) {}
        <span class="dt">int</span> left, right, sum, inc;                          <span class="co">// inc!</span>
    };
    <span class="kw">explicit</span> IntervalTree( <span class="dt">int</span> n ) : n(n) {
        arr     =   vector&lt;<span class="dt">int</span>&gt;( n<span class="dv">+1</span> );
        node    =   vector&lt;Node&gt;( <span class="dv">4</span>*(n<span class="dv">+1</span>), Node() );
    }
    <span class="dt">void</span> build( <span class="dt">int</span> root, <span class="dt">int</span> left, <span class="dt">int</span> right ) {
        Node &amp;r = node[root];
        r.left  = left;
        r.right = right;
        <span class="kw">if</span>( left == right ) {
            r.sum = arr[left];
            <span class="kw">return</span>;
        }
        <span class="dt">int</span> mid = (left+right)/<span class="dv">2</span>;
        build( <span class="dv">2</span>*root,      left,       mid     );
        build( <span class="dv">2</span>*root<span class="dv">+1</span>,    mid<span class="dv">+1</span>,      right   );
        r.sum = node[<span class="dv">2</span>*root].sum + node[<span class="dv">2</span>*root<span class="dv">+1</span>].sum;
    }

    <span class="dt">void</span> update( <span class="dt">int</span> root, <span class="dt">int</span> left, <span class="dt">int</span> right, <span class="dt">int</span> delta ) {
        Node &amp;r = node[root];
        <span class="kw">if</span>( r.left == left &amp;&amp; r.right == right ) {
            r.inc += delta;
            r.sum += delta * (right-left<span class="dv">+1</span>);
            <span class="kw">return</span>;
        }

        Node &amp;nr = node[<span class="dv">2</span>*root<span class="dv">+1</span>];
        Node &amp;nl = node[<span class="dv">2</span>*root];

        <span class="kw">if</span>( r.inc ) {
            nr.inc += r.inc;
            nl.inc += r.inc;
            nr.sum += r.inc * (nr.right-nr.left<span class="dv">+1</span>);
            nl.sum += r.inc * (nl.right-nl.left<span class="dv">+1</span>);
            r.inc = <span class="dv">0</span>;
        }
        <span class="dt">int</span> mid = (r.left+r.right)/<span class="dv">2</span>;
        <span class="kw">if</span>( left &gt; mid ) {
            update( <span class="dv">2</span>*root<span class="dv">+1</span>,   left,   right,  delta   );
        } <span class="kw">else</span> <span class="kw">if</span>( right &lt;= mid ) {
            update( <span class="dv">2</span>*root,     left,   right,  delta   );
        } <span class="kw">else</span> {
            update( <span class="dv">2</span>*root,     left,   mid,    delta   );
            update( <span class="dv">2</span>*root<span class="dv">+1</span>,   mid<span class="dv">+1</span>,  right,  delta   );
        }
        r.sum = nr.sum + nl.sum;
    }

    <span class="dt">int</span> query( <span class="dt">int</span> root, <span class="dt">int</span> left, <span class="dt">int</span> right ) {
        Node &amp;r = node[root];
        <span class="kw">if</span>( r.left == left &amp;&amp; r.right == right ) {
            <span class="kw">return</span> r.sum;
        }

        Node &amp;nr = node[<span class="dv">2</span>*root<span class="dv">+1</span>];
        Node &amp;nl = node[<span class="dv">2</span>*root];

        <span class="kw">if</span>( r.inc ) {
            nr.inc += r.inc;
            nl.inc += r.inc;
            nr.sum += r.inc * (nr.right-nr.left<span class="dv">+1</span>);
            nl.sum += r.inc * (nl.right-nl.left<span class="dv">+1</span>);
            r.inc = <span class="dv">0</span>;
        }
        <span class="dt">int</span> mid = (r.left + r.right)/<span class="dv">2</span>;
        <span class="kw">if</span>( left &gt; mid ) {
            <span class="kw">return</span> query( <span class="dv">2</span>*root<span class="dv">+1</span>, left, right );
        } <span class="kw">else</span> <span class="kw">if</span>( right &lt;= mid ) {
            <span class="kw">return</span> query( <span class="dv">2</span>*root,   left, right );
        } <span class="kw">else</span> {
            <span class="kw">return</span> query( <span class="dv">2</span>*root, left, mid ) + query( <span class="dv">2</span>*root<span class="dv">+1</span>, mid<span class="dv">+1</span>, right );
        }
    }

    <span class="dt">int</span> n;
    vector&lt;Node&gt; node;
    vector&lt;<span class="dt">int</span>&gt; arr;
};

<span class="dt">int</span> main() {

    <span class="dt">int</span> n, q;
    <span class="kw">while</span>( <span class="dv">2</span> == scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n, &amp;q ) ) {

        IntervalTree it(n);
        <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i ) { scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;it.arr[i] ); }
        it.build( <span class="dv">1</span>, <span class="dv">1</span>, n );

        <span class="kw">while</span> ( q-- ) {
            <span class="dt">char</span> buf[<span class="dv">5</span>];
            scanf( <span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, buf );
            <span class="dt">int</span> a, b, c;
            <span class="kw">if</span>( buf[<span class="dv">0</span>] == <span class="st">&#39;Q&#39;</span> ) {
                scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;a, &amp;b );
                printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, it.query(<span class="dv">1</span>,a,b) );
            } <span class="kw">else</span> {
                scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;a, &amp;b, &amp;c );
                <span class="kw">if</span>( c ) { it.update(<span class="dv">1</span>, a, b, c ); }
            }
        }
    }

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>input.txt</p>
<pre><code>10  5
1   2   3   4   5   6   7   8   9   10
Q   4   4
Q   1   10
Q   2   4
C   3   6   3
Q   2   4</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cat</span> input.txt <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">4</span>
<span class="kw">55</span>
<span class="kw">9</span>
<span class="kw">15</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>josephus problem &#9829;&#65039; <code class="fold">@</code></dt>
<dd><pre><code>N = 8 children, count M, 1 &lt;= N, M &lt;= 30000

     1  2
   8      3
   7       4
     6  5</code></pre>
<p>&#32422;&#29791;&#22827;&#38382;&#39064;&#30340;&#38590;&#28857;&#22312;&#20110;&#65292;&#27599;&#19968;&#36718;&#37117;&#19981;&#33021;&#36890;&#36807;&#31616;&#21333;&#30340;&#36816;&#31639;&#24471;&#20986;&#19979;&#19968;&#36718;&#35841;&#28120;&#27760;&#65292;&#22240;&#20026;&#20013;&#38388;&#26377;&#20154;&#24050;&#32463;&#36864;&#20986;&#20102;&#12290;&#22240;&#27492;&#19968;&#33324;&#21482;&#33021;&#27169;&#25311;&#65292;&#25928;&#29575;&#24456;&#20302;&#12290;</p>
<p>&#29616;&#22312;&#32771;&#34385;&#65292;&#27599;&#19968;&#36718;&#37117;&#20196;&#25152;&#26377;&#21097;&#19979;&#30340;&#20154;&#20174;&#24038;&#21040;&#21491;&#37325;&#26032;&#32534;&#21495;&#65292;&#20363;&#22914; 3 &#36864;&#20986;&#21518;&#65292;&#22330;&#19978;&#36824;&#21097;&#19979; 1&#12289;2&#12289;4&#12289;5&#65292;&#21017;&#32473;</p>
<pre><code>    1 &#26032;&#32534;&#21495; 1&#65292;
    2 &#26032;&#32534;&#21495; 2&#65292;
    4 &#26032;&#32534;&#21495; 3&#65292;
    5 &#26032;&#32534;&#21495; 4&#12290;</code></pre>
<p>&#19981;&#22952;&#31216;&#36825;&#20010;&#32534;&#21495;&#20026;&#8220;&#21097;&#20313;&#38431;&#21015;&#32534;&#21495;&#8221;&#12290;&#22914;&#19979;&#25152;&#31034;&#65292;&#25324;&#21495;&#20869;&#20026;&#21407;&#22987;&#32534;&#21495;&#65306;</p>
<pre><code>1(1) 2(2) 3(3) 4(4) 5(5)    --&gt; &#21097;&#20313;&#38431;&#21015;&#32534;&#21495; 3 &#28120;&#27760;&#65292;&#23545;&#24212;&#21407;&#32534;&#21495; 3
1(1) 2(2) 3(4) 4(5)         --&gt; &#21097;&#20313;&#38431;&#21015;&#32534;&#21495; 1 &#28120;&#27760;&#65292;&#23545;&#24212;&#21407;&#32534;&#21495; 1
1(2) 2(4) 3(5)              --&gt; &#21097;&#20313;&#38431;&#21015;&#32534;&#21495; 3 &#28120;&#27760;&#65292;&#23545;&#24212;&#21407;&#32534;&#21495; 5
1(2) 2(4)                   --&gt; &#21097;&#20313;&#38431;&#21015;&#32534;&#21495; 1 &#28120;&#27760;&#65292;&#23545;&#24212;&#21407;&#32534;&#21495; 2
1(4)                        --&gt; &#21097;&#20313;&#38431;&#21015;&#32534;&#21495; 1 &#28120;&#27760;&#65292;&#23545;&#24212;&#21407;&#32534;&#21495; 4</code></pre>
<p>&#19968;&#20010;&#20154;&#22312;&#24403;&#21069;&#21097;&#20313;&#38431;&#21015;&#20013;&#32534;&#21495;&#20026; i&#65292;&#21017;&#35828;&#26126;&#20182;&#26159;&#20174;&#24038;&#21040;&#21491;&#25968;&#31532; i &#20010;&#20154;&#65292;&#36825;&#21551;&#21457;&#25105;&#20204;&#21487;&#20197;&#29992;&#32447;&#27573;&#26641;&#26469;&#35299;&#20915;&#38382;&#39064;&#12290;&#29992;&#32447;&#27573;&#26641;&#32500;&#25252;&#21407;&#32534;&#21495; [i..j] &#20869;&#36824;&#26377;&#22810;&#23569;&#20154;&#27809; &#26377;&#34987;&#28120;&#27760;&#65292;&#36825;&#26679;&#27599;&#27425;&#36873;&#20986;&#34987;&#28120;&#27760;&#32773;&#21518;&#65292;&#22312;&#24403;&#21069;&#32447;&#27573;&#26641;&#20013;&#26597;&#25214;&#20301;&#32622;&#23601;&#21487;&#20197;&#20102;&#12290;</p>
<p>&#20363;&#22914;&#25105;&#20204;&#26377; 5 &#20010;&#21407;&#32534;&#21495;&#65292;&#24403;&#21069;&#28120;&#27760;&#32773;&#22312;&#21097;&#20313;&#38431;&#21015;&#20013;&#32534;&#21495;&#20026; 3&#65292;&#20808;&#30475;&#24038;&#23376;&#26641;&#65292;&#21363;&#21407;&#32534;&#21495; [1..3] &#21306;&#38388;&#20869;&#65292;&#22914;&#26524;&#21097;&#19979;&#30340;&#20154;&#19981;&#36275; 3 &#20010;&#65292;&#21017;&#35828;&#26126;&#24403;&#21069;&#21097;&#20313;&#32534;&#21495;&#20026; 3 &#30340; &#36825;&#20010;&#20154;&#21407;&#32534;&#21495;&#21482;&#33021;&#26159;&#22312; [4..5] &#21306;&#38388;&#20869;&#65292;&#32487;&#32493;&#22312; [4..5] &#19978;&#25628;&#32034;&#65307;&#22914;&#26524; [1..3] &#20869;&#21097;&#19979;&#30340;&#20154;&#22823;&#20110;&#31561;&#20110; 3 &#20010;&#65292;&#21017;&#35828;&#26126;&#23601;&#22312; [1..3] &#20869;&#65292;&#20063;&#32487;&#32493;&#32553;&#23567;&#33539;&#22260;&#26597;&#25214;&#65292;&#36825;&#26679;&#21363;&#21487;&#22312; O(log N) &#26102;&#38388;&#20869;&#23436;&#25104;&#23545;&#24212;&#12290;&#38382;&#39064;&#24471;&#21040;&#22278;&#28385;&#30340;&#35299;&#20915;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> IntervalTree {
    <span class="kw">struct</span> Node {
        Node( <span class="dt">int</span> l = <span class="dv">0</span>, <span class="dt">int</span> r = <span class="dv">0</span>, <span class="dt">int</span> c = <span class="dv">0</span> ) : left(l), right(r), count(c) {}
        <span class="dt">int</span> left, right, count;
    };
    <span class="kw">explicit</span> IntervalTree( <span class="dt">int</span> n ) : n(n) {
        node    =   vector&lt;Node&gt;( <span class="dv">4</span>*(n<span class="dv">+1</span>), Node() );
    }
    <span class="dt">void</span> build( <span class="dt">int</span> root, <span class="dt">int</span> left, <span class="dt">int</span> right ) {
        Node &amp;r = node[root];
        r.left  = left;
        r.right = right;
        r.count = right-left<span class="dv">+1</span>;
        <span class="kw">if</span>( left == right ) { <span class="kw">return</span>; }
        <span class="dt">int</span> mid = (left+right)/<span class="dv">2</span>;
        build( <span class="dv">2</span>*root,      left,       mid     );
        build( <span class="dv">2</span>*root<span class="dv">+1</span>,    mid<span class="dv">+1</span>,      right   );
    }

    <span class="dt">int</span> remove( <span class="dt">int</span> root, <span class="dt">int</span> i ) {
        Node &amp;n = node[root]; --n.count;
        <span class="kw">if</span>( n.left == n.right ) {
            <span class="kw">return</span> n.left;
        }
        <span class="kw">if</span>( node[<span class="dv">2</span>*root].count &gt;= i ) {
            <span class="kw">return</span> remove( <span class="dv">2</span>*root, i );
        } <span class="kw">else</span> {
            <span class="kw">return</span> remove( <span class="dv">2</span>*root<span class="dv">+1</span>, i-node[<span class="dv">2</span>*root].count );
        }
    }

    <span class="dt">int</span> getCount( <span class="dt">int</span> root, <span class="dt">int</span> i ) {
        <span class="kw">if</span>( node[root].right &lt;= i ) { <span class="kw">return</span> node[root].count; }

        <span class="dt">int</span> mid = (node[root].left+node[root].right)/<span class="dv">2</span>;
        <span class="dt">int</span> s = <span class="dv">0</span>;
        <span class="kw">if</span>( i &gt; mid ) {
            s += node[<span class="dv">2</span>*root].count;
            s += getCount( <span class="dv">2</span>*root<span class="dv">+1</span>, i );
        } <span class="kw">else</span> {
            s += getCount( <span class="dv">2</span>*root,   i );
        }
        <span class="kw">return</span> s;
    }

    <span class="dt">int</span> n;
    vector&lt;Node&gt; node;
};

<span class="dt">int</span> main() {

    <span class="dt">int</span> n, m;
    <span class="kw">while</span>( <span class="dv">2</span> == scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n, &amp;m ) ) {

        IntervalTree it(n);
        it.build( <span class="dv">1</span>, <span class="dv">1</span>, n );
        <span class="dt">int</span> i, j = <span class="dv">0</span>, k;
        <span class="kw">for</span>( i = <span class="dv">1</span>; i &lt;= n; ++i ) {
            j += m;
            <span class="kw">if</span>( j &gt; it.node[<span class="dv">1</span>].count ) { j %= it.node[<span class="dv">1</span>].count; }
            <span class="kw">if</span>( j == <span class="dv">0</span>    )            { j  = it.node[<span class="dv">1</span>].count; }
            k = it.remove(   <span class="dv">1</span>, j );
            j = it.getCount( <span class="dv">1</span>, k );
            printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, k );
        }

    }

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">echo</span> 5 3 <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">3</span>   1   5   2   4</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
</ul></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/08/29 &#19978;&#21320; 7:00:00 &#25968;&#25454;&#32467;&#26500; Data Structure (&#19979;) <code class="fold">@</code></dt>
<dd><ul>
<li><p>Heap &#30340;&#28145;&#20837;&#29702;&#35299;&#21644;&#36816;&#29992;</p></li>
<li><dl>
<dt>Heap &#37325;&#35201;&#25299;&#23637;&#65306; <code class="fold">@</code></dt>
<dd><ul>
<li><ol style="list-style-type: decimal">
<li>&#24102;&#21024;&#38500;&#30340;&#22534; hash-heap</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>Trapping rain water <code class="fold">@</code></li>
</ol>
<p>: <a href="https://leetcode.com/problems/trapping-rain-water/">Trapping Rain Water | LeetCode OJ</a> <code class="fold">@</code></p>
<pre><code>:   ![](http://www.leetcode.com/wp-content/uploads/2012/08/rainwatertrap.png)

    &#23545;&#20110;&#27599;&#20010;&#26609;&#23376;&#65292;&#25214;&#21040;&#20854;&#24038;&#21491;&#20004;&#36793;&#26368;&#39640;&#30340;&#26609;&#23376;&#65292;&#35813;&#26609;&#23376;&#33021;&#23481;&#32435;&#30340;&#38754;&#31215;&#23601;&#26159; min(max_left, max_right) - height&#12290;&#25152;&#20197;&#65292;

    -   &#20174;&#24038;&#24448;&#21491;&#25195;&#25551;&#19968;&#36941;&#65292;&#23545;&#20110;&#27599;&#20010;&#26609;&#23376;&#65292;&#27714;&#21462;&#24038;&#36793;&#26368;&#22823;&#20540;&#65307;
    -   &#20174;&#21491;&#24448;&#24038;&#25195;&#25551;&#19968;&#36941;&#65292;&#23545;&#20110;&#27599;&#20010;&#26609;&#23376;&#65292;&#27714;&#26368;&#22823;&#21491;&#20540;&#65307;
    -   &#20877;&#25195;&#25551;&#19968;&#36941;&#65292;&#25226;&#27599;&#20010;&#26609;&#23376;&#30340;&#38754;&#31215;&#24182;&#32047;&#21152;&#12290;

    &#20063;&#21487;&#20197;&#65292;

    -   &#25195;&#25551;&#19968;&#36941;&#65292;&#25214;&#21040;&#26368;&#39640;&#30340;&#26609;&#23376;&#65292;&#36825;&#20010;&#26609;&#23376;&#23558;&#25968;&#32452;&#20998;&#20026;&#20004;&#21322;&#65307;
    -   &#22788;&#29702;&#24038;&#36793;&#19968;&#21322;&#65307;
    -   &#22788;&#29702;&#21491;&#36793;&#19968;&#21322;&#12290;

    ```cpp
    // &#27809;&#30475;&#25026;&#65292;TODO
    class Solution {
    public:
        int trap(vector&lt;int&gt; &amp;h) {
            int hl = 0, hr = 0, i = 0, j = h.size(), s = 0;
            while (i &lt; j) {
                if (hl &lt; hr) {
                    s += max(min(hl, hr)-h[i], 0);
                    hl = max(hl, h[i++]);
                } else {
                    s += max(min(hl, hr)-h[--j], 0);
                    hr = max(hr, h[j]);
                }
            }
            return s;
        }
    };
    ```

    ```cpp
    // &#24605;&#36335; 1&#65292;&#26102;&#38388;&#22797;&#26434;&#24230; O(n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(n)
    class Solution {
    public:
        int trap(const vector&lt;int&gt;&amp; A) {
            if( n &lt; 2 ) { return 0; }                               // &#27880;&#24847;&#21518;&#38754;&#30340; A[n-1] &#19968;&#23450;&#35201;&#20445;&#35777;&#19981;&#36234;&#30028;&#21834;&#65281;

            const int n = A.size();
            vector&lt;int&gt; max_left( n ), max_right( n );
            max_left[0] = A[0]; max_right[n-1] = A[n-1];
            for (int i = 1; i &lt; n; i++ ) {
                max_left[i] = max(max_left[i - 1], A[i-1]);
                max_right[n-1-i] = max(max_right[n-i], A[n-i]);
            }

            int sum = 0;
            for (int i = 0; i &lt; n; i++) {
                int height = min(max_left[i], max_right[i]);
                if (height &gt; A[i]) {
                    sum += height - A[i];
                }
            }
            return sum;
        }
    };
    ```

    &#26368;&#25512;&#33616;&#36825;&#20010;&#20570;&#27861;&#65306;

    ```cpp
    // &#24605;&#36335; 2&#65292;&#26102;&#38388;&#22797;&#26434;&#24230; O(n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(1)
    class Solution {
    public:
        int trap(const vector&lt;int&gt;&amp; A) {
            const int n = A.size();
            int max = 0;                                    // &#26368;&#39640;&#30340;&#26609;&#23376;&#65292;&#23558;&#25968;&#32452;&#20998;&#20026;&#20004;&#21322;
            for (int i = 0; i &lt; n; i++)
                if (A[i] &gt; A[max]) max = i;

            int water = 0;
            for (int i = 0, peak = 0; i &lt; max; i++)         // &#24038;&#20391;&#65292;&#20174;&#24038;&#24448;&#21491;&#30452;&#21040; max
                if (A[i] &gt; peak) peak = A[i];
                else water += peak - A[i];
            for (int i = n - 1, peak = 0; i &gt; max; i--)      // &#21491;&#20391;&#65292;&#20174;&#21491;&#24448;&#24038;&#30452;&#21040; max
                if (A[i] &gt; peak) peak = A[i];
                else water += peak - A[i];
            return water;
        }
    };
    ```

    &#31532;&#19977;&#31181;&#35299;&#27861;&#65292;&#29992;&#19968;&#20010;&#26632;&#36741;&#21161;&#65292;&#23567;&#20110;&#26632;&#39030;&#30340;&#20803;&#32032;&#21387;&#20837;&#65292;&#22823;&#20110;
    &#31561;&#20110;&#26632;&#39030;&#23601;&#25226;&#26632;&#37324;&#25152;&#26377;&#23567;&#20110;&#25110;&#31561;&#20110;&#24403;&#21069;&#20540;&#30340;&#20803;&#32032;&#20840;&#37096;&#20986;&#26632;
    &#22788;&#29702;&#25481;&#12290;&#65288;&#19981;&#25512;&#33616;&#65289;

    ```cpp
    // &#29992;&#19968;&#20010;&#26632;&#36741;&#21161;&#65292;&#23567;&#20110;&#26632;&#39030;&#30340;&#20803;&#32032;&#21387;&#20837;&#65292;&#22823;&#20110;&#31561;&#20110;&#26632;&#39030;&#23601;&#25226;&#26632;&#37324;&#25152;&#26377;&#23567;&#20110;&#25110;
    // &#31561;&#20110;&#24403;&#21069;&#20540;&#30340;&#20803;&#32032;&#20840;&#37096;&#20986;&#26632;&#22788;&#29702;&#25481;&#65292;&#35745;&#31639;&#38754;&#31215;&#65292;&#26368;&#21518;&#25226;&#24403;&#21069;&#20803;&#32032;&#20837;&#26632;
    // &#26102;&#38388;&#22797;&#26434;&#24230;O(n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230;O(n)
    class Solution {
    public:
        int trap(const vector&lt;int&gt;&amp; A) {
            const int n = A.size();
            stack&lt;pair&lt;int, int&gt;&gt; s;
            int water = 0;

            for (int i = 0; i &lt; n; ++i) {
                int height = 0;

                while (!s.empty()) { // &#23558;&#26632;&#37324;&#27604;&#24403;&#21069;&#20803;&#32032;&#30702;&#25110;&#31561;&#39640;&#30340;&#20803;&#32032;&#20840;&#37096;&#22788;&#29702;&#25481;
                    int bar = s.top().first;
                    int pos = s.top().second;
                    // bar, height, A[i] &#19977;&#32773;&#22841;&#25104;&#30340;&#20985;&#38519;
                    water += (min(bar, A[i]) - height) * (i - pos - 1);
                    height = bar;

                    if (A[i] &lt; bar) // &#30896;&#21040;&#20102;&#27604;&#24403;&#21069;&#20803;&#32032;&#39640;&#30340;&#65292;&#36339;&#20986;&#24490;&#29615;
                        break;
                    else
                        s.pop(); // &#24377;&#20986;&#26632;&#39030;&#65292;&#22240;&#20026;&#35813;&#20803;&#32032;&#22788;&#29702;&#23436;&#20102;&#65292;&#19981;&#20877;&#38656;&#35201;&#20102;
                }

                s.push(make_pair(A[i], i));
            }

            return water;
        }
    };
    ```</code></pre></li>
<li><ol start="3" style="list-style-type: decimal">
<li>Building Outline</li>
</ol></li>
</ul>
</dd>
</dl></li>
<li>Median &#38382;&#39064;&#25299;&#23637;</li>
<li>Sliding Windows&#38382;&#39064;&#24635;&#32467;</li>
<li><p>&#21452;&#31471;&#38431;&#21015;Deque</p></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/09/04 &#19978;&#21320; 7:00:00 &#20004;&#20010;&#25351;&#38024; Two Pointers <code class="fold">@</code></dt>
<dd><ul>
<li>&#23545;&#25758;&#22411;&#25351;&#38024;
<ul>
<li><ol style="list-style-type: decimal">
<li>Two sum &#31867;</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>Partition &#31867;</li>
</ol></li>
</ul></li>
<li>&#21069;&#21521;&#22411;&#25351;&#38024;
<ul>
<li><ol style="list-style-type: decimal">
<li>&#31383;&#21475;&#31867;</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>&#24555;&#24930;&#31867;</li>
</ol></li>
</ul></li>
<li>&#20004;&#20010;&#25968;&#32452;&#19978;&#30340;&#25351;&#38024;</li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/9/5 &#19978;&#21320; 7:00:00 &#21160;&#24577;&#35268;&#21010; Dynamic Programming (&#19978;) <code class="fold">@</code></dt>
<dd><ul>
<li>&#35760;&#24518;&#21270;&#25628;&#32034;&#65288;&#21306;&#38388;&#21160;&#24577;&#35268;&#21010;&#12289;&#21338;&#24328;&#31867;&#21160;&#24577;&#35268;&#21010;&#65289;</li>
<li>&#32972;&#21253;&#31867;&#21160;&#24577;&#35268;&#21010;</li>
<li>&#21306;&#38388;&#31867;&#21160;&#24577;&#35268;&#21010;</li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/9/11 &#19978;&#21320; 7:00:00 &#21160;&#24577;&#35268;&#21010; Dynamic Programming (&#19979;) <code class="fold">@</code></dt>
<dd><ul>
<li>&#35760;&#24518;&#21270;&#25628;&#32034;&#25299;&#23637;
<ul>
<li><ol style="list-style-type: decimal">
<li>&#21306;&#38388;&#21160;&#24577;&#35268;&#21010;</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>&#21338;&#24328;&#31867;&#21160;&#24577;&#35268;&#21010;</li>
</ol></li>
</ul></li>
<li>&#32972;&#21253;&#31867;&#21160;&#24577;&#35268;&#21010;
<ul>
<li><ol style="list-style-type: decimal">
<li>BackPack I/II</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>K sum</li>
</ol></li>
<li><ol start="3" style="list-style-type: decimal">
<li>Minimum Adjustment Cost</li>
</ol></li>
</ul></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/9/12 &#19978;&#21320; 7:00:00 &#22914;&#20309;&#35299;&#20915; follow up &#38382;&#39064; <code class="fold">@</code></dt>
<dd><ul>
<li>Peak Element I/II</li>
<li>&#31532; K &#22823;
<ul>
<li><ol style="list-style-type: decimal">
<li>&#31532; K &#22823;</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>&#26377;&#24207;&#30697;&#38453;&#30340;&#31532; K &#22823;</li>
</ol></li>
<li><ol start="3" style="list-style-type: decimal">
<li>&#20004;&#20010;&#25968;&#32452;&#20056;&#31215;&#30340;&#31532; K &#22823;</li>
</ol></li>
<li><ol start="4" style="list-style-type: decimal">
<li>n &#20010;&#25968;&#32452;&#31532; K &#22823;</li>
</ol></li>
<li><ol start="5" style="list-style-type: decimal">
<li>n &#20010;&#25968;&#32452;&#22810;&#26426;&#31532; K &#22823; (K &#27604;&#36739;&#23567;)</li>
</ol></li>
<li><ol start="6" style="list-style-type: decimal">
<li>n &#20010;&#25968;&#32452;&#22810;&#26426;&#31532; K &#22823; (K &#27604;&#36739;&#22823;)</li>
</ol></li>
</ul></li>
<li>Subarray sum
<ul>
<li><ol style="list-style-type: decimal">
<li>Subarray sum</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>Submatrix sum</li>
</ol></li>
<li><ol start="3" style="list-style-type: decimal">
<li>Subarray Sum Closest</li>
</ol></li>
<li><ol start="4" style="list-style-type: decimal">
<li>Subarray sum II</li>
</ol></li>
</ul></li>
</ul>
</dd>
<dt>&#9986;&#65039; 2016/00/00 &#19978;&#21320; 7:00:00 Math Methods and Models <code class="fold">@</code></dt>
<dd><ul>
<li>number theory</li>
<li><p>combination</p></li>
<li><dl>
<dt>10-1 UVa11582 Colossal Fibonacci Numbers! ch10/UVa11582.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11582 Colossal Fibonacci Numbers!</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1000</span> + <span class="dv">5</span>;
<span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ULL;

<span class="dt">int</span> f[maxn][maxn*<span class="dv">6</span>], period[maxn];

<span class="dt">int</span> pow_mod(ULL a, ULL b, <span class="dt">int</span> n) {
    <span class="kw">if</span>(!b) <span class="kw">return</span> <span class="dv">1</span>;
    <span class="dt">int</span> k = pow_mod(a, b/<span class="dv">2</span>, n);
    k = k * k % n;
    <span class="kw">if</span>(b % <span class="dv">2</span>) k = k * a % n;
    <span class="kw">return</span> k;
}

<span class="dt">int</span> solve(ULL a, ULL b, <span class="dt">int</span> n) {
    <span class="kw">if</span>(a == <span class="dv">0</span> || n == <span class="dv">1</span>) <span class="kw">return</span> <span class="dv">0</span>; <span class="co">// attention!</span>
    <span class="dt">int</span> p = pow_mod(a % period[n], b, period[n]);
    <span class="kw">return</span> f[n][p];
}

<span class="dt">int</span> main() {
    <span class="kw">for</span>(<span class="dt">int</span> n = <span class="dv">2</span>; n &lt;= <span class="dv">1000</span>; n++) {
        f[n] = <span class="dv">0</span>; f[n] = <span class="dv">1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; ; i++) {
            f[n][i] = (f[n][i<span class="dv">-1</span>] + f[n][i<span class="dv">-2</span>]) % n;
            <span class="kw">if</span>(f[n][i<span class="dv">-1</span>] == <span class="dv">0</span> &amp;&amp; f[n][i] == <span class="dv">1</span>) {
                period[n] = i - <span class="dv">1</span>;
                <span class="kw">break</span>;
            }
        }
    }
    ULL a, b;
    <span class="dt">int</span> n, T;
    cin &gt;&gt; T;
    <span class="kw">while</span>(T--) {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; n;
        cout &lt;&lt; solve(a, b, n) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-2 UVa12169 Disgruntled Judge ch10/UVa12169.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12169 Disgruntled Judge (slow solution)</span>
<span class="co">// Rujia Liu</span>
<span class="co">//</span>
<span class="co">// rev2. fixed bug reported by EndlessCheng</span>

<span class="ot">#include&lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span>*<span class="dv">2</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> M = <span class="dv">10001</span>;
<span class="dt">int</span> T, x[maxn];

<span class="dt">void</span> solve() {
    <span class="kw">for</span>(<span class="dt">int</span> a = <span class="dv">0</span>; a &lt; M; a++)
        <span class="kw">for</span>(<span class="dt">int</span> b = <span class="dv">0</span>; b &lt; M; b++) {
            <span class="dt">bool</span> ok = <span class="kw">true</span>;
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= T*<span class="dv">2</span>; i += <span class="dv">2</span>) {
                x[i] = (a*x[i<span class="dv">-1</span>] + b) % M;
                <span class="kw">if</span>(i<span class="dv">+1</span> &lt;= T*<span class="dv">2</span> &amp;&amp; x[i<span class="dv">+1</span>] != (a*x[i] + b) % M) { ok = <span class="kw">false</span>; <span class="kw">break</span>; }
            }
            <span class="kw">if</span>(ok) <span class="kw">return</span>;
        }
}

<span class="dt">int</span> main () {
    <span class="kw">while</span>(cin &gt;&gt; T) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= T*<span class="dv">2-1</span>; i += <span class="dv">2</span>) cin &gt;&gt; x[i];
        solve();
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= T*<span class="dv">2</span>; i += <span class="dv">2</span>) cout &lt;&lt; x[i] &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-3 UVa10375 Choose and Divide ch10/UVa10375.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10375 Choose and divide</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">10000</span>;
vector&lt;<span class="dt">int</span>&gt; primes;
<span class="dt">int</span> e[maxn];

<span class="co">// &#20056;&#20197;&#25110;&#38500;&#20197;n. d=0&#34920;&#31034;&#20056;&#65292;d=-1&#34920;&#31034;&#38500;</span>
<span class="dt">void</span> add_integer(<span class="dt">int</span> n, <span class="dt">int</span> d) {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; primes.size(); i++) {
        <span class="kw">while</span>(n % primes[i] == <span class="dv">0</span>) {
            n /= primes[i];
            e[i] += d;
        }
        <span class="kw">if</span>(n == <span class="dv">1</span>) <span class="kw">break</span>; <span class="co">// &#25552;&#21069;&#32456;&#27490;&#24490;&#29615;&#65292;&#33410;&#32422;&#26102;&#38388;</span>
    }
}

<span class="dt">void</span> add_factorial(<span class="dt">int</span> n, <span class="dt">int</span> d) {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++)
        add_integer(i, d);
}

<span class="dt">bool</span> is_prime(<span class="dt">int</span> n) {
    <span class="dt">int</span> m = floor(sqrt(n) + <span class="fl">0.5</span>);
    <span class="kw">for</span>(<span class="dt">int</span> a = <span class="dv">2</span>; a &lt;= m; a++)
        <span class="kw">if</span>(n % a == <span class="dv">0</span>) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="dt">int</span> main() {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= <span class="dv">10000</span>; i++)
        <span class="kw">if</span>(is_prime(i)) primes.push_back(i);
    <span class="dt">int</span> p, q, r, s;
    <span class="kw">while</span>(cin &gt;&gt; p &gt;&gt; q &gt;&gt; r &gt;&gt; s) {
        memset(e, <span class="dv">0</span>, <span class="kw">sizeof</span>(e));
        add_factorial(p, <span class="dv">1</span>);
        add_factorial(q, <span class="dv">-1</span>);
        add_factorial(p-q, <span class="dv">-1</span>);
        add_factorial(r, <span class="dv">-1</span>);
        add_factorial(s, <span class="dv">1</span>);
        add_factorial(r-s, <span class="dv">1</span>);
        <span class="dt">double</span> ans = <span class="dv">1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; primes.size(); i++)
            ans *= pow(primes[i], e[i]);
        printf(<span class="st">&quot;</span><span class="ch">%.5lf\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-4 UVa10791 Minimum Sum LCM ch10/UVa10791.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10791 Minimum Sum LCM</span>
<span class="co">// Rujia Liu</span>
<span class="co">// &#39064;&#24847;&#65306;&#36755;&#20837;&#25972;&#25968;n&#65288;1&lt;=n&lt;2^31&#65289;&#65292;&#27714;&#33267;&#23569;&#20004;&#20010;&#27491;&#25972;&#25968;&#65292;&#20351;&#24471;&#23427;&#20204;&#30340;&#26368;&#23567;&#20844;&#20493;&#25968;&#20026;n&#65292;&#19988;&#36825;&#20123;&#25972;&#25968;&#30340;&#21644;&#26368;&#23567;&#12290;&#36755;&#20986;&#26368;&#23567;&#30340;&#21644;&#12290;</span>
<span class="co">// &#31639;&#27861;&#65306;&#35774;&#21807;&#19968;&#20998;&#35299;&#24335;n=a1^p1 * a2^p2...&#65292;&#19981;&#38590;&#21457;&#29616;&#27599;&#20010;a[i]^p[i]&#20316;&#20026;&#19968;&#20010;&#21333;&#29420;&#30340;&#25972;&#25968;&#26102;&#26368;&#20248;&#12290;</span>
<span class="co">// &#29305;&#20363;&#65306;n=1&#26102;&#31572;&#26696;&#20026;1+1=2&#12290;n&#21482;&#26377;&#19968;&#31181;&#22240;&#23376;&#26102;&#38656;&#35201;&#21152;&#20010;1&#12290;&#21478;&#22806;&#27880;&#24847;n=2^31-1&#26102;&#19981;&#35201;&#28322;&#20986;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> divide_all(<span class="dt">int</span>&amp; n, <span class="dt">int</span> d) {
    <span class="dt">int</span> x = <span class="dv">1</span>;
    <span class="kw">while</span>(n % d == <span class="dv">0</span>) { n /= d; x *= d; }
    <span class="kw">return</span> x;
}

<span class="dt">long</span> <span class="dt">long</span> solve(<span class="dt">int</span> n) {
    <span class="kw">if</span>(n == <span class="dv">1</span>) <span class="kw">return</span> <span class="dv">2</span>;
    <span class="dt">int</span> m = floor(sqrt(n) + <span class="fl">0.5</span>);
    <span class="dt">long</span> <span class="dt">long</span> ans = <span class="dv">0</span>;
    <span class="dt">int</span> pf = <span class="dv">0</span>; <span class="co">// &#32032;&#22240;&#23376;(prime_factor)&#20010;&#25968;</span>
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt; m; i++) {
        <span class="kw">if</span>(n % i == <span class="dv">0</span>) { <span class="co">// &#26032;&#30340;&#32032;&#22240;&#23376;</span>
            pf++;
            ans += divide_all(n, i);
        }
    }
    <span class="kw">if</span>(n &gt; <span class="dv">1</span>) { pf++; ans += n; }
    <span class="kw">if</span>(pf &lt;= <span class="dv">1</span>) ans++;
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, kase = <span class="dv">0</span>;
    <span class="kw">while</span>(cin &gt;&gt; n &amp;&amp; n)
        cout &lt;&lt; <span class="st">&quot;Case &quot;</span> &lt;&lt; ++kase &lt;&lt; <span class="st">&quot;: &quot;</span> &lt;&lt; solve(n) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-5 UVa12716 GCD XOR ch10/UVa12716.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12716 GCD XOR</span>
<span class="co">// Rujia Liu</span>

<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> M = <span class="dv">30000000</span>;
<span class="dt">int</span> cnt[M<span class="dv">+1</span>], sum[M<span class="dv">+1</span>];

<span class="dt">void</span> init() {
    memset(cnt, <span class="dv">0</span>, <span class="kw">sizeof</span>(cnt));
    <span class="kw">for</span>(<span class="dt">int</span> c = <span class="dv">1</span>; c &lt;= M; c++)
        <span class="kw">for</span>(<span class="dt">int</span> a = c*<span class="dv">2</span>; a &lt;= M; a += c) {
            <span class="dt">int</span> b = a - c;
            <span class="kw">if</span>(c == (a ^ b)) cnt[a]++;
        }
    sum = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= M; i++) sum[i] = sum[i<span class="dv">-1</span>] + cnt[i];
}

<span class="dt">int</span> main() {
    init();
    <span class="dt">int</span> T, n, kase = <span class="dv">0</span>;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        printf(<span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">: </span><span class="ch">%d\n</span><span class="st">&quot;</span>, ++kase, sum[n]);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-6 UVa1635 Irrelevant Elements ch10/UVa1635.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// LA3221/UVa1635 Irrelevant Elements</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100000</span> + <span class="dv">5</span>;
<span class="dt">int</span> bad[maxn];

<span class="dt">void</span> prime_factors(<span class="dt">int</span> n, vector&lt;<span class="dt">int</span>&gt;&amp; primes) {
    <span class="dt">int</span> m = floor(sqrt(n) + <span class="fl">0.5</span>);
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= m; i++) {
        <span class="kw">if</span>(n % i == <span class="dv">0</span>) { <span class="co">// &#26032;&#30340;&#32032;&#22240;&#23376;</span>
            primes.push_back(i);
            <span class="kw">while</span>(n % i == <span class="dv">0</span>) n /= i;
        }
    }
    <span class="kw">if</span>(n &gt; <span class="dv">1</span>) primes.push_back(n);
}
<span class="dt">int</span> main() {
    <span class="dt">int</span> n, m, kase = <span class="dv">0</span>;
    <span class="kw">while</span>(cin &gt;&gt; n &gt;&gt; m) {
        vector&lt;<span class="dt">int</span>&gt; primes;
        prime_factors(m, primes);
        memset(bad, <span class="dv">0</span>, <span class="kw">sizeof</span>(bad));
        n--;
        <span class="co">// &#27714;c(n,0)~c(n,n)&#26377;&#21738;&#20123;&#25968;&#26159;m&#30340;&#20493;&#25968;</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; primes.size(); i++) {
            <span class="dt">int</span> p = primes[i], e = <span class="dv">0</span>; <span class="co">// C(n,0) = p^e</span>
            <span class="dt">int</span> min_e = <span class="dv">0</span>, x = m;
            <span class="kw">while</span>(x % p == <span class="dv">0</span>) { x /= p; min_e++; }
            <span class="co">// c(n,k)=c(n,k-1)*(n-k+1)/k</span>
            <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">1</span>; k &lt; n; k++) {
                x = n-k<span class="dv">+1</span>;
                <span class="kw">while</span>(x % p == <span class="dv">0</span>) { x /= p; e++; }
                x = k;
                <span class="kw">while</span>(x % p == <span class="dv">0</span>) { x /= p; e--; }
                <span class="kw">if</span>(e &lt; min_e) bad[k] = <span class="dv">1</span>;
            }
        }
        vector&lt;<span class="dt">int</span>&gt; ans;
        <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">1</span>; k &lt; n; k++)
            <span class="kw">if</span>(!bad[k]) ans.push_back(k<span class="dv">+1</span>); <span class="co">// &#32534;&#21495;&#20174;1&#24320;&#22987;</span>
        cout &lt;&lt; ans.size() &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
        <span class="kw">if</span>(!ans.empty()) {
            cout &lt;&lt; ans;
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; ans.size(); i++) cout &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; ans[i];
        }
        cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-7 UVa10820 Send a Table ch10/UVa10820.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10820 Send a Table</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">50000</span>;
<span class="dt">int</span> phi[maxn<span class="dv">+1</span>], phi_psum[maxn<span class="dv">+1</span>];

<span class="dt">void</span> phi_table(<span class="dt">int</span> n) {
    phi = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= n; i++) <span class="kw">if</span>(phi[i] == <span class="dv">0</span>)
        <span class="kw">for</span>(<span class="dt">int</span> j = i; j &lt;= n; j += i) {
            <span class="kw">if</span>(phi[j] == <span class="dv">0</span>) phi[j] = j;
            phi[j] = phi[j] / i * (i<span class="dv">-1</span>);
        }
}

<span class="dt">int</span> main(){
    <span class="dt">int</span> n;
    phi_table(maxn);
    phi_psum = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= maxn; i++)
        phi_psum[i] = phi_psum[i<span class="dv">-1</span>] + phi[i];
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span> &amp;&amp; n)
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>,<span class="dv">2</span>*phi_psum[n] + <span class="dv">1</span>);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-8 UVa1262 Password ch10/UVa1262.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1262 Password</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> k, cnt;
<span class="dt">char</span> p, ans;

<span class="co">// return true if already found</span>
<span class="dt">bool</span> dfs(<span class="dt">int</span> col) {
    <span class="kw">if</span>(col == <span class="dv">5</span>) {
        <span class="kw">if</span>(++cnt == k) {
            ans[col] = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>;
            printf(<span class="st">&quot;</span><span class="ch">%s\n</span><span class="st">&quot;</span>, ans);
            <span class="kw">return</span> <span class="kw">true</span>;
        }
        <span class="kw">return</span> <span class="kw">false</span>;
    }
    <span class="dt">bool</span> vis;
    memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">2</span>; i++)
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">6</span>; j++)
            vis[i][p[i][j][col] - <span class="st">&#39;A&#39;</span>] = <span class="kw">true</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">26</span>; i++)
        <span class="kw">if</span>(vis[i] &amp;&amp; vis[i]) {
            ans[col] = <span class="st">&#39;A&#39;</span> + i;
            <span class="kw">if</span>(dfs(col<span class="dv">+1</span>)) <span class="kw">return</span> <span class="kw">true</span>;
        }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;k);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">2</span>; i++)
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">6</span>; j++)
                scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, p[i][j]);
        cnt = <span class="dv">0</span>;
        <span class="kw">if</span>(!dfs(<span class="dv">0</span>)) printf(<span class="st">&quot;NO</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-9 UVa1636 Headshot ch10/UVa1636.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1636/LA4596 Headshot</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="dt">int</span> main() {
    <span class="dt">char</span> s;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, s) == <span class="dv">1</span>) {
        <span class="dt">int</span> a = <span class="dv">0</span>, b = <span class="dv">0</span>, n = strlen(s);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            <span class="kw">if</span>(s[i] == <span class="st">&#39;0&#39;</span>) {
                b++;
                <span class="kw">if</span>(s[(i<span class="dv">+1</span>)%n] == <span class="st">&#39;0&#39;</span>) a++;
            }
        }
        <span class="kw">if</span>(a*n == b*b) printf(<span class="st">&quot;EQUAL</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">else</span> <span class="kw">if</span>(a*n &gt; b*b) printf(<span class="st">&quot;SHOOT</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">else</span> printf(<span class="st">&quot;ROTATE</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-10 UVa10491 Cows and Cars ch10/uva10491.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10491 Cows and Cars</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="dt">int</span> main() {
    <span class="dt">int</span> a, b, c;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, &amp;a, &amp;b, &amp;c) == <span class="dv">3</span>)
        printf(<span class="st">&quot;</span><span class="ch">%.5lf\n</span><span class="st">&quot;</span>, (<span class="dt">double</span>)(a*b+b*(b<span class="dv">-1</span>)) / (a+b) / (a+b-c<span class="dv">-1</span>));
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-11 UVa11181 Probability|Given ch10/uva11181.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11181 Probability|Given</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">20</span> + <span class="dv">5</span>;
<span class="dt">int</span> n, r, buy[maxn];
<span class="dt">double</span> P[maxn], sum[maxn];

<span class="co">// depth, current number of 1, and product of probs</span>
<span class="dt">void</span> dfs(<span class="dt">int</span> d, <span class="dt">int</span> c, <span class="dt">double</span> prob) {
    <span class="kw">if</span>(c &gt; r || d - c &gt; n - r) <span class="kw">return</span>; <span class="co">// too many 1/0</span>
    <span class="kw">if</span>(d == n) {
        sum[n] += prob;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) <span class="kw">if</span>(buy[i])
            sum[i] += prob;
        <span class="kw">return</span>;
    }
    buy[d] = <span class="dv">0</span>;
    dfs(d<span class="dv">+1</span>, c, prob*(<span class="dv">1</span>-P[d]));
    buy[d] = <span class="dv">1</span>;
    dfs(d<span class="dv">+1</span>, c<span class="dv">+1</span>, prob*P[d]);
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> kase = <span class="dv">0</span>;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;r) == <span class="dv">2</span> &amp;&amp; n) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) scanf(<span class="st">&quot;</span><span class="ch">%lf</span><span class="st">&quot;</span>, &amp;P[i]);
        memset(sum, <span class="dv">0</span>, <span class="kw">sizeof</span>(sum));
        dfs(<span class="dv">0</span>, <span class="dv">0</span>, <span class="fl">1.0</span>);
        printf(<span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">:</span><span class="ch">\n</span><span class="st">&quot;</span>, ++kase);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
            printf(<span class="st">&quot;</span><span class="ch">%.6lf\n</span><span class="st">&quot;</span>, sum[i] / sum[n]);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-12 UVa1637 Double Patience ch10/UVa1637.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1637 Double Patience</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;map&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

map&lt;vector&lt;<span class="dt">int</span>&gt;, <span class="dt">double</span>&gt; d;
<span class="dt">char</span> card;

<span class="co">// cnt is a vector of length 9, cnt[i] is the number of remaining cards in pile i.</span>
<span class="co">// c is the sum of cnt. It is here to save time and code length :)</span>
<span class="dt">double</span> dp(vector&lt;<span class="dt">int</span>&gt;&amp; cnt, <span class="dt">int</span> c) {
    <span class="kw">if</span>(c == <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">1</span>;
    <span class="kw">if</span>(d.count(cnt) != <span class="dv">0</span>) <span class="kw">return</span> d[cnt];
    <span class="dt">double</span> sum = <span class="dv">0</span>;
    <span class="dt">int</span> tot = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">9</span>; i++) <span class="kw">if</span>(cnt[i] &gt; <span class="dv">0</span>)
        <span class="kw">for</span>(<span class="dt">int</span> j = i<span class="dv">+1</span>; j &lt; <span class="dv">9</span>; j++) <span class="kw">if</span>(cnt[j] &gt; <span class="dv">0</span>)
            <span class="kw">if</span>(card[i][cnt[i]<span class="dv">-1</span>] == card[j][cnt[j]<span class="dv">-1</span>]) {
                tot++;
                cnt[i]--; cnt[j]--;
                sum += dp(cnt, c<span class="dv">-2</span>);
                cnt[i]++; cnt[j]++;
            }
    <span class="kw">if</span>(tot == <span class="dv">0</span>) <span class="kw">return</span> d[cnt] = <span class="dv">0</span>;
    <span class="kw">else</span> <span class="kw">return</span> d[cnt] = sum / tot;
}

<span class="dt">bool</span> read_input() {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">9</span>; i++)
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">4</span>; j++)
            <span class="kw">if</span>(scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, card[i][j]) != <span class="dv">1</span>) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="dt">int</span> main() {
    <span class="kw">while</span>(read_input()) {
        vector&lt;<span class="dt">int</span>&gt; cnt(<span class="dv">9</span>,<span class="dv">4</span>);
        d.clear();
        printf(<span class="st">&quot;</span><span class="ch">%.6lf\n</span><span class="st">&quot;</span>, dp(cnt, <span class="dv">36</span>));
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-13 UVa580 Critical Mass ch10/UVa580.cpp</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa580 Critical Mass</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> f, g;

<span class="dt">int</span> main() {
    f = f = f = <span class="dv">0</span>;
    g = <span class="dv">1</span>; g = <span class="dv">2</span>; g = <span class="dv">4</span>;
    <span class="kw">for</span>(<span class="dt">int</span> n = <span class="dv">3</span>; n &lt;= <span class="dv">30</span>; n++) {
        f[n] = <span class="dv">1</span> &lt;&lt; (n<span class="dv">-3</span>);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= n<span class="dv">-2</span>; i++)
            f[n] += g[i<span class="dv">-2</span>] * (<span class="dv">1</span> &lt;&lt; (n-i<span class="dv">-2</span>));
        g[n] = (<span class="dv">1</span>&lt;&lt;n) - f[n];
    }
    <span class="dt">int</span> n;
    <span class="kw">while</span>(cin &gt;&gt; n &amp;&amp; n)
        cout &lt;&lt; f[n] &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-14 UVa12034 Race ch10/UVa12034.cpp</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12034 Race</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1000</span>;
<span class="dt">const</span> <span class="dt">int</span> MOD = <span class="dv">10056</span>;
<span class="dt">int</span> C[maxn<span class="dv">+1</span>][maxn<span class="dv">+1</span>], f[maxn<span class="dv">+1</span>];

<span class="co">// &#36882;&#25512;&#20986;&#25152;&#26377;&#32452;&#21512;&#25968;</span>
<span class="dt">void</span> init() {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= maxn; i++) {
        C[i] = C[i][i] = <span class="dv">1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt; i; j++)
            C[i][j] = (C[i<span class="dv">-1</span>][j] + C[i<span class="dv">-1</span>][j<span class="dv">-1</span>]) % MOD;
    }
}

<span class="dt">int</span> main() {
    init();
    f = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= maxn; i++) {
        f[i] = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= i; j++) f[i] = (f[i] + C[i][j] * f[i-j]) % MOD;
    }

    <span class="dt">int</span> T, n;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">for</span>(<span class="dt">int</span> kase = <span class="dv">1</span>; kase &lt;= T; kase++) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        printf(<span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">: </span><span class="ch">%d\n</span><span class="st">&quot;</span>, kase, f[n]);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-15 UVa1638 Pole Arrangement ch10/UVa1638.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1638/LA6117 Pole Arrangement</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">20</span>;
<span class="dt">long</span> <span class="dt">long</span> d[maxn<span class="dv">+1</span>][maxn<span class="dv">+1</span>][maxn<span class="dv">+1</span>];

<span class="dt">int</span> main() {
    d = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= maxn; i++)
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= i; j++)
            <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">1</span>; k &lt;= i; k++) {
                d[i][j][k] = d[i<span class="dv">-1</span>][j][k] * (i<span class="dv">-2</span>);
                <span class="kw">if</span>(j &gt; <span class="dv">1</span>) d[i][j][k] += d[i<span class="dv">-1</span>][j<span class="dv">-1</span>][k];
                <span class="kw">if</span>(k &gt; <span class="dv">1</span>) d[i][j][k] += d[i<span class="dv">-1</span>][j][k<span class="dv">-1</span>];
            }

    <span class="dt">int</span> T, n, L, R;
    cin &gt;&gt; T;
    <span class="kw">while</span>(T--) {
        cin &gt;&gt; n &gt;&gt; L &gt;&gt; R;
        cout &lt;&lt; d[n][L][R] &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-16 UVa12230 Crossing Rivers ch10/uva12230.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12230 Crossing Rivers</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="dt">int</span> main() {
    <span class="dt">int</span> n, D, p, L, v, kase = <span class="dv">0</span>;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;D) == <span class="dv">2</span> &amp;&amp; D) {
        <span class="dt">double</span> ans = <span class="dv">0</span>;
        <span class="kw">while</span>(n--) {
            scanf(<span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, &amp;p, &amp;L, &amp;v);
            D -= L; ans += <span class="fl">2.0</span> * L / v;
        }
        printf(<span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">: </span><span class="ch">%.3lf\n\n</span><span class="st">&quot;</span>, ++kase, ans + D);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-17 UVa1639 Candy ch10/UVa1639.cpp</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1639/LA6163 Candy</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="co">// C(n,m) = n!/(m!(n-m)!)</span>
<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">200000</span> + <span class="dv">5</span>;
<span class="dt">long</span> <span class="dt">double</span> logF[maxn*<span class="dv">2+1</span>];

<span class="dt">long</span> <span class="dt">double</span> logC(<span class="dt">int</span> n, <span class="dt">int</span> m) {
    <span class="kw">return</span> logF[n] - logF[m] - logF[n-m];
}

<span class="dt">double</span> solve(<span class="dt">int</span> n, <span class="dt">double</span> p) {
    <span class="dt">double</span> ans = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= n; i++) {
        <span class="dt">long</span> <span class="dt">double</span> c = logC(n*<span class="dv">2</span>-i, n);
        <span class="dt">long</span> <span class="dt">double</span> v1 = c + (n<span class="dv">+1</span>)*log(p) + (n-i)*log(<span class="dv">1</span>-p);
        <span class="dt">long</span> <span class="dt">double</span> v2 = c + (n<span class="dv">+1</span>)*log(<span class="dv">1</span>-p) + (n-i)*log(p);
        <span class="dt">long</span> <span class="dt">double</span> x = exp(v1) + exp(v2);
        ans += i * (exp(v1) + exp(v2));
    }
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main() {
    logF = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= maxn; i++)
        logF[i] = logF[i<span class="dv">-1</span>] + log(i);

    <span class="dt">int</span> kase = <span class="dv">0</span>, n;
    <span class="dt">double</span> p;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%lf</span><span class="st">&quot;</span>, &amp;n, &amp;p) == <span class="dv">2</span>)
        printf(<span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">: </span><span class="ch">%.6lf\n</span><span class="st">&quot;</span>, ++kase, solve(n, p));
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-18 UVa10288 Coupons ch10/UVa10288.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10288 Coupons</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;sstream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL;

LL gcd(LL a, LL b) {
    <span class="kw">if</span>(!b) <span class="kw">return</span> a;
    <span class="kw">return</span> gcd(b, a%b);
}

LL lcm(LL a, LL b) {
    <span class="kw">return</span> a / gcd(a, b) * b;
}

<span class="dt">int</span> LL_len(LL x) {
    stringstream ss;
    ss &lt;&lt; x;
    <span class="kw">return</span> ss.str().length();
}

<span class="dt">void</span> print_chars(<span class="dt">int</span> cnt, <span class="dt">char</span> ch) {
    <span class="kw">while</span>(cnt--) cout &lt;&lt; ch;
}

<span class="dt">void</span> output(LL a, LL b, LL c) {
    <span class="kw">if</span>(b == <span class="dv">0</span>) cout &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    <span class="kw">else</span> {
        <span class="dt">int</span> L1 = LL_len(a);
        print_chars(L1<span class="dv">+1</span>, <span class="st">&#39; &#39;</span>); cout &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
        cout &lt;&lt; a &lt;&lt; <span class="st">&quot; &quot;</span>; print_chars(LL_len(c), <span class="st">&#39;-&#39;</span>); cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
        print_chars(L1<span class="dv">+1</span>, <span class="st">&#39; &#39;</span>); cout &lt;&lt; c &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    <span class="kw">while</span>(cin &gt;&gt; n &amp;&amp; n) {
        <span class="kw">if</span>(n == <span class="dv">1</span>) { output(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>); <span class="kw">continue</span>; }
        LL x = <span class="dv">1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= n<span class="dv">-1</span>; i++)
            x = lcm(x, i);

        <span class="co">// b/c = 1/(n-1) + ... + 1/2</span>
        LL c = x, b = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= n<span class="dv">-1</span>; i++)
            b += x / i;
        b *= n;
        LL g = gcd(b, c);
        b /= g; c /= g;

        <span class="co">// ans = a + b/c</span>
        LL a = <span class="dv">1</span> + n + b / c;
        b %= c;
        output(a, b, c);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-19 UVa11346 Probability ch10/uva11346.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11346 Probability</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        <span class="dt">double</span> a, b, s, ans;
        scanf(<span class="st">&quot;</span><span class="ch">%lf%lf%lf</span><span class="st">&quot;</span>, &amp;a, &amp;b, &amp;s);
        <span class="dt">double</span> m = a*b;
        <span class="kw">if</span>(fabs(s) &lt; <span class="fl">1e-6</span>) ans = <span class="dv">1</span>;
        <span class="kw">else</span> <span class="kw">if</span>(s &gt; m) ans = <span class="dv">0</span>;
        <span class="kw">else</span> ans = (m - s - s * log(m/s)) / m;
        printf(<span class="st">&quot;</span><span class="ch">%.6lf%%\n</span><span class="st">&quot;</span>, ans * <span class="dv">100</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-20 UVa10900 So you want to be a 2n-aire? ch10/UVa10900.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10900 So you want to be a 2n-aire?</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">30</span> + <span class="dv">5</span>;
<span class="dt">double</span> d[maxn];

<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    <span class="dt">double</span> t;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%lf</span><span class="st">&quot;</span>, &amp;n, &amp;t) == <span class="dv">2</span> &amp;&amp; n) {
        d[n] = <span class="dv">1</span>&lt;&lt;n;
        <span class="kw">for</span>(<span class="dt">int</span> i = n<span class="dv">-1</span>; i &gt;= <span class="dv">0</span>; i--) {
            <span class="dt">double</span> p0 = (<span class="dt">double</span>)(<span class="dv">1</span>&lt;&lt;i) / d[i<span class="dv">+1</span>];
            <span class="kw">if</span>(p0 &lt; t) p0 = t;
            <span class="dt">double</span> p1 = (p0-t)/(<span class="dv">1</span>-t);
            d[i] = (<span class="dt">double</span>)(<span class="dv">1</span>&lt;&lt;i) * p1 + (<span class="dv">1</span>+p0)/<span class="dv">2</span> * d[i<span class="dv">+1</span>] * (<span class="dv">1</span>-p1);
        }
        printf(<span class="st">&quot;</span><span class="ch">%.3lf\n</span><span class="st">&quot;</span>, d);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-21 UVa11971 Polygon ch10/UVa11971.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11971 Polygon</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL;

LL gcd(LL a, LL b) {
    <span class="kw">return</span> b == <span class="dv">0</span> ? a : gcd(b, a%b);
}

<span class="dt">void</span> reduce(LL&amp; a, LL&amp; b) {
    LL g = gcd(a, b);
    a /= g; b /= g;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T, n, k;
    cin &gt;&gt; T;
    <span class="kw">for</span>(<span class="dt">int</span> kase = <span class="dv">1</span>; kase &lt;= T; kase++) {
        cin &gt;&gt; n &gt;&gt; k;
        <span class="co">// &#32452;&#19981;&#25104;&#30340;&#27010;&#29575;&#20026;(k+1)/2^k</span>
        LL b = <span class="dv">1LL</span> &lt;&lt; k;
        LL a = b - k - <span class="dv">1</span>;
        reduce(a, b);
        cout &lt;&lt; <span class="st">&quot;Case #&quot;</span> &lt;&lt; kase &lt;&lt; <span class="st">&quot;: &quot;</span> &lt;&lt; a &lt;&lt; <span class="st">&quot;/&quot;</span> &lt;&lt; b &lt;&lt; endl;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-22 UVa1640 The Counting Problem ch10/UVa1640.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1640 The Counting Problem</span>
<span class="co">// Rujia Liu</span>
<span class="co">// The meaning of f is slightly different from the book</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// cnt[i] is the number of occurrence of EVERY digit, among all i-digit numbers (leading zeros ALLOWED)</span>
<span class="co">// for examples, there are 1000 3-digit numbers, each digit 0~9 has occurred 300 times, so cnt = 300</span>
<span class="dt">int</span> pow10, cnt;

<span class="co">// how many times digit d occurred in 0~n-1</span>
<span class="co">// numbers in 0~4567 can be divided into the following patterns:</span>
<span class="co">// fewer digits   : *, n*, n** (n means non-zero digit)</span>
<span class="co">// smaller digit 0: 1***, 2***, 3***</span>
<span class="co">// smaller digit 1: 40**, 41**, 42**, 43**, 44**</span>
<span class="co">// smaller digit 2: 450*, 451*, ...</span>
<span class="dt">int</span> f(<span class="dt">int</span> d, <span class="dt">int</span> n) {
    <span class="dt">char</span> s;
    sprintf(s, <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, n);
    <span class="dt">int</span> len = strlen(s);
    <span class="dt">int</span> ans = <span class="dv">0</span>;

    <span class="co">// fewer digits</span>
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; len; i++) {
        <span class="kw">if</span>(i == <span class="dv">1</span>) ans++; <span class="co">// single digit</span>
        <span class="kw">else</span> {
            ans += <span class="dv">9</span> * cnt[i<span class="dv">-1</span>];  <span class="co">// leading with another digit</span>
            <span class="kw">if</span>(d &gt; <span class="dv">0</span>) ans += pow10[i<span class="dv">-1</span>]; <span class="co">// leading with digit d</span>
        }
    }

    <span class="dt">int</span> pre; <span class="co">// pre[i] is the occurrence of digit d in s[0~i]</span>
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len; i++) {
        pre[i] = (s[i] - <span class="st">&#39;0&#39;</span> == d ? <span class="dv">1</span> : <span class="dv">0</span>);
        <span class="kw">if</span>(i &gt; <span class="dv">0</span>) pre[i] += pre[i<span class="dv">-1</span>];
    }

    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len; i++) {
        <span class="co">// smaller digit i</span>
        <span class="dt">int</span> maxd = s[i] - <span class="st">&#39;0&#39;</span> - <span class="dv">1</span>;
        <span class="dt">int</span> mind = <span class="dv">0</span>;
        <span class="kw">if</span>(i == <span class="dv">0</span> &amp;&amp; len &gt; <span class="dv">1</span>) mind = <span class="dv">1</span>; <span class="co">// no leading zeros allowed</span>
        <span class="kw">for</span>(<span class="dt">int</span> digit = mind; digit &lt;= maxd; digit++) {
            ans += cnt[len-i<span class="dv">-1</span>];
            <span class="kw">if</span>(i &gt; <span class="dv">0</span>) ans += pre[i<span class="dv">-1</span>] * pow10[len-i<span class="dv">-1</span>];
            <span class="kw">if</span>(digit == d) ans += pow10[len-i<span class="dv">-1</span>];
        }
    }
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main() {
    pow10 = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= <span class="dv">8</span>; i++) {
        pow10[i] = pow10[i<span class="dv">-1</span>] * <span class="dv">10</span>;
        cnt[i] = pow10[i<span class="dv">-1</span>] * i;
    }

    <span class="dt">int</span> a, b;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;a, &amp;b) == <span class="dv">2</span> &amp;&amp; a &amp;&amp; b) {
        <span class="kw">if</span>(a &gt; b) swap(a, b);
        <span class="kw">for</span>(<span class="dt">int</span> d = <span class="dv">0</span>; d &lt; <span class="dv">10</span>; d++) {
            <span class="kw">if</span>(d) printf(<span class="st">&quot; &quot;</span>);
            printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, f(d, b<span class="dv">+1</span>) - f(d, a));
        }
        printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-23 UVa10213 How Many Pieces of Land? ch10/UVa10213.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10213 How Many Pieces of Land?</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="dt">int</span> main() {
    <span class="dt">int</span> n, T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        <span class="dt">int</span> V = <span class="dv">0</span>, E = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= n<span class="dv">-2</span>; i++)
            V += i*(n<span class="dv">-2</span>-i), E += i*(n<span class="dv">-2</span>-i)<span class="dv">+1</span>;
        V = V*n/<span class="dv">4</span>+n;
        E = E*n/<span class="dv">2</span>+n;
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, E-V<span class="dv">+1</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-24 UVa1641 ASCII Area ch10/UVa1641.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1641/LA5910 ASCII Area</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="dt">int</span> main() {
    <span class="dt">int</span> h, w;
    <span class="dt">char</span> s;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;h, &amp;w) == <span class="dv">2</span>) {
        <span class="dt">int</span> ans = <span class="dv">0</span>, c = <span class="dv">0</span>;
        <span class="kw">while</span>(h--) {
            scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, s);
            <span class="dt">int</span> in = <span class="dv">0</span>;
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; w; i++) {
                <span class="kw">if</span>(s[i] == <span class="st">&#39;/&#39;</span> || s[i] == <span class="st">&#39;</span><span class="ch">\\</span><span class="st">&#39;</span>) { c++; in = !in; }
                <span class="kw">else</span> <span class="kw">if</span>(in) ans++;
            }
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans + c/<span class="dv">2</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-25 UVa1363 Joseph&#8217;s Problem ch10/UVa1363.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1363 Joseph&#39;s Problem</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// &#39318;&#39033;&#20026;a&#65292;&#20844;&#24046;&#20026;-d&#65292;&#38500;&#20102;&#39318;&#39033;&#20043;&#22806;&#36824;&#26377;n&#39033;</span>
<span class="co">// &#26411;&#39033;&#20026;a-n*d&#65292;&#24179;&#22343;&#25968;&#20026;(2*a-n*d)/2</span>
<span class="dt">long</span> <span class="dt">long</span> sum(<span class="dt">int</span> a, <span class="dt">int</span> d, <span class="dt">int</span> n) {
    <span class="kw">return</span> (<span class="dt">long</span> <span class="dt">long</span>)(<span class="dv">2</span>*a-n*d)*(n<span class="dv">+1</span>)/<span class="dv">2</span>;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, k;
    <span class="kw">while</span>(cin &gt;&gt; n &gt;&gt; k) {
        <span class="dt">int</span> i = <span class="dv">1</span>;
        <span class="dt">long</span> <span class="dt">long</span> ans = <span class="dv">0</span>;
        <span class="kw">while</span>(i &lt;= n) {
            <span class="dt">int</span> q = k % i, p = k / i;
            <span class="dt">int</span> cnt = n - i; <span class="co">// &#26368;&#22810;&#36824;&#26377;n - i&#39033;</span>
            <span class="kw">if</span>(p &gt; <span class="dv">0</span>) cnt = min(cnt, q / p);
            ans += sum(q, p, cnt);
            i += cnt + <span class="dv">1</span>;
        }
        cout &lt;&lt; ans &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-26 UVa11440 Help Mr.&#160;Tomisu ch10/UVa11440.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11440 Help Mr. Tomisu</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">10000000</span> + <span class="dv">10</span>;
<span class="dt">const</span> <span class="dt">int</span> MOD = <span class="dv">100000007</span>;

<span class="dt">int</span> vis[maxn], phifac[maxn];

<span class="dt">void</span> gen_primes(<span class="dt">int</span> n) {
    <span class="dt">int</span> m = (<span class="dt">int</span>)sqrt(n<span class="fl">+0.5</span>);
    <span class="dt">int</span> c = <span class="dv">0</span>;
    memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= m; i++) <span class="kw">if</span>(!vis[i]) {
        <span class="kw">for</span>(<span class="dt">int</span> j = i*i; j &lt;= n; j+=i) vis[j] = <span class="dv">1</span>;
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, m;
    gen_primes(<span class="dv">10000000</span>);
    phifac = phifac = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">3</span>; i &lt;= <span class="dv">10000000</span>; i++)
        phifac[i] = (<span class="dt">long</span> <span class="dt">long</span>)phifac[i<span class="dv">-1</span>] * (vis[i] ? i : i<span class="dv">-1</span>) % MOD;

    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m) == <span class="dv">2</span> &amp;&amp; n) {
        <span class="dt">int</span> ans = phifac[m];
        <span class="kw">for</span>(<span class="dt">int</span> i = m<span class="dv">+1</span>; i &lt;= n; i++) ans = (<span class="dt">long</span> <span class="dt">long</span>)ans * i % MOD;
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, (ans<span class="dv">-1</span>+MOD)%MOD);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-27 UVa10214 Trees in a Wood ch10/UVa10214.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10214 Trees in a Wood</span>
<span class="co">// Rujia Liu</span>
<span class="co">// This problem asks for K/N, where N is the total number of trees in area |x|&lt;=a, |y|&lt;=b</span>
<span class="co">// The answer converges to 6/pi^2, see the problem description</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> phi(<span class="dt">int</span> n) {
    <span class="dt">int</span> m = (<span class="dt">int</span>)sqrt(n<span class="fl">+0.5</span>);
    <span class="dt">int</span> ans = n;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= m; i++) <span class="kw">if</span>(n % i == <span class="dv">0</span>) {
        ans = ans / i * (i<span class="dv">-1</span>);
        <span class="kw">while</span>(n % i == <span class="dv">0</span>) n /= i;
    }
    <span class="kw">if</span>(n &gt; <span class="dv">1</span>) ans = ans / n * (n<span class="dv">-1</span>);
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> gcd(<span class="dt">int</span> a, <span class="dt">int</span> b) {
    <span class="kw">return</span> b == <span class="dv">0</span> ? a : gcd(b, a % b);
}

<span class="dt">long</span> <span class="dt">long</span> f(<span class="dt">int</span> a, <span class="dt">int</span> b) {
    <span class="dt">long</span> <span class="dt">long</span> ans = <span class="dv">0</span>; <span class="co">// only for 1&lt;=x&lt;=a, 1&lt;=y&lt;=b</span>
    <span class="kw">for</span>(<span class="dt">int</span> x = <span class="dv">1</span>; x &lt;= a; x++) {
        <span class="dt">int</span> k = b/x;
        ans += phi(x) * k;
        <span class="kw">for</span>(<span class="dt">int</span> y = k*x<span class="dv">+1</span>; y &lt;= b; y++)
            <span class="kw">if</span>(gcd(x, y) == <span class="dv">1</span>) ans++;
    }
    <span class="kw">return</span> ans * <span class="dv">4</span> + <span class="dv">4</span>;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> a, b;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;a, &amp;b) == <span class="dv">2</span> &amp;&amp; a) {
        <span class="dt">long</span> <span class="dt">long</span> K = f(a,b);
        <span class="dt">long</span> <span class="dt">long</span> N = (<span class="dt">long</span> <span class="dt">long</span>)(<span class="dv">2</span>*a<span class="dv">+1</span>) * (<span class="dv">2</span>*b<span class="dv">+1</span>) - <span class="dv">1</span>;
        printf(<span class="st">&quot;</span><span class="ch">%.7lf\n</span><span class="st">&quot;</span>, (<span class="dt">double</span>)K / N);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-28 UVa1393 Highway ch10/uva1393.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1393 Highway</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">300</span>;
<span class="dt">int</span> g[maxn<span class="dv">+1</span>][maxn<span class="dv">+1</span>];

<span class="dt">int</span> gcd(<span class="dt">int</span> a, <span class="dt">int</span> b) {
    <span class="kw">return</span> b == <span class="dv">0</span> ? a : gcd(b, a%b);
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, m;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= maxn; i++)
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= maxn; j++)
            g[i][j] = gcd(i, j);

    <span class="kw">while</span>(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) {
        <span class="dt">int</span> ans = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> a = <span class="dv">1</span>; a &lt;= m; a++)
            <span class="kw">for</span>(<span class="dt">int</span> b = <span class="dv">1</span>; b &lt;= n; b++)
                <span class="kw">if</span>(g[a][b] == <span class="dv">1</span>) {
                    <span class="dt">int</span> c = max(<span class="dv">0</span>, m<span class="dv">-2</span>*a) * max(<span class="dv">0</span>, n<span class="dv">-2</span>*b);
                    ans += (m-a)*(n-b) - c;
                }
        cout &lt;&lt; ans*<span class="dv">2</span> &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>10-29 UVa1642 Magical GCD ch10/UVa1642.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1642 Magical GCD</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL;

<span class="kw">struct</span> Item {
    LL g; <span class="co">// gcd</span>
    <span class="dt">int</span> p; <span class="co">// starting pos</span>
    Item(LL g=<span class="dv">0</span>, <span class="dt">int</span> p=<span class="dv">0</span>):g(g),p(p){}
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Item&amp; rhs) <span class="dt">const</span> {
        <span class="kw">return</span> g &lt; rhs.g || (g == rhs.g &amp;&amp; p &lt; rhs.p);
    }
};

LL gcd(LL a, LL b) { <span class="kw">return</span> b == <span class="dv">0</span> ? a : gcd(b, a%b); }

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100000</span> + <span class="dv">5</span>;

LL A[maxn];
<span class="dt">int</span> n;

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) scanf(<span class="st">&quot;</span><span class="ch">%lld</span><span class="st">&quot;</span>, &amp;A[i]);
        vector&lt;Item&gt; items;
        LL ans = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++) { <span class="co">// enumerate end pos</span>
            items.push_back(Item(<span class="dv">0</span>, j));
            <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; items.size(); k++)
                items[k].g = gcd(items[k].g, A[j]); <span class="co">// update items&#39; gcd</span>
            sort(items.begin(), items.end());

            <span class="co">// for each gcd, only keep smallest starting pos</span>
            vector&lt;Item&gt; newitems;
            <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; items.size(); k++)
                <span class="kw">if</span>(k == <span class="dv">0</span> || items[k].g != items[k<span class="dv">-1</span>].g) { <span class="co">// different gcd</span>
                    newitems.push_back(items[k]);
                    ans = max(ans, items[k].g * (j - items[k].p + <span class="dv">1</span>));
                }
            items = newitems;
        }
        printf(<span class="st">&quot;</span><span class="ch">%lld\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>11-1 UVa12219 Common Subexpression Elimination ch11/UVa12219.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12219 Common Subexpression Elimination</span>
<span class="co">// Rujia Liu</span>

<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;string&gt;</span>
<span class="ot">#include&lt;map&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">60000</span>;
<span class="dt">int</span> T, kase, cnt;
<span class="dt">char</span> expr[maxn*<span class="dv">5</span>], *p;
<span class="dt">int</span> done[maxn]; <span class="co">// &#35813;&#32467;&#28857;&#26159;&#21542;&#24050;&#36755;&#20986;</span>

<span class="kw">struct</span> Node {
    string s;
    <span class="dt">int</span> hash, left, right;
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Node&amp; rhs) <span class="dt">const</span> {
        <span class="kw">if</span>(hash != rhs.hash) <span class="kw">return</span> hash &lt; rhs.hash;
        <span class="kw">if</span>(left != rhs.left) <span class="kw">return</span> left &lt; rhs.left;
        <span class="kw">return</span> right &lt; rhs.right;
    }
} node[maxn];

map&lt;Node,<span class="dt">int</span>&gt; dict;

<span class="dt">int</span> parse() {
    <span class="dt">int</span> id = cnt++;
    Node&amp; u = node[id];
    u.left = u.right = <span class="dv">-1</span>;
    u.s = <span class="st">&quot;&quot;</span>;
    u.hash = <span class="dv">0</span>;
    <span class="kw">while</span>(isalpha(*p)) {
        u.hash = u.hash * <span class="dv">27</span> + *p - <span class="st">&#39;a&#39;</span> + <span class="dv">1</span>;
        u.s.push_back(*p);
        p++;
    }
    <span class="kw">if</span> (*p == <span class="st">&#39;(&#39;</span>) { <span class="co">// (L,R)</span>
        p++; u.left = parse(); p++; u.right = parse(); p++;
    }
    <span class="kw">if</span> (dict.count(u) != <span class="dv">0</span>) {
        id--; cnt--;
        <span class="kw">return</span> dict[u];
    }
    <span class="kw">return</span> dict[u] = id;
}

<span class="dt">void</span> print(<span class="dt">int</span> v) {
    <span class="kw">if</span>(done[v] == kase)
        printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, v + <span class="dv">1</span>);
    <span class="kw">else</span> {
        done[v] = kase; <span class="co">// &#24120;&#35265;&#23567;&#25216;&#24039;&#65292;&#21487;&#20197;&#36991;&#20813;memset(done, 0, sizeof(done))</span>
        printf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, node[v].s.c_str());
        <span class="kw">if</span>(node[v].left != <span class="dv">-1</span>) {
            putchar(<span class="st">&#39;(&#39;</span>);
            print(node[v].left);
            putchar(<span class="st">&#39;,&#39;</span>);
            print(node[v].right);
            putchar(<span class="st">&#39;)&#39;</span>);
        }
    }
}

<span class="dt">int</span> main() {
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">for</span>(kase = <span class="dv">1</span>; kase &lt;= T; kase++) {
        dict.clear();
        cnt = <span class="dv">0</span>;
        scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, expr);
        p = expr;
        print(parse());
        putchar(<span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>11-2 UVa1395 Slim Span ch11/UVa1395.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1395 Slim Span</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span> + <span class="dv">10</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;
<span class="dt">int</span> n;

<span class="dt">int</span> pa[maxn];
<span class="dt">int</span> findset(<span class="dt">int</span> x) { <span class="kw">return</span> pa[x] != x ? pa[x] = findset(pa[x]) : x; }

<span class="kw">struct</span> Edge {
    <span class="dt">int</span> u, v, d;
    Edge(<span class="dt">int</span> u, <span class="dt">int</span> v, <span class="dt">int</span> d):u(u),v(v),d(d) {}
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Edge&amp; rhs) <span class="dt">const</span> {
        <span class="kw">return</span> d &lt; rhs.d;
    }
};

vector&lt;Edge&gt; e;

<span class="dt">int</span> solve() {
    <span class="dt">int</span> m = e.size();
    sort(e.begin(), e.end());
    <span class="dt">int</span> ans = INF;
    <span class="kw">for</span>(<span class="dt">int</span> L = <span class="dv">0</span>; L &lt; m; L++) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) pa[i] = i;
        <span class="dt">int</span> cnt = n; <span class="co">// number of sets</span>
        <span class="kw">for</span>(<span class="dt">int</span> R = L; R &lt; m; R++) {
            <span class="dt">int</span> u = findset(e[R].u), v = findset(e[R].v);
            <span class="kw">if</span>(u != v) {
                pa[u] = v;
                <span class="kw">if</span>(--cnt == <span class="dv">1</span>) { ans = min(ans, e[R].d-e[L].d); <span class="kw">break</span>; }
            }
        }
    }
    <span class="kw">if</span>(ans == INF) ans = <span class="dv">-1</span>;
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> m, u, v, d;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m) == <span class="dv">2</span> &amp;&amp; n) {
        e.clear();
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, &amp;u, &amp;v, &amp;d);
            e.push_back(Edge(u, v, d));
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, solve());
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>11-3 UVa1151 Buy or Build ch11/UVa1151.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1151 Buy or Build</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1000</span> + <span class="dv">10</span>;
<span class="dt">const</span> <span class="dt">int</span> maxq = <span class="dv">8</span>;
<span class="dt">int</span> n;
<span class="dt">int</span> x[maxn], y[maxn], cost[maxq];
vector&lt;<span class="dt">int</span>&gt; subn[maxq];

<span class="dt">int</span> pa[maxn];
<span class="dt">int</span> findset(<span class="dt">int</span> x) { <span class="kw">return</span> pa[x] != x ? pa[x] = findset(pa[x]) : x; }

<span class="kw">struct</span> Edge {
    <span class="dt">int</span> u, v, d;
    Edge(<span class="dt">int</span> u, <span class="dt">int</span> v, <span class="dt">int</span> d):u(u),v(v),d(d) {}
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Edge&amp; rhs) <span class="dt">const</span> {
        <span class="kw">return</span> d &lt; rhs.d;
    }
};

<span class="co">// initialize pa and sort e before calling this method</span>
<span class="co">// cnt is the current number of components</span>
<span class="dt">int</span> MST(<span class="dt">int</span> cnt, <span class="dt">const</span> vector&lt;Edge&gt;&amp; e, vector&lt;Edge&gt;&amp; used) {
    <span class="kw">if</span>(cnt == <span class="dv">1</span>) <span class="kw">return</span> <span class="dv">0</span>;
    <span class="dt">int</span> m = e.size();
    <span class="dt">int</span> ans = <span class="dv">0</span>;
    used.clear();
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++) {
        <span class="dt">int</span> u = findset(e[i].u), v = findset(e[i].v);
        <span class="dt">int</span> d = e[i].d;
        <span class="kw">if</span>(u != v) {
            pa[u] = v;
            ans += d;
            used.push_back(e[i]);
            <span class="kw">if</span>(--cnt == <span class="dv">1</span>) <span class="kw">break</span>;
        }
    }
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T, q;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;q);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; q; i++) {
            <span class="dt">int</span> cnt;
            scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;cnt, &amp;cost[i]);
            subn[i].clear();
            <span class="kw">while</span>(cnt--) {
                <span class="dt">int</span> u;
                scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;u);
                subn[i].push_back(u<span class="dv">-1</span>);
            }
        }
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;x[i], &amp;y[i]);

        vector&lt;Edge&gt; e, need;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
            <span class="kw">for</span>(<span class="dt">int</span> j = i<span class="dv">+1</span>; j &lt; n; j++) {
                <span class="dt">int</span> c = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);
                e.push_back(Edge(i, j, c));
            }

        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) pa[i] = i;
        sort(e.begin(), e.end());

        <span class="dt">int</span> ans = MST(n, e, need);
        <span class="kw">for</span>(<span class="dt">int</span> mask = <span class="dv">0</span>; mask &lt; (<span class="dv">1</span>&lt;&lt;q); mask++) {
            <span class="co">// union cities in the same sub-network</span>
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) pa[i] = i;
            <span class="dt">int</span> cnt = n, c = <span class="dv">0</span>;
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; q; i++) <span class="kw">if</span>(mask &amp; (<span class="dv">1</span>&lt;&lt;i)) {
                c += cost[i];
                <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt; subn[i].size(); j++) {
                    <span class="dt">int</span> u = findset(subn[i][j]), v = findset(subn[i]);
                    <span class="kw">if</span>(u != v) { pa[u] = v; cnt--; }
                }
            }
            vector&lt;Edge&gt; dummy;
            ans = min(ans, c + MST(cnt, need, dummy));
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans);
        <span class="kw">if</span>(T) printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>11-4 UVa247 Calling Circles ch11/UVa247.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa247 Calling Circles</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;string&gt;</span>
<span class="ot">#include&lt;map&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

vector&lt;string&gt; names;
<span class="dt">int</span> ID(<span class="dt">const</span> string&amp; s) {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; names.size(); i++)
        <span class="kw">if</span>(names[i] == s) <span class="kw">return</span> i;
    names.push_back(s);
    <span class="kw">return</span> names.size() - <span class="dv">1</span>;
}

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">25</span> + <span class="dv">5</span>;
<span class="dt">int</span> n, m, vis[maxn], d[maxn][maxn];
<span class="dt">void</span> dfs(<span class="dt">int</span> u) {
    vis[u] = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> v = <span class="dv">0</span>; v &lt; n; v++)
        <span class="kw">if</span>(!vis[v] &amp;&amp; d[u][v] &amp;&amp; d[v][u]) {
            printf(<span class="st">&quot;, </span><span class="ch">%s</span><span class="st">&quot;</span>, names[v].c_str());
            dfs(v);
        }
}

<span class="dt">int</span> main() {
    <span class="dt">char</span> s1, s2;
    <span class="dt">int</span> kase = <span class="dv">0</span>;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m) == <span class="dv">2</span> &amp;&amp; n) {
        names.clear();
        memset(d, <span class="dv">0</span>, <span class="kw">sizeof</span>(d));
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) d[i][i] = <span class="dv">1</span>;
        <span class="kw">while</span>(m--) {
            scanf(<span class="st">&quot;</span><span class="ch">%s%s</span><span class="st">&quot;</span>, s1, s2);
            d[ID(s1)][ID(s2)] = <span class="dv">1</span>;
        }
        <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; k++)
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
                <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)
                    d[i][j] |= d[i][k] &amp;&amp; d[k][j];

        <span class="kw">if</span>(kase &gt; <span class="dv">0</span>) printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
        printf(<span class="st">&quot;Calling circles for data set </span><span class="ch">%d</span><span class="st">:</span><span class="ch">\n</span><span class="st">&quot;</span>, ++kase);

        memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
            <span class="kw">if</span>(!vis[i]) {
                printf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, names[i].c_str());
                dfs(i);
                printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
            }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>11-5 UVa10048 Audiophobia ch11/UVa10048.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10048 Audiophobia</span>
<span class="co">// Rujia Liu</span>
<span class="co">// &#39064;&#24847;&#65306;&#36755;&#20837;&#19968;&#20010;&#26080;&#39033;&#24102;&#26435;&#22270;&#65292;&#22238;&#31572;&#19968;&#20123;&#35810;&#38382;&#65292;&#35810;&#38382;&#20869;&#23481;&#26159;&#38382;&#26576;&#20004;&#28857;&#38388;&#26368;&#22823;&#26435;&#26368;&#23567;&#30340;&#36335;&#24452;</span>
<span class="co">// &#31639;&#27861;&#65306;&#21464;&#24418;&#30340;floyd</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;
<span class="dt">int</span> d[maxn][maxn];

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, m, Q, u, v, w, kase = <span class="dv">0</span>;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m, &amp;Q) == <span class="dv">3</span> &amp;&amp; n) {
        <span class="co">// &#21021;&#22987;&#21270;</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            d[i][i] = <span class="dv">0</span>;
            <span class="kw">for</span>(<span class="dt">int</span> j = i<span class="dv">+1</span>; j &lt; n; j++) { d[i][j] = d[j][i] = INF; }
        }
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, &amp;u, &amp;v, &amp;w); u--; v--;
            d[u][v] = min(d[u][v], w);
            d[v][u] = d[u][v];
        }
        <span class="co">// &#20027;&#31639;&#27861;</span>
        <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; k++)
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
                <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)
                    <span class="kw">if</span>(d[i][k] &lt; INF &amp;&amp; d[k][j] &lt; INF)
                        d[i][j] = min(d[i][j], max(d[i][k], d[k][j]));
        <span class="co">// &#35810;&#38382;</span>
        <span class="kw">if</span>(kase) printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
        printf(<span class="st">&quot;Case #</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ++kase);
        <span class="kw">while</span>(Q--) {
            scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;u, &amp;v); u--; v--;
            <span class="kw">if</span>(d[u][v] == INF) printf(<span class="st">&quot;no path</span><span class="ch">\n</span><span class="st">&quot;</span>); <span class="kw">else</span> printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, d[u][v]);
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>11-6 UVa658 It&#8217;s not a Bug, it&#8217;s a Feature! ch11/UVa658.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa658 It&#39;s not a Bug, it&#39;s a Feature!</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;queue&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> Node {
    <span class="dt">int</span> bugs, dist;
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Node&amp; rhs) <span class="dt">const</span> {
        <span class="kw">return</span> dist &gt; rhs.dist;
    }
};

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">20</span>;
<span class="dt">const</span> <span class="dt">int</span> maxm = <span class="dv">100</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;

<span class="dt">int</span> n, m, t[maxm], dist[<span class="dv">1</span>&lt;&lt;maxn], mark[<span class="dv">1</span>&lt;&lt;maxn];
<span class="dt">char</span> before[maxm][maxn + <span class="dv">5</span>], after[maxm][maxn + <span class="dv">5</span>];

<span class="dt">int</span> solve() {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; (<span class="dv">1</span>&lt;&lt;n); i++) { mark[i] = <span class="dv">0</span>; dist[i] = INF; }
    priority_queue&lt;Node&gt; q;

    Node start;
    start.dist = <span class="dv">0</span>;
    start.bugs = (<span class="dv">1</span>&lt;&lt;n) - <span class="dv">1</span>;
    q.push(start);

    dist[start.bugs] = <span class="dv">0</span>;
    <span class="kw">while</span>(!q.empty()) {
        Node u = q.top(); q.pop();
        <span class="kw">if</span>(u.bugs == <span class="dv">0</span>) <span class="kw">return</span> u.dist;
        <span class="kw">if</span>(mark[u.bugs]) <span class="kw">continue</span>;
        mark[u.bugs] = <span class="dv">1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++) {
            <span class="dt">bool</span> patchable = <span class="kw">true</span>;
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++) {
                <span class="kw">if</span>(before[i][j] == <span class="st">&#39;-&#39;</span> &amp;&amp; (u.bugs &amp; (<span class="dv">1</span>&lt;&lt;j))) { patchable = <span class="kw">false</span>; <span class="kw">break</span>; }
                <span class="kw">if</span>(before[i][j] == <span class="st">&#39;+&#39;</span> &amp;&amp; !(u.bugs &amp; (<span class="dv">1</span>&lt;&lt;j))) { patchable = <span class="kw">false</span>; <span class="kw">break</span>; }
            }
            <span class="kw">if</span>(!patchable) <span class="kw">continue</span>;

            Node u2;
            u2.dist = u.dist + t[i];
            u2.bugs = u.bugs;
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++) {
                <span class="kw">if</span>(after[i][j] == <span class="st">&#39;-&#39;</span>) u2.bugs &amp;= ~(<span class="dv">1</span>&lt;&lt;j);
                <span class="kw">if</span>(after[i][j] == <span class="st">&#39;+&#39;</span>) u2.bugs |= (<span class="dv">1</span>&lt;&lt;j);
            }
            <span class="dt">int</span>&amp; D = dist[u2.bugs];
            <span class="kw">if</span>(D &lt; <span class="dv">0</span> || u2.dist &lt; D) {
                D = u2.dist;
                q.push(u2);
            }
        }
    }
    <span class="kw">return</span> <span class="dv">-1</span>;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> kase = <span class="dv">0</span>;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m) == <span class="dv">2</span> &amp;&amp; n) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++) scanf(<span class="st">&quot;</span><span class="ch">%d%s%s</span><span class="st">&quot;</span>, &amp;t[i], before[i], after[i]);
        <span class="dt">int</span> ans = solve();
        printf(<span class="st">&quot;Product </span><span class="ch">%d\n</span><span class="st">&quot;</span>, ++kase);
        <span class="kw">if</span>(ans &lt; <span class="dv">0</span>) printf(<span class="st">&quot;Bugs cannot be fixed.</span><span class="ch">\n\n</span><span class="st">&quot;</span>);
        <span class="kw">else</span> printf(<span class="st">&quot;Fastest sequence takes </span><span class="ch">%d</span><span class="st"> seconds.</span><span class="ch">\n\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>11-7 UVa753 A Plug for UNIX ch11/UVa753.cpp UVa753b.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa753 A Plug for UNIX</span>
<span class="co">// Rujia Liu</span>
<span class="co">// &#31639;&#27861;&#19968;&#65306;&#20808;&#20570;&#19968;&#27425;floyd&#65292;&#28982;&#21518;&#20877;&#26500;&#22270;</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;map&gt;</span>
<span class="ot">#include&lt;string&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;queue&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

vector&lt;string&gt; names;
<span class="dt">int</span> ID(<span class="dt">const</span> string&amp; s) {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; names.size(); i++)
        <span class="kw">if</span>(names[i] == s) <span class="kw">return</span> i;
    names.push_back(s);
    <span class="kw">return</span> names.size() - <span class="dv">1</span>;
}

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">400</span> + <span class="dv">5</span>;

<span class="dt">int</span> n, m, k;       <span class="co">// &#25554;&#24231;&#20010;&#25968;&#65292;&#35774;&#22791;&#20010;&#25968;&#65292;&#36716;&#25442;&#22120;&#20010;&#25968;</span>
<span class="dt">int</span> d[maxn][maxn]; <span class="co">// d[i][j]=1&#34920;&#31034;&#25554;&#22836;&#31867;&#22411;i&#21487;&#20197;&#36716;&#21270;&#20026;&#25554;&#22836;&#31867;&#22411;j</span>
<span class="dt">int</span> target[maxn];  <span class="co">// &#21508;&#20010;&#25554;&#24231;&#30340;&#31867;&#22411;</span>
<span class="dt">int</span> device[maxn];  <span class="co">// &#21508;&#20010;&#35774;&#22791;&#30340;&#31867;&#22411;</span>

<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;

<span class="kw">struct</span> Edge {
    <span class="dt">int</span> from, to, cap, flow;
    Edge(<span class="dt">int</span> u, <span class="dt">int</span> v, <span class="dt">int</span> c, <span class="dt">int</span> f):from(u),to(v),cap(c),flow(f) {}
};

<span class="kw">struct</span> EdmondsKarp {
    <span class="dt">int</span> n, m;
    vector&lt;Edge&gt; edges;    <span class="co">// &#36793;&#25968;&#30340;&#20004;&#20493;</span>
    vector&lt;<span class="dt">int</span>&gt; G[maxn];   <span class="co">// &#37051;&#25509;&#34920;&#65292;G[i][j]&#34920;&#31034;&#32467;&#28857;i&#30340;&#31532;j&#26465;&#36793;&#22312;e&#25968;&#32452;&#20013;&#30340;&#24207;&#21495;</span>
    <span class="dt">int</span> a[maxn];           <span class="co">// &#24403;&#36215;&#28857;&#21040;i&#30340;&#21487;&#25913;&#36827;&#37327;</span>
    <span class="dt">int</span> p[maxn];           <span class="co">// &#26368;&#30701;&#36335;&#26641;&#19978;p&#30340;&#20837;&#24359;&#32534;&#21495;</span>

    <span class="dt">void</span> init(<span class="dt">int</span> n) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) G[i].clear();
        edges.clear();
    }

    <span class="dt">void</span> AddEdge(<span class="dt">int</span> from, <span class="dt">int</span> to, <span class="dt">int</span> cap) {
        edges.push_back(Edge(from, to, cap, <span class="dv">0</span>));
        edges.push_back(Edge(to, from, <span class="dv">0</span>, <span class="dv">0</span>));
        m = edges.size();
        G[from].push_back(m<span class="dv">-2</span>);
        G[to].push_back(m<span class="dv">-1</span>);
    }

    <span class="dt">int</span> Maxflow(<span class="dt">int</span> s, <span class="dt">int</span> t) {
        <span class="dt">int</span> flow = <span class="dv">0</span>;
        <span class="kw">for</span>(;;) {
            memset(a, <span class="dv">0</span>, <span class="kw">sizeof</span>(a));
            queue&lt;<span class="dt">int</span>&gt; Q;
            Q.push(s);
            a[s] = INF;
            <span class="kw">while</span>(!Q.empty()) {
                <span class="dt">int</span> x = Q.front(); Q.pop();
                <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[x].size(); i++) {
                    Edge&amp; e = edges[G[x][i]];
                    <span class="kw">if</span>(!a[e.to] &amp;&amp; e.cap &gt; e.flow) {
                        p[e.to] = G[x][i];
                        a[e.to] = min(a[x], e.cap-e.flow);
                        Q.push(e.to);
                    }
                }
                <span class="kw">if</span>(a[t]) <span class="kw">break</span>;
            }
            <span class="kw">if</span>(!a[t]) <span class="kw">break</span>;
            <span class="kw">for</span>(<span class="dt">int</span> u = t; u != s; u = edges[p[u]].from) {
                edges[p[u]].flow += a[t];
                edges[p[u]^<span class="dv">1</span>].flow -= a[t];
            }
            flow += a[t];
        }
        <span class="kw">return</span> flow;
    }
};

EdmondsKarp g;

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    cin &gt;&gt; T;
    <span class="kw">while</span>(T--) {
        names.clear();
        string s1, s2;
        cin &gt;&gt; n;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            cin &gt;&gt; s1;
            target[i] = ID(s1);
        }
        cin &gt;&gt; m;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++) {
            cin &gt;&gt; s1 &gt;&gt; s2;
            device[i] = ID(s2);
        }
        cin &gt;&gt; k;
        memset(d, <span class="dv">0</span>, <span class="kw">sizeof</span>(d));
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; k; i++) {
            cin &gt;&gt; s1 &gt;&gt; s2;
            d[ID(s1)][ID(s2)] = <span class="dv">1</span>;
        }
        <span class="co">// floyd</span>
        <span class="dt">int</span> V = names.size(); <span class="co">// &#25554;&#22836;&#31867;&#22411;&#20010;&#25968;</span>
        <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; V; k++)
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; V; i++)
                <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; V; j++)
                    d[i][j] |= d[i][k] &amp;&amp; d[k][j];

        g.init(V<span class="dv">+2</span>);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++)
            g.AddEdge(V, device[i], <span class="dv">1</span>); <span class="co">// &#28304;&#28857;-&gt;&#35774;&#22791;</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
            g.AddEdge(target[i], V<span class="dv">+1</span>, <span class="dv">1</span>); <span class="co">// &#25554;&#24231;-&gt;&#27719;&#28857;</span>

        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++)
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)
                <span class="kw">if</span>(d[device[i]][target[j]]) g.AddEdge(device[i], target[j], INF); <span class="co">// &#35774;&#22791;-&gt;&#25554;&#24231;</span>
        <span class="dt">int</span> r = g.Maxflow(V, V<span class="dv">+1</span>);
        cout &lt;&lt; m-r &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
        <span class="kw">if</span>(T) cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>11-8 UVa11082 Matrix Decompressing ch11/UVa11082.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11082 Matrix Decompressing</span>
<span class="co">// Rujia Liu</span>
<span class="co">// Slower version with EdmondsKarp</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;queue&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">50</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;

<span class="kw">struct</span> Edge {
    <span class="dt">int</span> from, to, cap, flow;
    Edge(<span class="dt">int</span> u, <span class="dt">int</span> v, <span class="dt">int</span> c, <span class="dt">int</span> f):from(u),to(v),cap(c),flow(f) {}
};

<span class="kw">struct</span> EdmondsKarp {
    <span class="dt">int</span> n, m;
    vector&lt;Edge&gt; edges;    <span class="co">// &#36793;&#25968;&#30340;&#20004;&#20493;</span>
    vector&lt;<span class="dt">int</span>&gt; G[maxn];   <span class="co">// &#37051;&#25509;&#34920;&#65292;G[i][j]&#34920;&#31034;&#32467;&#28857;i&#30340;&#31532;j&#26465;&#36793;&#22312;e&#25968;&#32452;&#20013;&#30340;&#24207;&#21495;</span>
    <span class="dt">int</span> a[maxn];           <span class="co">// &#24403;&#36215;&#28857;&#21040;i&#30340;&#21487;&#25913;&#36827;&#37327;</span>
    <span class="dt">int</span> p[maxn];           <span class="co">// &#26368;&#30701;&#36335;&#26641;&#19978;p&#30340;&#20837;&#24359;&#32534;&#21495;</span>

    <span class="dt">void</span> init(<span class="dt">int</span> n) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) G[i].clear();
        edges.clear();
    }

    <span class="dt">void</span> AddEdge(<span class="dt">int</span> from, <span class="dt">int</span> to, <span class="dt">int</span> cap) {
        edges.push_back(Edge(from, to, cap, <span class="dv">0</span>));
        edges.push_back(Edge(to, from, <span class="dv">0</span>, <span class="dv">0</span>));
        m = edges.size();
        G[from].push_back(m<span class="dv">-2</span>);
        G[to].push_back(m<span class="dv">-1</span>);
    }

    <span class="dt">int</span> Maxflow(<span class="dt">int</span> s, <span class="dt">int</span> t) {
        <span class="dt">int</span> flow = <span class="dv">0</span>;
        <span class="kw">for</span>(;;) {
            memset(a, <span class="dv">0</span>, <span class="kw">sizeof</span>(a));
            queue&lt;<span class="dt">int</span>&gt; Q;
            Q.push(s);
            a[s] = INF;
            <span class="kw">while</span>(!Q.empty()) {
                <span class="dt">int</span> x = Q.front(); Q.pop();
                <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[x].size(); i++) {
                    Edge&amp; e = edges[G[x][i]];
                    <span class="kw">if</span>(!a[e.to] &amp;&amp; e.cap &gt; e.flow) {
                        p[e.to] = G[x][i];
                        a[e.to] = min(a[x], e.cap-e.flow);
                        Q.push(e.to);
                    }
                }
                <span class="kw">if</span>(a[t]) <span class="kw">break</span>;
            }
            <span class="kw">if</span>(!a[t]) <span class="kw">break</span>;
            <span class="kw">for</span>(<span class="dt">int</span> u = t; u != s; u = edges[p[u]].from) {
                edges[p[u]].flow += a[t];
                edges[p[u]^<span class="dv">1</span>].flow -= a[t];
            }
            flow += a[t];
        }
        <span class="kw">return</span> flow;
    }
};

EdmondsKarp g;
<span class="dt">int</span> no[maxn][maxn];

<span class="dt">int</span> main() {
    <span class="dt">int</span> T, R, C, v, kase = <span class="dv">0</span>;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">for</span>(<span class="dt">int</span> kase = <span class="dv">1</span>; kase &lt;= T; kase++) {
        scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;R, &amp;C);
        g.init(R+C<span class="dv">+2</span>);
        <span class="dt">int</span> last = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= R; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;v);
            g.AddEdge(<span class="dv">0</span>, i, v - last - C); <span class="co">// row sum is v - last</span>
            last = v;
        }
        last = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= C; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;v);
            g.AddEdge(R+i, R+C<span class="dv">+1</span>, v - last - R); <span class="co">// col sum is v - last</span>
            last = v;
        }
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= R; i++)
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= C; j++) {
                g.AddEdge(i, R+j, <span class="dv">19</span>);
                no[i][j] = g.edges.size() - <span class="dv">2</span>; <span class="co">// no[i][j] is the index of arc for cell(i,j)</span>
            }
        g.Maxflow(<span class="dv">0</span>, R+C<span class="dv">+1</span>);

        printf(<span class="st">&quot;Matrix </span><span class="ch">%d\n</span><span class="st">&quot;</span>, kase);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= R; i++) {
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= C; j++)
                printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, g.edges[no[i][j]].flow + <span class="dv">1</span>); <span class="co">// we subtracted 1 from every cell</span>
            printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
        }
        printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>11-9 UVa1658 Admiral ch11/UVa1658.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1658 Admiral</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;queue&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="ot">#include&lt;cassert&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">2000</span> + <span class="dv">10</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;

<span class="kw">struct</span> Edge {
    <span class="dt">int</span> from, to, cap, flow, cost;
    Edge(<span class="dt">int</span> u, <span class="dt">int</span> v, <span class="dt">int</span> c, <span class="dt">int</span> f, <span class="dt">int</span> w):from(u),to(v),cap(c),flow(f),cost(w) {}
};

<span class="kw">struct</span> MCMF {
    <span class="dt">int</span> n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;<span class="dt">int</span>&gt; G[maxn];
    <span class="dt">int</span> inq[maxn];         <span class="co">// &#26159;&#21542;&#22312;&#38431;&#21015;&#20013;</span>
    <span class="dt">int</span> d[maxn];           <span class="co">// Bellman-Ford</span>
    <span class="dt">int</span> p[maxn];           <span class="co">// &#19978;&#19968;&#26465;&#24359;</span>
    <span class="dt">int</span> a[maxn];           <span class="co">// &#21487;&#25913;&#36827;&#37327;</span>

    <span class="dt">void</span> init(<span class="dt">int</span> n) {
        <span class="kw">this</span>-&gt;n = n;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) G[i].clear();
        edges.clear();
    }

    <span class="dt">void</span> AddEdge(<span class="dt">int</span> from, <span class="dt">int</span> to, <span class="dt">int</span> cap, <span class="dt">int</span> cost) {
        edges.push_back(Edge(from, to, cap, <span class="dv">0</span>, cost));
        edges.push_back(Edge(to, from, <span class="dv">0</span>, <span class="dv">0</span>, -cost));
        m = edges.size();
        G[from].push_back(m<span class="dv">-2</span>);
        G[to].push_back(m<span class="dv">-1</span>);
    }

    <span class="dt">bool</span> BellmanFord(<span class="dt">int</span> s, <span class="dt">int</span> t, <span class="dt">int</span> flow_limit, <span class="dt">int</span>&amp; flow, <span class="dt">int</span>&amp; cost) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) d[i] = INF;
        memset(inq, <span class="dv">0</span>, <span class="kw">sizeof</span>(inq));
        d[s] = <span class="dv">0</span>; inq[s] = <span class="dv">1</span>; p[s] = <span class="dv">0</span>; a[s] = INF;

        queue&lt;<span class="dt">int</span>&gt; Q;
        Q.push(s);
        <span class="kw">while</span>(!Q.empty()) {
            <span class="dt">int</span> u = Q.front(); Q.pop();
            inq[u] = <span class="dv">0</span>;
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[u].size(); i++) {
                Edge&amp; e = edges[G[u][i]];
                <span class="kw">if</span>(e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost) {
                    d[e.to] = d[u] + e.cost;
                    p[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    <span class="kw">if</span>(!inq[e.to]) { Q.push(e.to); inq[e.to] = <span class="dv">1</span>; }
                }
            }
        }
        <span class="kw">if</span>(d[t] == INF) <span class="kw">return</span> <span class="kw">false</span>;
        <span class="kw">if</span>(flow + a[t] &gt; flow_limit) a[t] = flow_limit - flow;
        flow += a[t];
        cost += d[t] * a[t];
        <span class="kw">for</span>(<span class="dt">int</span> u = t; u != s; u = edges[p[u]].from) {
            edges[p[u]].flow += a[t];
            edges[p[u]^<span class="dv">1</span>].flow -= a[t];
        }
        <span class="kw">return</span> <span class="kw">true</span>;
    }

    <span class="co">// &#38656;&#35201;&#20445;&#35777;&#21021;&#22987;&#32593;&#32476;&#20013;&#27809;&#26377;&#36127;&#26435;&#22280;</span>
    <span class="dt">int</span> MincostFlow(<span class="dt">int</span> s, <span class="dt">int</span> t, <span class="dt">int</span> flow_limit, <span class="dt">int</span>&amp; cost) {
        <span class="dt">int</span> flow = <span class="dv">0</span>; cost = <span class="dv">0</span>;
        <span class="kw">while</span>(flow &lt; flow_limit &amp;&amp; BellmanFord(s, t, flow_limit, flow, cost));
        <span class="kw">return</span> flow;
    }

};

MCMF g;

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, m, a, b, c;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m) == <span class="dv">2</span> &amp;&amp; n) {
        g.init(n*<span class="dv">2-2</span>);

        <span class="co">// &#28857;2~n-1&#25286;&#25104;&#24359;i-&gt;i&#39;&#65292;&#21069;&#32773;&#32534;&#21495;&#20026;0~n-1&#65292;&#21518;&#32773;&#32534;&#21495;&#20026;n~2n-3</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= n<span class="dv">-1</span>; i++)
            g.AddEdge(i<span class="dv">-1</span>, i+n<span class="dv">-2</span>, <span class="dv">1</span>, <span class="dv">0</span>);

        <span class="kw">while</span>(m--) {
            scanf(<span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, &amp;a, &amp;b, &amp;c);
            <span class="co">// &#36830;a&#39;-&gt;b</span>
            <span class="kw">if</span>(a != <span class="dv">1</span> &amp;&amp; a != n) a += n<span class="dv">-2</span>; <span class="kw">else</span> a--;
            b--;
            g.AddEdge(a, b, <span class="dv">1</span>, c);
        }
        <span class="dt">int</span> cost;
        g.MincostFlow(<span class="dv">0</span>, n<span class="dv">-1</span>, <span class="dv">2</span>, cost);
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, cost);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>11-10 UVa1349 Optimal Bus Route Design ch11/UVa1349.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1349 Optimal Bus Route Design</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;queue&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="ot">#include&lt;cassert&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">200</span> + <span class="dv">10</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;

<span class="kw">struct</span> Edge {
    <span class="dt">int</span> from, to, cap, flow, cost;
    Edge(<span class="dt">int</span> u, <span class="dt">int</span> v, <span class="dt">int</span> c, <span class="dt">int</span> f, <span class="dt">int</span> w):from(u),to(v),cap(c),flow(f),cost(w) {}
};

<span class="kw">struct</span> MCMF {
    <span class="dt">int</span> n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;<span class="dt">int</span>&gt; G[maxn];
    <span class="dt">int</span> inq[maxn];         <span class="co">// &#26159;&#21542;&#22312;&#38431;&#21015;&#20013;</span>
    <span class="dt">int</span> d[maxn];           <span class="co">// Bellman-Ford</span>
    <span class="dt">int</span> p[maxn];           <span class="co">// &#19978;&#19968;&#26465;&#24359;</span>
    <span class="dt">int</span> a[maxn];           <span class="co">// &#21487;&#25913;&#36827;&#37327;</span>

    <span class="dt">void</span> init(<span class="dt">int</span> n) {
        <span class="kw">this</span>-&gt;n = n;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) G[i].clear();
        edges.clear();
    }

    <span class="dt">void</span> AddEdge(<span class="dt">int</span> from, <span class="dt">int</span> to, <span class="dt">int</span> cap, <span class="dt">int</span> cost) {
        edges.push_back(Edge(from, to, cap, <span class="dv">0</span>, cost));
        edges.push_back(Edge(to, from, <span class="dv">0</span>, <span class="dv">0</span>, -cost));
        m = edges.size();
        G[from].push_back(m<span class="dv">-2</span>);
        G[to].push_back(m<span class="dv">-1</span>);
    }

    <span class="dt">bool</span> BellmanFord(<span class="dt">int</span> s, <span class="dt">int</span> t, <span class="dt">int</span>&amp; flow, <span class="dt">int</span>&amp; cost) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) d[i] = INF;
        memset(inq, <span class="dv">0</span>, <span class="kw">sizeof</span>(inq));
        d[s] = <span class="dv">0</span>; inq[s] = <span class="dv">1</span>; p[s] = <span class="dv">0</span>; a[s] = INF;

        queue&lt;<span class="dt">int</span>&gt; Q;
        Q.push(s);
        <span class="kw">while</span>(!Q.empty()) {
            <span class="dt">int</span> u = Q.front(); Q.pop();
            inq[u] = <span class="dv">0</span>;
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[u].size(); i++) {
                Edge&amp; e = edges[G[u][i]];
                <span class="kw">if</span>(e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost) {
                    d[e.to] = d[u] + e.cost;
                    p[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    <span class="kw">if</span>(!inq[e.to]) { Q.push(e.to); inq[e.to] = <span class="dv">1</span>; }
                }
            }
        }
        <span class="kw">if</span>(d[t] == INF) <span class="kw">return</span> <span class="kw">false</span>;
        flow += a[t];
        cost += d[t] * a[t];
        <span class="kw">for</span>(<span class="dt">int</span> u = t; u != s; u = edges[p[u]].from) {
            edges[p[u]].flow += a[t];
            edges[p[u]^<span class="dv">1</span>].flow -= a[t];
        }
        <span class="kw">return</span> <span class="kw">true</span>;
    }

    <span class="co">// &#38656;&#35201;&#20445;&#35777;&#21021;&#22987;&#32593;&#32476;&#20013;&#27809;&#26377;&#36127;&#26435;&#22280;</span>
    <span class="dt">int</span> MincostMaxflow(<span class="dt">int</span> s, <span class="dt">int</span> t, <span class="dt">int</span>&amp; cost) {
        <span class="dt">int</span> flow = <span class="dv">0</span>; cost = <span class="dv">0</span>;
        <span class="kw">while</span>(BellmanFord(s, t, flow, cost));
        <span class="kw">return</span> flow;
    }

};

MCMF g;

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, m, d, k;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span> &amp;&amp; n) {
        g.init(n*<span class="dv">2+2</span>);
        <span class="kw">for</span>(<span class="dt">int</span> u = <span class="dv">1</span>; u &lt;= n; u++) {
            g.AddEdge(<span class="dv">0</span>, u, <span class="dv">1</span>, <span class="dv">0</span>);
            g.AddEdge(n+u, n*<span class="dv">2+1</span>, <span class="dv">1</span>, <span class="dv">0</span>);
        }
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {
            <span class="kw">for</span>(;;) {
                <span class="dt">int</span> j;
                scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;j); <span class="kw">if</span>(j == <span class="dv">0</span>) <span class="kw">break</span>;
                scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;d);
                g.AddEdge(i, j+n, <span class="dv">1</span>, d);
            }
        }

        <span class="dt">int</span> cost;
        <span class="dt">int</span> flow = g.MincostMaxflow(<span class="dv">0</span>, n*<span class="dv">2+1</span>, cost);
        <span class="kw">if</span>(flow &lt; n) printf(<span class="st">&quot;N</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">else</span> printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, cost);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>11-11 UVa12661 Funny Car Racing <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">nill</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>11-12 UVa1515 Pool construction ch11/UVa1515.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1515 Pool Construction</span>
<span class="co">// Rujia Liu</span>
<span class="co">// &#22240;&#20026;&#22270;&#36739;&#22823;&#65292;&#25152;&#20197;&#37319;&#29992;Dinic&#32780;&#19981;&#26159;EdmondsKarp</span>
<span class="co">// &#24471;&#30410;&#20110;&#25509;&#21475;&#19968;&#33268;&#24615;&#65292;&#35835;&#32773;&#26080;&#39035;&#29702;&#35299;Dinic&#23601;&#33021;&#20351;&#29992;&#23427;&#12290;</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;queue&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">50</span>*<span class="dv">50+10</span>;

<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;

<span class="kw">struct</span> Edge {
    <span class="dt">int</span> from, to, cap, flow;
};

<span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Edge&amp; a, <span class="dt">const</span> Edge&amp; b) {
    <span class="kw">return</span> a.from &lt; b.from || (a.from == b.from &amp;&amp; a.to &lt; b.to);
}

<span class="kw">struct</span> Dinic {
    <span class="dt">int</span> n, m, s, t;
    vector&lt;Edge&gt; edges;    <span class="co">// &#36793;&#25968;&#30340;&#20004;&#20493;</span>
    vector&lt;<span class="dt">int</span>&gt; G[maxn];   <span class="co">// &#37051;&#25509;&#34920;&#65292;G[i][j]&#34920;&#31034;&#32467;&#28857;i&#30340;&#31532;j&#26465;&#36793;&#22312;e&#25968;&#32452;&#20013;&#30340;&#24207;&#21495;</span>
    <span class="dt">bool</span> vis[maxn];        <span class="co">// BFS&#20351;&#29992;</span>
    <span class="dt">int</span> d[maxn];           <span class="co">// &#20174;&#36215;&#28857;&#21040;i&#30340;&#36317;&#31163;</span>
    <span class="dt">int</span> cur[maxn];         <span class="co">// &#24403;&#21069;&#24359;&#25351;&#38024;</span>

    <span class="dt">void</span> init(<span class="dt">int</span> n) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) G[i].clear();
        edges.clear();
    }

    <span class="dt">void</span> AddEdge(<span class="dt">int</span> from, <span class="dt">int</span> to, <span class="dt">int</span> cap) {
        edges.push_back((Edge){from, to, cap, <span class="dv">0</span>});
        edges.push_back((Edge){to, from, <span class="dv">0</span>, <span class="dv">0</span>});
        m = edges.size();
        G[from].push_back(m<span class="dv">-2</span>);
        G[to].push_back(m<span class="dv">-1</span>);
    }

    <span class="dt">bool</span> BFS() {
        memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
        queue&lt;<span class="dt">int</span>&gt; Q;
        Q.push(s);
        vis[s] = <span class="dv">1</span>;
        d[s] = <span class="dv">0</span>;
        <span class="kw">while</span>(!Q.empty()) {
            <span class="dt">int</span> x = Q.front(); Q.pop();
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[x].size(); i++) {
                Edge&amp; e = edges[G[x][i]];
                <span class="kw">if</span>(!vis[e.to] &amp;&amp; e.cap &gt; e.flow) {
                    vis[e.to] = <span class="dv">1</span>;
                    d[e.to] = d[x] + <span class="dv">1</span>;
                    Q.push(e.to);
                }
            }
        }
        <span class="kw">return</span> vis[t];
    }

    <span class="dt">int</span> DFS(<span class="dt">int</span> x, <span class="dt">int</span> a) {
        <span class="kw">if</span>(x == t || a == <span class="dv">0</span>) <span class="kw">return</span> a;
        <span class="dt">int</span> flow = <span class="dv">0</span>, f;
        <span class="kw">for</span>(<span class="dt">int</span>&amp; i = cur[x]; i &lt; G[x].size(); i++) {
            Edge&amp; e = edges[G[x][i]];
            <span class="kw">if</span>(d[x] + <span class="dv">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap-e.flow))) &gt; <span class="dv">0</span>) {
                e.flow += f;
                edges[G[x][i]^<span class="dv">1</span>].flow -= f;
                flow += f;
                a -= f;
                <span class="kw">if</span>(a == <span class="dv">0</span>) <span class="kw">break</span>;
            }
        }
        <span class="kw">return</span> flow;
    }

    <span class="dt">int</span> Maxflow(<span class="dt">int</span> s, <span class="dt">int</span> t) {
        <span class="kw">this</span>-&gt;s = s; <span class="kw">this</span>-&gt;t = t;
        <span class="dt">int</span> flow = <span class="dv">0</span>;
        <span class="kw">while</span>(BFS()) {
            memset(cur, <span class="dv">0</span>, <span class="kw">sizeof</span>(cur));
            flow += DFS(s, INF);
        }
        <span class="kw">return</span> flow;
    }
};

Dinic g;

<span class="dt">int</span> w, h;
<span class="dt">char</span> pool;

<span class="kw">inline</span> <span class="dt">int</span> ID(<span class="dt">int</span> i, <span class="dt">int</span> j) { <span class="kw">return</span> i*w+j; }

<span class="dt">int</span> main() {
    <span class="dt">int</span> T, d, f, b;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d%d%d%d%d</span><span class="st">&quot;</span>, &amp;w, &amp;h, &amp;d, &amp;f, &amp;b);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; h; i++) scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, pool[i]);
        <span class="dt">int</span> cost = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; h; i++) {
            <span class="kw">if</span>(pool[i] == <span class="st">&#39;.&#39;</span>) { pool[i] = <span class="st">&#39;#&#39;</span>; cost += f; }
            <span class="kw">if</span>(pool[i][w<span class="dv">-1</span>] == <span class="st">&#39;.&#39;</span>) { pool[i][w<span class="dv">-1</span>] = <span class="st">&#39;#&#39;</span>; cost += f; }
        }
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; w; i++) {
            <span class="kw">if</span>(pool[i] == <span class="st">&#39;.&#39;</span>) { pool[i] = <span class="st">&#39;#&#39;</span>; cost += f; }
            <span class="kw">if</span>(pool[h<span class="dv">-1</span>][i] == <span class="st">&#39;.&#39;</span>) { pool[h<span class="dv">-1</span>][i] = <span class="st">&#39;#&#39;</span>; cost += f; }
        }
        g.init(h*w<span class="dv">+2</span>);

        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; h; i++)
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; w; j++){
                <span class="kw">if</span>(pool[i][j] == <span class="st">&#39;#&#39;</span>) { <span class="co">// grass</span>
                    <span class="dt">int</span> cap = INF;
                    <span class="kw">if</span>(i != <span class="dv">0</span> &amp;&amp; i != h<span class="dv">-1</span> &amp;&amp; j != <span class="dv">0</span> &amp;&amp; j != w<span class="dv">-1</span>) cap = d;
                    g.AddEdge(h*w, ID(i,j), cap); <span class="co">// s-&gt;grass, cap=d or inf</span>
                } <span class="kw">else</span> { <span class="co">// hole</span>
                    g.AddEdge(ID(i,j), h*w<span class="dv">+1</span>, f); <span class="co">// hole-&gt;t, cap=f</span>
                }
                <span class="kw">if</span>(i &gt; <span class="dv">0</span>)   g.AddEdge(ID(i,j), ID(i<span class="dv">-1</span>,j), b);
                <span class="kw">if</span>(i &lt; h<span class="dv">-1</span>) g.AddEdge(ID(i,j), ID(i<span class="dv">+1</span>,j), b);
                <span class="kw">if</span>(j &gt; <span class="dv">0</span>)   g.AddEdge(ID(i,j), ID(i,j<span class="dv">-1</span>), b);
                <span class="kw">if</span>(j &lt; w<span class="dv">-1</span>) g.AddEdge(ID(i,j), ID(i,j<span class="dv">+1</span>), b);
            }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, cost + g.Maxflow(h*w, h*w<span class="dv">+1</span>));
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>11-13 UVa10735 Euler Circuit ch11/UVa10735.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10735 Euler Circuit</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;queue&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;

<span class="kw">struct</span> Edge {
    <span class="dt">int</span> from, to, cap, flow;
    Edge(<span class="dt">int</span> u, <span class="dt">int</span> v, <span class="dt">int</span> c, <span class="dt">int</span> f):from(u),to(v),cap(c),flow(f) {}
};

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100+10</span>;

<span class="kw">struct</span> EdmondsKarp {
    <span class="dt">int</span> n, m;
    vector&lt;Edge&gt; edges;    <span class="co">// &#36793;&#25968;&#30340;&#20004;&#20493;</span>
    vector&lt;<span class="dt">int</span>&gt; G[maxn];   <span class="co">// &#37051;&#25509;&#34920;&#65292;G[i][j]&#34920;&#31034;&#32467;&#28857;i&#30340;&#31532;j&#26465;&#36793;&#22312;e&#25968;&#32452;&#20013;&#30340;&#24207;&#21495;</span>
    <span class="dt">int</span> a[maxn];           <span class="co">// &#24403;&#36215;&#28857;&#21040;i&#30340;&#21487;&#25913;&#36827;&#37327;</span>
    <span class="dt">int</span> p[maxn];           <span class="co">// &#26368;&#30701;&#36335;&#26641;&#19978;p&#30340;&#20837;&#24359;&#32534;&#21495;</span>

    <span class="dt">void</span> init(<span class="dt">int</span> n) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) G[i].clear();
        edges.clear();
    }

    <span class="dt">void</span> AddEdge(<span class="dt">int</span> from, <span class="dt">int</span> to, <span class="dt">int</span> cap) {
        edges.push_back(Edge(from, to, cap, <span class="dv">0</span>));
        edges.push_back(Edge(to, from, <span class="dv">0</span>, <span class="dv">0</span>));
        m = edges.size();
        G[from].push_back(m<span class="dv">-2</span>);
        G[to].push_back(m<span class="dv">-1</span>);
    }

    <span class="dt">int</span> Maxflow(<span class="dt">int</span> s, <span class="dt">int</span> t) {
        <span class="dt">int</span> flow = <span class="dv">0</span>;
        <span class="kw">for</span>(;;) {
            memset(a, <span class="dv">0</span>, <span class="kw">sizeof</span>(a));
            queue&lt;<span class="dt">int</span>&gt; Q;
            Q.push(s);
            a[s] = INF;
            <span class="kw">while</span>(!Q.empty()) {
                <span class="dt">int</span> x = Q.front(); Q.pop();
                <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[x].size(); i++) {
                    Edge&amp; e = edges[G[x][i]];
                    <span class="kw">if</span>(!a[e.to] &amp;&amp; e.cap &gt; e.flow) {
                        p[e.to] = G[x][i];
                        a[e.to] = min(a[x], e.cap-e.flow);
                        Q.push(e.to);
                    }
                }
                <span class="kw">if</span>(a[t]) <span class="kw">break</span>;
            }
            <span class="kw">if</span>(!a[t]) <span class="kw">break</span>;
            <span class="kw">for</span>(<span class="dt">int</span> u = t; u != s; u = edges[p[u]].from) {
                edges[p[u]].flow += a[t];
                edges[p[u]^<span class="dv">1</span>].flow -= a[t];
            }
            flow += a[t];
        }
        <span class="kw">return</span> flow;
    }
};

EdmondsKarp g;

<span class="dt">const</span> <span class="dt">int</span> maxm = <span class="dv">500</span> + <span class="dv">5</span>;

<span class="dt">int</span> n, m, u[maxm], v[maxm], directed[maxm], id[maxm], diff[maxn];

<span class="co">// for euler tour only</span>
vector&lt;<span class="dt">int</span>&gt; G[maxn];
vector&lt;<span class="dt">int</span>&gt; vis[maxn];
vector&lt;<span class="dt">int</span>&gt; path;

<span class="dt">void</span> euler(<span class="dt">int</span> u) {
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[u].size(); i++)
        <span class="kw">if</span>(!vis[u][i]) {
            vis[u][i] = <span class="dv">1</span>;
            euler(G[u][i]);
            path.push_back(G[u][i]<span class="dv">+1</span>);
        }
}

<span class="dt">void</span> print_answer() {
    <span class="co">// build the new graph</span>
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) { G[i].clear(); vis[i].clear(); }
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++) {
        <span class="dt">bool</span> rev = <span class="kw">false</span>;
        <span class="kw">if</span>(!directed[i] &amp;&amp; g.edges[id[i]].flow &gt; <span class="dv">0</span>) rev = <span class="kw">true</span>;
        <span class="kw">if</span>(!rev) { G[u[i]].push_back(v[i]); vis[u[i]].push_back(<span class="dv">0</span>); }
        <span class="kw">else</span> { G[v[i]].push_back(u[i]); vis[v[i]].push_back(<span class="dv">0</span>); }
    }

    <span class="co">// print euler tour</span>
    path.clear();
    euler(<span class="dv">0</span>);

    printf(<span class="st">&quot;1&quot;</span>);
    <span class="kw">for</span>(<span class="dt">int</span> i = path.size()<span class="dv">-1</span>; i &gt;= <span class="dv">0</span>; i--) printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>, path[i]);
    printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);

    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m);
        g.init(n<span class="dv">+2</span>);

        memset(diff, <span class="dv">0</span>, <span class="kw">sizeof</span>(diff));
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++) {
            <span class="dt">char</span> dir;
            scanf(<span class="st">&quot;</span><span class="ch">%d%d%s</span><span class="st">&quot;</span>, &amp;u[i], &amp;v[i], dir);
            u[i]--; v[i]--;
            directed[i] = (dir == <span class="st">&#39;D&#39;</span> ? <span class="dv">1</span> : <span class="dv">0</span>);
            diff[u[i]]++; diff[v[i]]--;
            <span class="kw">if</span>(!directed[i]) { id[i] = g.edges.size(); g.AddEdge(u[i], v[i], <span class="dv">1</span>); }
        }

        <span class="dt">bool</span> ok = <span class="kw">true</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
            <span class="kw">if</span>(diff[i] % <span class="dv">2</span> != <span class="dv">0</span>) { ok = <span class="kw">false</span>; <span class="kw">break</span>; }

        <span class="dt">int</span> s = n, t = n<span class="dv">+1</span>;
        <span class="kw">if</span>(ok) {
            <span class="dt">int</span> sum = <span class="dv">0</span>;
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
                <span class="kw">if</span>(diff[i] &gt; <span class="dv">0</span>) { g.AddEdge(s, i, diff[i]/<span class="dv">2</span>); sum += diff[i]/<span class="dv">2</span>; } <span class="co">// provide &quot;out-degree&quot;</span>
                <span class="kw">if</span>(diff[i] &lt; <span class="dv">0</span>) { g.AddEdge(i, t, -diff[i]/<span class="dv">2</span>); }
            }
            <span class="kw">if</span>(g.Maxflow(s, t) != sum) ok = <span class="kw">false</span>;
        }

        <span class="kw">if</span>(!ok) printf(<span class="st">&quot;No euler circuit exist</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">else</span> print_answer(); <span class="co">// underlying graph is always connected</span>

        <span class="kw">if</span>(T) printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>11-14 UVa1279 Asteroid Rangers ch11/UVa1279.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1279 Asteroid Rangers</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">50</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> maxks = maxn * (maxn<span class="dv">+1</span>) / <span class="dv">2</span>;
<span class="dt">const</span> <span class="dt">double</span> eps = <span class="fl">1e-8</span>;

<span class="dt">int</span> n, nks;

<span class="co">// event</span>
<span class="kw">struct</span> Event {
    <span class="dt">double</span> t;
    <span class="dt">int</span> newks, oldks; <span class="co">// After event, newks will be smaller than oldks</span>
    Event(<span class="dt">double</span> t=<span class="dv">0</span>, <span class="dt">int</span> newks=<span class="dv">0</span>, <span class="dt">int</span> oldks=<span class="dv">0</span>) : t(t), newks(newks), oldks(oldks) {}
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Event&amp; rhs) <span class="dt">const</span> {
        <span class="kw">return</span> t - rhs.t &lt; <span class="dv">0</span>;
    }
};
vector &lt;Event&gt; events;

<span class="kw">struct</span> KineticPoint {
    <span class="dt">double</span> x, y, z; <span class="co">// initial position</span>
    <span class="dt">double</span> dx, dy, dz; <span class="co">// velocity</span>
    <span class="dt">void</span> read() {
        scanf(<span class="st">&quot;</span><span class="ch">%lf%lf%lf%lf%lf%lf</span><span class="st">&quot;</span>, &amp;x, &amp;y, &amp;z, &amp;dx, &amp;dy, &amp;dz);
    }
} kp[maxn];

<span class="kw">struct</span> KineticSegment {
    <span class="dt">double</span> a, b, c; <span class="co">// length is at^2+bt+c</span>
    <span class="dt">int</span> u, v; <span class="co">// end point IDs</span>
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> KineticSegment&amp; rhs) <span class="dt">const</span> { <span class="co">// compare initial length</span>
        <span class="kw">return</span> c - rhs.c &lt; <span class="dv">0</span>;
    }
} ks[maxks];

<span class="kw">inline</span> <span class="dt">double</span> sqr(<span class="dt">double</span> x) { <span class="kw">return</span> x * x; }

<span class="co">// union-find</span>
<span class="dt">int</span> pa[maxn];

<span class="dt">void</span> init_ufset() { <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) pa[i] = i; }
<span class="dt">int</span> findset(<span class="dt">int</span> x) { <span class="kw">return</span> pa[x] != x ? pa[x] = findset(pa[x]) : x; }

<span class="dt">void</span> make_segments() {
    nks = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
        <span class="kw">for</span>(<span class="dt">int</span> j = i<span class="dv">+1</span>; j &lt; n; j++) {
            <span class="co">// the square distance between point i and point j is sum{((kp[i].dx-kp[j].dx) * t + (kp[i].x-kp[j].x))^2}</span>
            <span class="co">// which can be re-written to at^2+bt+c. a&gt;0, c&gt;0</span>
            ks[nks].a = sqr(kp[i].dx-kp[j].dx) + sqr(kp[i].dy-kp[j].dy) + sqr(kp[i].dz-kp[j].dz);
            ks[nks].b = <span class="dv">2</span>*((kp[i].dx-kp[j].dx)*(kp[i].x-kp[j].x) + (kp[i].dy-kp[j].dy)*(kp[i].y-kp[j].y) + (kp[i].dz-kp[j].dz)*(kp[i].z-kp[j].z));
            ks[nks].c = sqr(kp[i].x-kp[j].x) + sqr(kp[i].y-kp[j].y) + sqr(kp[i].z-kp[j].z);
            ks[nks].u = i;
            ks[nks].v = j;
            nks++;
        }
    sort(ks, ks + nks);
}

<span class="dt">void</span> make_events() {
    events.clear();
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nks; i++)
        <span class="kw">for</span>(<span class="dt">int</span> j = i<span class="dv">+1</span>; j &lt; nks; j++) {
            <span class="co">// when segment i&#39;s length is equal to segment j?</span>
            <span class="dt">int</span> s1 = i, s2 = j;
            <span class="kw">if</span> (ks[s1].a - ks[s2].a &lt; <span class="dv">0</span>) s1 = j, s2 = i; <span class="co">// s1 is more steep (bigger a value)</span>

            <span class="dt">double</span> a = ks[s1].a - ks[s2].a;
            <span class="dt">double</span> b = ks[s1].b - ks[s2].b;
            <span class="dt">double</span> c = ks[s1].c - ks[s2].c;
            <span class="kw">if</span>(fabs(a) &lt; eps) { <span class="co">// bt + c = 0</span>
                <span class="kw">if</span> (fabs(b) &lt; eps) <span class="kw">continue</span>; <span class="co">// no solution</span>
                <span class="kw">if</span> (b &gt; <span class="dv">0</span>) { swap(s1, s2); b = -b; c = -c; } <span class="co">// bt + c = 0, b &lt; 0</span>
                <span class="kw">if</span> (c &gt; <span class="dv">0</span>) events.push_back(Event(-c / b, s1, s2)); <span class="co">// t &gt; 0</span>
                <span class="kw">continue</span>;
            }
            <span class="dt">double</span> delta = b * b - <span class="dv">4</span> * a * c;
            <span class="kw">if</span> (delta &lt; eps) <span class="kw">continue</span>; <span class="co">// no solution</span>
            delta = sqrt(delta);
            <span class="dt">double</span> t1 = -(b + delta) / (<span class="dv">2</span> * a); <span class="co">// solution 1</span>
            <span class="dt">double</span> t2 = (delta - b) / (<span class="dv">2</span> * a); <span class="co">// solution 2</span>
            <span class="kw">if</span> (t1 &gt; <span class="dv">0</span>) events.push_back(Event(t1, s1, s2)); <span class="co">// steep one will be smaller</span>
            <span class="kw">if</span> (t2 &gt; <span class="dv">0</span>) events.push_back(Event(t2, s2, s1)); <span class="co">// flat one will be smaller</span>
        }
    sort(events.begin(), events.end());
}

<span class="dt">int</span> solve() {
    <span class="dt">int</span> pos[maxks]; <span class="co">// pos[i] is the index of i-th segment in the MST. 0 means &quot;not in MST&quot;</span>
    <span class="dt">int</span> e[maxn];    <span class="co">// e[i] (i &gt; 0) is the i-th edge in current MST. pos[e[i]] = i</span>

    <span class="co">// initial MST</span>
    init_ufset();
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nks; i++) pos[i] = <span class="dv">0</span>;
    <span class="dt">int</span> idx = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nks; i++) {
        <span class="dt">int</span> u = findset(ks[i].u), v = findset(ks[i].v);
        <span class="kw">if</span> (u != v) {
            e[pos[i] = ++idx] = i;
            pa[u] = v;
        }
        <span class="kw">if</span>(idx == n<span class="dv">-1</span>) <span class="kw">break</span>;
    }

    <span class="dt">int</span> ans = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; events.size(); i++) {
        <span class="kw">if</span>(pos[events[i].oldks] &amp;&amp; (!pos[events[i].newks])) {
            init_ufset();
            <span class="dt">int</span> oldpos = pos[events[i].oldks];
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">1</span>; j &lt; n; j++)
                <span class="kw">if</span> (j != oldpos) {
                    <span class="dt">int</span> u = findset(ks[e[j]].u), v = findset(ks[e[j]].v);
                    <span class="kw">if</span>(u != v) pa[u] = v;
                }
            <span class="dt">int</span> u = findset(ks[events[i].newks].u), v = findset(ks[events[i].newks].v);
            <span class="kw">if</span>(u != v) {
                <span class="co">// new MST found! now replace oldks with newks</span>
                ans++;
                pos[events[i].newks] = oldpos;
                e[oldpos] = events[i].newks;
                pos[events[i].oldks] = <span class="dv">0</span>;
            }
        }
    }
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> kase = <span class="dv">0</span>;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span>) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) kp[i].read();
        make_segments();
        make_events();
        <span class="dt">int</span> ans = solve();
        printf(<span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">: </span><span class="ch">%d\n</span><span class="st">&quot;</span>, ++kase, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>11-15 UVa1659 Help Little Laura ch11/UVa1659.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1659 Help Little Laura</span>
<span class="co">// Rujia Liu</span>
<span class="co">// &#31639;&#27861;&#19968;&#65306;&#25913;&#36896;&#32593;&#32476;&#65292;&#21435;&#25481;&#36127;&#26435;</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cmath&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;queue&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="ot">#include&lt;cassert&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span> + <span class="dv">10</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>;

<span class="kw">struct</span> Edge {
    <span class="dt">int</span> from, to, cap, flow;
    <span class="dt">double</span> cost;
    Edge(<span class="dt">int</span> u, <span class="dt">int</span> v, <span class="dt">int</span> c, <span class="dt">int</span> f, <span class="dt">double</span> w):from(u),to(v),cap(c),flow(f),cost(w) {}
};

<span class="kw">struct</span> MCMF {
    <span class="dt">int</span> n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;<span class="dt">int</span>&gt; G[maxn];
    <span class="dt">int</span> inq[maxn];         <span class="co">// &#26159;&#21542;&#22312;&#38431;&#21015;&#20013;</span>
    <span class="dt">double</span> d[maxn];        <span class="co">// Bellman-Ford</span>
    <span class="dt">int</span> p[maxn];           <span class="co">// &#19978;&#19968;&#26465;&#24359;</span>
    <span class="dt">int</span> a[maxn];           <span class="co">// &#21487;&#25913;&#36827;&#37327;</span>

    <span class="dt">void</span> init(<span class="dt">int</span> n) {
        <span class="kw">this</span>-&gt;n = n;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) G[i].clear();
        edges.clear();
    }

    <span class="dt">void</span> AddEdge(<span class="dt">int</span> from, <span class="dt">int</span> to, <span class="dt">int</span> cap, <span class="dt">double</span> cost) {
        edges.push_back(Edge(from, to, cap, <span class="dv">0</span>, cost));
        edges.push_back(Edge(to, from, <span class="dv">0</span>, <span class="dv">0</span>, -cost));
        m = edges.size();
        G[from].push_back(m<span class="dv">-2</span>);
        G[to].push_back(m<span class="dv">-1</span>);
    }

    <span class="dt">bool</span> BellmanFord(<span class="dt">int</span> s, <span class="dt">int</span> t, <span class="dt">int</span>&amp; flow, <span class="dt">double</span>&amp; cost) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) d[i] = INF;
        memset(inq, <span class="dv">0</span>, <span class="kw">sizeof</span>(inq));
        d[s] = <span class="dv">0</span>; inq[s] = <span class="dv">1</span>; p[s] = <span class="dv">0</span>; a[s] = INF;

        queue&lt;<span class="dt">int</span>&gt; Q;
        Q.push(s);
        <span class="kw">while</span>(!Q.empty()) {
            <span class="dt">int</span> u = Q.front(); Q.pop();
            inq[u] = <span class="dv">0</span>;
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[u].size(); i++) {
                Edge&amp; e = edges[G[u][i]];
                <span class="kw">if</span>(e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost) {
                    d[e.to] = d[u] + e.cost;
                    p[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    <span class="kw">if</span>(!inq[e.to]) { Q.push(e.to); inq[e.to] = <span class="dv">1</span>; }
                }
            }
        }
        <span class="kw">if</span>(d[t] == INF) <span class="kw">return</span> <span class="kw">false</span>;
        flow += a[t];
        cost += d[t] * a[t];
        <span class="kw">for</span>(<span class="dt">int</span> u = t; u != s; u = edges[p[u]].from) {
            edges[p[u]].flow += a[t];
            edges[p[u]^<span class="dv">1</span>].flow -= a[t];
        }
        <span class="kw">return</span> <span class="kw">true</span>;
    }

    <span class="co">// &#38656;&#35201;&#20445;&#35777;&#21021;&#22987;&#32593;&#32476;&#20013;&#27809;&#26377;&#36127;&#26435;&#22280;</span>
    <span class="dt">int</span> MincostMaxflow(<span class="dt">int</span> s, <span class="dt">int</span> t, <span class="dt">double</span>&amp; cost) {
        <span class="dt">int</span> flow = <span class="dv">0</span>; cost = <span class="dv">0</span>;
        <span class="kw">while</span>(BellmanFord(s, t, flow, cost));
        <span class="kw">return</span> flow;
    }

};

MCMF g;

<span class="dt">int</span> x[maxn], y[maxn], c1[maxn], c2[maxn];
vector&lt;<span class="dt">int</span>&gt; G[maxn];

<span class="dt">int</span> main() {
    <span class="dt">int</span> n, a, b, v, kase = <span class="dv">0</span>;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;a, &amp;b) == <span class="dv">3</span>) {
        g.init(n<span class="dv">+2</span>);
        <span class="kw">for</span>(<span class="dt">int</span> u = <span class="dv">0</span>; u &lt; n; u++) {
            scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;x[u], &amp;y[u]);
            G[u].clear();
            <span class="kw">for</span>(;;) {
                scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;v);
                <span class="kw">if</span>(v == <span class="dv">0</span>) <span class="kw">break</span>;
                G[u].push_back(v<span class="dv">-1</span>);
            }
        }

        memset(c1, <span class="dv">0</span>, <span class="kw">sizeof</span>(c1));
        memset(c2, <span class="dv">0</span>, <span class="kw">sizeof</span>(c2));
        <span class="dt">double</span> sum = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> u = <span class="dv">0</span>; u &lt; n; u++) {
            <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[u].size(); i++) {
                <span class="dt">int</span> v = G[u][i];
                <span class="dt">double</span> d = sqrt((x[u] - x[v])*(x[u] - x[v]) + (y[u] - y[v])*(y[u] - y[v]));
                <span class="dt">double</span> edge_cost = -d*a+b; <span class="co">// minimize sum{edge_cost}</span>
            <span class="kw">if</span>(edge_cost &gt;= <span class="dv">0</span>) {
                g.AddEdge(u, v, <span class="dv">1</span>, edge_cost);
            } <span class="kw">else</span> {
                g.AddEdge(v, u, <span class="dv">1</span>, -edge_cost);
                c1[v]++; c2[u]++;
                sum += -edge_cost;
            }
            }
        }
        <span class="kw">for</span>(<span class="dt">int</span> u = <span class="dv">0</span>; u &lt; n; u++) {
            <span class="kw">if</span>(c1[u] &gt; c2[u]) g.AddEdge(n, u, c1[u]-c2[u], <span class="dv">0</span>);
            <span class="kw">if</span>(c2[u] &gt; c1[u]) g.AddEdge(u, n<span class="dv">+1</span>, c2[u]-c1[u], <span class="dv">0</span>);
        }

        <span class="dt">double</span> cost;
        <span class="dt">int</span> flow = g.MincostMaxflow(n, n<span class="dv">+1</span>, cost);
        <span class="dt">double</span> ans = sum - cost;
        <span class="kw">if</span>(ans &lt; <span class="dv">0</span>) ans = <span class="dv">0</span>; <span class="co">// avoid -0.0</span>
        printf(<span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">: </span><span class="ch">%.2lf\n</span><span class="st">&quot;</span>, ++kase, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>12-1 UVa1671 History of Languages ch12/UVa1671.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1671 History of Languages</span>
<span class="co">// Rujia Liu</span>
<span class="co">//</span>
<span class="co">// This is Problem 12-1 of &lt;&lt;Beginning Algorithm Contests&gt;&gt; 2nd edition</span>
<span class="co">//</span>
<span class="co">// We want to test whether A intersects with ~B (finalA = 1, finalB = 0), or B intersects with ~A (finalA = 0, finalB = 1)</span>
<span class="co">// So we can do a single DFS instead of two, checking finalA XOR finals B=1</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">2000</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> maxt = <span class="dv">26</span>;

<span class="co">// Note: state 0 is a dummy state, other states&#39; number is increased by 1</span>
<span class="kw">struct</span> DFA {
    <span class="dt">int</span> n;
    <span class="dt">int</span> is_final[maxn];
    <span class="dt">int</span> next[maxn][maxt];
    <span class="dt">void</span> read(<span class="dt">int</span> t) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;is_final[i]);
            <span class="kw">for</span>(<span class="dt">int</span> c = <span class="dv">0</span>; c &lt; t; c++) {
                <span class="dt">int</span> s;
                scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;s);
                next[i][c] = s<span class="dv">+1</span>;
            }
        }
        is_final = <span class="dv">0</span>; <span class="co">// dummy state is not final</span>
    }
}A, B;

<span class="dt">int</span> vis[maxn][maxn], kase, t;

<span class="co">// try to find a common string starting from (s1, s2)</span>
<span class="dt">bool</span> dfs(<span class="dt">int</span> s1, <span class="dt">int</span> s2) {
    vis[s1][s2] = kase;
    <span class="kw">if</span>(A.is_final[s1] ^ B.is_final[s2]) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; t; i++) {
        <span class="dt">int</span> nexta = A.next[s1][i];
        <span class="dt">int</span> nextb = B.next[s2][i];
        <span class="kw">if</span>(vis[nexta][nextb] != kase &amp;&amp; dfs(nexta, nextb)) <span class="kw">return</span> <span class="kw">true</span>;
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">int</span> main() {
    kase = <span class="dv">0</span>;
    memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;t) == <span class="dv">1</span> &amp;&amp; t) {
        A.read(t);
        B.read(t);
        printf(<span class="st">&quot;Case #</span><span class="ch">%d</span><span class="st">: &quot;</span>, ++kase);
        <span class="kw">if</span>(dfs(<span class="dv">1</span>, <span class="dv">1</span>)) printf(<span class="st">&quot;No</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">else</span> printf(<span class="st">&quot;Yes</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>12-2 UVa1672 Disjoint Regular Expressions ch12/uva1672.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1672 Disjoint Regular Expressions</span>
<span class="co">// Rujia Liu</span>
<span class="co">//</span>
<span class="co">// This is Problem 12-2 of &lt;&lt;Beginning Algorithm Contests&gt;&gt; 2nd edition</span>
<span class="co">//</span>
<span class="co">// This code is neither simplest nor most efficient, but it&#39;s easy to understand and fast enough.</span>
<span class="co">// Algorithm implemented here:</span>
<span class="co">//   1. build epsilon-NFA from the regex</span>
<span class="co">//   2. build NFA by removing epsilon from epsilon-NFA. Note that we did NOT optimize the epsilon-NFA as described in the book.</span>
<span class="co">//   3. use BFS to find a common string of these two NFAs</span>
<span class="co">// Attention: the output should NOT be empty so we used a little trick.</span>
<span class="co">//</span>
<span class="co">// Alternative algorithm: do BFS directly on epsilon-NFAs.</span>
<span class="co">// State is (s1,s2,b) where b=1 iff at least one non-epsilon transition is performed.</span>
<span class="co">// However, this graph is now 0-1 weighted so we need to use deque (or two-phase BFS).</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;set&gt;</span>
<span class="ot">#include&lt;string&gt;</span>
<span class="ot">#include&lt;queue&gt;</span>
<span class="ot">#include&lt;cassert&gt;</span>
<span class="ot">#define REP(i,n) for(int i = 0; i &lt; (n); ++i)</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Part I: Expression Parser</span>
<span class="kw">struct</span> ExprNode {
    <span class="kw">enum</span> {A, STAR, OR, CONCAT};
    <span class="dt">int</span> type, val;
    ExprNode *l, *r;

    ExprNode(<span class="dt">int</span> type, ExprNode* l, ExprNode* r, <span class="dt">int</span> val = <span class="dv">-1</span>):type(type),l(l),r(r),val(val){}
    ~ExprNode() {
        <span class="kw">if</span>(l) <span class="kw">delete</span> l;
        <span class="kw">if</span>(r) <span class="kw">delete</span> r;
    }
};

<span class="kw">struct</span> Parser {
    <span class="dt">char</span>* s;
    <span class="dt">int</span> p, n;

    <span class="dt">void</span> Skip(<span class="dt">char</span> c) { p++; } <span class="co">// for debug purpose</span>

    <span class="co">// (u)*</span>
    ExprNode* Item() {
        ExprNode* u;
        <span class="kw">if</span>(s[p] == <span class="st">&#39;(&#39;</span>) { Skip(<span class="st">&#39;(&#39;</span>); u = Expr(); Skip(<span class="st">&#39;)&#39;</span>); }
        <span class="kw">else</span> u = <span class="kw">new</span> ExprNode(ExprNode::A, NULL, NULL, s[p++]);
        <span class="kw">while</span>(s[p] == <span class="st">&#39;*&#39;</span>) {
            Skip(<span class="st">&#39;*&#39;</span>);
            u = <span class="kw">new</span> ExprNode(ExprNode::STAR, u, NULL);
        }
        <span class="kw">return</span> u;
    }

    <span class="co">// u1u2u3...</span>
    ExprNode* Concat() {
        ExprNode* u = Item();
        <span class="kw">while</span>(s[p] &amp;&amp; s[p] != <span class="st">&#39;)&#39;</span> &amp;&amp; s[p] != <span class="st">&#39;|&#39;</span>)
            u = <span class="kw">new</span> ExprNode(ExprNode::CONCAT, u, Item());
        <span class="kw">return</span> u;
    }

    <span class="co">// u1|u2|u3</span>
    ExprNode* Expr() {
        ExprNode* u = Concat();
        <span class="kw">while</span>(s[p] == <span class="st">&#39;|&#39;</span>) {
            Skip(<span class="st">&#39;|&#39;</span>);
            u = <span class="kw">new</span> ExprNode(ExprNode::OR, u, Concat());
        }
        <span class="kw">return</span> u;
    }

    ExprNode* parse(<span class="dt">char</span>* str) {
        s = str;
        n = strlen(s);
        p = <span class="dv">0</span>;
        <span class="kw">return</span> Expr();
    }

};

<span class="co">// Part II: NFA construction</span>
<span class="dt">const</span> <span class="dt">int</span> maxs = <span class="dv">100</span> * <span class="dv">4</span> + <span class="dv">5</span>;

<span class="kw">struct</span> NFA {
    <span class="dt">int</span> n; <span class="co">// number of states</span>

    <span class="kw">struct</span> Transition {
        <span class="dt">int</span> ch, next;
        Transition(<span class="dt">int</span> ch = <span class="dv">0</span>, <span class="dt">int</span> next = <span class="dv">0</span>):ch(ch),next(next){}
        <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> Transition&amp; rhs) <span class="dt">const</span> {
            <span class="kw">if</span>(ch != rhs.ch) <span class="kw">return</span> ch &lt; rhs.ch;
            <span class="kw">return</span> next &lt; rhs.next;
        }
    };
    vector&lt;Transition&gt; trans[maxs];

    <span class="dt">void</span> add(<span class="dt">int</span> s, <span class="dt">int</span> t, <span class="dt">int</span> c) {
        trans[s].push_back(Transition(c, t));
    }

    <span class="dt">void</span> process(ExprNode* u) {
        <span class="dt">int</span> st = n++; <span class="co">// state &#39;start&#39;</span>
        <span class="kw">if</span>(u-&gt;type == ExprNode::A) add(st, n, u-&gt;val);
        <span class="kw">else</span> <span class="kw">if</span>(u-&gt;type == ExprNode::STAR) {
            process(u-&gt;l);
            add(st, st<span class="dv">+1</span>, <span class="dv">-1</span>);
            add(st, n, <span class="dv">-1</span>);
            add(n<span class="dv">-1</span>, st, <span class="dv">-1</span>);
        }
        <span class="kw">else</span> <span class="kw">if</span>(u-&gt;type == ExprNode::OR) {
            process(u-&gt;l);
            <span class="dt">int</span> m = n;
            process(u-&gt;r);
            add(st, st<span class="dv">+1</span>, <span class="dv">-1</span>);
            add(st, m, <span class="dv">-1</span>);
            add(m<span class="dv">-1</span>, n, <span class="dv">-1</span>);
            add(n<span class="dv">-1</span>, n, <span class="dv">-1</span>);
        }
        <span class="kw">else</span> <span class="kw">if</span>(u-&gt;type == ExprNode::CONCAT) {
            add(st, st<span class="dv">+1</span>, <span class="dv">-1</span>);
            process(u-&gt;l);
            add(n<span class="dv">-1</span>, n, <span class="dv">-1</span>);
            process(u-&gt;r);
            add(n<span class="dv">-1</span>, n, <span class="dv">-1</span>);
        }
        n++; <span class="co">// state &#39;end&#39;</span>
    }

    <span class="dt">void</span> init(<span class="dt">char</span>* s) {
        Parser p;
        ExprNode* root = p.parse(s);
        n = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; maxs; i++) {
            trans[i].clear();
        }
        process(root);
        <span class="kw">delete</span> root;
    }

    vector&lt;<span class="dt">int</span>&gt; ss; <span class="co">// starting states</span>

    <span class="dt">void</span> remove_epsilon() {
        <span class="co">// find epsilon-closure for each state</span>
        vector&lt;<span class="dt">int</span>&gt; reachable[maxs];
        <span class="dt">int</span> vis[maxs];
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            reachable[i].clear();
            reachable[i].push_back(i);
            queue&lt;<span class="dt">int</span>&gt; q;
            q.push(i);
            memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
            vis[i] = <span class="dv">1</span>;
            <span class="kw">while</span>(!q.empty()) {
                <span class="dt">int</span> s = q.front(); q.pop();
                <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; trans[s].size(); j++)
                    <span class="kw">if</span>(trans[s][j].ch == <span class="dv">-1</span>) {
                        <span class="dt">int</span> s2 = trans[s][j].next;
                        <span class="kw">if</span>(!vis[s2]) {
                            reachable[i].push_back(s2);
                            vis[s2] = <span class="dv">1</span>;
                            q.push(s2);
                        }
                    }
            }
        }
        ss = reachable;

        <span class="co">// merge transitions</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            set&lt;Transition&gt; <span class="fu">tr</span>;
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; trans[i].size(); j++) {
                <span class="kw">if</span>(trans[i][j].ch == <span class="dv">-1</span>) <span class="kw">continue</span>;
                <span class="dt">int</span> s = trans[i][j].next;
                <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; reachable[s].size(); k++)
                    <span class="fu">tr</span>.insert(Transition(trans[i][j].ch, reachable[s][k]));
            }
            trans[i] = vector&lt;Transition&gt;(<span class="fu">tr</span>.begin(), <span class="fu">tr</span>.end());
        }
    }
};

<span class="co">// Part III: BFS to find the answer</span>

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> maxq = <span class="dv">100</span> * <span class="dv">4</span> * <span class="dv">100</span> * <span class="dv">4</span> * <span class="dv">2</span> + <span class="dv">5</span>; <span class="co">// case 26</span>
<span class="dt">char</span> sa[maxn], sb[maxn];

<span class="kw">struct</span> State {
    <span class="dt">int</span> s1, s2, fa, ch;
} states[maxq];
<span class="dt">int</span> ns;

<span class="dt">void</span> print_solution(<span class="dt">int</span> s) {
    <span class="kw">if</span>(states[s].fa == <span class="dv">-1</span>) <span class="kw">return</span>;
    print_solution(states[s].fa);
    printf(<span class="st">&quot;</span><span class="ch">%c</span><span class="st">&quot;</span>, states[s].ch);
}

<span class="dt">void</span> solve(<span class="dt">const</span> NFA&amp; A, <span class="dt">const</span> NFA&amp; B) {
    queue&lt;<span class="dt">int</span>&gt; q;
    <span class="dt">int</span> vis[maxs][maxs];
    memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
    ns = <span class="dv">0</span>;
    REP(i, A.ss.size())
        REP(j, B.ss.size()) {
            <span class="dt">int</span> s1 = A.ss[i], s2 = B.ss[j];
            states[ns].s1 = s1;
            states[ns].s2 = s2;
            states[ns].fa = <span class="dv">-1</span>;
            q.push(ns++);
        }

    <span class="kw">while</span>(!q.empty()) {
        <span class="dt">int</span> s = q.front(); q.pop();
        <span class="dt">int</span> s1 = states[s].s1;
        <span class="dt">int</span> s2 = states[s].s2;
        <span class="kw">if</span>(s1 == A.n<span class="dv">-1</span> &amp;&amp; s2 == B.n<span class="dv">-1</span> &amp;&amp; states[s].fa != <span class="dv">-1</span>) {
            printf(<span class="st">&quot;Wrong</span><span class="ch">\n</span><span class="st">&quot;</span>);
            print_solution(s);
            printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
            <span class="kw">return</span>;
        }
        <span class="dt">int</span> n1 = A.trans[s1].size();
        <span class="dt">int</span> n2 = B.trans[s2].size();

        REP(i, n1) REP(j, n2)
            <span class="kw">if</span>(A.trans[s1][i].ch == B.trans[s2][j].ch) {
                <span class="dt">int</span> s1b = A.trans[s1][i].next;
                <span class="dt">int</span> s2b = B.trans[s2][j].next;
                <span class="dt">int</span> c = A.trans[s1][i].ch;
                <span class="kw">if</span>(vis[s1b][s2b]) <span class="kw">continue</span>;
                vis[s1b][s2b] = <span class="dv">1</span>;
                states[ns].s1 = s1b;
                states[ns].s2 = s2b;
                states[ns].fa = s;
                states[ns].ch = c;
                q.push(ns++);
            }
    }
    printf(<span class="st">&quot;Correct</span><span class="ch">\n</span><span class="st">&quot;</span>);
}

NFA A, B;
<span class="dt">int</span> main() {
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%s%s</span><span class="st">&quot;</span>, sa, sb) == <span class="dv">2</span>) {
        A.init(sa);
        B.init(sb);
        A.remove_epsilon();
        B.remove_epsilon();
        solve(A, B);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>12-3 UVa1673 str2int ch12/UVa1673.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1673 str2int</span>
<span class="co">// Rujia Liu</span>
<span class="co">//</span>
<span class="co">// This is Problem 12-3 of &lt;&lt;Beginning Algorithm Contests&gt;&gt; 2nd edition</span>
<span class="co">//</span>
<span class="co">// Note that we&#39;re using the &quot;big string method&quot;, as explained in the book.</span>
<span class="co">// It&#39;s slightly less efficient than the official &quot;multiple string DAWG&quot; because we need to explicitly store &#39;$&#39; edges.</span>
<span class="co">// However, it&#39;s conceptually cleaner, and easier to understand.</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxc = <span class="dv">11</span>; <span class="co">// 10 digits and &#39;$&#39;</span>
<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100000</span> + <span class="dv">10</span>;

<span class="kw">struct</span> DAWG {
    <span class="kw">struct</span> Node {
        Node *fa, *next[maxc];
        <span class="dt">int</span> len;
        <span class="dt">int</span> id, pos;
        Node(){}
        Node(<span class="dt">int</span> len):fa(<span class="dv">0</span>),len(len){
            memset(next, <span class="dv">0</span>, <span class="kw">sizeof</span>(next));
        }
    };

    Node node[maxn*<span class="dv">2</span>], *root, *last;
    <span class="dt">int</span> tot;

    Node *newnode(<span class="dt">const</span> Node&amp; u) {
        node[tot] = u;
        node[tot].id = tot;
        <span class="kw">return</span> &amp;node[tot++];
    }
    Node* newnode(<span class="dt">int</span> len) { <span class="kw">return</span> newnode(Node(len)); }
    Node* newnode(Node *p) { <span class="kw">return</span> newnode(*p); }

    <span class="dt">void</span> init() {
        tot = <span class="dv">0</span>;
        root = last = newnode(<span class="dv">0</span>);
        node.pos = <span class="dv">0</span>;
    }

    <span class="dt">void</span> add(<span class="dt">int</span> x,<span class="dt">int</span> len) {
        Node *p = last, *np = newnode(p-&gt;len + <span class="dv">1</span>);
        np-&gt;pos = len;
        last = np;
        <span class="kw">for</span>(; p &amp;&amp; !p-&gt;next[x];p = p-&gt;fa)
            p-&gt;next[x] = np;
        <span class="kw">if</span>(!p) { np-&gt;fa = root; <span class="kw">return</span>; }

        Node *q = p-&gt;next[x];
        <span class="kw">if</span>(q-&gt;len == p-&gt;len + <span class="dv">1</span>) { np-&gt;fa = q; <span class="kw">return</span>; }

        Node *nq = newnode(q);
        nq-&gt;len = p-&gt;len + <span class="dv">1</span>;
        q-&gt;fa = nq;
        np-&gt;fa = nq;
        <span class="kw">for</span>(; p &amp;&amp; p-&gt;next[x] == q; p = p-&gt;fa)
            p-&gt;next[x] = nq;
    }
};


<span class="co">/////// problem related</span>

<span class="dt">const</span> <span class="dt">int</span> MOD = <span class="dv">2012</span>;

<span class="dt">char</span> s[maxn];
<span class="dt">int</span> topo[maxn*<span class="dv">2</span>], topocnt[maxn*<span class="dv">2</span>], sum[maxn*<span class="dv">2</span>], cnt[maxn*<span class="dv">2</span>];
DAWG g;

<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span>) {
        g.init();
        <span class="dt">int</span> totlen = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, s);
            <span class="dt">int</span> len = strlen(s);
            <span class="kw">if</span>(i &gt; <span class="dv">0</span>) g.add(<span class="dv">10</span>, ++totlen); <span class="co">// $</span>
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; len; j++) {
                g.add(s[j] - <span class="st">&#39;0&#39;</span>, ++totlen); <span class="co">// regular edges</span>
            }
        }

        <span class="co">// topology sort</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= totlen; i++)
            topocnt[i] = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; g.tot; i++)
            topocnt[g.node[i].len]++;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= totlen; i++)
            topocnt[i] += topocnt[i<span class="dv">-1</span>];
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; g.tot; i++)
            topo[--topocnt[g.node[i].len]] = i;

        <span class="dt">int</span> ans = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; g.tot; i++)
            cnt[i] = sum[i] = <span class="dv">0</span>;
        cnt = <span class="dv">1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; g.tot; i++) {
            <span class="dt">int</span> fa = topo[i];
            DAWG::Node* u = &amp;g.node[fa];
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">10</span>; j++) {
                <span class="kw">if</span>(i == <span class="dv">0</span> &amp;&amp; j == <span class="dv">0</span>) <span class="kw">continue</span>;
                <span class="kw">if</span>(u-&gt;next[j]) {
                    <span class="dt">int</span> son = u-&gt;next[j]-&gt;id;
                    cnt[son] = (cnt[son] + cnt[fa]) % MOD;
                    sum[son] = (sum[son] + sum[fa]*<span class="dv">10</span> + cnt[fa]*j) % MOD;
                }
            }
            ans = (ans + sum[fa]) % MOD;
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>12-7 UVa12538 Version Controlled IDE ch12/UVa12538_rope.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12538 Version Controlled IDE</span>
<span class="co">// Rujia Liu</span>
<span class="co">// This code makes use of rope, a persistent string available in gcc&#39;s STL extensions.</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;ext/rope&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="kw">using</span> <span class="kw">namespace</span> __gnu_cxx;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">50000</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> maxlen = <span class="dv">100000</span> + <span class="dv">5</span>;

crope cur, versions[maxn];
<span class="dt">char</span> s[maxlen];

<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n); <span class="co">// a single test case</span>
    <span class="dt">int</span> d = <span class="dv">0</span>;
    <span class="dt">int</span> vnow = <span class="dv">0</span>;
    <span class="kw">while</span>(n--) {
        <span class="dt">int</span> op, p, c, v;
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;op);
        <span class="kw">if</span>(op == <span class="dv">1</span>) {
            scanf(<span class="st">&quot;</span><span class="ch">%d%s</span><span class="st">&quot;</span>, &amp;p, s);
            p -= d;
            cur.insert(p, s);
            versions[++vnow] = cur;
        }
        <span class="kw">else</span> <span class="kw">if</span>(op == <span class="dv">2</span>) {
            scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;p, &amp;c);
            p -= d; c -= d;
            cur.erase(p<span class="dv">-1</span>, c);
            versions[++vnow] = cur;
        }
        <span class="kw">else</span> {
            scanf(<span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, &amp;v, &amp;p, &amp;c);
            p -= d; v -= d; c -= d;
            crope r = versions[v].substr(p<span class="dv">-1</span>, c);
            d += count(r.begin(), r.end(), <span class="st">&#39;c&#39;</span>);
            cout &lt;&lt; r &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
<dt>&#9986;&#65039; Bonus Problems <code class="fold">@</code></dt>
<dd><dl>
<dt><a href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Bresenham&#8217;s line algorithm - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p>Bresenham&#8217;s line algorithm is named after Jack Elton Bresenham who developed it in 1962 at IBM.</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ab/Bresenham.svg/300px-Bresenham.svg.png" />

</div>
<p><span class="math display">\[{\frac {y-y_{0}}{y_{1}-y_{0}}}={\frac {x-x_{0}}{x_{1}-x_{0}}}.\]</span></p>
<pre><code>function line(x0, y0, x1, y1)
    real deltax := x1 - x0
    real deltay := y1 - y0
    real error := -1.0
    real deltaerr := abs(deltay / deltax)       // Assume deltax != 0 (line is not vertical),
                                                // note that this division needs to be done in a way that preserves the fractional part
    int y := y0
    for x from x0 to x1-1
        plot(x,y)
        error := error + deltaerr
        if error &#8805; 0.0 then
            y := y + 1
            error := error - 1.0

+----------+                            +--------------+
| y = f(x) |                            | f(x, y) = 0  |
+----------+                            +--------------+
                                                                    A = dy
y       = f(x) = mx + b                                             B = dx
        = (dy/dx)x + b                                              C = dx*b
dx*y    = dy*x + dx*b
0       = dy*x - dx*y + dx*b            f(x,y)  = 0 = Ax + By + C

+------+
| e.g. |
+------+

y = 0.5 * x +1                          f(x, y) = x - 2y + 2</code></pre>
<p>starting point: f(x0, y0) = 0</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/14/Line_1.5x%2B1_--_candidates.svg/300px-Line_1.5x%2B1_--_candidates.svg.png" />

</div>
<pre><code>(x0+1, y0), (x0+1, y0+1)  ----- mid point : D = f(x0+1, y0+0.5)
                                            D &lt; 0   ---&gt;    go right
                                            D &gt; 0   ---&gt;    go down</code></pre>
<p>if D is positive, then choose ( x 0 + 1 , y 0 + 1 ), otherwise choose ( x 0 + 1 , y 0 ).</p>
<p>Alternatively, the difference between points can be used instead of evaluating f(x,y) at midpoints. This alternative method allows for integer-only arithmetic, which is generally faster than using floating-point arithmetic. To derive the alternative method, define the difference to be as follows:</p>
<pre><code>D = f(x0+1, y0+0.5) - f(x0, y0) = A(x0+1-x0) + B(y0+0.5-y0)
  = A + 0.5*B
           if    &lt;   0 ----------&gt;  (x0, y0)
           if    &gt;   0 ----------&gt;  (x0, y0+1)

plotLine(x0,y0, x1,y1)
    dx = x1 - x0
    dy = y1 - y0
    D = dy - dx
    y = y0

    for x from x0 to x1-1
        plot(x,y)
        if D &#8805; 0
            y = y + 1
            D = D - dx
        D = D + dy</code></pre>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Line_1.5x%2B1_--_points.svg/300px-Line_1.5x%2B1_--_points.svg.png" />

</div>
<p>However, as mentioned above this is only for the first octant. This means there are eight possible cases to consider. The simplest way to extend the same algorithm, if implemented in hardware, is to flip the co-ordinate system on the input and output of the single-octant drawer.</p>
<pre><code> Octants:
  \2|1/
  3\|/0
 ---+---
  4/|\7
  /5|6\</code></pre>
<dl>
<dt><a href="https://en.wikipedia.org/wiki/Octant_(plane_geometry)">Octant (plane geometry) - Wikipedia, the free encyclopedia</a></dt>
<dd><div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bb/Windrose.svg/150px-Windrose.svg.png" alt="An 8-point windrose" />
<p class="caption">An 8-point windrose</p>
</div>
</dd>
<dt><a href="https://en.wikipedia.org/wiki/Orthant">Orthant - Wikipedia, the free encyclopedia</a></dt>
<dd><div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1a/Cartesian_coordinates_2D.svg/220px-Cartesian_coordinates_2D.svg.png" alt="In two dimensions, there are 4 orthants (called quadrants)" />
<p class="caption">In two dimensions, there are 4 orthants (called quadrants)</p>
</div>
</dd>
</dl>
</dd>
<dt><a href="https://leetcode.com/problems/rotate-image/">Rotate Image | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>&#22797;&#21046;&#22826;&#24930;&#65281;&#29992;&#20004;&#27425;&#32763;&#25240;&#65292;&#22914;&#19979;&#22270;&#65306;</p>
<pre><code>&#20808;&#21103;&#23545;&#35282;&#32447;&#65292;&#22312;&#20013;&#32447;
1   2               4   2               3   1
  /         --&gt;      ---        ---&gt;
3   4               3   1               4   2
(i,j)
i=[0,n-1)       P(i,j)-&gt;P(n-1-j,n-1-i)
j=[0,n-1-i)

&#20808;&#20013;&#32447;&#65292;&#20877;&#20027;&#23545;&#35282;&#32447;
1   2               3   4               3   1
 ---        --&gt;       \         ---&gt;
3   4               1   2               4   2</code></pre>
<p>&#30475;&#26469;&#24590;&#20040;&#32763;&#25240;&#37117;&#26159;&#21487;&#20197;&#24471;&#12290;&#33258;&#24049;&#38543;&#24847;&#36873;&#25321;&#25226;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Rotate Image</span>
<span class="ot">#define REP(i, n) for (int i = 0; i &lt; (n); i++)</span>

<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">void</span> rotate(vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; &amp;a) {
        <span class="dt">int</span> n = a.size();
        REP(i, n<span class="dv">-1</span>)
            REP(j, n<span class="dv">-1</span>-i)
            swap(a[i][j], a[n<span class="dv">-1</span>-j][n<span class="dv">-1</span>-i]);
        REP(i, n/<span class="dv">2</span>)
            swap_ranges(a[i].begin(), a[i].end(), a[n<span class="dv">-1</span>-i].begin());
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/gray-code/">Gray Code | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>
<p>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:</p>
<pre><code>00 - 0
01 - 1
11 - 3
10 - 2</code></pre>
<p>&#33258;&#28982;&#20108;&#36827;&#21046;&#30721;&#36716;&#25442;&#20026;&#26684;&#38647;&#30721;&#65306;g<sub>0</sub> = b<sub>0</sub>, g<sub>i</sub>=b<sub>i</sub> ^ b<sub>i-1</sub></p>
<p>&#20445;&#30041;&#33258;&#28982;&#20108;&#36827;&#21046;&#30721;&#30340;&#26368;&#39640;&#20301;&#20316;&#20026;&#26684;&#38647;&#30721;&#30340;&#26368;&#39640;&#20301;&#65292;&#26684;&#38647;&#30721;&#27425;&#39640;&#20301;&#20026;&#20108;&#36827;&#21046;&#30721;&#30340;&#39640;&#20301;&#19982;&#27425;&#39640;&#20301;&#24322;&#25110;&#65292;&#20854;&#20313;&#21508;&#20301;&#19982;&#27425;&#39640;&#20301;&#30340;&#27714;&#27861;&#31867;&#20284;&#12290;&#20363;&#22914;&#65292;&#23558;&#33258;&#28982;&#20108;&#36827;&#21046;&#30721; 1001&#65292;&#36716;&#25442;&#20026;&#26684;&#38647;&#30721;&#30340;&#36807;&#31243;&#26159;&#65306;&#20445;&#30041;&#26368;&#39640;&#20301;&#65307;&#28982;&#21518;&#23558;&#31532; 1 &#20301;&#30340; 1 &#21644;&#31532; 2 &#20301;&#30340; 0 &#24322;&#25110;&#65292;&#24471;&#21040; 1&#65292;&#20316;&#20026;&#26684;&#38647;&#30721;&#30340;&#31532; 2 &#20301;&#65307;&#23558;&#31532; 2 &#20301;&#30340; 0 &#21644;&#31532; 3 &#20301;&#30340; 0 &#24322;&#25110;&#65292;&#24471;&#21040; 0&#65292;&#20316;&#20026;&#26684;&#38647;&#30721;&#30340;&#31532; 3 &#20301;&#65307;&#23558;&#31532; 3 &#20301;&#30340; 0 &#21644;&#31532; 4 &#20301;&#30340; 1 &#24322;&#25110;&#65292;&#24471;&#21040; 1&#65292;&#20316;&#20026;&#26684;&#38647;&#30721;&#30340;&#31532; 4 &#20301;&#65292;&#26368;&#32456;&#65292;&#26684;&#38647;&#30721;&#20026; 1101&#12290;</p>
<p>&#26684;&#38647;&#30721;&#26377;&#25968;&#23398;&#20844;&#24335;&#65292;<strong>&#25972;&#25968; n &#30340;&#26684;&#38647;&#30721;&#26159; n ^ (n/2)</strong>&#12290;</p>
<p>&#36825;&#39064;&#35201;&#27714;&#29983;&#25104; n &#27604;&#29305;&#30340;&#25152;&#26377;&#26684;&#38647;&#30721;&#12290;</p>
<ul>
<li>&#26041;&#27861; 1&#65292;&#26368;&#31616;&#21333;&#30340;&#26041;&#27861;&#65292;&#21033;&#29992;&#25968;&#23398;&#20844;&#24335;&#65292;&#23545;&#20174; 0..2<sup>n-1</sup> &#30340;&#25152;&#26377;&#25972;&#25968;&#65292;&#36716;&#21270;&#20026;&#26684;&#38647;&#30721;&#12290;</li>
<li>&#26041;&#27861; 2&#65292;n &#27604;&#29305;&#30340;&#26684;&#38647;&#30721;&#65292;&#21487;&#20197;&#36882;&#24402;&#22320;&#20174; n-1 &#27604;&#29305;&#30340;&#26684;&#38647;&#30721;&#29983;&#25104;&#12290;</li>
</ul>
<p>For a given n, a gray code sequence is <strong>not uniquely defined</strong>. &#39318;&#20808;&#65292;&#26684;&#38647;&#30721;&#19981;&#26159;&#21807;&#19968;&#30340;&#12290;&#23427;&#26159;&#19968;&#20010; sequence&#65292;&#26377; 2<sup>n</sup> &#20010;&#25968;&#23383;&#12290;&#27599;&#20010;&#25968;&#23383;&#65292;&#20381;&#27425;&#65292;&#21482;&#25913;&#21464;&#19968;&#20010; bit&#12290;</p>
<p>For example, <code>[0,2,3,1]</code> is also a valid gray code sequence according to the above definition.</p>
<p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p>
<p>see more at <a href="https://en.wikipedia.org/wiki/Gray_code">Gray code - Wikipedia, the free encyclopedia</a>.</p>
<p>&#30452;&#25509;&#29992;&#20844;&#24335;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#26102;&#38388;&#22797;&#26434;&#24230; O(2^n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(2^n)</span>
<span class="ot">#define FOR(i, a, b) for (decltype(b) i = (a); i &lt; (b); i++)        </span><span class="co">// for,     [a, b)</span>
<span class="ot">#define REP(i, n) FOR(i, 0, n)                                      </span><span class="co">// repeat,  [0, n)</span>

<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    vector&lt;<span class="dt">int</span>&gt; grayCode(<span class="dt">int</span> n) {
        <span class="dt">int</span> size = <span class="dv">1</span> &lt;&lt; n;
        vector&lt;<span class="dt">int</span>&gt; r(size);
        REP(i, size)
            r[i] = i^i&gt;&gt;<span class="dv">1</span>;      <span class="co">// n ^ (n/2)</span>
        <span class="kw">return</span> r;
    }
};</code></pre></div>
<p>reflect and prefix &#27861;&#65306;TODO</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c1/Binary-reflected_Gray_code_construction.svg/250px-Binary-reflected_Gray_code_construction.svg.png" alt="The first few steps of the reflect-and-prefix method." />
<p class="caption">The first few steps of the reflect-and-prefix method.</p>
</div>
<pre><code>&#24102; * &#30340;&#26159;&#27599;&#27425;&#26032;&#21152;&#20837;&#30340;&#20803;&#32032;&#12290;

        n=1     n=2     n=3
   *0   0       00      000
       *1       01      001
               *11      011
               *10      010
                       *110
                       *111
                       *101
                       *100</code></pre>
<p>// reflect-and-prefix method // &#26102;&#38388;&#22797;&#26434;&#24230; O(2^n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(1) class Solution { public: vector<int> grayCode(int n) { vector<int> result; result.reserve(1&lt;&lt;n); result.push_back(0); for (int i = 0; i &lt; n; i++) { const int highest_bit = 1 &lt;&lt; i; for (int j = result.size() - 1; j &gt;= 0; j&#8211;) // &#35201;&#21453;&#30528;&#36941;&#21382;&#65292;&#25165;&#33021;&#23545;&#31216;&#65292;&#36941;&#21382;&#23436;&#21518;&#65292;&#23610;&#23544;&#21152;&#20493; result.push_back(highest_bit | result[j]); // &#25226; 0 &#35843;&#25972;&#25104; 1 } return result; } }; ```</p>
</dd>
<dt><a href="https://leetcode.com/problems/single-number/">Single Number | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p><strong>&#20598;&#25968;&#27425;&#24322;&#25110;&#31561;&#20110; 0&#12290;0 &#24322;&#25110; x &#31561;&#20110; x&#12290;</strong>&#65288;&#36825;&#20010;&#32467;&#35770;&#22826;&#37325;&#35201;&#65281;&#65289;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> singleNumber(vector&lt;<span class="dt">int</span>&gt; &amp;a) {
        <span class="kw">return</span> accumulate(a.begin(), a.end(), <span class="dv">0</span>, bit_xor&lt;<span class="dt">int</span>&gt;());
    }
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> singleNumber(vector&lt;<span class="dt">int</span>&gt;&amp; nums) {
        <span class="dt">int</span> x = <span class="dv">0</span>;
        <span class="kw">for</span> (<span class="kw">auto</span> i : nums) {
            x ^= i;
        }
        <span class="kw">return</span> x;
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/single-number-ii/">Single Number II | LeetCode OJ</a> &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#21482;&#26377;&#19968;&#27425;&#25968;&#21482;&#20986;&#29616;&#20102;&#19968;&#27425;&#65292;&#20854;&#20313;&#37117;&#26159;&#19977;&#27425;&#12290;</p>
<p>&#26041;&#27861;1&#65306;&#21019;&#24314;&#19968;&#20010;&#38271;&#24230;&#20026; sizeof(int) &#30340;&#25968;&#32452; <code>count[sizeof(int)]</code>&#65292;<code>count[i]</code> &#34920;&#31034;&#22312; i &#20301;&#20986;&#29616;&#30340; 1 &#30340;&#27425;&#25968;&#12290;&#22914;&#26524; count[i] &#26159; 3 &#30340;&#25972;&#25968;&#20493;&#65292;&#21017;&#24573;&#30053;&#65307;&#21542;&#21017;&#23601;&#25226;&#35813;&#20301;&#21462;&#20986;&#26469;&#32452;&#25104;&#31572;&#26696;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define FOR(i, a, b) for (decltype(b) i = (a); i &lt; (b); i++)</span>
<span class="ot">#define REP(i, n) FOR(i, 0, n)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> singleNumber(vector&lt;<span class="dt">int</span>&gt; &amp;a) {
        vector&lt;<span class="dt">int</span>&gt; c(<span class="dv">32</span>);
        <span class="kw">for</span> (<span class="dt">int</span> x: a)
            REP(j, <span class="dv">32</span>)
                c[j] += x&gt;&gt;j &amp; <span class="dv">1</span>;
        <span class="dt">int</span> r = <span class="dv">0</span>;
        REP(j, <span class="dv">32</span>)
            r |= ( c[j]%<span class="dv">3</span> &amp; <span class="dv">1</span> ) &lt;&lt; j;
        <span class="kw">return</span> r;
    }
};</code></pre></div>
<p>&#26041;&#27861; 2&#65306;&#29992; one &#35760;&#24405;&#21040;&#24403;&#21069;&#22788;&#29702;&#30340;&#20803;&#32032;&#20026;&#27490;&#65292;&#20108;&#36827;&#21046; 1 &#20986;&#29616;&#8220;1 &#27425;&#8221;&#65288;mod 3 &#20043;&#21518;&#30340;1&#65289;&#30340;&#26377;&#21738;&#20123;&#20108;&#36827;&#21046;&#20301;&#65307;&#29992; two &#35760;&#24405;&#21040;&#24403;&#21069;&#35745;&#31639;&#30340;&#21464;&#37327;&#20026;&#27490;&#65292;&#20108;&#36827;&#21046; 1 &#20986;&#29616;&#8220;2 &#27425;&#8221;&#65288;mod 3 &#20043;&#21518;&#30340; 2&#65289;&#30340;&#26377;&#21738;&#20123;&#20108;&#36827;&#21046;&#20301;&#12290;&#24403; one &#21644; two &#20013;&#30340;&#26576;&#19968;&#20301;&#21516;&#26102;&#20026; 1 &#26102;&#34920;&#31034;&#35813;&#20108;&#36827;&#21046;&#20301;&#19978; 1 &#20986;&#29616;&#20102; 3 &#27425;&#65292;&#27492;&#26102;&#38656;&#35201;&#28165;&#38646;&#12290;&#21363;<strong>&#29992;&#20108;&#36827;&#21046;&#27169;&#25311;&#19977;&#36827;&#21046;&#36816;&#31639;</strong>&#12290;&#26368;&#32456; one &#35760;&#24405;&#30340;&#26159;&#26368;&#32456;&#32467;&#26524;&#12290;</p>
<p>&#65288;&#38590;&#20197;&#29702;&#35299;&#8230;&#8230;&#65289;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> singleNumber(vector&lt;<span class="dt">int</span>&gt; &amp;a) {
        <span class="dt">int</span> one = <span class="dv">0</span>, two = <span class="dv">0</span>;
        <span class="kw">for</span> (<span class="dt">int</span> x: a) {
            one = (one ^ x) &amp; ~ two;
            two = (two ^ x) &amp; ~ one;
        }
        <span class="kw">return</span> one;
    }
};</code></pre></div>
<pre><code>[1, 3, 3, 2, 1, 3, 1]                           one = (one ^ x) &amp; ~ two;
x           one             two                 two = (two ^ x) &amp; ~ one;
            0000,0000       0000,0000

0000,0001   0000,0001
            &amp;
            1111,1111

0000,0001   1111,1111       0000,0001
                            &amp;
                            0000,0000

0000,0001   1111,1111       0000,0001
3</code></pre>
</dd>
<dt>Shift right <code class="fold">@</code></dt>
<dd><p>from acm-cheatsheet/Functionalities</p>
</dd>
<dt>Big Integer <code class="fold">@</code></dt>
<dd><ul>
<li>addition</li>
<li>subtraction</li>
<li>multiplication</li>
<li>division</li>
<li>power</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> BigInteger {
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> BASE = <span class="dv">100000000</span>;
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> WIDTH = <span class="dv">8</span>;
    vector&lt;<span class="dt">int</span>&gt; s;

    BigInteger(<span class="dt">long</span> <span class="dt">long</span> num = <span class="dv">0</span>) { *<span class="kw">this</span> = num; }          <span class="co">// &#26500;&#36896;&#20989;&#25968;</span>
    BigInteger <span class="kw">operator</span> = (<span class="dt">long</span> <span class="dt">long</span> num) {                 <span class="co">// &#36171;&#20540;&#36816;&#31639;&#31526;</span>
        s.clear();
        <span class="kw">do</span> {
            s.push_back(num % BASE);
            num /= BASE;
        } <span class="kw">while</span>(num &gt; <span class="dv">0</span>);
        <span class="kw">return</span> *<span class="kw">this</span>;
    }
    BigInteger <span class="kw">operator</span> = (<span class="dt">const</span> string&amp; str) {             <span class="co">// &#36171;&#20540;&#36816;&#31639;&#31526;</span>
        s.clear();
        <span class="dt">int</span> x, len = (str.length() - <span class="dv">1</span>) / WIDTH + <span class="dv">1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len; i++) {
            <span class="dt">int</span> end = str.length() - i*WIDTH;
            <span class="dt">int</span> start = max(<span class="dv">0</span>, end - WIDTH);
            sscanf(str.substr(start, end-start).c_str(), <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;x);
            s.push_back(x);
        }
        <span class="kw">return</span> *<span class="kw">this</span>;
    }
    BigInteger <span class="kw">operator</span> + (<span class="dt">const</span> BigInteger&amp; b) <span class="dt">const</span> {
        BigInteger c;
        c.s.clear();
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>, g = <span class="dv">0</span>; ; i++) {
            <span class="kw">if</span>(g == <span class="dv">0</span> &amp;&amp; i &gt;= s.size() &amp;&amp; i &gt;= b.s.size()) <span class="kw">break</span>;
            <span class="dt">int</span> x = g;
            <span class="kw">if</span>(i &lt; s.size()) x += s[i];
            <span class="kw">if</span>(i &lt; b.s.size()) x += b.s[i];
            c.s.push_back(x % BASE);
            g = x / BASE;
        }
        <span class="kw">return</span> c;
    }
};

ostream&amp; <span class="kw">operator</span> &lt;&lt; (ostream &amp;out, <span class="dt">const</span> BigInteger&amp; x) {
    out &lt;&lt; x.s.back();
    <span class="kw">for</span>(<span class="dt">int</span> i = x.s.size()<span class="dv">-2</span>; i &gt;= <span class="dv">0</span>; i--) {
        <span class="dt">char</span> buf;
        sprintf(buf, <span class="st">&quot;</span><span class="ch">%08d</span><span class="st">&quot;</span>, x.s[i]);
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; strlen(buf); j++) out &lt;&lt; buf[j];
    }
    <span class="kw">return</span> out;
}

istream&amp; <span class="kw">operator</span> &gt;&gt; (istream &amp;in, BigInteger&amp; x) {
    string s;
    <span class="kw">if</span>(!(in &gt;&gt; s)) <span class="kw">return</span> in;
    x = s;
    <span class="kw">return</span> in;
}

<span class="ot">#include&lt;set&gt;</span>
<span class="ot">#include&lt;map&gt;</span>
set&lt;BigInteger&gt; s;
map&lt;BigInteger, <span class="dt">int</span>&gt; m;

<span class="dt">int</span> main() {
    BigInteger y;
    BigInteger x = y;
    BigInteger z = <span class="dv">123</span>;

    BigInteger a, b;
    cin &gt;&gt; a &gt;&gt; b;
    cout &lt;&lt; a + b &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    cout &lt;&lt; BigInteger::BASE &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
<dt>AOAPC &#20195;&#30721;&#36873;&#35762; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#38384;&#24180; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;stdio.h&gt;</span>
<span class="dt">int</span> main() {
    <span class="dt">int</span> year;
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;year );
    <span class="kw">if</span>( year % <span class="dv">4</span> != <span class="dv">0</span> || (year % <span class="dv">100</span> == <span class="dv">0</span> &amp;&amp; year % <span class="dv">400</span> != <span class="dv">0</span>) ) {
        printf( <span class="st">&quot;no</span><span class="ch">\n</span><span class="st">&quot;</span> );
    } <span class="kw">else</span> {
        printf(<span class="st">&quot;yes</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>6-1 UVa210 &#24182;&#34892;&#31243;&#24207;&#27169;&#25311;&#65292;Concurrency Simulator ch6/UVa210.cpp <code class="fold">@</code></dt>
<dd><p>&#27169;&#25311; n &#20010;&#31243;&#24207;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa210 Concurrency Simulator</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;cctype&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1000</span>;

deque&lt;<span class="dt">int</span>&gt; readyQ;
queue&lt;<span class="dt">int</span>&gt; blockQ;
<span class="dt">int</span> n, quantum, c, var, ip[maxn];                        <span class="co">// ip[pid] &#26159;&#31243;&#24207; pid &#30340;&#24403;&#21069;&#34892;&#21495;&#12290;&#25152;&#26377;&#31243;&#24207;&#37117;&#23384;&#22312; prog &#25968;&#32452;&#65292;&#26356;&#31867;&#20284;&#30495;&#23454;&#30340;&#24773;&#20917;&#65292;&#20195;&#30721;&#20063;&#26356;&#30701;</span>
<span class="dt">bool</span> locked;
<span class="dt">char</span> prog[maxn];

<span class="dt">void</span> run(<span class="dt">int</span> pid) {
    <span class="dt">int</span> q = quantum;
    <span class="kw">while</span>(q &gt; <span class="dv">0</span>) {
        <span class="dt">char</span> *p = prog[ip[pid]];
        <span class="kw">switch</span>(p) {
            <span class="kw">case</span> <span class="st">&#39;=&#39;</span>:
                var[p - <span class="st">&#39;a&#39;</span>] = isdigit(p) ? (p - <span class="st">&#39;0&#39;</span>) * <span class="dv">10</span> + p - <span class="st">&#39;0&#39;</span> : p - <span class="st">&#39;0&#39;</span>;
                q -= c;
                <span class="kw">break</span>;
            <span class="kw">case</span> <span class="st">&#39;i&#39;</span>: <span class="co">// print</span>
                printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">: </span><span class="ch">%d\n</span><span class="st">&quot;</span>, pid<span class="dv">+1</span>, var[p - <span class="st">&#39;a&#39;</span>]);
                q -= c;
                <span class="kw">break</span>;
            <span class="kw">case</span> <span class="st">&#39;c&#39;</span>: <span class="co">// lock</span>
                <span class="kw">if</span>(locked) { blockQ.push(pid); <span class="kw">return</span>; }
                locked = <span class="kw">true</span>;
                q -= c;
                <span class="kw">break</span>;
            <span class="kw">case</span> <span class="st">&#39;l&#39;</span>: <span class="co">// unlock</span>
                locked = <span class="kw">false</span>;
                <span class="kw">if</span>(!blockQ.empty()) {
                    <span class="dt">int</span> pid2 = blockQ.front(); blockQ.pop();
                    readyQ.push_front(pid2);
                }
                q -= c;
                <span class="kw">break</span>;
            <span class="kw">case</span> <span class="st">&#39;d&#39;</span>: <span class="co">// end</span>
                <span class="kw">return</span>;
        }
        ip[pid]++;
    }
    readyQ.push_back(pid);
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>, &amp;n, &amp;c, &amp;c, &amp;c, &amp;c, &amp;c, &amp;quantum);
        memset(var, <span class="dv">0</span>, <span class="kw">sizeof</span>(var));

        <span class="dt">int</span> line = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            fgets(prog[line++], maxn, stdin);
            ip[i] = line - <span class="dv">1</span>;
            <span class="kw">while</span>(prog[line - <span class="dv">1</span>] != <span class="st">&#39;d&#39;</span>)
                fgets(prog[line++], maxn, stdin);
            readyQ.push_back(i);
        }

        locked = <span class="kw">false</span>;
        <span class="kw">while</span>(!readyQ.empty()) {
            <span class="dt">int</span> pid = readyQ.front(); readyQ.pop_front();
            run(pid);
        }
        <span class="kw">if</span>(T) printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>6-2 UVa514 Rails ch6/UVa514.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa514 Rails</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;stack&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="dt">const</span> <span class="dt">int</span> MAXN = <span class="dv">1000</span> + <span class="dv">10</span>;

<span class="dt">int</span> n, target[MAXN];

<span class="dt">int</span> main() {
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n) == <span class="dv">1</span>) {
        stack&lt;<span class="dt">int</span>&gt; s;
        <span class="dt">int</span> A = <span class="dv">1</span>, B = <span class="dv">1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++)
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;target[i]);
        <span class="dt">int</span> ok = <span class="dv">1</span>;
        <span class="kw">while</span>(B &lt;= n) {
            <span class="kw">if</span>(A == target[B]){ A++; B++; }
            <span class="kw">else</span> <span class="kw">if</span>(!s.empty() &amp;&amp; s.top() == target[B]){ s.pop(); B++; }
            <span class="kw">else</span> <span class="kw">if</span>(A &lt;= n) s.push(A++);
            <span class="kw">else</span> { ok = <span class="dv">0</span>; <span class="kw">break</span>; }
        }
        printf(<span class="st">&quot;</span><span class="ch">%s\n</span><span class="st">&quot;</span>, ok ? <span class="st">&quot;Yes&quot;</span> : <span class="st">&quot;No&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>6-3 UVa442 Matrix Chain Multiplication ch6/UVa442.cpp <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa442 Matrix Chain Multiplication</span>
<span class="co">// Rujia Liu</span>
<span class="co">// &#39064;&#24847;&#65306;&#36755;&#20837;n&#20010;&#30697;&#38453;&#30340;&#32500;&#24230;&#21644;&#19968;&#20123;&#30697;&#38453;&#38142;&#20056;&#34920;&#36798;&#24335;&#65292;&#36755;&#20986;&#20056;&#27861;&#30340;&#27425;&#25968;&#12290;&#20551;&#23450;A&#21644;m*n&#30340;&#65292;B&#26159;n*p&#30340;&#65292;&#37027;&#20040;AB&#26159;m*p&#30340;&#65292;&#20056;&#27861;&#27425;&#25968;&#20026;m*n*p</span>
<span class="co">// &#31639;&#27861;&#65306;&#29992;&#19968;&#20010;&#26632;&#12290;&#36935;&#21040;&#23383;&#27597;&#26102;&#20837;&#26632;&#65292;&#21491;&#25324;&#21495;&#26102;&#20986;&#26632;&#24182;&#35745;&#31639;&#65292;&#28982;&#21518;&#32467;&#26524;&#20837;&#26632;&#12290;&#22240;&#20026;&#36755;&#20837;&#20445;&#35777;&#21512;&#27861;&#65292;&#25324;&#21495;&#26080;&#24207;&#20837;&#26632;</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;stack&gt;</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;string&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> Matrix {
    <span class="dt">int</span> a, b;
    Matrix(<span class="dt">int</span> a=<span class="dv">0</span>, <span class="dt">int</span> b=<span class="dv">0</span>):a(a),b(b) {}
} m;

stack&lt;Matrix&gt; s;

<span class="dt">int</span> main() {
    <span class="dt">int</span> n;
    cin &gt;&gt; n;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
        string name;
        cin &gt;&gt; name;
        <span class="dt">int</span> k = name - <span class="st">&#39;A&#39;</span>;
        cin &gt;&gt; m[k].a &gt;&gt; m[k].b;
    }
    string expr;
    <span class="kw">while</span>(cin &gt;&gt; expr) {
        <span class="dt">int</span> len = expr.length();
        <span class="dt">bool</span> error = <span class="kw">false</span>;
        <span class="dt">int</span> ans = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len; i++) {
            <span class="kw">if</span>(isalpha(expr[i])) s.push(m[expr[i] - <span class="st">&#39;A&#39;</span>]);
            <span class="kw">else</span> <span class="kw">if</span>(expr[i] == <span class="st">&#39;)&#39;</span>) {
                Matrix m2 = s.top(); s.pop();
                Matrix m1 = s.top(); s.pop();
                <span class="kw">if</span>(m1.b != m2.a) { error = <span class="kw">true</span>; <span class="kw">break</span>; }
                ans += m1.a * m1.b * m2.b;
                s.push(Matrix(m1.a, m2.b));
            }
        }
        <span class="kw">if</span>(error) printf(<span class="st">&quot;error</span><span class="ch">\n</span><span class="st">&quot;</span>); <span class="kw">else</span> printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans);
    }

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>6-4 UVa11988 Broken Keyboard <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa11988 Broken Keyboard</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100000</span> + <span class="dv">5</span>;
<span class="dt">int</span> last, cur, next[maxn]; <span class="co">// &#20809;&#26631;&#20301;&#20110;cur&#21495;&#23383;&#31526;&#20043;&#21518;&#38754;</span>
<span class="dt">char</span> s[maxn];

<span class="dt">int</span> main() {
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, s<span class="dv">+1</span>) == <span class="dv">1</span>) {
        <span class="dt">int</span> n = strlen(s<span class="dv">+1</span>); <span class="co">// &#36755;&#20837;&#20445;&#23384;&#22312;s, s...&#20013;</span>
        last = cur = <span class="dv">0</span>;
        next = <span class="dv">0</span>;

        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {
            <span class="dt">char</span> ch = s[i];
            <span class="kw">if</span>(ch == <span class="st">&#39;[&#39;</span>) cur = <span class="dv">0</span>;
            <span class="kw">else</span> <span class="kw">if</span>(ch == <span class="st">&#39;]&#39;</span>) cur = last;
            <span class="kw">else</span> {
                next[i] = next[cur];
                next[cur] = i;
                <span class="kw">if</span>(cur == last) last = i; <span class="co">// &#26356;&#26032;&#8220;&#26368;&#21518;&#19968;&#20010;&#23383;&#31526;&#8221;&#32534;&#21495;</span>
                cur = i; <span class="co">// &#31227;&#21160;&#20809;&#26631;</span>
            }
        }
        <span class="kw">for</span>(<span class="dt">int</span> i = next; i != <span class="dv">0</span>; i = next[i])
            printf(<span class="st">&quot;</span><span class="ch">%c</span><span class="st">&quot;</span>, s[i]);
        printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>6-5 UVa12657 Boxes in a Line ch6/UVa12657.cpp</dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa12657 Boxes in a Line</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100000</span> + <span class="dv">5</span>;
<span class="dt">int</span> n, left[maxn], right[maxn];

<span class="kw">inline</span> <span class="dt">void</span> link(<span class="dt">int</span> L, <span class="dt">int</span> R) {
    right[L] = R; left[R] = L;
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> m, kase = <span class="dv">0</span>;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m) == <span class="dv">2</span>) {
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {
            left[i] = i<span class="dv">-1</span>;
            right[i] = (i<span class="dv">+1</span>) % (n<span class="dv">+1</span>);
        }
        right = <span class="dv">1</span>; left = n;
        <span class="dt">int</span> op, X, Y, inv = <span class="dv">0</span>;

        <span class="kw">while</span>(m--) {
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;op);
            <span class="kw">if</span>(op == <span class="dv">4</span>) inv = !inv;
            <span class="kw">else</span> {
                scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;X, &amp;Y);
                <span class="kw">if</span>(op == <span class="dv">3</span> &amp;&amp; right[Y] == X) swap(X, Y);
                <span class="kw">if</span>(op != <span class="dv">3</span> &amp;&amp; inv) op = <span class="dv">3</span> - op;
                <span class="kw">if</span>(op == <span class="dv">1</span> &amp;&amp; X == left[Y]) <span class="kw">continue</span>;
                <span class="kw">if</span>(op == <span class="dv">2</span> &amp;&amp; X == right[Y]) <span class="kw">continue</span>;

                <span class="dt">int</span> LX = left[X], RX = right[X], LY = left[Y], RY = right[Y];
                <span class="kw">if</span>(op == <span class="dv">1</span>) {
                    link(LX, RX); link(LY, X); link(X, Y);
                }
                <span class="kw">else</span> <span class="kw">if</span>(op == <span class="dv">2</span>) {
                    link(LX, RX); link(Y, X); link(X, RY);
                }
                <span class="kw">else</span> <span class="kw">if</span>(op == <span class="dv">3</span>) {
                    <span class="kw">if</span>(right[X] == Y) { link(LX, Y); link(Y, X); link(X, RY); }
                    <span class="kw">else</span> { link(LX, Y); link(Y, RX); link(LY, X); link(X, RY); }
                }
            }
        }

        <span class="dt">int</span> b = <span class="dv">0</span>;
        <span class="dt">long</span> <span class="dt">long</span> ans = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++) {
            b = right[b];
            <span class="kw">if</span>(i % <span class="dv">2</span> == <span class="dv">1</span>) ans += b;
        }
        <span class="kw">if</span>(inv &amp;&amp; n % <span class="dv">2</span> == <span class="dv">0</span>) ans = (<span class="dt">long</span> <span class="dt">long</span>)n*(n<span class="dv">+1</span>)/<span class="dv">2</span> - ans;
        printf(<span class="st">&quot;Case </span><span class="ch">%d</span><span class="st">: </span><span class="ch">%lld\n</span><span class="st">&quot;</span>, ++kase, ans);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>6-6 UVa679 Dropping Balls UVa679.cpp <code class="fold">@</code></dt>
<dd><p>ch6, page148.</p>
<p>&#27599;&#20010;&#33410;&#28857;&#26377;&#19968;&#20010;&#24320;&#20851;&#65292;&#27599;&#27425;&#26377;&#23567;&#29699;&#36890;&#36807;&#65292;&#24320;&#20851; toggle&#12290;&#21021;&#22987;&#20026;&#21487;&#20197;&#21521;&#24038;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa679 Dropping Balls</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="dt">int</span> main() {
  <span class="dt">int</span> T, D, I;
  scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
  <span class="kw">while</span>(T--) {
    scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;D, &amp;I);
    <span class="dt">int</span> k = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; D<span class="dv">-1</span>; i++)
      <span class="kw">if</span>(I%<span class="dv">2</span>) { k = k*<span class="dv">2</span>; I = (I<span class="dv">+1</span>)/<span class="dv">2</span>; }
      <span class="kw">else</span> { k = k*<span class="dv">2+1</span>; I /= <span class="dv">2</span>; }
    printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, k);
  }
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>6-8 UVa548 Tree ch6/UVa548.cpp <code class="fold">@</code></dt>
<dd><p>ch6, page156.</p>
<p>&#39064;&#24847;&#65306;&#32473;&#19968;&#26869;&#28857;&#24102;&#26435;&#65288;&#26435;&#21508;&#19981;&#30456;&#21516;&#65292;&#37117;&#26159;&#27491;&#25972;&#25968;&#65289;&#20108;&#21449;&#26641;&#30340;&#20013;&#24207;&#21644;&#21518;&#24207;&#36941;&#21382;&#65292;&#25214;&#19968;&#20010;&#21494;&#23376;&#20351;&#24471;&#23427;&#21040;&#26681;&#30340;&#36335;&#24452;&#19978;&#30340;&#26435;&#21644;&#26368;&#23567;&#12290;&#22914;&#26524;&#26377;&#22810;&#35299;&#65292;&#35813;&#21494;&#23376;&#26412;&#36523;&#30340;&#26435;&#24212;&#23613;&#37327;&#23567;</p>
<p>&#31639;&#27861;&#65306;&#36882;&#24402;&#24314;&#26641;&#65292;&#28982;&#21518; DFS&#12290;&#27880;&#24847;&#65292;&#30452;&#25509;&#36882;&#24402;&#27714;&#32467;&#26524;&#20063;&#21487;&#20197;&#65292;&#20294;&#26159;&#20808;&#24314;&#26641;&#30340;&#26041;&#27861;&#19981;&#20165;&#30452;&#35266;&#65292;&#32780;&#19988;&#26356;&#22909;&#35843;&#35797;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa548 Tree</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;string&gt;</span>
<span class="ot">#include&lt;sstream&gt;</span>
<span class="ot">#include&lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// &#22240;&#20026;&#21508;&#20010;&#32467;&#28857;&#30340;&#26435;&#20540;&#21508;&#19981;&#30456;&#21516;&#19988;&#37117;&#26159;&#27491;&#25972;&#25968;&#65292;&#30452;&#25509;&#29992;&#26435;&#20540;&#20316;&#20026;&#32467;&#28857;&#32534;&#21495;</span>
<span class="dt">const</span> <span class="dt">int</span> maxv = <span class="dv">10000</span> + <span class="dv">10</span>;
<span class="dt">int</span> in_order[maxv], post_order[maxv], lch[maxv], rch[maxv];
<span class="dt">int</span> n;

<span class="dt">bool</span> read_list(<span class="dt">int</span>* a) {
    string line;
    <span class="kw">if</span>(!getline(cin, line)) <span class="kw">return</span> <span class="kw">false</span>;
    stringstream ss(line);
    n = <span class="dv">0</span>;
    <span class="dt">int</span> x;
    <span class="kw">while</span>(ss &gt;&gt; x) a[n++] = x;
    <span class="kw">return</span> n &gt; <span class="dv">0</span>;
}

<span class="co">// &#25226;in_order[L1..R1]&#21644;post_order[L2..R2]&#24314;&#25104;&#19968;&#26869;&#20108;&#21449;&#26641;&#65292;&#36820;&#22238;&#26641;&#26681;</span>
<span class="dt">int</span> build(<span class="dt">int</span> L1, <span class="dt">int</span> R1, <span class="dt">int</span> L2, <span class="dt">int</span> R2) {
    <span class="kw">if</span>(L1 &gt; R1) <span class="kw">return</span> <span class="dv">0</span>; <span class="co">// &#31354;&#26641;</span>
    <span class="dt">int</span> root = post_order[R2];
    <span class="dt">int</span> p = L1;
    <span class="kw">while</span>(in_order[p] != root) p++;
    <span class="dt">int</span> cnt = p-L1; <span class="co">// &#24038;&#23376;&#26641;&#30340;&#32467;&#28857;&#20010;&#25968;</span>
    lch[root] = build(L1, p<span class="dv">-1</span>, L2, L2+cnt<span class="dv">-1</span>);
    rch[root] = build(p<span class="dv">+1</span>, R1, L2+cnt, R2<span class="dv">-1</span>);
    <span class="kw">return</span> root;
}

<span class="dt">int</span> best, best_sum; <span class="co">// &#30446;&#21069;&#20026;&#27490;&#30340;&#26368;&#20248;&#35299;&#21644;&#23545;&#24212;&#30340;&#26435;&#21644;</span>

<span class="dt">void</span> dfs(<span class="dt">int</span> u, <span class="dt">int</span> sum) {
    sum += u;
    <span class="kw">if</span>(!lch[u] &amp;&amp; !rch[u]) { <span class="co">// &#21494;&#23376;</span>
        <span class="kw">if</span>(sum &lt; best_sum || (sum == best_sum &amp;&amp; u &lt; best)) { best = u; best_sum = sum; }
    }
    <span class="kw">if</span>(lch[u]) dfs(lch[u], sum);
    <span class="kw">if</span>(rch[u]) dfs(rch[u], sum);
}

<span class="dt">int</span> main() {
    <span class="kw">while</span>(read_list(in_order)) {
        read_list(post_order);
        build(<span class="dv">0</span>, n<span class="dv">-1</span>, <span class="dv">0</span>, n<span class="dv">-1</span>);
        best_sum = <span class="dv">1000000000</span>;
        dfs(post_order[n<span class="dv">-1</span>], <span class="dv">0</span>);
        cout &lt;&lt; best &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>&#20063;&#21487;&#20197;&#22312;&#36882;&#24402;&#30340;&#21516;&#26102;&#32479;&#35745;&#26368;&#20248;&#35299;&#12290;&#30041;&#32473;&#35835;&#32773;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>Falling Leaves <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa699 The Falling Leaves</span>
<span class="co">// Rujia Liu</span>
<span class="co">// &#39064;&#24847;&#65306;&#32473;&#19968;&#26869;&#20108;&#21449;&#26641;&#65292;&#27599;&#20010;&#33410;&#28857;&#37117;&#26377;&#19968;&#20010;&#27700;&#24179;&#20301;&#32622;&#65306;&#24038;&#20799;&#23376;&#22312;&#23427;&#24038;&#36793;1&#20010;&#21333;&#20301;&#65292;&#21491;&#20799;&#23376;&#22312;&#21491;&#36793;1&#20010;&#21333;&#20301;&#12290;&#20174;&#24038;&#21521;&#21491;&#36755;&#20986;&#27599;&#20010;&#27700;&#24179;&#20301;&#32622;&#30340;&#25152;&#26377;&#32467;&#28857;&#30340;&#26435;&#20540;&#20043;&#21644;&#12290;&#25353;&#29031;&#36882;&#24402;&#26041;&#24335;&#36755;&#20837;&#65292;-1&#34920;&#31034;&#31354;&#26641;</span>
<span class="co">// &#31639;&#27861;&#65306;&#22312;&#8220;&#24314;&#26641;&#8221;&#30340;&#21516;&#26102;&#35745;&#31639;&#65292;&#26080;&#39035;&#30495;&#27491;&#30340;&#25226;&#26641;&#20445;&#23384;&#19979;&#26469;</span>

<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">200</span>;
<span class="dt">int</span> sum[maxn];

<span class="co">// &#36755;&#20837;&#24182;&#32479;&#35745;&#19968;&#26869;&#23376;&#26641;&#65292;&#26641;&#26681;&#27700;&#24179;&#20301;&#32622;&#20026;p</span>
<span class="dt">void</span> build(<span class="dt">int</span> p) {
    <span class="dt">int</span> v;
    cin &gt;&gt; v;
    <span class="kw">if</span>(v == <span class="dv">-1</span>) <span class="kw">return</span>; <span class="co">// &#31354;&#26641;</span>
    sum[p] += v;
    build(p - <span class="dv">1</span>);
    build(p + <span class="dv">1</span>);
}

<span class="co">// &#36793;&#35835;&#20837;&#36793;&#32479;&#35745;</span>
<span class="dt">bool</span> init() {
    <span class="dt">int</span> v;
    cin &gt;&gt; v;
    <span class="kw">if</span>(v == <span class="dv">-1</span>) <span class="kw">return</span> <span class="kw">false</span>;

    memset(sum, <span class="dv">0</span>, <span class="kw">sizeof</span>(sum));
    <span class="dt">int</span> pos = maxn/<span class="dv">2</span>; <span class="co">// &#26641;&#26681;&#30340;&#27700;&#24179;&#20301;&#32622;</span>
    sum[pos] = v;
    build(pos - <span class="dv">1</span>); <span class="co">// &#24038;&#23376;&#26641;</span>
    build(pos + <span class="dv">1</span>); <span class="co">// &#21491;&#23376;&#26641;</span>
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> kase = <span class="dv">0</span>;
    <span class="kw">while</span>(init()) {
        <span class="dt">int</span> p = <span class="dv">0</span>;
        <span class="kw">while</span>(sum[p] == <span class="dv">0</span>) p++; <span class="co">// &#25214;&#26368;&#24038;&#36793;&#30340;&#21494;&#23376;</span>

        <span class="co">// &#24320;&#22987;&#36755;&#20986;&#12290;&#22240;&#20026;&#35201;&#36991;&#20813;&#34892;&#26411;&#22810;&#20313;&#31354;&#26684;&#65292;&#25152;&#20197;&#31245;&#24494;&#40635;&#28902;&#19968;&#28857;</span>
        cout &lt;&lt; <span class="st">&quot;Case &quot;</span> &lt;&lt; ++kase &lt;&lt; <span class="st">&quot;:</span><span class="ch">\n</span><span class="st">&quot;</span> &lt;&lt; sum[p++];
        <span class="kw">while</span>(sum[p] != <span class="dv">0</span>) {
            cout &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; sum[p];
            p++;
        }
        cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n\n</span><span class="st">&quot;</span>;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Quadtree <code class="fold">@</code></dt>
<dd><p>ch6, page160.</p>
<p>&#39064;&#24847;&#65306;&#32473;&#20004;&#26869;&#22235;&#20998;&#26641;&#30340;&#20808;&#24207;&#36941;&#21382;&#65292;&#27714;&#20108;&#32773;&#21512;&#24182;&#20043;&#21518;&#65288;&#40657;&#33394;&#37096;&#20998;&#21512;&#24182;&#65289;&#40657;&#33394;&#20687;&#32032;&#30340;&#20010;&#25968;&#12290;p &#34920;&#31034;&#20013;&#38388;&#32467;&#28857;&#65292;f &#34920;&#31034;&#40657;&#33394;&#65288;full&#65289;&#65292;e &#34920;&#31034;&#30333;&#33394;&#65288;empty&#65289;</p>
<p>&#31639;&#27861;&#65306;&#20808;&#24314;&#26641;&#65292;&#28982;&#21518;&#32479;&#35745;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>

<span class="dt">const</span> <span class="dt">int</span> len = <span class="dv">32</span>;
<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1024</span> + <span class="dv">10</span>;
<span class="dt">char</span> s[maxn];
<span class="dt">int</span> buf[len][len], cnt;

<span class="co">// &#25226;&#23383;&#31526;&#20018; s[p..] &#23548;&#20986;&#21040;&#20197; (r,c) &#20026;&#24038;&#19978;&#35282;&#65292;&#36793;&#38271;&#20026; w &#30340;&#32531;&#20914;&#21306;&#20013;</span>
<span class="co">// 2 1</span>
<span class="co">// 3 4</span>
<span class="dt">void</span> draw(<span class="dt">const</span> <span class="dt">char</span>* s, <span class="dt">int</span>&amp; p, <span class="dt">int</span> r, <span class="dt">int</span> c, <span class="dt">int</span> w) {
    <span class="dt">char</span> ch = s[p++];
    <span class="kw">if</span>(ch == <span class="st">&#39;p&#39;</span>) {
        draw(s, p, r,     c+w/<span class="dv">2</span>, w/<span class="dv">2</span>); <span class="co">// 1</span>
        draw(s, p, r,     c    , w/<span class="dv">2</span>); <span class="co">// 2</span>
        draw(s, p, r+w/<span class="dv">2</span>, c    , w/<span class="dv">2</span>); <span class="co">// 3</span>
        draw(s, p, r+w/<span class="dv">2</span>, c+w/<span class="dv">2</span>, w/<span class="dv">2</span>); <span class="co">// 4</span>
    } <span class="kw">else</span> <span class="kw">if</span>(ch == <span class="st">&#39;f&#39;</span>) { <span class="co">// &#30011;&#40657;&#20687;&#32032;&#65288;&#30333;&#20687;&#32032;&#19981;&#30011;&#65289;</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = r; i &lt; r+w; i++)
            <span class="kw">for</span>(<span class="dt">int</span> j = c; j &lt; c+w; j++)
                <span class="kw">if</span>(buf[i][j] == <span class="dv">0</span>) { buf[i][j] = <span class="dv">1</span>; cnt++; }
    }
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T--) {
        memset(buf, <span class="dv">0</span>, <span class="kw">sizeof</span>(buf));
        cnt = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">2</span>; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, s);
            <span class="dt">int</span> p = <span class="dv">0</span>;
            draw(s, p, <span class="dv">0</span>, <span class="dv">0</span>, len);
        }
        printf(<span class="st">&quot;There are </span><span class="ch">%d</span><span class="st"> black pixels.</span><span class="ch">\n</span><span class="st">&quot;</span>, cnt);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Oil Deposits <code class="fold">@</code></dt>
<dd><p>ch6, page162.</p>
<p>&#39064;&#24847;&#65306;&#36755;&#20837;&#19968;&#20010;&#23383;&#31526;&#30697;&#38453;&#65292;&#32479;&#35745;&#23383;&#31526; @ &#32452;&#25104;&#22810;&#23569;&#20010;&#22235;&#36830;&#22359;</p>
<pre><code>input:

    4   4                       # 4 &#34892; 4 &#21015;
    *   *   *   *   @
    *   @   @   *   @
    *   @   *   *   @
    @   @   @   *   @
    @   @   *   *   @

output:

    2</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100</span> + <span class="dv">5</span>;
<span class="dt">char</span> pic[maxn][maxn];
<span class="dt">int</span> m, n, idx[maxn][maxn];

<span class="dt">void</span> dfs( <span class="dt">int</span> r, <span class="dt">int</span> c, <span class="dt">int</span> id ) {
    <span class="kw">if</span>( r &lt; <span class="dv">0</span> || r &gt;= m || c &lt; <span class="dv">0</span> || c &gt;= n ) { <span class="kw">return</span>; }
    <span class="kw">if</span>( idx[r][c] &gt; <span class="dv">0</span>  || pic[r][c] != <span class="st">&#39;@&#39;</span> ) { <span class="kw">return</span>; }
    idx[r][c] = id;
    <span class="kw">for</span>( <span class="dt">int</span> dr = <span class="dv">-1</span>; dr &lt;= <span class="dv">1</span>; dr++ ) {
        <span class="kw">for</span>( <span class="dt">int</span> dc = <span class="dv">-1</span>; dc &lt;= <span class="dv">1</span>; dc++ ) {
            <span class="kw">if</span>( dr != <span class="dv">0</span> || dc != <span class="dv">0</span> ) {
                dfs( r+dr, c+dc, id );
            }
        }
    }
}

<span class="dt">int</span> main() {
    <span class="kw">while</span>( scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;m, &amp;n) == <span class="dv">2</span> &amp;&amp; m &amp;&amp; n ) {
        <span class="dt">int</span> i = <span class="dv">0</span>;
        <span class="dt">char</span> c;
        <span class="kw">while</span>( i &lt; m*n &amp;&amp; (c = getchar()) != EOF ) {
            <span class="kw">if</span>( c != <span class="st">&#39;*&#39;</span> &amp;&amp; c != <span class="st">&#39;@&#39;</span> ) {
                <span class="kw">continue</span>;
            } <span class="kw">else</span> {
                pic[i/n][i%n] = c;
                ++i;
            }
        }
        memset( idx, <span class="dv">0</span>, <span class="kw">sizeof</span>(idx) );
        <span class="dt">int</span> cnt = <span class="dv">0</span>;
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; ++i ) {
            <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j ) {
                <span class="kw">if</span>( idx[i][j] == <span class="dv">0</span> &amp;&amp; pic[i][j] == <span class="st">&#39;@&#39;</span> ) {
                    dfs( i, j, ++cnt );
                }
            }
        }
        printf( <span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, cnt );
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>&#27714;&#22810;&#32500;&#25968;&#32452;&#36830;&#36890;&#22359;&#30340;&#36807;&#31243;&#20063;&#31216;&#20026;&#31181;&#23376;&#22635;&#20805;&#65288;floodfill&#65289;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>Ordering Tasks <code class="fold">@</code></dt>
<dd><p>&#20108;&#20803;&#32452; (u, v)&#65292;&#26500;&#36896;&#26377;&#21521;&#22270;&#65292;&#22914;&#26524;&#26377;&#29615;&#65292;&#20851;&#31995;&#8220;&#30772;&#35010;&#8221;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10305 Ordering Tasks</span>
<span class="co">// Rujia Liu</span>
<span class="co">// &#39064;&#24847;&#65306;&#36755;&#20837; n &#21644; m&#65292;&#20197;&#21450; m &#20010;&#20108;&#20803;&#32452; (i,j)&#65292;&#27714; 1~n &#30340;&#19968;&#20010;&#25490;&#21015;&#20351;&#24471;&#23545;&#20110;&#27599;&#20010; (i,j)&#65292;i &#22312; j &#30340;&#21069;&#38754;</span>
<span class="co">// &#31639;&#27861;&#65306;&#25299;&#25169;&#25490;&#24207;&#12290;&#27880;&#24847; m &#21487;&#33021;&#31561;&#20110; 0</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1000</span>;
<span class="dt">int</span> n, m, G[maxn][maxn], c[maxn], topo[maxn], t;

<span class="dt">bool</span> dfs( <span class="dt">int</span> u ) {
    c[u] = <span class="dv">-1</span>;
    <span class="kw">for</span>( <span class="dt">int</span> v = <span class="dv">0</span>; v &lt; n; v++ ) {
        <span class="kw">if</span>( G[u][v] ) {
            <span class="kw">if</span>( c[v]&lt;<span class="dv">0</span> ) { <span class="kw">return</span> <span class="kw">false</span>; }
        } <span class="kw">else</span> {
            <span class="kw">if</span>( !c[v]  ) { dfs(v); }
        }
    }
    c[u] = <span class="dv">1</span>; topo[--t] = u;
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="dt">bool</span> toposort() {
    t = n;
    memset( c, <span class="dv">0</span>, <span class="kw">sizeof</span>(c) );
    <span class="kw">for</span>( <span class="dt">int</span> u = <span class="dv">0</span>; u &lt; n; u++) {
        <span class="kw">if</span>( !c[u] &amp;&amp; !dfs(u) ) {
            <span class="kw">return</span> <span class="kw">false</span>;
        }
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="dt">int</span> main() {
    <span class="kw">while</span>( scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m) == <span class="dv">2</span> &amp;&amp; n ) {
        memset( G, <span class="dv">0</span>, <span class="kw">sizeof</span>(G) );
        <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++ ) {
            <span class="dt">int</span> u, v;
            scanf( <span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;u, &amp;v );
            G[u<span class="dv">-1</span>][v<span class="dv">-1</span>] = <span class="dv">1</span>;
        }
        <span class="kw">if</span>( toposort() ) {
            <span class="kw">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n<span class="dv">-1</span>; i++ ) {
                printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> &quot;</span>, topo[i]<span class="dv">+1</span>);
            }
            printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, topo[n<span class="dv">-1</span>]<span class="dv">+1</span>);
        } <span class="kw">else</span> {
            printf(<span class="st">&quot;No</span><span class="ch">\n</span><span class="st">&quot;</span>); <span class="co">// &#39064;&#30446;&#27809;&#35828;&#26080;&#35299;&#36755;&#20986;&#20160;&#20040;&#65292;&#24212;&#35813;&#26159;&#20445;&#35777;&#26377;&#35299;&#21543;</span>
        }
    }
}</code></pre></div>
<pre><code>$ cat input.txt
5 3
2 1
4 2
3 2

3 3
3 2
2 1
1 3

$ cat input.txt | ./a.out
1 1 1 1 5
No</code></pre>
</dd>
</dl></li>
<li><dl>
<dt>Play on Words <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa10129 Play on Words</span>
<span class="co">// Rujia Liu</span>
<span class="co">// &#39064;&#24847;&#65306;&#36755;&#20837; n &#20010;&#21333;&#35789;&#65292;&#26159;&#21542;&#21487;&#20197;&#25490;&#25104;&#19968;&#20010;&#24207;&#21015;&#65292;&#20351;&#24471;&#27599;&#20010;&#21333;&#35789;&#30340;&#31532;&#19968;&#20010;&#23383;&#27597;&#21644;&#19978;&#19968;&#20010;&#21333;&#35789;&#30340;&#26368;&#21518;&#19968;&#20010;&#23383;&#27597;&#30456;&#21516;</span>
<span class="co">// &#31639;&#27861;&#65306;&#25226;&#23383;&#27597;&#30475;&#20316;&#32467;&#28857;&#65292;&#21333;&#35789;&#30475;&#25104;&#26377;&#21521;&#36793;&#65292;&#21017;&#26377;&#35299;&#24403;&#19988;&#20165;&#24403;&#22270;&#20013;&#26377;&#27431;&#25289;&#36335;&#24452;&#12290;&#27880;&#24847;&#35201;&#20808;&#21028;&#36830;&#36890;</span>

<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">1000</span> + <span class="dv">5</span>;

<span class="co">// &#24182;&#26597;&#38598;</span>
<span class="dt">int</span> pa;
<span class="dt">int</span> findset(<span class="dt">int</span> x) { <span class="kw">return</span> pa[x] != x ? pa[x] = findset(pa[x]) : x; }
<span class="dt">int</span> used, deg;                                <span class="co">// &#26159;&#21542;&#20986;&#29616;&#36807;&#65307;&#24230;&#25968;</span>

<span class="dt">int</span> main() {
    <span class="dt">int</span> T;
    scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T );
    <span class="kw">while</span>( T-- ) {
        <span class="dt">int</span> n;
        <span class="dt">char</span> word[maxn];

        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
        memset(used, <span class="dv">0</span>, <span class="kw">sizeof</span>(used));
        memset(deg, <span class="dv">0</span>, <span class="kw">sizeof</span>(deg));
        <span class="kw">for</span>(<span class="dt">int</span> ch = <span class="st">&#39;a&#39;</span>; ch &lt;= <span class="st">&#39;z&#39;</span>; ch++) pa[ch] = ch;
        <span class="dt">int</span> cc = <span class="dv">26</span>;                                        <span class="co">// &#36830;&#36890;&#22359;&#20010;&#25968;</span>

        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
            scanf(<span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, word);
            <span class="dt">char</span> c1 = word, c2 = word[strlen(word)<span class="dv">-1</span>];
            deg[c1]++;
            deg[c2]--;
            used[c1] = used[c2] = <span class="dv">1</span>;
            <span class="dt">int</span> s1 = findset(c1), s2 = findset(c2);
            <span class="kw">if</span>(s1 != s2) { pa[s1] = s2; cc--; }
        }

        vector&lt;<span class="dt">int</span>&gt; d;
        <span class="kw">for</span>(<span class="dt">int</span> ch = <span class="st">&#39;a&#39;</span>; ch &lt;= <span class="st">&#39;z&#39;</span>; ch++) {
            <span class="kw">if</span>(!used[ch]) cc--;                               <span class="co">// &#27809;&#20986;&#29616;&#36807;&#30340;&#23383;&#27597;</span>
            <span class="kw">else</span> <span class="kw">if</span>(deg[ch] != <span class="dv">0</span>) d.push_back(deg[ch]);
        }
        <span class="dt">bool</span> ok = <span class="kw">false</span>;
        <span class="kw">if</span>(cc == <span class="dv">1</span> &amp;&amp; (d.empty() || (d.size() == <span class="dv">2</span> &amp;&amp; (d == <span class="dv">1</span> || d == <span class="dv">-1</span>)))) ok = <span class="kw">true</span>;
        <span class="kw">if</span>(ok) printf(<span class="st">&quot;Ordering is possible.</span><span class="ch">\n</span><span class="st">&quot;</span>);
        <span class="kw">else</span> printf(<span class="st">&quot;The door cannot be opened.</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cat</span> input.txt
<span class="kw">2</span>
<span class="kw">3</span>
<span class="kw">acm</span>
<span class="kw">malform</span>
<span class="kw">mouse</span>
<span class="kw">3</span>
<span class="kw">ack</span>
<span class="kw">malform</span>
<span class="kw">mouse</span>

$ <span class="kw">cat</span> input.txt <span class="kw">|</span> <span class="kw">./a.out</span>
<span class="kw">Ordering</span> is possible.
<span class="kw">The</span> door cannot be opened.</code></pre></div>
</dd>
</dl></li>
<li>6-17 UVa10562 Undraw the Trees UVa10562.cpp</li>
<li>6-18 UVa12171 Sculpture UVa12171.cpp</li>
<li>6-19 UVa1572 Self-Assembly UVa1572.cpp</li>
<li><dl>
<dt>6-20 UVa1599 Ideal Path UVa1599.cpp &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>n &#20010;&#28857;&#65292;m &#26465;&#36793;&#65288;2&lt;=n&lt;=100000&#65292;1&lt;=m&lt;=200000&#65289;&#30340;&#26080;&#21521;&#22270;&#65292;&#27599;&#22825;&#36793;&#19978;&#37117;&#28034;&#26377;&#19968;&#31181;&#39068;&#33394;&#12290;&#27714;&#20174;&#33410;&#28857; 1 &#21040;&#33410;&#28857; n &#30340;&#19968;&#26465;&#36335;&#24452;&#65292;&#20351;&#24471;&#32463;&#36807;&#30340;&#36793;&#25968;&#23613;&#37327;&#23569;&#65292;&#22312;&#27492;&#21069;&#25552;&#19979;&#65292;&#32463;&#36807;&#36793;&#30340;&#39068;&#33394;&#24207;&#21015;&#30340;&#23383;&#20856;&#24207;&#26368;&#23567;&#12290;&#19968;&#23545;&#33410;&#28857;&#38388;&#21487;&#33021;&#26377;&#22810;&#26465;&#36793;&#65292;&#19968;&#26465;&#36793;&#65292;&#21487;&#33021;&#36830;&#25509;&#20004;&#20010;&#30456;&#21516;&#30340;&#32467;&#28857;&#12290;&#36755;&#20837;&#20445;&#35777;&#33410;&#28857; 1 &#21487;&#20197;&#36798;&#21040;&#33410;&#28857; n&#12290;&#39068;&#33394;&#20026; 1~10<sup>9</sup> &#30340;&#25972;&#25968;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// UVa1599 Idea Path</span>
<span class="co">// Rujia Liu</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;vector&gt;</span>
<span class="ot">#include&lt;queue&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">100000</span> + <span class="dv">5</span>;
<span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1000000000</span>; <span class="co">// maximal color</span>

<span class="kw">struct</span> Edge {
    <span class="dt">int</span> u, v, c;
    Edge(<span class="dt">int</span> u=<span class="dv">0</span>, <span class="dt">int</span> v=<span class="dv">0</span>, <span class="dt">int</span> c=<span class="dv">0</span>):u(u),v(v),c(c) {}
};

vector&lt;Edge&gt; edges;
vector&lt;<span class="dt">int</span>&gt; G[maxn];

<span class="dt">void</span> AddEdge(<span class="dt">int</span> u, <span class="dt">int</span> v, <span class="dt">int</span> c) {
    edges.push_back(Edge(u, v, c));
    <span class="dt">int</span> idx = edges.size() - <span class="dv">1</span>;
    G[u].push_back(idx);
}

<span class="dt">int</span> n, vis[maxn];
<span class="dt">int</span> d[maxn];
<span class="co">// reverse bfs to find out the distance from each node to n-1</span>
<span class="dt">void</span> rev_bfs() {
    memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
    d[n<span class="dv">-1</span>] = <span class="dv">0</span>;
    vis[n<span class="dv">-1</span>] = <span class="kw">true</span>;

    queue&lt;<span class="dt">int</span>&gt; q;
    q.push(n<span class="dv">-1</span>);
    <span class="kw">while</span>(!q.empty()) {
        <span class="dt">int</span> v = q.front(); q.pop();
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[v].size(); i++) {
            <span class="dt">int</span> e = G[v][i];
            <span class="dt">int</span> u = edges[e].v;
            <span class="kw">if</span>(!vis[u]) {
                vis[u] = <span class="kw">true</span>;
                d[u] = d[v] + <span class="dv">1</span>;
                q.push(u);
            }
        }
    }
}

vector&lt;<span class="dt">int</span>&gt; ans;

<span class="co">// forward bfs to construct the path</span>
<span class="dt">void</span> bfs() {
    memset(vis, <span class="dv">0</span>, <span class="kw">sizeof</span>(vis));
    vis = <span class="kw">true</span>;
    ans.clear();

    vector&lt;<span class="dt">int</span>&gt; next;
    next.push_back(<span class="dv">0</span>);
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; d; i++) {
        <span class="dt">int</span> min_color = INF;
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; next.size(); j++) {
            <span class="dt">int</span> u = next[j];
            <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; G[u].size(); k++) {
                <span class="dt">int</span> e = G[u][k];
                <span class="dt">int</span> v = edges[e].v;
                <span class="kw">if</span>(d[u] == d[v] + <span class="dv">1</span>)
                    min_color = min(min_color, edges[e].c);
            }
        }
        ans.push_back(min_color);

        <span class="co">// find out the next vertices of the next phase</span>
        vector&lt;<span class="dt">int</span>&gt; next2;
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; next.size(); j++) {
            <span class="dt">int</span> u = next[j];
            <span class="kw">for</span>(<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; G[u].size(); k++) {
                <span class="dt">int</span> e = G[u][k];
                <span class="dt">int</span> v = edges[e].v;
                <span class="kw">if</span>(d[u] == d[v] + <span class="dv">1</span> &amp;&amp; !vis[v] &amp;&amp; edges[e].c == min_color) {
                    vis[v] = <span class="kw">true</span>;
                    next2.push_back(v);
                }
            }
        }
        next = next2;
    }

    printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans.size());
    printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, ans);
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; ans.size(); i++) printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>, ans[i]);
    printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
}

<span class="dt">int</span> main() {
    <span class="dt">int</span> u, v, c, m;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;m) == <span class="dv">2</span>) {
        edges.size();
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) G[i].clear();
        <span class="kw">while</span>(m--) {
            scanf(<span class="st">&quot;</span><span class="ch">%d%d%d</span><span class="st">&quot;</span>, &amp;u, &amp;v, &amp;c);
            AddEdge(u<span class="dv">-1</span>, v<span class="dv">-1</span>, c);
            AddEdge(v<span class="dv">-1</span>, u<span class="dv">-1</span>, c);
        }
        rev_bfs();
        bfs();
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
</dl></li>
<li>6-21 UVa506 System Dependencies uva506.cpp</li>
<li>6-22 UVa11853 Paintball UVa11853.cpp</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/course/1/">&#20061;&#31456;&#31639;&#27861;&#29677; - &#30789;&#35895;&#39030;&#23574; IT &#20225;&#19994;&#19968;&#32447;&#24037;&#31243;&#24072;&#30452;&#25773;&#25945;&#23398;</a></li>
<li><a href="http://www.jiuzhang.com/course/5/">&#20061;&#31456;&#31639;&#27861;&#24378;&#21270;&#29677; - &#30789;&#35895;&#39030;&#23574; IT &#20225;&#19994;&#19968;&#32447;&#24037;&#31243;&#24072;&#30452;&#25773;&#25945;&#23398;</a></li>
<li><a href="https://github.com/soulmachine/acm-cheat-sheet">GitHub - soulmachine/acm-cheat-sheet: Acm Cheat Sheet</a></li>
<li><a href="https://github.com/soulmachine/acm-cheat-sheet/wiki/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E3%80%8B%E4%B8%AD%E7%9A%84%E4%BE%8B%E9%A2%98%E5%AF%B9%E5%BA%94%E7%9A%84OJ%E9%A2%98%E5%8F%B7">&#12298;&#31639;&#27861;&#31454;&#36187;&#20837;&#38376;&#32463;&#20856;&#12299;&#20013;&#30340;&#20363;&#39064;&#23545;&#24212;&#30340; OJ &#39064;&#21495; &#183; soulmachine/acm-cheat-sheet Wiki &#183; GitHub</a></li>
</ul>
</dd>
<dt>&#31995;&#32479;&#35774;&#35745;&#29677; <code class="fold">@</code></dt>
<dd><blockquote>
<p>&#24590;&#26679;&#35774;&#35745; Facebook&#65311;&#29702;&#35299; Google &#30340;&#19977;&#39550;&#39532;&#36710;&#65281;</p>
</blockquote>
<ul>
<li>&#26080;&#31995;&#32479;&#35774;&#35745;&#32463;&#39564;&#65292;&#25110;&#31995;&#32479;&#35774;&#35745;&#22522;&#30784;&#34180;&#24369;</li>
<li>&#29616;&#22312;&#23454;&#20064;&#29983;&#65288;Intern&#65289;&#37117;&#22312;&#38754;&#31995;&#32479;&#35774;&#35745;&#20102;&#20320;&#30693;&#36947;&#20040;&#65311;</li>
<li>&#24076;&#26395;&#30693;&#36947;&#24590;&#26679;&#35774;&#35745; Facebook Messenger? News Feed</li>
<li>&#24076;&#26395;&#30693;&#36947;&#24590;&#26679;&#20570;&#19968;&#20010;&#29228;&#34411;&#31995;&#32479;</li>
<li>&#24076;&#26395;&#29702;&#35299; Google &#19977;&#39550;&#39532;&#36710;</li>
<li>&#24076;&#26395;&#20102;&#35299; NoSQL Database</li>
</ul>
<dl>
<dt>&#9986;&#65039; 8/15/2016, 1:00:00 AM &#36208;&#36827;&#31995;&#32479;&#35774;&#35745; &amp; &#35774;&#35745;&#25512;&#29305; &#12304;&#20813;&#36153;&#35797;&#21548;&#12305; <code class="fold">@</code></dt>
<dd><ul>
<li>&#20160;&#20040;&#26159;&#31995;&#32479;&#35774;&#35745; What is System Design</li>
<li>&#31995;&#32479;&#35774;&#35745;&#20013;&#24120;&#35265;&#30340;&#38382;&#39064;&#26159;&#20160;&#20040; How we ask System Design in Interview</li>
<li>&#24590;&#26679;&#22238;&#31572;&#31995;&#32479;&#35774;&#35745;&#38382;&#39064; How to answer System Design Question</li>
<li>&#31995;&#32479;&#35774;&#35745;&#30340; 4S &#20998;&#26512;&#27861; 4S in System Design</li>
<li>&#31995;&#32479;&#35774;&#35745;&#30340;&#30693;&#35782;&#28857;&#26500;&#25104; Basic Knowledge of System Design</li>
<li>&#35774;&#35745;&#25512;&#29305; Design a Twitter</li>
</ul>
</dd>
<dt>&#9986;&#65039; 8/21/2016, 1:00:00 AM &#25968;&#25454;&#24211;&#31995;&#32479; Database System <code class="fold">@</code></dt>
<dd><p>&#36890;&#36807;&#35774;&#35745;&#32842;&#22825;&#31995;&#32479; Whatsapp &#20102;&#35299;&#65306;</p>
<ul>
<li>&#29992;&#25143;&#31995;&#32479;&#35774;&#35745;</li>
<li>&#32842;&#22825;&#31995;&#32479;&#30340;&#26680;&#24515;&#35774;&#35745;&#28857;</li>
<li>&#25968;&#25454;&#24211;&#31995;&#32479;&#30340;&#30456;&#20851;&#30693;&#35782;</li>
<li>NoSQL &#19982; SQL &#25968;&#25454;&#24211;&#30340;&#20248;&#21155;&#27604;&#36739;&#19982;&#36873;&#21462;&#26631;&#20934;</li>
<li>&#19968;&#33268;&#24615;&#21704;&#24076;&#31639;&#27861; Consistent Hashing</li>
<li>&#20998;&#29255;&#31639;&#27861; Sharding</li>
</ul>
</dd>
<dt>&#9986;&#65039; 8/22/2016, 1:00:00 AM &#29228;&#34411;&#31995;&#32479;&#19982;&#25628;&#32034;&#24314;&#35758;&#31995;&#32479; Web Crawler &amp; Google Suggestion <code class="fold">@</code></dt>
<dd><p>&#36890;&#36807;&#23545;&#29228;&#34411;&#31995;&#32479;&#35774;&#35745; (Web Crawler) &#19982; &#25628;&#32034;&#24314;&#35758;&#31995;&#32479;&#35774;&#35745; (Google Suggestion) &#20102;&#35299;&#22914;&#19979;&#20869;&#23481;&#65306;</p>
<ul>
<li>&#22810;&#32447;&#31243;</li>
<li>&#29983;&#20135;&#32773;&#28040;&#36153;&#32773;&#27169;&#22411;</li>
<li>&#29228;&#34411;&#31995;&#32479;&#30340;&#28436;&#21270;&#65306;&#21333;&#32447;&#31243;&#65292;&#22810;&#32447;&#31243;&#65292;&#20998;&#24067;&#24335;</li>
<li>Trie &#32467;&#26500;&#30340;&#21407;&#29702;&#21450;&#24212;&#29992;</li>
<li>&#22914;&#20309;&#22312;&#31995;&#32479;&#35774;&#35745;&#20013;&#20351;&#29992; Trie</li>
</ul>
</dd>
<dt>&#9986;&#65039; 8/28/2016, 1:00:00 AM &#20998;&#24067;&#24335;&#25991;&#20214;&#31995;&#32479; &amp; &#35774;&#35745;&#26597;&#35810;&#31995;&#32479; Google File System &amp; Design Lookup Service <code class="fold">@</code></dt>
<dd><p>&#20197; GFS &#20026;&#20363;&#31995;&#32479;&#23398;&#20064; Google File System&#65292;&#24182;&#36890;&#36807;&#19968;&#36947;&#23454;&#25112;&#30495;&#39064; Lookup Service &#24041;&#22266;&#35201;&#28857;&#65292;&#20102;&#35299;&#22914;&#19979;&#20869;&#23481;&#65306;</p>
<ul>
<li>Master Slave &#30340;&#35774;&#35745;&#27169;&#24335;</li>
<li>&#24590;&#20040;&#22788;&#29702;&#20998;&#24067;&#24335;&#31995;&#32479;&#20013;&#30340; failure &#21644; recovery &#30340;&#38382;&#39064;.</li>
<li>&#22914;&#20309;&#20570; replica, check sum &#26816;&#26597;</li>
<li>&#20102;&#35299; consistent hash &#21644; sharding &#30340;&#23454;&#38469;&#24212;&#29992;</li>
</ul>
</dd>
<dt>&#9986;&#65039; 8/29/2016, 1:00:00 AM, Web System &amp; Design Tiny Url &#32593;&#31449;&#31995;&#32479;&#35774;&#35745; &amp; &#35774;&#35745;&#30701;&#32593;&#22336;&#31995;&#32479; <code class="fold">@</code></dt>
<dd><p>&#23454;&#25112;&#30495;&#39064;</p>
<ul>
<li>What happend if you visit www.google.com?</li>
<li>How to design tiny url?</li>
<li>How to design rate limiter?</li>
<li>How to design data dog?</li>
</ul>
<p>&#20851;&#38190;&#35789;&#65306;Web, Consistent Hashing, Memcached, Tiny url.</p>
</dd>
<dt>&#9986;&#65039; 9/04/2016, 1:00:00 AM, Big Table &#21407;&#29702;&#36879;&#26512; <code class="fold">@</code></dt>
<dd><p>&#36890;&#36807;&#35774;&#35745;&#20998;&#24067;&#24335;&#25968;&#25454;&#24211;&#31995;&#32479; Bigtable &#20102;&#35299;&#22914;&#19979;&#20869;&#23481;&#65306;</p>
<ul>
<li>Big Table &#30340;&#21407;&#29702;&#19982;&#23454;&#29616;</li>
<li>&#20102;&#35299; NoSQL Database &#22914;&#20309;&#36827;&#34892;&#35835;&#20889;&#25805;&#20316;&#30340;, &#20197;&#21450;&#30456;&#24212;&#30340;&#20248;&#21270;</li>
<li>&#20102;&#35299;&#22914;&#20309;&#24314;&#31435; index</li>
<li>&#23398;&#20064; Bloom Filter &#30340;&#23454;&#29616;&#21407;&#29702;</li>
</ul>
</dd>
<dt>&#9986;&#65039; 9/05/2016, 1:00:00 AM, Map Reduce &amp; Design WhatsApp <code class="fold">@</code></dt>
<dd><p>&#23398;&#20064; Map Reduce &#30340;&#24212;&#29992;&#19982;&#21407;&#29702;</p>
<ul>
<li>&#20102;&#35299;&#22914;&#20309;&#22810;&#21488;&#26426;&#22120;&#24182;&#34892;&#35299;&#20915;&#31639;&#27861;&#38382;&#39064;</li>
<li>&#25484;&#25569; Map &#21644; Reduce &#30340;&#21407;&#29702;</li>
<li>&#36890;&#36807;&#19977;&#20010;&#39064;&#30446;&#25484;&#25569; MapReduce &#31639;&#27861;&#23454;&#29616;&#65306;
<ul>
<li>WordCount</li>
<li>InvertedIndex</li>
<li>Anagram</li>
</ul></li>
</ul>
<p>&#35774;&#35745;&#32842;&#22825;&#31995;&#32479; Whatsapp</p>
<ul>
<li>&#32842;&#22825;&#31995;&#32479;&#20013;&#30340; Pull vs Push</li>
<li>&#35762;&#35299;&#19968;&#31181;&#29305;&#27530;&#30340; Service - Realtime Service</li>
</ul>
</dd>
<dt>&#9986;&#65039; 9/11/2016, 1:00:00 AM, &#22522;&#20110;&#22320;&#29702;&#20301;&#32622;&#20449;&#24687;&#30340;&#31995;&#32479;&#35774;&#35745; Location Based Service <code class="fold">@</code></dt>
<dd><p>&#31995;&#32479;&#23398;&#20064; LBS &#30456;&#20851;&#31995;&#32479;&#35774;&#35745;&#30340;&#26680;&#24515;&#35201;&#28857;&#65306;</p>
<ul>
<li>&#22320;&#29702;&#20301;&#32622;&#20449;&#24687;&#23384;&#20648;&#19982;&#26597;&#35810;&#24120;&#29992;&#31639;&#27861;&#20043; Geohash</li>
<li>&#22914;&#20309;&#35774;&#35745; Yelp</li>
<li>&#22914;&#20309;&#35774;&#35745; Uber</li>
<li>&#22914;&#20309;&#35774;&#35745; Facebook Nearby</li>
</ul>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/course/2/">&#31995;&#32479;&#35774;&#35745;&#29677; - &#30789;&#35895;&#39030;&#23574; IT &#20225;&#19994;&#19968;&#32447;&#24037;&#31243;&#24072;&#30452;&#25773;&#25945;&#23398;</a></li>
</ul>
</dd>
<dt>Programming Pearls <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>part-1: preliminaries <code class="fold">@</code></dt>
<dd><p>Basics of programming.</p>
<ul>
<li><dl>
<dt>column-1: cracking the oyster <code class="fold">@</code></dt>
<dd><p>&#30913;&#30424;&#25490;&#24207;&#65306;&#23545;&#20110;&#19968;&#20010;&#25552;&#20986;&#30340;&#38382;&#39064;&#65292;&#19981;&#35201;&#26410;&#32463;&#24605;&#32771;&#23601;&#30452;&#25509;&#32473;&#20986;&#31572;&#26696;&#12290;&#35201;&#20808;&#28145;&#20837;&#30740;&#31350;&#38382;&#39064;&#65292;&#25630;&#28165;&#26970;&#36825;&#20010;&#38382;&#39064;&#30340;&#29305;&#28857;&#65292;&#26681;&#25454;&#36825;&#20010;&#29305;&#28857;&#65292;&#21487;&#33021;&#26377;&#26356;&#22909;&#30340;&#35299;&#20915;&#26041;&#26696;&#12290;&#28982;&#21518;&#29992;&#20102; bitmap&#12290;</p>
<pre><code>// init
for i = [0, n)
    bit[i] = 0
// assign
for each i in the input file
    bit[i] = 1
for i = [0, n)
    if bit[i] == 1
        write i on the output file</code></pre>
<p>&#39318;&#20808;&#20320;&#35201;&#25214;&#21040; the right problem&#12290;</p>
<ul>
<li>the bitmap data structure&#65306;a dense set over a finite domain</li>
<li>multiple-pass algorithms: &#22810;&#27425;&#35835;&#20837;&#36755;&#20837;&#65292;&#27599;&#27425;&#31163;&#30446;&#26631;&#36817;&#19968;&#28857;</li>
<li>a time-space tradeoff and one that isn&#8217;t</li>
<li>a simple design&#65306;&#19981;&#22810;&#19981;&#23569;&#21018;&#21018;&#22909;&#65292;&#31616;&#21333;&#30340;&#35774;&#35745; bug &#23569;</li>
<li>stages of program design</li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>column-2: aha! alogrithms <code class="fold">@</code></dt>
<dd><dl>
<dt>&#32463;&#20856;&#38382;&#39064;&#65306;&#25214;&#25968;&#23383; <code class="fold">@</code></dt>
<dd><p>&#32473;&#23450;&#19968;&#20010;&#21253;&#21547; 32 &#20301;&#25972;&#25968;&#30340;&#39034;&#24207;&#25991;&#20214; (sequential file)&#65292;&#23427;&#33267;&#22810;&#21482;&#33021;&#21253;&#21547; 40 &#20159; (4 billion) &#20010;&#36825;&#26679;&#30340;&#25972;&#25968;&#65292;&#24182;&#19988;&#25972;&#25968;&#30340;&#27425;&#24207;&#26159;&#38543;&#26426;&#30340; (in a random order)&#12290;&#35831;&#26597;&#25214;&#19968;&#20010;&#27492;&#25991;&#20214;&#20013;&#19981;&#23384;&#22312;&#30340; 32 &#20301;&#25972;&#25968;&#12290;&#22312;&#26377;&#36275;&#22815;&#20869;&#23384;&#30340;&#24773;&#20917;&#19979; (with ample quantities of main memory)&#65292;&#20320;&#20250;&#22914;&#20309;&#35299;&#20915;&#36825;&#20010;&#38382;&#39064;&#65311;&#22914;&#26524;&#20320;&#21487;&#20197;&#20351;&#29992;&#33509;&#24178;&#22806;&#37096;&#20020;&#26102;&#25991;&#20214;&#20294;&#21487;&#29992;&#20027;&#23384;&#21364;&#21482;&#26377;&#19978;&#30334;&#23383;&#33410;&#65292;&#20320;&#20250;&#22914;&#20309;&#35299;&#20915;&#36825;&#20010;&#38382;&#39064;&#65311;</p>
<ul>
<li>Given a sequential file that contain at most 4x109 integers(32-bit) in random order, find a 32-bit integer that is not in the file.</li>
<li>How would you solve it with ample main memory? &#8211; bitmap (232 bits)</li>
<li>or using several external &#8220;scratch&#8221; files but only a few hundred bytes of main memory? &#8211; binary search &#20108;&#20998;&#26597;&#25214;</li>
</ul>
<p>&#39318;&#20808;&#65292;&#21482;&#26159;&#35828;&#25214;&#19968;&#20010;&#12290;&#20854;&#23454; missing &#30340;&#26377;&#24456;&#22810;==&#65288;&#22240;&#20026; 32 bit &#30340;&#25972;&#25968;&#26377; 2^32 (4,294,967,296)&#20010;&#65292;&#36825;&#37324;&#21482;&#26377; 4 billion &#20010;&#25968;&#23383;&#65292;&#32943;&#23450;&#26377;&#19968;&#20123;&#25968;&#27809;&#26377;&#12290;&#65289;</p>
<p>4 billion &#20869;&#30340;&#25968;&#23383;&#37117;&#21487;&#20197;&#29992; int &#26469;&#34920;&#31034;&#65292;&#25152;&#20197;&#29992; bitmap &#30340;&#35805;&#65292;&#26377; 2^32 &#20010; bit &#23601;&#22815;&#20102;&#65292;&#20063;&#23601;&#26159; 2^{32}/8 bytes = 2^{32-3=29=9+10+10} bytes = 2^9 MBytes = 512 MBytes.</p>
<p>&#31867;&#20284;&#20108;&#20998;&#26597;&#25214;&#12290;&#21487;&#20197;&#26681;&#25454;&#26576;&#19968;&#20301;&#65288;&#25805;&#20316;&#26102;&#65292;&#21487;&#20197;&#20174;&#26368;&#39640;&#20301; &#21040;&#26368;&#20302;&#20301;&#20381;&#27425;&#22788;&#29702;&#65289;&#65292;&#25226;&#24453;&#22788;&#29702;&#30340;&#25968;&#25454;&#20998;&#25104;&#20004;&#37096;&#20998;&#12290;&#22312;&#19968;&#37096;&#20998;&#20013;&#65292;&#27492;&#20301;&#20026; 0&#65292;&#21478;&#19968;&#37096;&#20998;&#27492;&#20301;&#20026; 1&#12290;</p>
<p>&#20043;&#21518;&#65292;&#20998;&#21035;&#32479;&#35745;&#33853;&#22312;&#20004;&#20010;&#37096;&#20998;&#30340;&#25968;&#30340;&#20010;&#25968;&#12290;&#65288;&#27492;&#26102;&#25105;&#20204;&#19981;&#32771;&#34385;&#25968;&#25454;&#26159;&#21542;&#37325;&#22797;&#65289;</p>
<ul>
<li>&#22914;&#26524;&#65292;&#27809;&#26377;&#32570;&#22833;&#65292;&#37027;&#20040;&#36825;&#20004;&#37096;&#20998;&#25968;&#30340;&#20010;&#25968;&#24212;&#35813;&#26159;&#30456;&#31561;&#30340;&#12290;</li>
<li>&#22914;&#26524;&#65292;&#25968;&#25454;&#26377;&#32570;&#22833;&#65292;&#37027;&#20040;&#20004;&#37096;&#20998;&#25968;&#21487;&#33021;&#30456;&#31561;&#65292;&#20063;&#21487;&#33021;&#19981;&#31561;
<ul>
<li>&#20004;&#37096;&#20998;&#30456;&#31561;&#30340;&#24773;&#20917;&#65306;&#20004;&#27573;&#37117;&#32570;&#22833;&#65292;&#20294;&#32570;&#22833;&#30340;&#20010;&#25968;&#30456;&#31561;</li>
<li>&#20004;&#37096;&#20998;&#19981;&#31561;&#30340;&#24773;&#20917;&#65306;&#19968;&#20010;&#32570;&#19968;&#20010;&#19981;&#32570; &#25110; &#37117;&#32570;&#20294;&#32570;&#30340;&#20010;&#25968;&#19981;&#21516;</li>
</ul></li>
</ul>
</dd>
<dt>Reverse, n=8, i=3, abcdefgh -&gt; defghabc <code class="fold">@</code></dt>
<dd><pre><code>reverse( 0, i-1 );          // cbadefgh
reverse( i, n-1 );          // cbahgfed
reverse( 0, n-1 );          // defghabc</code></pre>
<p>&#20316;&#32773;&#36824;&#24456;&#24039;&#22937;&#30340;&#29992;&#32763;&#25163;&#26469;&#35299;&#37322;&#36825;&#20010;&#26041;&#26696;&#12290;</p>
<p>&#36825;&#20010; reverse &#21487;&#20197;&#36825;&#20010;&#20889;&#65306;&#65288;&#20004;&#36793;&#37117;&#26159;&#38381;&#21306;&#38388;&#65292;<code>[left, right]</code>&#65289;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// method 1</span>
<span class="dt">void</span> reverse( <span class="dt">char</span> *str, <span class="dt">int</span> start, <span class="dt">int</span> end ) {
    <span class="dt">char</span> tmp;
    <span class="dt">int</span> mid = (start + end)/<span class="dv">2</span>;
    <span class="kw">for</span> ( <span class="dt">int</span> i = start, j = end; i &lt;= mid; ++i, --j ) {
        tmp = str[i];
        str[i] = str[j];
        str[j] = tmp;
    }
}

<span class="co">// method 2, I prefer this one</span>
<span class="dt">void</span> reverse( <span class="dt">char</span> *str, <span class="dt">int</span> start, <span class="dt">int</span> end ) {
    <span class="dt">char</span> tmp;
    <span class="kw">while</span>( start &lt; end ) {
        tmp         =   str[start];
        str[start]  =   str[end];
        str[end]    =   tmp;
        ++start;
        --end;
    }
}

<span class="co">// &#20294;&#19981;&#31649;&#24590;&#26679;&#65292;&#35843;&#29992;&#30340;&#26102;&#20505;&#19981;&#35201;&#25226;</span>
reverse( str, <span class="dv">0</span>, strlen(str)<span class="dv">-1</span> );
<span class="co">// &#20889;&#25104;</span>
reverse( str, <span class="dv">0</span>, strlen(str) );         <span class="co">// &#38381;&#21306;&#38388;&#21834;&#65292;&#21516;&#23398;&#65281;</span></code></pre></div>
</dd>
<dt>signature &#30340;&#37325;&#35201;&#24615;&#65292;pots, stop, tops <code class="fold">@</code></dt>
<dd><p>&#25214; signature &#26159;&#26368;&#37325;&#35201;&#30340;&#12290;</p>
</dd>
</dl>
<p>&#21407;&#21017;&#65306;</p>
<ul>
<li>sorting</li>
<li>binary search</li>
<li>signatures</li>
</ul>
<dl>
<dt>Problems</dt>
<dd><ul>
<li><dl>
<dt>&#32763;&#36716;&#21477;&#23376;&#20013;&#21333;&#35789;&#30340;&#39034;&#24207;&#65292;&#20294;&#21333;&#35789;&#20869;&#23383;&#31526;&#30340;&#39034;&#24207;&#19981;&#21464; <code class="fold">@</code></dt>
<dd><p>&#21477;&#23376;&#20013;&#21333;&#35789;&#20197;&#31354;&#26684;&#31526;&#38548;&#24320;&#12290;&#20026;&#31616;&#21333;&#36215;&#35265;&#65292;&#26631;&#28857;&#31526;&#21495;&#21644;&#26222;&#36890;&#23383;&#27597;&#19968;&#26679;&#22788;&#29702;&#12290;</p>
<p>&#26041;&#27861;&#65306;&#20808;&#20998;&#21035;&#23545;&#21508;&#20010;&#21333;&#35789;&#36827;&#34892;&#36870;&#36716;&#65292;&#28982;&#21518;&#23545;&#25972;&#20010;&#21477;&#23376;&#36827;&#34892;&#36870;&#36716;&#12290;</p>
<p>I love you. -&gt; I evol .uoy -&gt; you. love I</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="dt">void</span> reverse( <span class="dt">char</span> *s, <span class="dt">int</span> left, <span class="dt">int</span> right ) {
    <span class="dt">char</span> tmp;
    <span class="kw">while</span>( left &lt; right ) {
        tmp       =  s[left];
        s[left]   =  s[right];
        s[right]  =  tmp;
        ++left;
        --right;
    }
}

<span class="dt">void</span> solve( <span class="dt">char</span> *s ) {
    <span class="dt">int</span> left = <span class="dv">0</span>, right = <span class="dv">0</span>, len = strlen(s);
    <span class="kw">while</span>( left &lt; len &amp;&amp; right &lt; len ) {
        <span class="kw">while</span>( s[right] &amp;&amp; s[right] != <span class="st">&#39; &#39;</span> ) {
            ++right;
        }
        <span class="kw">if</span>( !s[right] &amp;&amp; left &lt; right<span class="dv">-1</span> ) {
            reverse( s, left, right<span class="dv">-1</span> );    <span class="co">// &#26368;&#21518;&#19968;&#27573;</span>
            <span class="kw">break</span>;
        }
        reverse( s, left, right<span class="dv">-1</span> );
        left = right + <span class="dv">1</span>;                   <span class="co">// &#36339;&#36807;&#36830;&#32493;&#31354;&#26684;</span>
        <span class="kw">while</span>( s[left] == <span class="st">&#39; &#39;</span> ) {
            ++left;
        }
        right = left + <span class="dv">1</span>;
    }
    reverse( s, <span class="dv">0</span>, len<span class="dv">-1</span> );                 <span class="co">// &#36825;&#20010; len-1 &#21315;&#19975;&#19981;&#33021;&#26159; len</span>
}

<span class="dt">int</span> main() {
    <span class="dt">char</span> buf;
    sprintf( buf, <span class="st">&quot;</span><span class="ch">%s</span><span class="st">&quot;</span>, <span class="st">&quot;I love Sia Furler.&quot;</span> );
    printf( <span class="st">&quot;before: </span><span class="ch">%s\n</span><span class="st">&quot;</span>, buf );
    solve( buf );
    printf( <span class="st">&quot;</span><span class="ch">%s\n</span><span class="st">&quot;</span>, buf );
}</code></pre></div>
<p><code>Furler. Sia love I</code></p>
</dd>
</dl></li>
<li><dl>
<dt>&#31867;&#20284;&#25163;&#26426;&#38190;&#30424;</dt>
<dd><p>&#27599;&#20010;&#25968;&#23383;&#23545;&#24212;&#20960;&#20010;&#23383;&#27597;&#12290;&#25353;&#19979;&#25968;&#23383;&#38190;&#65292;&#23601;&#24847;&#21619;&#30528;&#22810;&#20010;&#23383;&#31526;&#32452;&#21512;&#65292;&#26377;&#20851;&#36825;&#20123;&#23383;&#31526;&#32452;&#21512;&#30340;&#22995;&#21517;&#21644;&#25163;&#26426;&#21495;&#23601;&#25214;&#21040;&#12290;&#38382;&#39064;&#65292;&#22914;&#20309;&#23454;&#29616;&#19968;&#20010;&#20197;&#21517;&#23383;&#30340;&#25353;&#38190;&#32534;&#30721;&#20026;&#21442;&#25968;&#65292;&#24182;&#36820;&#22238;&#25152;&#26377;&#21487;&#33021;&#30340;&#21305;&#37197;&#21517;&#23383;&#30340;&#20989;&#25968;</p>
<p>&#26041;&#27861;&#65306;&#25226;&#21517;&#23383;&#23545;&#24212;&#30340;&#25968;&#23383;&#25353;&#38190;&#24418;&#25104;&#19968;&#20010;&#21807;&#19968;&#30340;&#26631;&#35782;&#31526;&#65292;&#20540;&#23384;&#20837;&#25968;&#23383;&#38190;&#23545;&#24212;&#30340;&#21517;&#23383; <code>map&lt;int,map&lt;string&gt; &gt; rec;</code></p>
</dd>
</dl></li>
<li>sequential file &#37324;&#30340; 4,300,000,000 &#20010; 32-bit integers &#20013;&#25214; one that appears at least twice&#65311;</li>
</ul>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>column-3: data structures programs <code class="fold">@</code></dt>
<dd><p><code>if( k == 500 ) c500++;</code>&#8230;&#8230;&#22914;&#27492;&#34507;&#30140;&#30340;&#20195;&#30721;&#12290;</p>
<p>&#20449;&#20214;&#27169;&#26495;&#12290;</p>
<p>Principles</p>
<ul>
<li><strong>Don&#8217;t write a big program when a little one will do.</strong></li>
<li>&#20351;&#29992;&#25968;&#32452;&#37325;&#26032;&#32534;&#20889;&#37325;&#22797;&#20195;&#30721;&#12290;</li>
<li>&#23553;&#35013;&#22797;&#26434;&#32467;&#26500;&#12290;</li>
<li>&#23613;&#21487;&#33021;&#20351;&#29992;&#39640;&#32423;&#24037;&#20855;&#12290;&#21517;&#23383;-&#20540;&#23545;&#65292;&#30005;&#23376;&#34920;&#26684;&#65288;&#20108;&#32500;&#25968;&#32452;&#65289;&#65292;&#25968;&#25454;&#24211;&#65292;&#29305;&#23450;&#32534;&#31243;&#35821;&#35328;&#30340;&#24378;&#22823;&#30340;&#24037;&#20855;&#12290;</li>
<li>&#20174;&#25968;&#25454;&#24471;&#20986;&#31243;&#24207;&#30340;&#32467;&#26500;&#12290;(<strong>let data structure the program.</strong>)</li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>column-4: writing correct programs <code class="fold">@</code></dt>
<dd><p>Knuth &#35828;&#65292;46 &#24180; binary search &#30340;&#35770;&#25991;&#20986;&#26469;&#20102;&#65292;62 &#24180;&#65292;&#32456;&#20110;&#26377;&#19968;&#20010; bug free &#30340;&#23454;&#29616;==&#12290;</p>
<p>&#26412;&#31456;&#20316;&#32773;&#20027;&#35201;&#35777;&#26126;&#20102;&#20108;&#20998;&#25628;&#32034;&#31243;&#24207;&#30340;&#27491;&#30830;&#24615;&#12290;</p>
<p>&#26500;&#36896;&#31243;&#24207;&#30340;&#27491;&#30830;&#24615;&#19978;&#26469;&#20808;&#35201;&#25214;&#21040;<strong>&#26029;&#35328;</strong>(assertions)&#65292;&#20063;&#23601;&#26159;&#25152;&#35859;&#30340;&#12304;&#24490;&#29615;&#19981;&#21464;&#24335;&#12305;&#65292;&#24403;&#28982;&#36825;&#20010;&#22312;&#23454;&#38469;&#31243;&#24207;&#20013;&#65292;&#21482;&#26377;&#38752;&#32463;&#39564;&#20102;&#12290;&#25214;&#21040;&#26029;&#35328;&#65292;&#21363;&#21487;&#20197;&#21246;&#21202;&#20986;&#65292;&#36755;&#20837;&#12289;&#31243;&#24207;&#21464;&#37327;&#21644;&#36755;&#20986;&#20043;&#38388;&#30340;&#20851;&#31995;&#65292;&#20351;&#24471;&#31243;&#24207;&#21592;&#21487;&#20197;&#20934;&#30830;&#38416;&#36848;&#36825;&#20123;&#20851;&#31995;&#12290;&#25343;&#20108;&#20998;&#26469;&#35828;&#65292;&#23601;&#26159;&#22914;&#26524;&#20803;&#32032; t &#22312;&#25968;&#32452;&#20013;&#65292;&#37027;&#20040;&#23427;&#19968;&#23450;&#22312; range &#20013;&#12290;&#22312;&#20043;&#21518;&#25152;&#26377;&#30340;&#25805;&#20316;&#37117;&#35201;&#36981;&#24490;&#35813;&#19981;&#21464;&#24335;&#12290;</p>
<p>&#25509;&#19979;&#26469;&#30475;&#31243;&#24207;&#30340;&#32467;&#26500;&#12290;</p>
<ul>
<li>&#22914;&#26524;&#26159;&#39034;&#24207;&#25511;&#21046;&#32467;&#26500; (sequential control structures)&#12290;&#21017;&#21487;&#20197;&#36890;&#36807;&#22312;&#35821;&#21477;&#20043;&#38388;&#28155;&#21152;&#26029;&#35328;&#24182;&#20998;&#21035;&#20998;&#26512;&#31243;&#24207;&#25191;&#34892;&#30340;&#27599;&#19968;&#27493;&#12290;</li>
<li>&#22914;&#26524;&#26159;&#36873;&#25321;&#25511;&#21046;&#32467;&#26500; (selection control structures)&#65292;&#21017;&#35201;&#23545;&#27599;&#19968;&#20010;&#20998;&#25903;&#36827;&#34892;&#32467;&#26500;&#30340;&#27491;&#30830;&#24615;&#35777;&#26126;&#12290;&#36873;&#25321;&#27599;&#19968;&#20010;&#20998;&#25903;&#65292;&#20351;&#29992;&#26029;&#35328;&#26469;&#35777;&#26126;&#12290;&#20363;&#22914;&#65292;&#22914;&#26524;&#36827;&#20837;&#20102; <code>if i &gt; j</code> &#30340;&#20998;&#25903;&#65292;&#37027;&#20040;&#25105;&#20204;&#23601;&#21487;&#20197;&#26029;&#35328; <code>i &gt; j</code> &#24182;&#19988;&#20351;&#29992;&#36825;&#20010;&#20107;&#23454;&#26469;&#25512;&#20498;&#20986;&#19979;&#19968;&#20010;&#26029;&#35328;&#12290;</li>
<li>&#26368;&#40635;&#28902;&#23601;&#26159;&#36845;&#20195;&#25511;&#21046;&#32467;&#26500; (iteration control structures)&#12290;&#35201;&#35777;&#26126;&#24490;&#29615;&#30340;&#27491;&#30830;&#24615;&#65292;&#23601;&#24517;&#39035;&#20026;&#20854;&#30830;&#31435; 3 &#20010;&#24615;&#36136;&#12290;
<ul>
<li>&#21021;&#22987;&#21270; (initialization)&#65306;&#24490;&#29615;&#21021;&#27425;&#25191;&#34892;&#30340;&#26102;&#20505;&#19981;&#21464;&#24335;&#20026;&#30495;&#12290;</li>
<li>&#20445;&#25345; (preservation)&#65306;&#22914;&#26524;&#22312;&#26576;&#27425;&#36845;&#20195;&#24320;&#22987;&#30340;&#26102;&#20505;&#20197;&#21450;&#24490;&#29615;&#20307;&#25191;&#34892;&#30340;&#26102;&#20505;&#65292;&#19981;&#21464;&#24335;&#20026;&#30495;&#65292;&#37027;&#20040;&#24490;&#29615;&#25191;&#34892;&#23436;&#27605;&#30340;&#26102;&#20505;&#19981;&#21464;&#24335;&#20173;&#28982;&#20026;&#30495;&#12290;&#27599;&#27425;&#36845;&#20195;&#37117;&#20445;&#25345;&#35813;&#19981;&#21464;&#24335;&#20026;&#30495;&#12290;</li>
<li>&#32456;&#27490; (termination)&#65306;&#24490;&#29615;&#33021;&#22815;&#32456;&#27490;&#65292;&#24182;&#19988;&#21487;&#20197;&#24471;&#21040;&#39044;&#26399;&#30340;&#32467;&#26524;&#65292;&#32780;&#19988;&#25105;&#20204;&#24517;&#39035;&#29992;&#20854;&#20182;&#26041;&#27861;&#35777;&#26126;&#24490;&#29615;&#19968;&#23450;&#33021;&#32456;&#27490;&#12290;&#23601;&#20687;&#20108;&#20998;&#27599;&#27425;&#33539;&#22260;&#37117;&#22312;&#20943;&#23569;&#65292;&#35838;&#21518;&#20064;&#39064;&#65292;&#35910;&#23376;&#27599;&#27425;&#37117;&#22312;&#20943;&#23569;&#19968;&#20010;&#12290;</li>
</ul>
<p>&#23545;&#20110;&#20989;&#25968;&#30340;&#27491;&#30830;&#24615;&#35777;&#26126;&#65292;&#39318;&#20808;&#35201;&#20351;&#29992;&#20004;&#20010;&#26029;&#35328;&#26469;&#38472;&#36848;&#30446;&#30340;&#12290;</p>
<ul>
<li>&#21069;&#32622;&#26465;&#20214;&#65306;&#35843;&#29992;&#35813;&#20989;&#25968;&#20043;&#21069;&#25104;&#31435;&#30340;&#29366;&#24577;&#12290;</li>
<li>&#21518;&#32622;&#26465;&#20214;&#30340;&#27491;&#30830;&#24615;&#30001;&#20989;&#25968;&#22312;&#32456;&#27490;&#26102;&#20445;&#35777;&#12290;</li>
</ul>
<p>&#25343;&#20108;&#20998;&#26469;&#35828;&#65292;&#21069;&#32622;&#26465;&#20214;&#26159;&#24207;&#21015;&#26377;&#24207;&#65288;&#20108;&#20998;&#65289;&#65292;&#21518;&#32622;&#26465;&#20214;&#26159;&#25214;&#27809;&#26377;&#25214;&#21040;&#20803;&#32032;&#65292;&#36820;&#22238;&#20301;&#32622;&#12290;</p>
<p>&#22914;&#26524;&#22312;&#21069;&#32622;&#26465;&#20214;&#28385;&#36275;&#24773;&#20917;&#19979;&#35843;&#29992;&#20989;&#25968;&#65292;&#37027;&#20040;&#20989;&#25968;&#30340;&#25191;&#34892;&#23558;&#30830;&#31435;&#21518;&#32622;&#26465;&#20214;&#65292;&#36825;&#23601;&#26159;&#22865;&#32422;&#32534;&#31243;&#12290;</p>
<p><strong>&#35777;&#26126;&#31243;&#24207;&#30340;&#27491;&#30830;&#24615;&#26159;&#19968;&#38376;&#23398;&#38382;&#65292;&#22914;&#26524;&#36829;&#21453;&#26029;&#35328;&#23601;&#25351;&#26126;&#20102;&#31243;&#24207;&#30340;&#38169;&#35823;&#25152;&#22312;&#12290;&#31243;&#24207;&#29366;&#24577;&#30340;&#26029;&#35328;&#23545;&#29702;&#35299;&#31243;&#24207;&#24456;&#26377;&#24110;&#21161;&#12290;</strong></p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> binary_search( <span class="dt">int</span> A[], <span class="dt">int</span> n, <span class="dt">int</span> target ) {
    <span class="dt">int</span> low = <span class="dv">0</span>, high = n<span class="dv">-1</span>;        <span class="co">// &#27880;&#24847;&#19981;&#26159; n&#65292;&#22240;&#20026; low &#21644; high &#37117;&#26159;&#38381;&#21306;&#38388;&#30340;&#31471;&#28857;&#12290;</span>
    <span class="dt">int</span> mid;
    <span class="kw">while</span>( low &lt;= high ) {
        mid = (low+high)/<span class="dv">2</span>;
        <span class="kw">if</span>( A[mid] &lt; target ) {
            low = mid<span class="dv">+1</span>;
        } <span class="kw">else</span> <span class="kw">if</span>( A[mid] &gt; target ) {
            high = mid<span class="dv">-1</span>;
        } <span class="kw">else</span> {
            <span class="kw">return</span> mid;
        }
    }
    <span class="kw">return</span> <span class="dv">-1</span>;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>column-5: a small matter of programming <code class="fold">@</code></dt>
<dd><p>&#20027;&#35201;&#35762;&#35299;&#22914;&#20309;&#20445;&#35777;&#32534;&#31243;&#30340;&#27491;&#30830;&#24615;&#12290;&#22312;&#31243;&#24207;&#20013;&#21152;&#20837;&#26029;&#35328;&#65288;<code>assert(&#26029;&#35328;&#20869;&#23481;) //&#22914;&#26524;&#38169;&#35823;&#65292;&#21017;&#32456;&#27490;&#31243;&#24207;&#12290;&#21542;&#21017;&#27491;&#24120;&#25191;&#34892;&#65289;</code>&#65289;&#12290;</p>
<p>&#19968;&#20123; debug &#25216;&#24039;&#65311;assert &#20160;&#20040;&#30340;&#20351;&#29992;&#65292;&#33258;&#21160;&#21270;&#27979;&#35797;&#12290;</p>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>part-2: performance <code class="fold">@</code></dt>
<dd><p>&#21521;&#24615;&#33021;&#21069;&#36827;&#65281;</p>
<ul>
<li><dl>
<dt>column-6: perspective on performance <code class="fold">@</code></dt>
<dd><p>&#22914;&#26524;&#35201;&#25552;&#39640;&#36719;&#20214;&#30340;&#24615;&#33021;&#65292;&#38656;&#35201;&#20174;&#19979;&#38754;&#20960;&#20010;&#26041;&#38754;&#20837;&#25163;&#65306;</p>
<ul>
<li>&#31639;&#27861;&#19982;&#25968;&#25454;&#32467;&#26500;</li>
<li>&#31639;&#27861;&#35843;&#20248;</li>
<li>&#25968;&#25454;&#32467;&#26500;&#37325;&#32452;</li>
<li>&#19982;&#31995;&#32479;&#26080;&#20851;&#30340;&#20195;&#30721;&#30340;&#35843;&#20248;&#65288;float &#21462;&#20195; double&#65289;&#12290;</li>
<li>&#19982;&#31995;&#32479;&#30456;&#20851;&#30340;&#35843;&#20248;&#65292;&#25226;&#32463;&#24120;&#20351;&#29992;&#30340;&#20989;&#25968;&#36827;&#34892;&#21152;&#36895;&#65292;&#27604;&#22914;&#20851;&#38190;&#20195;&#30721;&#20351;&#29992;&#27719;&#32534;&#20195;&#26367;&#39640;&#32423;&#35821;&#35328;</li>
<li>&#30828;&#20214;&#19978;&#20351;&#29992;&#28014;&#28857;&#21152;&#36895;&#22120;&#12290;</li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>column-7: the back of the envelope <code class="fold">@</code></dt>
<dd><p>&#23494;&#35199;&#35199;&#27604;&#27827;&#19968;&#22825;&#27969;&#20986;&#22810;&#23569;&#27700;&#65311;</p>
<p><strong>&#37327;&#32434;&#26816;&#39564;</strong>&#65306;&#21363;&#22312;&#26816;&#39564;&#20960;&#20309;&#25110;&#29289;&#29702;&#31561;&#24335;&#26102;&#65292;&#25105;&#20204;&#21487;&#20197;&#20808;&#30475;&#30475;&#20854;&#20013;&#30340;&#21333;&#20301;&#22312;&#20056;&#38500;&#36807;&#21518;&#26159;&#21542;&#19982;&#21407;&#24335;&#33021;&#20445;&#25345;&#19968;&#33268;&#12290;</p>
<p>&#27169; 9 &#27861;&#65288;&#33293; 9 &#27861;&#65289;&#65306;&#22312;&#21152;&#27861;&#35745;&#31639;&#24403;&#20013;&#65292;&#21152;&#25968;&#30340;&#25968;&#23383;&#24635;&#21644;&#19982;&#21644;&#25968;&#30340;&#25968;&#23383;&#24635;&#21644;&#27169; 9 &#30456;&#31561;&#12290;&#20030;&#20010;&#20363;&#23376;&#65306;3142+2718+1123=6973. &#65288;3+1+4+2+2+7+1+8+1+1+2+3&#65289;%9=7=&#65288;6+9+7+3&#65289;%9.</p>
<dl>
<dt>72 &#27861;&#21017;</dt>
<dd><p>&#8220;&#20551;&#35774;&#20197;&#24180;&#21033;&#29575; r% &#25237;&#36164;&#19968;&#31508;&#38065; y &#24180;&#65292;&#22914;&#26524; r&#215;y=72&#65292;&#37027;&#20040;&#20320;&#30340;&#25237;&#36164;&#24046;&#19981;&#22810;&#20250;&#32763;&#20493;&#12290;&#8221;&#27604;&#22914;&#24180;&#21033;&#29575; 6% &#25237;&#36164; 1000 &#32654;&#20803; 12 &#24180;&#65292;&#21487;&#20197;&#24471;&#21040; 2012 &#32654;&#20803;&#12290;&#24456;&#26377;&#24847;&#24605;&#65374;</p>
<p>&#20551;&#35774;&#19968;&#20010;&#31243;&#24207; n=40 &#26102;&#38656;&#35201; 10 &#31186;&#65292;&#24182;&#19988; n &#22686;&#21152; 1&#65292;&#26102;&#38388;&#23601;&#22686;&#21152; 12%&#65292;&#26681;&#25454; 72 &#27861;&#21017;&#65292;&#27599;&#24403; n &#22686;&#21152; 6&#65292;&#36816;&#34892;&#26102;&#38388;&#23601;&#21152;&#20493;&#65292;n &#27599;&#22686;&#21152; 60&#65292;&#36816;&#34892;&#26102;&#38388;&#23601;&#26159;&#21407;&#26469;&#30340; 1000 &#20493;&#65288;n &#22686;&#21152; 60&#65292;&#20063;&#23601;&#26159;&#35828;&#32763; 10 &#20493;&#65292;2 &#30340; 10 &#27425;&#26041;&#26159; 1024&#65289;</p>
<p>tip&#65306;&#960;&#31186; = 1 &#32435;&#19990;&#32426;&#31186; = 10^-9 * 100 s = 10^-7 s</p>
<p><strong>&#19968;&#24180;&#26377; pi * 10^7 &#31186;&#12290;</strong></p>
<p>pi&#215;10<sup>7</sup> = 2<sup>1.65</sup>&#215;10&#215;10<sup>6</sup> = 2<sup>1.65+3.3+20</sup> = 2<sup>24.95</sup></p>
<p>&#19968;&#20998;&#38047; &#31561;&#20110; 60s&#65288;2<sup>5.9</sup>s&#65289;&#65292;&#19968;&#23567;&#26102; 60<sup>2</sup>s&#65288;2<sup>11.8</sup>s&#65289;&#65292;&#19968;&#22825;&#26377; 60<sup>2</sup>&#215;24s&#65288;2<sup>11.8</sup>2<sup>4.6</sup> = 2<sup>16.4</sup>&#65289;s&#12290;&#19968;&#24180;&#23601;&#26377; 2<sup>16.4&#215;2</sup>8.5^ = 2<sup>24.9</sup>&#12290;</p>
<dl>
<dt><a href="https://en.wikipedia.org/wiki/Rule_of_thumb">Rule of thumb - Wikipedia, the free encyclopedia</a></dt>
<dd><p>Statistical &#8211; Rule of 72: A rule of thumb for exponential growth at a constant rate. An approximation of the doubling time formula used in population growth, according to which the doubling time is roughly equal to 70 divided by the percent growth rate (using continuous compounding, the actual number would be about 69.31 or 100 times the natural logarithm of 2). In terms of money, since most people use the annual effective interest rate (which is equivalent to annual compounding) for interest rates between 4% and 12%, the number that gives the most accurate result is actually 72. Therefore, one may divide 72 by the percent interest rate to determine the approximate amount of time it would take to double one&#8217;s money in an investment. For example, at 8% interest, the investment will double in approximately 9 years (72/8 = 9).</p>
<dl>
<dt><a href="https://en.wikipedia.org/wiki/Rule_of_72">Rule of 72 - Wikipedia, the free encyclopedia</a> <code class="fold">@</code></dt>
<dd><p>For instance, if you were to invest $100 with compounding interest at a rate of 9% per annum, the rule of 72 gives 72/9 = 8 years required for the investment to be worth $200; an exact calculation gives ln(2)/ln(1+.09) = 8.0432 years.</p>
<p>To determine the time for money&#8217;s buying power to halve, financiers simply divide the rule-quantity by the inflation rate. Thus at 3.5% inflation using the rule of 70, it should take approximately 70/3.5 = 20 years for the value of a unit of currency to halve.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>&#23433;&#20840;&#31995;&#25968;</dt>
<dd><p>&#20316;&#32773;&#24378;&#35843;&#23433;&#20840;&#24615;&#65292;&#24182;&#19988;&#20030;&#20102;&#19968;&#20010;&#20363;&#23376;&#12290;&#19968;&#20010;&#24314;&#31569;&#24037;&#31243;&#24072;&#23545;&#20110;&#26725;&#24314;&#31569;&#30340;&#30772;&#29615;&#20989;&#25968;&#30340;&#25968;&#23398;&#20844;&#24335;&#19981;&#25026;&#65288;&#23545;&#20110;&#26725;&#26469;&#35828;&#65292;&#39118;&#21147;&#12289;&#38663;&#21160;&#31561;&#30772;&#29615;&#22240;&#23376;&#37117;&#21487;&#20197;&#36890;&#36807;&#22797;&#26434;&#30340;&#25968;&#23398;&#20844;&#24335;&#25512;&#23548;&#20986;&#26469;&#65289;&#65292;&#20110;&#26159;&#20182;&#35774;&#24819;&#20182;&#30340;&#26725;&#20250;&#36973;&#21463;&#21040;&#27491;&#24120;&#30772;&#29615;&#30340; 6 &#20493;&#12290;&#32467;&#26524;&#26159;&#19982;&#20182;&#21516;&#26102;&#26399;&#24314;&#36896;&#30340;&#26725;&#20840;&#37096;&#20498;&#22604;&#65292;&#21482;&#26377;&#20182;&#30340;&#26725;&#23673;&#31435;&#19981;&#20498;&#12290;</p>
<p>&#8220;&#25105;&#20204;&#26159;&#21644; john Roebling(&#25991;&#20013;&#30340;&#24314;&#31569;&#24037;&#31243;&#24072;) &#19968;&#26679;&#30340;&#24037;&#31243;&#24072;&#20040;&#65311;&#25105;&#24456;&#24576;&#30097;&#8221;</p>
</dd>
<dt>Little&#23450;&#24459;</dt>
<dd><p>Denning &#21644; Buzen &#20171;&#32461;&#30340; Little &#23450;&#24459;&#8220;&#31995;&#32479;&#20013;&#29289;&#20307;&#30340;&#24179;&#22343;&#25968;&#37327;&#31561;&#20110;&#29289;&#20307;&#31163;&#24320;&#31995;&#32479;&#30340;&#24179;&#22343;&#36895;&#29575;&#21644;&#27599;&#20010;&#29289;&#20307;&#22312;&#31995;&#32479;&#20013;&#20572;&#30041;&#30340;&#24179;&#22343;&#26102;&#38388;&#30340;&#20056;&#31215;&#65288;&#24182;&#19988;&#22914;&#26524;&#29289;&#20307;&#31163;&#24320;&#21644;&#36827;&#20837;&#31995;&#32479;&#30340;&#36890;&#20307;&#20986;&#20837;&#27969;&#26159;&#24179;&#34913;&#30340;&#65292;&#37027;&#20040;&#31163;&#24320;&#36895;&#29575;&#20063;&#23601;&#26159;&#36827;&#20837;&#36895;&#29575;&#12290;&#65289;&#8221;&#20070;&#20013;&#20030;&#20102;&#20010;&#20363;&#23376;&#65292;&#20551;&#22914;&#20320;&#35201;&#36827;&#20837;&#19968;&#20010;&#28779;&#29190;&#30340;&#22812;&#24635;&#20250;&#65288;&#32654;&#22269;&#30005;&#24433;&#20013;&#32463;&#24120;&#35265;&#21040;&#65289;&#65292;&#8220;<strong>&#36825;&#20010;&#22320;&#26041;&#21487;&#20197;&#23481;&#32435;&#32422; 60 &#20154;&#65292;&#27599;&#20010;&#20154;&#22312;&#37324;&#38754;&#36887;&#30041;&#30340;&#26102;&#38388;&#22823;&#32422;&#26159; 3 &#23567;&#26102;&#65292;&#22240;&#27492;&#25105;&#20204;&#36827;&#20837;&#22812;&#24635;&#20250;&#30340;&#36895;&#29575;&#22823;&#27010;&#26159;&#27599;&#23567;&#26102; 20 &#20154;</strong>&#65292;&#29616;&#22312;&#22312;&#38431;&#20237;&#20013;&#25105;&#20204;&#21069;&#38754;&#36824;&#26377; 20 &#20154;&#65292;&#20063;&#23601;&#26159;&#35828;&#25105;&#20204;&#35201;&#31561;&#22823;&#32422; 1 &#20010;&#23567;&#26102;&#65292;&#19981;&#22914;&#25105;&#20204;&#22238;&#23478;&#21435;&#35835;&#12298;&#32534;&#31243;&#29664;&#29585;&#12299;&#21543;&#12290;&#8221;&#21704;&#21704;</p>
</dd>
</dl>
<p>&#22312;&#36827;&#34892;&#31895;&#30053;&#20272;&#31639;&#30340;&#26102;&#20505;&#65292;&#35201;&#20999;&#35760;&#29233;&#22240;&#26031;&#22374;&#30340;&#21517;&#35328;&#65306;</p>
<blockquote>
<p>&#20219;&#20309;&#20107;&#37117;&#24212;&#23613;&#37327;&#31616;&#21333;&#65292;&#20294;&#19981;&#23452;&#36807;&#20110;&#31616;&#21333;&#12290;</p>
</blockquote>
</dd>
</dl></li>
<li><dl>
<dt>column-8: algorithms design techniques <code class="fold">@</code></dt>
<dd><p><a href="http://blog.csdn.net/tianshuai1111/article/details/7566244">&#12304;&#32534;&#31243;&#29664;&#29585;&#12305;&#31532;&#20843;&#31456; &#31639;&#27861;&#35774;&#35745;&#25216;&#26415; - &#23567;&#30000;&#30340;&#19987;&#26639; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></p>
</dd>
</dl></li>
<li><dl>
<dt>column-9: code tuning <code class="fold">@</code></dt>
<dd><p>&#26368;&#21518;&#65292;&#20316;&#32773;&#35762;&#21040;&#65292;&#23545;&#20110;&#20195;&#30721;&#35843;&#20248;&#26368;&#37325;&#35201;&#30340;&#21407;&#21017;&#23601;&#26159;&#23613;&#37327;&#23569;&#29992;&#23427;&#12290;&#20316;&#32773;&#20174;&#25928;&#29575;&#30340;&#35282;&#33394;&#12289;&#24230;&#37327;&#24037;&#20855;&#12289;&#35774;&#35745;&#23618;&#38754;&#12289;&#21452;&#20995;&#21073;&#20960;&#20010;&#26041;&#38754;&#20998;&#26512;&#20102;&#20195;&#30721;&#35843;&#20248;&#30340;&#20248;&#21155;&#20004;&#38754;&#24615;&#12290;&#22238;&#24402;&#21040;&#19968;&#28857;&#65292;&#23601;&#26159;&#23545;&#20110;&#19968;&#20010;&#20248;&#31168;&#30340;&#31243;&#24207;&#21592;&#65292;&#19981;&#35770;&#26159;&#22312;&#31243;&#24207;&#32500;&#25252;&#65292;&#31243;&#24207;&#21487;&#38752;&#24615;&#65292;&#36824;&#26159;&#31243;&#24207;&#30340;&#25928;&#29575;&#26041;&#38754;&#65292;&#37117;&#19981;&#33021;&#21482;&#39038;&#19968;&#22836;&#65292;&#32780;&#26159;&#35201;&#23613;&#37327;&#20570;&#19968;&#20010;&#32508;&#21512;&#30340;&#35780;&#20272;&#20877;&#26681;&#25454;&#23454;&#38469;&#38656;&#27714;&#36827;&#34892;&#21462;&#33293;&#12290;</p>
<p><a href="http://blog.csdn.net/tianshuai1111/article/details/7569326">&#12304;&#32534;&#31243;&#29664;&#29585;&#12305;&#31532;&#20061;&#31456; &#20195;&#30721;&#35843;&#20248; - &#23567;&#30000;&#30340;&#19987;&#26639; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></p>
</dd>
</dl></li>
<li><dl>
<dt>column-10: squeezing space <code class="fold">@</code></dt>
<dd><p><a href="http://blog.csdn.net/tianshuai1111/article/details/7575563">&#12304;&#32534;&#31243;&#29664;&#29585;&#12305;&#31532;&#21313;&#31456; &#33410;&#30465;&#31354;&#38388; - &#23567;&#30000;&#30340;&#19987;&#26639; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></p>
<p>principles</p>
<ul>
<li>the cost of space</li>
<li>the &#8220;hot spot&#8221; of space (&#21738;&#37324;&#26159;&#32791;&#26102;&#26368;&#38271;&#30340;&#65311;)</li>
<li>measuring space</li>
<li>tradeoffs</li>
<li>work with the environment</li>
<li>use the right tool fo the job.</li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>part-3 <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>column-11: sorting <code class="fold">@</code></dt>
<dd><p><a href="http://blog.csdn.net/dazhong159/article/details/7793132">&#32534;&#31243;&#29664;&#29585;&#31532;&#21313;&#19968;&#31456;&#8212;-&#25490;&#24207; - dazhong159&#30340;&#19987;&#26639; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></p>
</dd>
</dl></li>
<li><p>column-12: a sample problem</p></li>
<li><p>column-13: searching</p></li>
<li><p>column-14: heaps</p></li>
<li><p>column-15: strings of pearls</p></li>
</ul>
</dd>
</dl></li>
</ul>
<p>refs and see also <code class="fold">@</code></p>
<ul>
<li><a href="http://blog.csdn.net/yang_yulei/article/details/36068789">&#12298;&#32534;&#31243;&#29664;&#29585;&#12299;&#8212; &#31508;&#35760;&#12290;&#27983;&#35272;&#27492;&#25991;&#65292;&#19968;&#31397;&#27492;&#20070;&#12290; - &#33756;&#40479;&#30340;&#33258;&#30041;&#22320; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
<li><a href="http://blog.csdn.net/insistgogo/article/details/7749328">&#32534;&#31243;&#29664;&#29585;_&#31532;&#20108;&#31456;_&#21834;&#21704; &#31639;&#27861; - &#24605;&#32771;&#65292;&#24605;&#32771;&#65292;&#20877;&#24605;&#32771;~ - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
<li><a href="http://blog.csdn.net/omashion/article/details/11694141" class="heart">&#32534;&#31243;&#29664;&#29585;&#31532;&#22235;&#31456; - chloe - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
<li><a href="http://www.jimye.com/bian-cheng-zhu-ji-di-qi-zhang-cu-lue-gu-ji/">[&#32534;&#31243;&#29664;&#29585;] &#31532;&#19971;&#31456;&#31895;&#30053;&#20272;&#35745;</a></li>
</ul>
</dd>
<dt>VisuAlgo - visualising data structures and algorithms through animation <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>&#20882;&#27873;&#25490;&#24207; <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-17-58-bubble.gif" />

</div>
<p>&#22823;&#27873;&#27873;&#39128;&#19978;&#21435;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#36873;&#25321;&#25490;&#24207; <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-19-47-select.gif" />

</div>
<p>&#36873;&#25321;&#19968;&#20010; pivot &#26469;&#27604;&#12290;&#28982;&#21518;&#26356;&#26032;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#25554;&#20837;&#25490;&#24207; <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-22-49-insert.gif" />

</div>
<p>&#24038;&#36793;&#26159;&#25490;&#22909;&#30340;&#65292;&#19981;&#26029;&#25226;&#21491;&#36793;&#27809;&#26377;&#25490;&#22909;&#30340;&#25554;&#20837;&#36827;&#21435;&#12290;&#27880;&#24847;&#31227;&#20301;&#30340;&#26102;&#20505; i &#21644; j&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#24402;&#24182;&#25490;&#24207; <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-24-32-merge.gif" />

</div>
</dd>
</dl></li>
<li><dl>
<dt>&#24555;&#25490; <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-25-47-quick.gif" />

</div>
</dd>
</dl></li>
<li><dl>
<dt>&#38543;&#26426;&#24555;&#25490; <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-26-57-rquick.gif" />

</div>
</dd>
</dl></li>
<li><dl>
<dt>&#35745;&#25968;&#25490;&#24207; <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-28-54-count.gif" />

</div>
</dd>
</dl></li>
<li><dl>
<dt>&#22522;&#25968;&#25490;&#24207; <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-34-41-radix.gif" />

</div>
</dd>
</dl></li>
<li><dl>
<dt>create binary heap <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-45-26-create-binary-heap-Onlgn.gif" />

</div>
<div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-46-26-create-binary-heap-On.gif" />

</div>
</dd>
</dl></li>
<li><dl>
<dt>heap sort <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-52-11-heap-sort.gif" />

</div>
</dd>
</dl></li>
<li><dl>
<dt>MISC <code class="fold">@</code></dt>
<dd><p><img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-58-31-pred.gif" alt="a" /> <img src="http://whudoc.qiniudn.com/2016/2016-08-06_10-59-12-next.gif" alt="b" /> <img src="http://whudoc.qiniudn.com/2016/2016-08-06_11-04-07.gif" alt="c" /> <img src="http://whudoc.qiniudn.com/2016/2016-08-06_11-05-11-avl-balanced.gif" alt="d" /> <img src="http://whudoc.qiniudn.com/2016/firefox_2016-08-06_11-07-06.png" alt="e" /> <img src="http://whudoc.qiniudn.com/2016/firefox_2016-08-06_11-07-22.png" alt="f" /> <img src="http://whudoc.qiniudn.com/2016/firefox_2016-08-06_11-08-17.png" alt="g" /> <img src="http://whudoc.qiniudn.com/2016/firefox_2016-08-06_11-08-42.png" alt="h" /></p>
</dd>
</dl></li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="http://visualgo.net/">VisuAlgo - visualising data structures and algorithms through animation</a></li>
</ul>
</dd>
<dt>Beauty of Programming <code class="fold">@</code></dt>
<dd><ul>
<li><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> main() {
    <span class="dt">int</span> i = <span class="dv">81</span>;
    <span class="kw">while</span>( i-- ) {
        <span class="kw">if</span>( i/<span class="dv">9</span>%<span class="dv">3</span> == i%<span class="dv">9</span>%<span class="dv">3</span> ) { <span class="kw">continue</span>; }
        printf( <span class="st">&quot;A = </span><span class="ch">%d</span><span class="st">, B = </span><span class="ch">%d\n</span><span class="st">&quot;</span>, i/<span class="dv">9+1</span>, i%<span class="dv">9+1</span> );
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="kw">struct</span> {
    <span class="dt">unsigned</span> <span class="dt">char</span> a:<span class="dv">4</span>;
    <span class="dt">unsigned</span> <span class="dt">char</span> b:<span class="dv">4</span>;
} i;

<span class="kw">for</span>( i.a = <span class="dv">1</span>; i.a &lt;= <span class="dv">9</span>; ++i.a ) {
    <span class="kw">for</span>( i.b = <span class="dv">1</span>; i.b &lt;= <span class="dv">9</span>; ++i.b ) {
        <span class="kw">if</span>( i.a%<span class="dv">3</span> != i.b%<span class="dv">3</span> ) {
            printf( <span class="st">&quot;A = </span><span class="ch">%d</span><span class="st">, B = </span><span class="ch">%d\n</span><span class="st">&quot;</span>, i.a, i.b );
        }
    }
}</code></pre></div></li>
<li><p>XOR</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> main() {
    <span class="dt">int</span> A[] = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">3</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">9</span> }; <span class="co">// 0!</span>
    <span class="dt">int</span> x = <span class="dv">0</span>;
    <span class="kw">for</span>( <span class="dt">int</span> i =<span class="dv">0</span>; i &lt; <span class="kw">sizeof</span>(A)/<span class="kw">sizeof</span>(A[<span class="dv">0</span>]); ++i ) {
        x ^= A[i]; <span class="co">// communitive rule, xor</span>
    }
    printf( <span class="st">&quot;the missing one is: </span><span class="ch">%d\n</span><span class="st">&quot;</span>, x );
}</code></pre></div></li>
</ul>
</dd>
</dl>
<h2 id="section-2">2.</h2>
<dl>
<dt>&#24120;&#35265; C/C++ &#20989;&#25968; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt><code class="sourceCode cpp">size_t strlen( <span class="dt">const</span> <span class="dt">char</span> *str )</code> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">size_t strlen( <span class="dt">const</span> <span class="dt">char</span> *str )
{
    <span class="dt">const</span> <span class="dt">char</span> *s = str;
    <span class="kw">while</span>( *s ) { ++s; }
    <span class="kw">return</span> s-str;
}</code></pre></div>
<p>&#19981;&#35201;&#25226; <code>while( *s ) { ++s; }</code> &#20889;&#25104; <code>while( *s++ ) { }</code></p>
<p>&#28982;&#32780;&#36825;&#37324;&#21364;&#21487;&#20197;&#25226; <code>++</code> &#20889;&#22312; while &#30340;&#21028;&#26029;&#37324;&#38754;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">size_t strlen( <span class="dt">const</span> <span class="dt">char</span> *str )
{
    size_t i = <span class="dv">0</span>;
    <span class="kw">while</span>( *str++ ) { ++i; }
    <span class="kw">return</span> i;
}</code></pre></div>
<p>&#20989;&#25968;&#31614;&#21517;&#21487;&#20197;&#22312; <code>man strlen</code> &#25110;&#32773; <code>man 3 strlen</code> &#30475;&#21040;&#12290;</p>
<p>&#25110;&#32773;&#29992; for &#24490;&#29615;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">size_t strlen( <span class="dt">const</span> <span class="dt">char</span> *str ) {
    <span class="dt">const</span> <span class="dt">char</span> *s;
    <span class="kw">for</span> ( s = str; *s; ++s ) {}
    <span class="kw">return</span> (s - str);
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt><code class="sourceCode cpp"><span class="dt">char</span> * strcpy( <span class="dt">char</span> *to, <span class="dt">const</span> <span class="dt">char</span> *from )</code> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> * strcpy( <span class="dt">char</span> *to, <span class="dt">const</span> <span class="dt">char</span> *from  )
{
    <span class="kw">if</span> ( !from &amp;&amp; !to ) { <span class="kw">return</span> NULL; }
    <span class="dt">char</span> *p = to;
    <span class="kw">while</span>( (*p++=*from++) != <span class="dv">0</span> ) { }
    <span class="kw">return</span> to;
}</code></pre></div>
<p>&#21069;&#38754;&#30340;&#21028;&#26029;&#20284;&#20046;&#22810;&#20313;&#65292;&#22240;&#20026;&#25105;&#20204;&#19981;&#20851;&#24515; to &#26159;&#21542;&#26377;&#31354;&#38388;&#20197;&#21450;&#23427;&#21407;&#26469;&#30340;&#20869;&#23481;&#65292;&#25105;&#20204;&#20063;&#19981;&#38656;&#35201;&#30693;&#36947; from &#26159;&#21542;&#20026; NULL&#65288;&#22914;&#26524; NULL&#65292;&#37027;&#22312; while &#37324;&#38754;&#22797;&#21046;&#19968;&#20010; NULL &#23601;&#32467;&#26463;&#65292;&#20063;&#26159;&#31526;&#21512;&#39044;&#26399;&#30340;&#12290;&#65289;</p>
</dd>
</dl></li>
<li><dl>
<dt><code class="sourceCode cpp"><span class="dt">int</span> atoi( <span class="dt">const</span> <span class="dt">char</span> *str)</code> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> atoi( <span class="dt">const</span> <span class="dt">char</span> *str )
{
    <span class="co">// TODO: handle overflow</span>
    <span class="kw">if</span> ( !str ) { <span class="kw">return</span> <span class="dv">0</span>; }

    <span class="dt">int</span> len = strlen( str );
    <span class="dt">int</span> sign = <span class="dv">1</span>;

    <span class="dt">const</span> <span class="dt">char</span> *p = str;
    <span class="kw">while</span> ( *p == <span class="st">&#39; &#39;</span> ) {
        ++p;
    }

    <span class="kw">if</span> ( *p == <span class="st">&#39;+&#39;</span> ) { sign = <span class="dv">+1</span>; ++p; }
    <span class="kw">if</span> ( *p == <span class="st">&#39;-&#39;</span> ) { sign = <span class="dv">-1</span>; ++p; }

    <span class="dt">int</span> i = <span class="dv">0</span>;
    <span class="kw">while</span>( p &amp;&amp; <span class="st">&#39;0&#39;</span> &lt;= *p &amp;&amp; *p &lt;= <span class="st">&#39;9&#39;</span> ) {
        i = i * <span class="dv">10</span> + (*p - <span class="st">&#39;0&#39;</span>);
        ++p;
    }

    <span class="kw">return</span> i*sign;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> atoi( <span class="dt">const</span> <span class="dt">char</span> *str )
{
    <span class="dt">const</span> <span class="dt">char</span> *p = str;
    <span class="kw">while</span> ( *p == <span class="st">&#39; &#39;</span> ) { ++p; }

    <span class="dt">int</span> sign = <span class="dv">1</span>;
    <span class="kw">if</span> ( *p == <span class="st">&#39;+&#39;</span> ) { sign = <span class="dv">+1</span>; ++p; }
    <span class="kw">if</span> ( *p == <span class="st">&#39;-&#39;</span> ) { sign = <span class="dv">-1</span>; ++p; }

    <span class="dt">int</span> num = <span class="dv">0</span>;
    <span class="kw">while</span>( <span class="st">&#39;0&#39;</span> &lt;= *p &amp;&amp; *p &lt;= <span class="st">&#39;9&#39;</span> ) {
        <span class="co">// buggy here: -2^31 ~ 2^31-1, it&#39;s not symmetric</span>
        <span class="kw">if</span>( num &gt; INT_MAX / <span class="dv">10</span> || (num == INT_MAX/<span class="dv">10</span> &amp;&amp; (*p-<span class="st">&#39;0&#39;</span>)&gt;INTMAX%<span class="dv">10</span> ) {
            <span class="kw">return</span> sign == <span class="dv">-1</span> ? INT_MIN : INT_MAX;
        }
        num = num * <span class="dv">10</span> + (*p - <span class="st">&#39;0&#39;</span>);
        ++p;
    }

    <span class="kw">return</span> sign*num;
}</code></pre></div>
<p>see LeetCode String to Integer (atoi), <a href="http://leetcode.com/oldoj#question_8" class="uri">http://leetcode.com/oldoj#question_8</a>.</p>
</dd>
</dl></li>
<li><dl>
<dt><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">char</span> * convert( <span class="dt">char</span> buf[], <span class="dt">int</span> value )</code> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">const</span> <span class="dt">char</span>* convert( <span class="dt">char</span> buf[], <span class="dt">int</span> value )
{
    <span class="dt">static</span> <span class="dt">char</span> digits =
    { <span class="st">&#39;9&#39;</span>, <span class="st">&#39;8&#39;</span>, <span class="st">&#39;7&#39;</span>, <span class="st">&#39;6&#39;</span>, <span class="st">&#39;5&#39;</span>, <span class="st">&#39;4&#39;</span>, <span class="st">&#39;3&#39;</span>, <span class="st">&#39;2&#39;</span>, <span class="st">&#39;1&#39;</span>, <span class="st">&#39;0&#39;</span>,
        <span class="st">&#39;1&#39;</span>, <span class="st">&#39;2&#39;</span>, <span class="st">&#39;3&#39;</span>, <span class="st">&#39;4&#39;</span>, <span class="st">&#39;5&#39;</span>, <span class="st">&#39;6&#39;</span>, <span class="st">&#39;7&#39;</span>, <span class="st">&#39;8&#39;</span>, <span class="st">&#39;9&#39;</span> };
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">char</span> *<span class="dt">const</span> zero = digits + <span class="dv">9</span>; <span class="co">// zero &#25351;&#21521; &#39;0&#39;</span>
    <span class="co">// works for -2147483648 .. 2147483647</span>
    <span class="dt">int</span> i = value;
    <span class="dt">char</span>* p = buf;
    <span class="kw">do</span> {
        <span class="co">// lsd - least significant digit</span>
        <span class="dt">int</span> lsd = i % <span class="dv">10</span>; <span class="co">// lsd &#21487;&#33021;&#23567;&#20110; 0</span>
        <span class="co">// &#26159;&#21521;&#19979;&#21462;&#25972;&#36824;&#26159;&#21521;&#38646;&#21462;&#25972;?</span>
        *p++ = zero[lsd]; <span class="co">// &#19979;&#26631;&#21487;&#33021;&#20026;&#36127;</span>
        i /= <span class="dv">10</span>;
    } <span class="kw">while</span> (i != <span class="dv">0</span>);
    <span class="kw">if</span> (value &lt; <span class="dv">0</span>) {
        *p++ = <span class="st">&#39;-&#39;</span>;
    }
    *p = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>;
    std::reverse(buf, p);
    <span class="kw">return</span> p; <span class="co">// p - buf &#21363;&#20026;&#25972;&#25968;&#38271;&#24230;</span>
}

<span class="dt">int</span> main() {
    <span class="dt">char</span> buf;
    <span class="dt">int</span> num;
    <span class="kw">while</span>( <span class="dv">1</span> == scanf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;num ) ) {
        convert( buf, num );
        printf( <span class="st">&quot;</span><span class="ch">%d</span><span class="st"> -&gt; </span><span class="ch">\&quot;%s\&quot;\n</span><span class="st">&quot;</span>, num, buf );
    }
}</code></pre></div>
<p>&#19978;&#38754;&#30340;&#20195;&#30721;&#26469;&#33258; chenshuo&#65292;&#20294;&#25105;&#24635;&#35273;&#24471;&#36825; 19 &#20010; digits &#25226;&#20107;&#24773;&#24324;&#22797;&#26434;&#20102;&#12290;&#25105;&#30340;&#31574;&#30053;&#26159;&#65292;&#36127;&#25968;&#25105;&#23601;&#25226;&#23427;&#20808;&#36716;&#25104;&#27491;&#25968;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">char</span>* convert( <span class="dt">char</span> buf[], <span class="dt">int</span> value )
{
    <span class="kw">if</span>( value &lt; <span class="dv">0</span> ) {
        buf = <span class="st">&#39;-&#39;</span>;
        <span class="kw">return</span> convert( buf<span class="dv">+1</span>, -value );
    }

    <span class="dt">static</span> <span class="dt">char</span> zero = { <span class="st">&#39;0&#39;</span>, <span class="st">&#39;1&#39;</span>, <span class="st">&#39;2&#39;</span>, <span class="st">&#39;3&#39;</span>, <span class="st">&#39;4&#39;</span>, <span class="st">&#39;5&#39;</span>, <span class="st">&#39;6&#39;</span>, <span class="st">&#39;7&#39;</span>, <span class="st">&#39;8&#39;</span>, <span class="st">&#39;9&#39;</span> };

    <span class="dt">char</span>* p = buf;
    <span class="kw">do</span> {
        *p++ = zero[value%<span class="dv">10</span>];
        value /= <span class="dv">10</span>;
    } <span class="kw">while</span> (value != <span class="dv">0</span>);
    *p = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>;
    std::reverse(buf, p);
    <span class="kw">return</span> p;
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt><code class="sourceCode cpp"><span class="dt">char</span> * strchr( <span class="dt">const</span> <span class="dt">char</span> *s, <span class="dt">int</span> c )</code> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> * strchr( <span class="dt">const</span> <span class="dt">char</span> *s, <span class="dt">int</span> c )
{
    <span class="kw">while</span>( *s ) {
        <span class="kw">if</span>( *s == c ) {
            <span class="kw">return</span> s;
        } <span class="kw">else</span> {
            ++s;
        }
    }
    <span class="kw">return</span> s;
}</code></pre></div>
<p>&#30446;&#27979;&#27809;&#26377; bug&#12290;&#25042;&#24471;&#27979;&#20102;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt><code>char * strstr( const char *haystack, const char *needle)</code> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> *strstr(<span class="dt">const</span> <span class="dt">char</span> *haystack, <span class="dt">const</span> <span class="dt">char</span> *needle) {
    <span class="co">// if needle is empty return the full string</span>
    <span class="kw">if</span> (!*needle) <span class="kw">return</span> (<span class="dt">char</span>*) haystack;

    <span class="dt">const</span> <span class="dt">char</span> *p1;
    <span class="dt">const</span> <span class="dt">char</span> *p2;
    <span class="dt">const</span> <span class="dt">char</span> *p1_advance = haystack;
    <span class="kw">for</span> (p2 = &amp;needle; *p2; ++p2) {
        p1_advance++;   <span class="co">// advance p1_advance M-1 times</span>
    }

    <span class="kw">for</span> (p1 = haystack; *p1_advance; p1_advance++) {
        <span class="dt">char</span> *p1_old = (<span class="dt">char</span>*) p1;
        p2 = needle;
        <span class="kw">while</span> (*p1 &amp;&amp; *p2 &amp;&amp; *p1 == *p2) {
            p1++;
            p2++;
        }
        <span class="kw">if</span> (!*p2) <span class="kw">return</span> p1_old;

        p1 = p1_old + <span class="dv">1</span>;
    }
    <span class="kw">return</span> NULL;
}</code></pre></div>
<p>see also KMP.</p>
</dd>
</dl></li>
<li><dl>
<dt>TODO: strncpy, strcmp, strcat <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> * __cdecl strcat (<span class="dt">char</span> * dst,<span class="dt">const</span> <span class="dt">char</span> * src)
{
    <span class="dt">char</span> * cp = dst;

    <span class="kw">while</span>( *cp )
        cp++;                   <span class="co">/* find end of dst */</span>

    <span class="kw">while</span>( *cp++ = *src++ ) ;       <span class="co">/* Copy src to end of dst */</span>

    <span class="kw">return</span>( dst );                  <span class="co">/* return dst */</span>

}

<span class="dt">int</span> __cdecl strcmp (<span class="dt">const</span> <span class="dt">char</span> * src,<span class="dt">const</span> <span class="dt">char</span> * dst)
{
    <span class="dt">int</span> ret = <span class="dv">0</span> ;

    <span class="kw">while</span>( ! (ret = *(<span class="dt">unsigned</span> <span class="dt">char</span> *)src - *(<span class="dt">unsigned</span> <span class="dt">char</span> *)dst) &amp;&amp; *dst)
        ++src, ++dst;

    <span class="kw">if</span> ( ret &lt; <span class="dv">0</span> )
        ret = <span class="dv">-1</span> ;
    <span class="kw">else</span> <span class="kw">if</span> ( ret &gt; <span class="dv">0</span> )
        ret = <span class="dv">1</span> ;

    <span class="kw">return</span>( ret );
}

size_t __cdecl strlen (<span class="dt">const</span> <span class="dt">char</span> * str)
{
    <span class="dt">const</span> <span class="dt">char</span> *eos = str;

    <span class="kw">while</span>( *eos++ ) ;

    <span class="kw">return</span>( (<span class="dt">int</span>)(eos - str - <span class="dv">1</span>) );
}

<span class="dt">char</span> * __cdecl strncat (<span class="dt">char</span> * front,<span class="dt">const</span> <span class="dt">char</span> * back,size_t count)
{
    <span class="dt">char</span> *start = front;

    <span class="kw">while</span> (*front++)
        ;
    front--;

    <span class="kw">while</span> (count--)
        <span class="kw">if</span> (!(*front++ = *back++))
            <span class="kw">return</span>(start);

        *front = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>;
        <span class="kw">return</span>(start);
}

<span class="dt">int</span> __cdecl strncmp (<span class="dt">const</span> <span class="dt">char</span> * first,<span class="dt">const</span> <span class="dt">char</span> * last,size_t count)
{
    <span class="kw">if</span> (!count)
        <span class="kw">return</span>(<span class="dv">0</span>);

    <span class="kw">while</span> (--count &amp;&amp; *first &amp;&amp; *first == *last)
    {
        first++;
        last++;
    }

    <span class="kw">return</span>( *(<span class="dt">unsigned</span> <span class="dt">char</span> *)first - *(<span class="dt">unsigned</span> <span class="dt">char</span> *)last );
}

<span class="co">/* Copy SRC to DEST.  */</span>
<span class="dt">char</span> *
strcpy (dest, src)
<span class="dt">char</span> *dest;
<span class="dt">const</span> <span class="dt">char</span> *src;
{
    reg_char c;
    <span class="dt">char</span> *__unbounded s = (<span class="dt">char</span> *__unbounded) CHECK_BOUNDS_LOW (src);
    <span class="dt">const</span> ptrdiff_t off = CHECK_BOUNDS_LOW (dest) - s - <span class="dv">1</span>;
    size_t n;

    <span class="kw">do</span>
    {
        c = *s++;
        s[off] = c;
    }
    <span class="kw">while</span> (c != <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>);

    n = s - src;
    (<span class="dt">void</span>) CHECK_BOUNDS_HIGH (src + n);
    (<span class="dt">void</span>) CHECK_BOUNDS_HIGH (dest + n);

    <span class="kw">return</span> dest;
}

<span class="dt">char</span> * __cdecl strncpy (<span class="dt">char</span> * dest,<span class="dt">const</span> <span class="dt">char</span> * source,size_t count)
{
    <span class="dt">char</span> *start = dest;

    <span class="kw">while</span> (count &amp;&amp; (*dest++ = *source++))    <span class="co">/* copy string */</span>
        count--;

    <span class="kw">if</span> (count)                              <span class="co">/* pad out with zeroes */</span>
        <span class="kw">while</span> (--count)
            *dest++ = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>;

        <span class="kw">return</span>(start);
}</code></pre></div>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://blog.csdn.net/v_JULY_v/article/details/6417600">&#31243;&#24207;&#21592;&#32534;&#31243;&#33402;&#26415;&#65306;&#31532;&#22235;&#31456;&#12289;&#29616;&#22330;&#32534;&#20889;&#31867;&#20284; strstr/strcpy/strpbrk &#30340;&#20989;&#25968; - &#32467;&#26500;&#20043;&#27861; &#31639;&#27861;&#20043;&#36947; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
</ul></li>
</ul>
</dd>
<dt>StackOverflow &#9829;&#65039; <code class="fold">@</code></dt>
<dd><ul>
<li><p><a href="http://stackoverflow.com/questions/22342854/what-is-the-optimal-algorithm-for-the-game-2048">logic - What is the optimal algorithm for the game 2048? - Stack Overflow</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/487258/what-is-a-plain-english-explanation-of-big-o-notation">algorithm - What is a plain English explanation of &#8220;Big O&#8221; notation? - Stack Overflow</a></p></li>
<li><dl>
<dt><a href="http://stackoverflow.com/questions/10168686/image-processing-algorithm-improvement-for-coca-cola-can-recognition">c++ - Image Processing: Algorithm Improvement for &#8216;Coca-Cola Can&#8217; Recognition - Stack Overflow</a> <code class="fold">@</code></dt>
<dd><p>signature scan lines.</p>
</dd>
</dl></li>
<li><dl>
<dt><a href="http://stackoverflow.com/questions/33923/what-is-tail-recursion">algorithm - What is tail recursion? - Stack Overflow</a> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> recsum(x):
    <span class="cf">if</span> x <span class="op">==</span> <span class="dv">1</span>:
        <span class="cf">return</span> x
    <span class="cf">else</span>:
        <span class="cf">return</span> x <span class="op">+</span> recsum(x <span class="op">-</span> <span class="dv">1</span>)</code></pre></div>
<p>In traditional recursion, the typical model is that you perform your recursive calls first, and then you take the return value of the recursive call and calculate the result. In this manner, you don&#8217;t get the result of your calculation until you have returned from every recursive call.</p>
<p>In tail recursion, you perform your calculations first, and then you execute the recursive call, passing the results of your current step to the next recursive step. This results in the last statement being in the form of &#8220;(return (recursive-function params))&#8221; (I think that&#8217;s the syntax for Lisp). Basically, the return value of any given recursive step is the same as the return value of the next recursive call.</p>
<p>The consequence of this is that once you are ready to perform your next recursive step, you don&#8217;t need the current stack frame any more. This allows for some optimization. In fact, with an appropriately written compiler, you should never have a stack overflow snicker with a tail recursive call. Simply reuse the current stack frame for the next recursive step. I&#8217;m pretty sure Lisp does this.</p>
<blockquote>
<p>An important point is that tail recursion is essentially equivalent to looping.</p>
</blockquote>
</dd>
</dl></li>
<li><dl>
<dt><a href="http://stackoverflow.com/questions/3492302/easy-interview-question-got-harder-given-numbers-1-100-find-the-missing-numbe" class="hearts">algorithm - Easy interview question got harder: given numbers 1..100, find the missing number(s) - Stack Overflow</a> <code class="fold">@</code></dt>
<dd><p><a href="https://en.wikipedia.org/wiki/Newton%27s_identities#Formulation_in_terms_of_symmetric_polynomials">Newton&#8217;s identities - Wikipedia, the free encyclopedia</a></p>
</dd>
</dl></li>
<li><p><a href="http://stackoverflow.com/questions/9452701/ukkonens-suffix-tree-algorithm-in-plain-english">search - Ukkonen&#8217;s suffix tree algorithm in plain English? - Stack Overflow</a></p></li>
<li><dl>
<dt><a href="http://stackoverflow.com/questions/7153659/find-an-integer-not-among-four-billion-given-ones">algorithm - Find an integer not among four billion given ones - Stack Overflow</a> <code class="fold">@</code></dt>
<dd><blockquote>
<p>Given an input file with four billion integers, provide an algorithm to generate an integer which is not contained in the file. Assume you have 1 GB memory. Follow up with what you would do if you have only 10 MB of memory.</p>
</blockquote>
<dl>
<dt>Assuming that &#8220;integer&#8221; means 32 bits</dt>
<dd><p>Having 10 MB of space is more than enough for you to count how many numbers there are in the input file with any given 16-bit prefix, for all possible 16-bit prefixes in one pass through the input file. At least one of the buckets will have be hit less than 2^16 times. Do a second pass to find of which of the possible numbers in that bucket are used already.</p>
</dd>
<dt>If it means more than 32 bits, but still of bounded size</dt>
<dd><p>Do as above, ignoring all input numbers that happen to fall outside the (signed or unsigned; your choice) 32-bit range.</p>
</dd>
<dt>If &#8220;integer&#8221; means mathematical integer</dt>
<dd><p>Read through the input once and keep track of the largest number length of the longest number you&#8217;ve ever seen. When you&#8217;re done, output the maximum plus one a random number that has one more digit. (One of the numbers in the file may be a bignum that takes more than 10 MB to represent exactly, but if the input is a file, then you can at least represent the length of anything that fits in it).</p>
</dd>
</dl>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define BITSPERWORD 32</span>
<span class="ot">#define SHIFT 5</span>
<span class="ot">#define MASK 0x1F</span>
<span class="ot">#define N 10000000</span>
<span class="dt">int</span> a[<span class="dv">1</span> + N/BITSPERWORD];

<span class="dt">void</span> set(<span class="dt">int</span> i) {        a[i&gt;&gt;SHIFT] |=  (<span class="dv">1</span>&lt;&lt;(i &amp; MASK)); }
<span class="dt">void</span> clr(<span class="dt">int</span> i) {        a[i&gt;&gt;SHIFT] &amp;= ~(<span class="dv">1</span>&lt;&lt;(i &amp; MASK)); }
<span class="dt">int</span>  test(<span class="dt">int</span> i){ <span class="kw">return</span> a[i&gt;&gt;SHIFT] &amp;   (<span class="dv">1</span>&lt;&lt;(i &amp; MASK)); }</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt><a href="http://stackoverflow.com/questions/1857244/what-are-the-differences-between-np-np-complete-and-np-hard">algorithm - What are the differences between NP, NP-Complete and NP-Hard? - Stack Overflow</a> <code class="fold">@</code></dt>
<dd><dl>
<dt>Decision problem</dt>
<dd>A problem with a yes or no answer.
</dd>
</dl>
<p>Now, let us define those complexity classes.</p>
<dl>
<dt>P</dt>
<dd><p>P is a complexity class that represents the set of all decision problems that can be solved in <strong>polynomial time</strong>. That is, given an instance of the problem, the answer yes or no can be decided in polynomial time.</p>
<p>Example</p>
<p>Given a graph connected G, can its vertices be coloured using two colours so that no edge is monochromatic?</p>
<p>Algorithm: start with an arbitrary vertex, color it red and all of its neighbours blue and continue. Stop when you run out of vertices or you are forced to make an edge have both of its endpoints be the same color.</p>
</dd>
<dt>NP</dt>
<dd><p>NP is a complexity class that represents the set of all decision problems for which the instances where the answer is &#8220;yes&#8221; have proofs that can be verified in polynomial time.</p>
<p>This means that if someone gives us an instance of the problem and a certificate (sometimes called a witness) to the answer being yes, we can check that it is correct in polynomial time.</p>
<p>Example</p>
<p>Integer factorisation is in NP. This is the problem that given integers n and m, is there an integer f with 1 &lt; f &lt; m, such that f divides n (f is a small factor of n)?</p>
<p>This is a decision problem because the answers are yes or no. If someone hands us an instance of the problem (so they hand us integers n and m) and an integer f with 1 &lt; f &lt; m, and claim that f is a factor of n (the certificate), we can check the answer in polynomial time by performing the division n / f.</p>
</dd>
<dt>NP-Complete</dt>
<dd><p>NP-Complete is a complexity class which represents the set of all problems X in NP for which it is possible to reduce any other NP problem Y to X in polynomial time.</p>
<p>Intuitively this means that we can solve Y quickly if we know how to solve X quickly. Precisely, Y is reducible to X, if there is a polynomial time algorithm f to transform instances y of Y to instances x = f(y) of X in polynomial time, with the property that the answer to y is yes, if and only if the answer to f(y) is yes.</p>
<p>Example</p>
<p>3-SAT. This is the problem wherein we are given a conjunction (ANDs) of 3-clause disjunctions (ORs), statements of the form</p>
<pre><code>(x_v11 OR x_v21 OR x_v31) AND
(x_v12 OR x_v22 OR x_v32) AND
...                       AND
(x_v1n OR x_v2n OR x_v3n)</code></pre>
<p>where each x_vij is a boolean variable or the negation of a variable from a finite predefined list (x_1, x_2, &#8230; x_n).</p>
<p>It can be shown that every NP problem can be reduced to 3-SAT. The proof of this is technical and requires use of the technical definition of NP (based on non-deterministic Turing machines). This is known as Cook&#8217;s theorem.</p>
<p>What makes NP-complete problems important is that if a deterministic polynomial time algorithm can be found to solve one of them, <strong>every NP problem is solvable in polynomial time</strong> (one problem to rule them all).</p>
</dd>
</dl>
<p>NP-hard</p>
<p>P = NP</p>
<pre><code>____________________________________________________________
| Problem Type | Verifiable in P time | Solvable in P time | Increasing Difficulty
|______________|______________________|____________________|           |
| P            |        Yes           |        Yes         |           |
| NP           |        Yes           |     Yes or No *    |           |
| NP-Complete  |        Yes           |      Unknown       |           |
| NP-Hard      |     Yes or No **     |      Unknown ***   |           |
|______________|______________________|____________________|           V</code></pre>
</dd>
</dl></li>
<li><p><a href="http://stackoverflow.com/questions/3255/big-o-how-do-you-calculate-approximate-it">algorithm - Big O, how do you calculate/approximate it? - Stack Overflow</a></p></li>
<li><dl>
<dt><a href="http://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula">algorithm - Calculate distance between two latitude-longitude points? (Haversine formula) - Stack Overflow</a> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// This script [in Javascript] calculates great-circle distances between the</span>
<span class="co">// two points &#8211; that is, the shortest distance over the earth&#8217;s surface &#8211; using</span>
<span class="co">// the &#8216;Haversine&#8217; formula.</span>
<span class="kw">function</span> <span class="at">getDistanceFromLatLonInKm</span>(lat1<span class="op">,</span>lon1<span class="op">,</span>lat2<span class="op">,</span>lon2) <span class="op">{</span>
    <span class="kw">var</span> R <span class="op">=</span> <span class="dv">6371</span><span class="op">;</span> <span class="co">// Radius of the earth in km</span>
    <span class="kw">var</span> dLat <span class="op">=</span> <span class="at">deg2rad</span>(lat2<span class="op">-</span>lat1)<span class="op">;</span>  <span class="co">// deg2rad below</span>
    <span class="kw">var</span> dLon <span class="op">=</span> <span class="at">deg2rad</span>(lon2<span class="op">-</span>lon1)<span class="op">;</span>
    <span class="kw">var</span> a <span class="op">=</span>
        <span class="va">Math</span>.<span class="at">sin</span>(dLat/<span class="dv">2</span>) <span class="op">*</span> <span class="va">Math</span>.<span class="at">sin</span>(dLat/<span class="dv">2</span>) <span class="op">+</span>
        <span class="va">Math</span>.<span class="at">cos</span>(<span class="at">deg2rad</span>(lat1)) <span class="op">*</span> <span class="va">Math</span>.<span class="at">cos</span>(<span class="at">deg2rad</span>(lat2)) <span class="op">*</span>
        <span class="va">Math</span>.<span class="at">sin</span>(dLon/<span class="dv">2</span>) <span class="op">*</span> <span class="va">Math</span>.<span class="at">sin</span>(dLon/<span class="dv">2</span>)
        <span class="op">;</span>
    <span class="kw">var</span> c <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> <span class="va">Math</span>.<span class="at">atan2</span>(<span class="va">Math</span>.<span class="at">sqrt</span>(a)<span class="op">,</span> <span class="va">Math</span>.<span class="at">sqrt</span>(<span class="dv">1</span><span class="op">-</span>a))<span class="op">;</span>
    <span class="kw">var</span> d <span class="op">=</span> R <span class="op">*</span> c<span class="op">;</span> <span class="co">// Distance in km</span>
    <span class="cf">return</span> d<span class="op">;</span>
<span class="op">}</span>

<span class="kw">function</span> <span class="at">deg2rad</span>(deg) <span class="op">{</span>
    <span class="cf">return</span> deg <span class="op">*</span> (<span class="va">Math</span>.<span class="at">PI</span>/<span class="dv">180</span>)
<span class="op">}</span></code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Haversine_formula">Haversine formula - Wikipedia, the free encyclopedia</a>+</li>
<li><a href="http://www.movable-type.co.uk/scripts/latlong.html">Calculate distance and bearing between two Latitude/Longitude points using haversine formula in JavaScript</a></li>
</ul>
</dd>
</dl></li>
<li><p><a href="http://stackoverflow.com/questions/430142/what-algorithms-compute-directions-from-point-a-to-point-b-on-a-map">routing - What algorithms compute directions from point A to point B on a map? - Stack Overflow</a></p></li>
<li><dl>
<dt><a href="http://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2">c# - How to check if a number is a power of 2 - Stack Overflow</a> <code class="fold">@</code></dt>
<dd><p><code>x &amp; (x-1) == 0 ?</code>, as I expected.</p>
</dd>
</dl></li>
<li><dl>
<dt><a href="http://stackoverflow.com/questions/742013/how-to-code-a-url-shortener">algorithm - How to code a URL shortener? - Stack Overflow</a> <code class="fold">@</code></dt>
<dd><ul>
<li>encode, bijective.</li>
<li>checksum</li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt><a href="http://stackoverflow.com/questions/127704/algorithm-to-return-all-combinations-of-k-elements-from-n">Algorithm to return all combinations of k elements from n - Stack Overflow</a> <code class="fold">@</code></dt>
<dd><p>chenshuo has a better solution.</p>
</dd>
</dl></li>
<li><p><a href="http://stackoverflow.com/questions/192220/what-is-the-most-efficient-elegant-way-to-parse-a-flat-table-into-a-tree">sql - What is the most efficient/elegant way to parse a flat table into a tree? - Stack Overflow</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/746082/how-to-find-list-of-possible-words-from-a-letter-matrix-boggle-solver">algorithm - How to find list of possible words from a letter matrix [Boggle Solver] - Stack Overflow</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/17333/most-effective-way-for-float-and-double-comparison">c++ - Most effective way for float and double comparison - Stack Overflow</a></p></li>
<li><dl>
<dt><a href="http://stackoverflow.com/questions/5859561/getting-the-closest-string-match">algorithm - Getting the closest string match - Stack Overflow</a> <code class="fold">@</code></dt>
<dd><ul>
<li><a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt><a href="http://stackoverflow.com/questions/6430448/why-doesnt-gcc-optimize-aaaaaa-to-aaaaaa">c - Why doesn&#8217;t GCC optimize a<em>a</em>a<em>a</em>a<em>a to (a</em>a<em>a)</em>(a<em>a</em>a)? - Stack Overflow</a> <code class="fold">@</code></dt>
<dd><p>Because Floating Point Math is not Associative. The way you group the operands in floating point multiplication has an effect on the numerical accuracy of the answer.</p>
<p>As a result, most compilers are very conservative about reordering floating point calculations unless they can be sure that the answer will stay the same, or unless you tell them you don&#8217;t care about numerical accuracy. For example: the <code>-fassociative-math</code> option of gcc which allows gcc to reassociate floating point operations, or even the <code>-ffast-math</code> option which allows even more aggressive tradeoffs of accuracy against speed.</p>
<p>Another similar case: most compilers won&#8217;t optimize a + b + c + d to (a + b) + (c + d) (this is an optimization since the second expression can be pipelined better) and evaluate it as given (i.e.&#160;as (((a + b) + c) + d)). This too is because of corner cases:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> main() {
    <span class="dt">float</span> a = <span class="fl">1e35</span>, b = <span class="fl">1e-5</span>, c = <span class="fl">-1e35</span>, d = <span class="fl">1e-5</span>;
    printf(<span class="st">&quot;</span><span class="ch">%e</span><span class="st"> </span><span class="ch">%e\n</span><span class="st">&quot;</span>, a + b + c + d, (a + b) + (c + d)); <span class="co">// 1.000000e-05 0.000000e+00</span>
}</code></pre></div>
<p><a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a></p>
</dd>
</dl></li>
<li><dl>
<dt><a href="http://stackoverflow.com/questions/11694546/divide-a-number-by-3-without-using-operators">c - Divide a number by 3 without using <code>*</code>, <code>/</code>, <code>+</code>, <code>-,</code> <code>%</code> operators - Stack Overflow</a> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// replaces the + operator</span>
<span class="dt">int</span> add(<span class="dt">int</span> x, <span class="dt">int</span> y) {
    <span class="kw">while</span>(x) {
        <span class="dt">int</span> t = (x &amp; y) &lt;&lt;<span class="dv">1</span>;
        y ^= x;
        x = t;
    }
    <span class="kw">return</span> y;
}

<span class="dt">int</span> divideby3 (<span class="dt">int</span> num) {
    <span class="dt">int</span> sum = <span class="dv">0</span>;
    <span class="kw">while</span> (num &gt; <span class="dv">3</span>) {
        sum = add(num &gt;&gt; <span class="dv">2</span>, sum);
        num = add(num &gt;&gt; <span class="dv">2</span>, num &amp; <span class="dv">3</span>);
    }
    <span class="kw">if</span> (num == <span class="dv">3</span>)
        sum = add(sum, <span class="dv">1</span>);
    <span class="kw">return</span> sum;
}</code></pre></div>
<p>As Jim commented this works because:</p>
<ul>
<li>n = 4 * a + b</li>
<li>n / 3 = a + (a + b) / 3</li>
<li>So sum += a, n = a + b, and iterate</li>
<li>When a == 0 (n &lt; 4), sum += floor(n / 3); i.e.&#160;1, if n == 3, else 0</li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt><a href="http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c">How do you set, clear and toggle a single bit in C/C++? - Stack Overflow</a> <code class="fold">@</code></dt>
<dd><ul>
<li>set a bit: <code>number |= 1 &lt;&lt; x;</code></li>
<li>clear a bit: <code>number &amp;= ~(1 &lt;&lt; x);</code></li>
<li>toggle a bit: <code>number ^= 1 &lt;&lt; x;</code></li>
<li>checking a bit: <code>bit = (number &gt;&gt; x) &amp; 1;</code></li>
<li>changing the nth bit to x: <code>number ^= (-x ^ number) &amp; (1 &lt;&lt; n);</code></li>
</ul>
</dd>
</dl></li>
<li><p><a href="http://stackoverflow.com/questions/1041866/in-c-source-what-is-the-effect-of-extern-c">In C++ source, what is the effect of extern &#8220;C&#8221;? - Stack Overflow</a></p></li>
<li><dl>
<dt><a href="http://stackoverflow.com/questions/201101/how-to-initialize-all-members-of-an-array-to-the-same-value">c - How to initialize all members of an array to the same value - Stack Overflow</a> <code class="fold">@</code></dt>
<dd><p>refs and see also</p>
<ul>
<li><a href="https://github.com/district10/notes/issues/2">&#19981;&#35201;&#34987;&#21035;&#20154;&#30340; memset(buf, -1, sizeof(buf)) &#36855;&#24785;&#20102; &#183; Issue #2 &#183; district10/notes &#183; GitHub</a></li>
</ul>
</dd>
</dl></li>
<li><p><a href="http://stackoverflow.com/questions/154136/why-use-apparently-meaningless-do-while-and-if-else-statements-in-c-c-macros">Why use apparently meaningless do-while and if-else statements in C/C++ macros? - Stack Overflow</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/11483060/stdnext-permutation-implementation-explanation">c++ - std::next_permutation Implementation Explanation - Stack Overflow</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/13448064/how-to-find-the-intersection-of-two-stdset-in-c">how to find the intersection of two std:set in C++? - Stack Overflow</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/22600100/why-are-stdshuffle-methods-being-deprecated-in-c14">c++ - Why are std::shuffle methods being deprecated in C++14? - Stack Overflow</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/6743093/composability-of-stl-algorithms">c++ - Composability of STL algorithms - Stack Overflow</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/17663449/c-algorithm-implementation-explained">C++ <algorithm> implementation explained - Stack Overflow</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/26119212/stdcopy-n-elements-or-to-the-end">c++ - std::copy n elements or to the end - Stack Overflow</a></p></li>
</ul>
</dd>
<dt>Milo Yip &#30340;&#21338;&#23458; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt><a href="http://www.cnblogs.com/miloyip/archive/2010/02/25/binary_tree_distance.html">&#12298;&#32534;&#31243;&#20043;&#32654;: &#27714;&#20108;&#21449;&#26641;&#20013;&#33410;&#28857;&#30340;&#26368;&#22823;&#36317;&#31163;&#12299;&#30340;&#21478;&#19968;&#20010;&#35299;&#27861; - Milo Yip - &#21338;&#23458;&#22253;</a> <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://pic002.cnblogs.com/img/miloyip/201002/2010022503291293.png" />

</div>
<p>&#20070;&#20013;&#23545;&#36825;&#20010;&#38382;&#39064;&#30340;&#20998;&#26512;&#26159;&#24456;&#28165;&#26970;&#30340;&#65292;&#25105;&#23581;&#35797;&#29992;&#33258;&#24049;&#30340;&#26041;&#24335;&#31616;&#30701;&#35206;&#36848;&#12290;</p>
<p>&#35745;&#31639;&#19968;&#20010;&#20108;&#21449;&#26641;&#30340;&#26368;&#22823;&#36317;&#31163;&#26377;&#20004;&#20010;&#24773;&#20917;:</p>
<ul>
<li>&#24773;&#20917; A: &#36335;&#24452;&#32463;&#36807;&#24038;&#23376;&#26641;&#30340;&#26368;&#28145;&#33410;&#28857;&#65292;&#36890;&#36807;&#26681;&#33410;&#28857;&#65292;&#20877;&#21040;&#21491;&#23376;&#26641;&#30340;&#26368;&#28145;&#33410;&#28857;&#12290;</li>
<li>&#24773;&#20917; B: &#36335;&#24452;&#19981;&#31359;&#36807;&#26681;&#33410;&#28857;&#65292;&#32780;&#26159;&#24038;&#23376;&#26641;&#25110;&#21491;&#23376;&#26641;&#30340;&#26368;&#22823;&#36317;&#31163;&#36335;&#24452;&#65292;&#21462;&#20854;&#22823;&#32773;&#12290;</li>
</ul>
<p>&#21482;&#38656;&#35201;&#35745;&#31639;&#36825;&#20004;&#20010;&#24773;&#20917;&#30340;&#36335;&#24452;&#36317;&#31163;&#65292;&#24182;&#21462;&#20854;&#22823;&#32773;&#65292;&#23601;&#26159;&#35813;&#20108;&#21449;&#26641;&#30340;&#26368;&#22823;&#36317;&#31163;&#12290;</p>
<p>&#36825;&#27573;&#20195;&#30721;&#26377;&#20960;&#20010;&#32570;&#28857;:</p>
<ul>
<li>&#31639;&#27861;&#21152;&#20837;&#20102;&#20405;&#20837;&#24335; (intrusive) &#30340;&#36164;&#26009; nMaxLeft, nMaxRight</li>
<li>&#20351;&#29992;&#20102;&#20840;&#23616;&#21464;&#37327; nMaxLen&#12290;&#27599;&#27425;&#20351;&#29992;&#35201;&#39069;&#22806;&#21021;&#22987;&#21270;&#12290;&#32780;&#19988;&#23601;&#31639;&#26159;&#19981;&#21516;&#30340;&#29420;&#31435;&#36164;&#26009;&#65292;&#20063;&#19981;&#33021;&#22312;&#22810;&#20010;&#32447;&#31243;&#20351;&#29992;&#36825;&#20010;&#20989;&#25968;</li>
<li>&#36923;&#36753;&#27604;&#36739;&#22797;&#26434;&#65292;&#20063;&#26377;&#35768;&#22810; NULL &#30456;&#20851;&#30340;&#26465;&#20214;&#27979;&#35797;&#12290;</li>
</ul>
<p>&#25105;&#26041;&#30693;&#36947;&#36889;&#20491;&#12300;&#36317;&#38626;&#12301;&#25033;&#35442;&#26159;&#21483;&#12300;&#30452;&#24465;&#12301;(<strong>Tree Diameter</strong>)&#12290;&#30340;&#30830;&#26159;&#8220;&#30452;&#24452;&#8221;&#8212;&#8212;&#22312;&#25968;&#23398;&#20013;&#30452;&#24452;&#30340;&#23450;&#20041;&#26159;&#65306;&#19968;&#20010;&#36317;&#31163;&#31354;&#38388;&#20013;&#20219;&#24847;&#20004;&#28857;&#38388;&#36317;&#31163;&#30340;&#19978;&#30830;&#30028; (supremum)&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> NODE {
    NODE *pLeft;
    NODE *pRight;
};

<span class="kw">struct</span> RESULT {
    <span class="dt">int</span> nMaxDistance;
    <span class="dt">int</span> nMaxDepth;
};

RESULT GetMaximumDistance(NODE* root) {
    <span class="kw">if</span> (!root) {
        RESULT empty = { <span class="dv">0</span>, <span class="dv">-1</span> };   <span class="co">// trick: nMaxDepth is -1 and then caller will plus 1 to balance it as zero.</span>
        <span class="kw">return</span> empty;
    }

    RESULT lhs = GetMaximumDistance(root-&gt;pLeft);
    RESULT rhs = GetMaximumDistance(root-&gt;pRight);

    RESULT result = {
        max(max(lhs.nMaxDistance, rhs.nMaxDistance), lhs.nMaxDepth + rhs.nMaxDepth + <span class="dv">2</span>),
        max(lhs.nMaxDepth + <span class="dv">1</span>, rhs.nMaxDepth + <span class="dv">1</span>)
    };
    <span class="kw">return</span> result;
}

<span class="dt">void</span> Link(NODE* nodes, <span class="dt">int</span> parent, <span class="dt">int</span> left, <span class="dt">int</span> right) {
    <span class="kw">if</span>( left  != <span class="dv">-1</span> ) { nodes[parent].pLeft = &amp;nodes[left]; }
    <span class="kw">if</span>( right != <span class="dv">-1</span> ) { nodes[parent].pRight = &amp;nodes[right]; }
}

<span class="dt">void</span> main() {
    <span class="co">// P. 241 Graph 3-12</span>
    NODE test1 = { <span class="dv">0</span> };
    Link(test1, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>);
    Link(test1, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>);
    Link(test1, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">6</span>);
    Link(test1, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">-1</span>);
    Link(test1, <span class="dv">5</span>, <span class="dv">-1</span>, <span class="dv">8</span>);
    cout &lt;&lt; <span class="st">&quot;test1: &quot;</span> &lt;&lt; GetMaximumDistance(&amp;test1).nMaxDistance &lt;&lt; endl;

    <span class="co">// P. 242 Graph 3-13 left</span>
    NODE test2 = { <span class="dv">0</span> };
    Link(test2, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>);
    Link(test2, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">-1</span>);
    cout &lt;&lt; <span class="st">&quot;test2: &quot;</span> &lt;&lt; GetMaximumDistance(&amp;test2).nMaxDistance &lt;&lt; endl;

    <span class="co">// P. 242 Graph 3-13 right</span>
    NODE test3 = { <span class="dv">0</span> };
    Link(test3, <span class="dv">0</span>, <span class="dv">-1</span>, <span class="dv">1</span>);
    Link(test3, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);
    Link(test3, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">-1</span>);
    Link(test3, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">6</span>);
    Link(test3, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">-1</span>);
    Link(test3, <span class="dv">5</span>, <span class="dv">-1</span>, <span class="dv">8</span>);
    cout &lt;&lt; <span class="st">&quot;test3: &quot;</span> &lt;&lt; GetMaximumDistance(&amp;test3).nMaxDistance &lt;&lt; endl;

    <span class="co">// P. 242 Graph 3-14</span>
    <span class="co">// Same as Graph 3-2, not test</span>

    <span class="co">// P. 243 Graph 3-15</span>
    NODE test4 = { <span class="dv">0</span> };
    Link(test4, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>);
    Link(test4, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>);
    Link(test4, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">6</span>);
    Link(test4, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">-1</span>);
    Link(test4, <span class="dv">6</span>, <span class="dv">-1</span>, <span class="dv">8</span>);
    cout &lt;&lt; <span class="st">&quot;test4: &quot;</span> &lt;&lt; GetMaximumDistance(&amp;test4).nMaxDistance &lt;&lt; endl;
}</code></pre></div>
<pre><code>test1: 6
test2: 3
test3: 6
test4: 5</code></pre>
<p>refs and see also</p>
<ul>
<li><a href="http://www.cs.duke.edu/courses/spring00/cps100/assign/trees/diameter.html">Tree Diameter</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt><a href="http://www.cnblogs.com/miloyip/archive/2010/05/12/binary_tree_traversal.html">&#12298;&#32534;&#31243;&#20043;&#32654;&#65306;&#20998;&#23618;&#36941;&#21382;&#20108;&#21449;&#26641;&#12299;&#30340;&#21478;&#22806;&#20004;&#20010;&#23454;&#29616; - Milo Yip - &#21338;&#23458;&#22253;</a> <code class="fold">@</code></dt>
<dd><p>&#65288;&#36825;&#31687; post &#30340;&#20869;&#23481;&#24050;&#32463;&#34987;&#36716;&#20837; jiuzhang&#12290;&#65289;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> PrintNodeByLevel(Node* root) {
     vector&lt;Node *&gt; vec;                                <span class="co">// &#36825;&#37324;&#25105;&#20204;&#20351;&#29992; STL &#20013;&#30340; vector &#26469;&#20195;&#26367;&#25968;&#32452;&#65292;&#21487;&#21033;&#29992;&#21040;&#20854;&#21160;&#24577;&#25193;&#23637;&#30340;&#23646;&#24615;</span>
     vec.push_back(root);
     <span class="dt">int</span> cur = <span class="dv">0</span>, last = <span class="dv">1</span>;                             <span class="co">// vec.size(); &#23601;&#20687; iterator&#65292;&#25351;&#21521; end</span>
     <span class="kw">while</span>( cur &lt; vec.size() ) {
          last = vec.size();                            <span class="co">// &#26032;&#30340;&#19968;&#34892;&#35775;&#38382;&#24320;&#22987;&#65292;&#37325;&#26032;&#23450;&#20301; last &#20110;&#24403;&#21069;&#34892;&#26368;&#21518;&#19968;&#20010;&#33410;&#28857;&#30340;&#19979;&#19968;&#20010;&#20301;&#32622;</span>
          <span class="kw">while</span>( cur &lt; last ) {
               cout &lt;&lt; vec[cur] -&gt; data &lt;&lt; <span class="st">&quot; &quot;</span>;         <span class="co">// &#35775;&#38382;&#33410;&#28857;</span>
               <span class="kw">if</span>(vec[cur] -&gt; lChild) { vec.push_back(vec[cur] -&gt; lChild); }
               <span class="kw">if</span>(vec[cur] -&gt; rChild) { vec.push_back(vec[cur] -&gt; rChild); }
               ++cur;
          }
          cout &lt;&lt; endl;                                 <span class="co">// &#24403; cur == last &#26102;, &#35828;&#26126;&#35813;&#23618;&#35775;&#38382;&#32467;&#26463;&#65292;&#36755;&#20986;&#25442;&#34892;&#31526;</span>
     }
}</code></pre></div>
<p>&#20070;&#20013;&#27809;&#26377;&#25552;&#21450;&#65292;&#26412;&#38382;&#39064;&#20854;&#23454;&#26159;&#20197;&#24191;&#24230;&#20248;&#20808;&#25628;&#32034; (breath-first search, BFS) &#21435;&#36941;&#21382;&#19968;&#20010;&#26641;&#32467;&#26500;&#12290;&#24191;&#24230;&#20248;&#20808;&#25628;&#32034;&#30340;&#20856;&#22411;&#23454;&#29616;&#26159;&#20351;&#29992;&#38431;&#21015; (queue)&#12290;&#20854;&#20266;&#20195;&#30721;&#22914;&#19979;:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">enqueue(Q, root)
<span class="kw">do</span>
    node = dequeue(Q)
    process(node)               <span class="co">// &#22914;&#25226;&#20869;&#23481;&#21015;&#21360;</span>
    <span class="kw">for</span> each child of node
        enqueue(Q, child)
<span class="kw">while</span> Q is <span class="kw">not</span> empty</code></pre></div>
<p>&#20070;&#19978;&#30340;&#35299;&#27861;&#65292;&#20107;&#23454;&#19978;&#20063;&#20351;&#29992;&#20102;&#19968;&#20010;&#38431;&#21015;&#12290;&#20294;&#26412;&#20154;&#35748;&#20026;&#65292;&#20351;&#29992; vector &#23481;&#22120;&#65292;&#36739;&#19981;&#30452;&#35273;&#65292;&#32780;&#19988;&#20854;&#31354;&#38388;&#22797;&#26434;&#24230;&#26159; O(n)&#12290;</p>
<p>&#22914;&#26524;&#29992;&#38431;&#21015;&#21435;&#23454;&#29616; BFS&#65292;&#19981;&#22788;&#29702;&#25442;&#34892;&#65292;&#33021;&#31616;&#21333;&#32763;&#35793;&#20266;&#20195;&#30721;&#20026; C++ &#20195;&#30721;:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> PrintBFS(Node* root) {
    queue&lt;Node*&gt; Q;
    Q.push(root);
    <span class="kw">do</span> {
        Node *node = Q.front(); Q.pop();
        cout &lt;&lt; node-&gt;data &lt;&lt; <span class="st">&quot; &quot;</span>;
        <span class="kw">if</span> (node-&gt;pLeft)  { Q.push(node-&gt;pLeft); }
        <span class="kw">if</span> (node-&gt;pRight) { Q.push(node-&gt;pRight); }
    }
    <span class="kw">while</span> (!Q.empty());
}</code></pre></div>
<p>&#26412;&#20154;&#35273;&#24471;&#36825;&#26679;&#30340;&#31639;&#27861;&#23454;&#29616;&#21487;&#33021;&#27604;&#36739;&#28165;&#26970;&#65292;&#32780;&#19988;&#31354;&#38388;&#22797;&#26434;&#24230;&#21482;&#38656; O(m)&#65292;m &#20026;&#26641;&#20013;&#26368;&#22810;&#33410;&#28857;&#30340;&#23618;&#30340;&#33410;&#28857;&#25968;&#37327;&#12290;&#26368;&#22351;&#30340;&#24773;&#20917;&#26159;&#24403;&#20108;&#21449;&#26641;&#20026;&#23436;&#25972;&#65292;m = n/2&#12290;&#20043;&#21518;&#30340;&#38590;&#28857;&#22312;&#20110;<strong>&#22914;&#20309;&#25442;&#34892;</strong>&#12290;</p>
<dl>
<dt>&#26412;&#20154;&#30340;&#23581;&#35797;&#20043;&#19968; <code class="fold">@</code></dt>
<dd><p>&#31532;&#19968;&#20010;&#23581;&#35797;&#65292;&#21033;&#29992;&#20102;&#20004;&#20010;&#38431;&#21015;&#65292;&#19968;&#20010;&#20648;&#23384;&#26412;&#23618;&#30340;&#33410;&#28857;&#65292;&#21478;&#19968;&#20010;&#20648;&#23384;&#19979;&#23618;&#30340;&#33410;&#28857;&#12290;&#36941;&#21382;&#26412;&#23618;&#30340;&#33410;&#28857;&#65292;&#25226;&#20854;&#23376;&#20195;&#33410;&#28857;&#25490;&#20837;&#19979;&#23618;&#38431;&#21015;&#12290;&#26412;&#23618;&#36941;&#21382;&#23436;&#27605;&#21518;&#65292;&#23601;&#21487;&#25442;&#34892;&#65292;&#24182;&#20132;&#25442;&#20004;&#20010;&#38431;&#21015;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> PrintNodeByLevel(Node* root) {
    deque&lt;Node*&gt; Q1, Q2;
    Q1.push_back(root);
    <span class="kw">do</span> {
        <span class="kw">do</span> {
            Node* node = Q1.front();
            Q1.pop_front();
            cout &lt;&lt; node-&gt;data &lt;&lt; <span class="st">&quot; &quot;</span>;
            <span class="kw">if</span> (node-&gt;pLeft)
                Q2.push_back(node-&gt;pLeft);
            <span class="kw">if</span> (node-&gt;pRight)
                Q2.push_back(node-&gt;pRight);
        } <span class="kw">while</span> (!Q1.empty());
        cout &lt;&lt; endl;
        Q1.swap(Q2);
    } <span class="kw">while</span>(!Q1.empty());
}</code></pre></div>
<p>&#26412;&#23454;&#29616;&#20351;&#29992; deque &#32780;&#19981;&#26159; queue&#65292;&#22240;&#20026; deque &#25165;&#25903;&#25345; swap() &#25805;&#20316; ( <code>swap(q1, q2)</code> )&#12290;&#27880;&#24847;&#65292; <code>swap()</code> &#26159; <code>O(1)</code> &#30340;&#25805;&#20316;&#65292;&#23454;&#38469;&#19978;&#21482;&#26159;&#20132;&#25442;&#25351;&#38024;&#12290;</p>
<p>&#36825;&#23454;&#29616;&#35201;&#29992;&#20004;&#20010;&#24490;&#29615;(&#20070;&#19978;&#30340;&#23454;&#29616;&#20063;&#26159;)&#65292;&#24182;&#19988;&#29992;&#20102;&#20004;&#20010;&#38431;&#21015;&#12290;&#33021;&#22815;&#21482;&#29992;&#19968;&#20010;&#24490;&#29615;&#12289;&#19968;&#20010;&#38431;&#21015;&#20040;?</p>
</dd>
<dt>&#26412;&#20154;&#30340;&#23581;&#35797;&#20043;&#20108;</dt>
<dd><p>&#25442;&#34892;&#38382;&#39064;&#20854;&#23454;&#22312;&#20110;&#22914;&#20309;&#34920;&#36798;&#19968;&#23618;&#30340;&#32467;&#26463;&#12290;&#20070;&#19978;&#37319;&#29992;&#20102;&#28216;&#26631;&#65292;&#32780;&#31532;&#19968;&#20010;&#23581;&#35797;&#21017;&#29992;&#20102;&#20004;&#20010;&#38431;&#21015;&#12290;&#26412;&#20154;&#24819;&#21040;&#31532;&#19977;&#20010;&#21487;&#34892;&#26041;&#26696;&#65292;&#26159;&#25226;&#19968;&#20010;&#32467;&#26463;&#20449;&#21495;&#25918;&#36827;&#38431;&#21015;&#37324;&#12290;&#30001;&#20110;&#20351;&#29992; <code>queue&lt;Node*&gt;</code>&#65292;&#21487;&#20197;&#25554;&#20837;&#19968;&#20010;&#31354;&#25351;&#38024;&#21435;&#34920;&#31034;&#19968;&#23618;&#30340;&#36941;&#21382;&#32467;&#26463;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> PrintNodeByLevel(Node* root) {
    queue&lt;Node*&gt; Q;
    Q.push(root);
    Q.push(<span class="dv">0</span>);      <span class="co">// indicate end of level</span>
    <span class="kw">do</span> {
        Node* node = Q.front(); Q.pop();
        <span class="kw">if</span> (node) {
            cout &lt;&lt; node-&gt;data &lt;&lt; <span class="st">&quot; &quot;</span>;
            <span class="kw">if</span> ( node-&gt;pLeft  ) { Q.push(node-&gt;pLeft); }
            <span class="kw">if</span> ( node-&gt;pRight ) { Q.push(node-&gt;pRight); }
        } <span class="kw">else</span> <span class="kw">if</span> (!Q.empty()) {
            cout &lt;&lt; endl;
            Q.push(<span class="dv">0</span>);
        }
    } <span class="kw">while</span> (!Q.empty());
}</code></pre></div>
<p>&#36825;&#20010;&#23454;&#29616;&#30340;&#20195;&#30721;&#24456;&#36148;&#36817;&#20043;&#21069;&#30340; PrintBFS()&#65292;&#20063;&#21482;&#26377;&#19968;&#20010;&#24490;&#29615;&#12290;&#27880;&#24847;&#19968;&#28857;&#65292;&#24403;&#21457;&#29616;&#31354;&#25351;&#38024; (&#32467;&#26463;&#20449;&#21495;) &#26102;&#65292;&#35201;&#26816;&#26597;&#38431;&#21015;&#20869;&#26159;&#21542;&#36824;&#26377;&#33410;&#28857;&#65292;&#22914;&#26524;&#27809;&#26377;&#30340;&#35805;&#36824;&#25554;&#20837;&#26032;&#30340;&#32467;&#26463;&#20449;&#21495;&#65292;&#21017;&#20250;&#20570;&#25104;&#27515;&#24490;&#29615;&#12290;</p>
</dd>
<dt>&#27979;&#35797;&#20195;&#30721; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Link(Node* nodes, <span class="dt">int</span> parent, <span class="dt">int</span> left, <span class="dt">int</span> right) {
    <span class="kw">if</span> (left != <span class="dv">-1</span>)
        nodes[parent].pLeft = &amp;nodes[left];

    <span class="kw">if</span> (right != <span class="dv">-1</span>)
        nodes[parent].pRight = &amp;nodes[right];
}

<span class="dt">void</span> main()
{
    Node test1 = { <span class="dv">0</span> };

    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="dv">9</span>; i++)
        test1[i].data = i;

    Link(test1, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);
    Link(test1, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">5</span>);
    Link(test1, <span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">-1</span>);
    Link(test1, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">8</span>);

    PrintBFS(&amp;test1);
    cout &lt;&lt; endl &lt;&lt; endl;

    PrintNodeByLevel(&amp;test1);
    cout &lt;&lt; endl;</code></pre></div>
</dd>
</dl>
</dd>
</dl></li>
<li><p><a href="http://www.cnblogs.com/miloyip/archive/2013/04/19/3029852.html" class="heart">&#38754;&#35797;&#39064;&#65306;&#26816;&#27979;&#28857;&#26159;&#21542;&#22312;&#25159;&#24418;&#20043;&#20869; - Milo Yip - &#21338;&#23458;&#22253;</a></p></li>
<li><dl>
<dt><a href="https://www.zhihu.com/question/24251545/answer/27184960">&#24590;&#26679;&#21028;&#26029;&#24179;&#38754;&#19978;&#19968;&#20010;&#30697;&#24418;&#21644;&#19968;&#20010;&#22278;&#24418;&#26159;&#21542;&#26377;&#37325;&#21472;&#65311; - Milo Yip &#30340;&#22238;&#31572; - &#30693;&#20046;</a> <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="https://pic1.zhimg.com/31fcf0a6ba5b5b925d7d82dc5bc8a684_r.jpg" />

</div>
<div class="figure">
<img src="https://pic2.zhimg.com/60b09b89d9b4eda3fe9bdb849ec5d5d1_r.jpg" />

</div>
<p>&#26368;&#21518;&#35201;&#27604;&#36739; u &#21644; r &#30340;&#38271;&#24230;&#65292;&#33509;&#36317;&#31163;&#23569;&#20110; r&#65292;&#21017;&#20004;&#32773;&#30456;&#20132;&#12290;&#21487;&#20197;&#21482;&#27714; u &#30340;&#38271;&#24230;&#24179;&#26041;&#26159;&#21542;&#23567;&#20110; r &#30340;&#24179;&#26041;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt><a href="http://www.cnblogs.com/miloyip/archive/2010/03/04/1677902.html">&#20004;&#26465;&#20687;&#38754;&#35797;&#29992;&#30340;&#32534;&#31243;&#38382;&#39064;&#65292;&#21644;&#25105;&#30340;&#22247;&#20107; - Milo Yip - &#21338;&#23458;&#22253;</a> <code class="fold">@</code></dt>
<dd><ul>
<li>&#35774;&#35745;&#19968;&#20010;&#20989;&#25968; f&#65292;&#20351;&#24471;&#23427;&#28385;&#36275;&#65306;f(f(x))=-x&#65292;&#36825;&#37324;&#36755;&#20837;&#21442;&#25968;&#20026; 32 &#20301;&#25972;&#22411;</li>
<li>&#35774;&#35745;&#19968;&#20010;&#20989;&#25968; g&#65292;&#28385;&#36275;&#65306;g(g(x))=1/x&#65292;x &#26159;&#28014;&#28857;&#25968;</li>
</ul>
<p>&#20170;&#22825;&#21320;&#39277;&#26102;&#38388;&#23601;&#21457;&#20102;&#20197;&#19979;&#30340;&#38169;&#35823;&#35777;&#26126;&#65306;</p>
<ul>
<li>&#20551;&#35774;&#19968;&#20010;&#20989;&#25968; f &#23384;&#22312;&#65292;x &#20026; 32-bit &#25972;&#25968;&#65292;f(x)) = -x</li>
<li>&#35774; y = f(x)</li>
<li>f(f(x)) = -x -&gt; f(y) = &#8211;x</li>
<li>&#21464;&#25442;&#21464;&#37327;, f(y) = -x -&gt; f(x) = -y -&gt; y = -f(x)</li>
<li>y = f(x) = -f(x)</li>
</ul>
<p>&#31532; 5 &#27493;&#21482;&#26159;&#24403; y=0 &#25165;&#25104;&#31435;&#65292;&#21644; f &#30340;&#20540;&#22495;&#30683;&#30462;&#65292;&#25353;&#21453;&#35777;&#27861;&#65292;&#20989;&#25968; f &#19981;&#23384;&#22312;&#12290;</p>
<p>&#37073;&#32769;&#24072;&#25351;&#20986;&#65292;&#21482;&#26377;&#33258;&#30001;&#21464;&#37327; (Free Variable) &#25165;&#21487;&#20197;&#32622;&#25442; (Subsititue)&#12290;</p>
<p>&#36825;&#20004;&#38382;&#39064;&#30340;&#38590;&#28857;&#22312;&#20110;&#65292;&#20989;&#25968;&#19981;&#33021;&#20648;&#23384;&#39069;&#22806;&#29366;&#24577;&#12290;</p>
<p>&#25105;&#20204;&#39318;&#20808;&#20998;&#26512;&#38382;&#39064; (1)&#65292;&#35774; y=f(x)&#65292;&#21017;</p>
<ul>
<li>f(x) = y</li>
<li>f(y) = -x</li>
</ul>
<p>&#22914;&#26524;&#20877;&#25226;&#32467;&#26524; -x &#20877;&#24212;&#29992;&#19968;&#27425; f &#20989;&#25968;&#65292;f(-x) = ?</p>
<p>&#22240;&#20026;&#20043;&#21069; f(y)=-x&#65292;&#32780;&#25353;&#39064;&#30446;&#23450;&#20041;&#65292;f(f(y))=-y &#65292;&#25152;&#20197; f(-x) = -y&#12290;&#25105;&#20204;&#21487;&#20197;&#21015;&#20986;:</p>
<ul>
<li>f(-x) = -y</li>
<li>f(-y) = x</li>
</ul>
<p>&#25105;&#20204;&#21487;&#20197;&#21457;&#29616;&#65292;4 &#27425;&#20989;&#25968;&#26144;&#23556;&#20043;&#21518;&#65292;&#20250;&#21464;&#25104;&#19968;&#20010;&#24490;&#29615;&#12290;&#20063;&#23601;&#26159;&#35828;&#65292;</p>
<pre><code>x &#8594; y &#8594; &#8211;x &#8594; &#8211;y &#8594; x&#8594; ...</code></pre>
<p>&#25105;&#20204;&#21482;&#35201;&#25226;&#25968;&#23383;&#20998;&#20026;&#22235;&#31867;&#65292;&#23601;&#21487;&#20197;&#23454;&#29616;&#36825;&#20010;&#24490;&#29615;&#12290;x &#21644; -x &#30340;&#20998;&#21035;&#26159;&#27491;&#36127;&#21495;&#65292;&#25105;&#20204;&#21487;&#20197;&#20877;&#21033;&#29992;&#25968;&#23383;&#30340;&#22855;&#20598;&#24615;&#65292;&#36825;&#20004;&#20010;&#27491;&#20132;&#23646;&#24615;&#21487;&#20197;&#20135;&#29983; 4 &#20010;&#32452;&#21512;&#12290;&#36825;&#20010;&#24490;&#29615;&#23601;&#21487;&#21464;&#25104;</p>
<pre><code>&#27491;&#22855;&#8594; &#27491;&#20598;&#8594; &#36127;&#22855;&#8594; &#36127;&#20598;&#8594; &#27491;&#22855;&#8594; ...</code></pre>
<p>&#37073;&#32769;&#24072;&#35828;&#20182;&#32463;&#36807;&#20960;&#27425;&#25512;&#25970;&#65292;&#24471;&#21040;:</p>
<p>f(x) = (-1)<sup>x</sup>x + sign(x)</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> t&gt;
<span class="kw">inline</span> T even(T x) {
    <span class="kw">return</span> x % <span class="dv">2</span> == <span class="dv">0</span> ? <span class="dv">-1</span> : <span class="dv">1</span>;
}

<span class="kw">template</span>&lt;<span class="kw">typename</span> t&gt;
<span class="kw">inline</span> T sgn(T x) {
    <span class="kw">if</span> (x &gt; <span class="dv">0</span>)
        <span class="kw">return</span> <span class="dv">1</span>;
    <span class="kw">else</span> <span class="kw">if</span> (x &lt; <span class="dv">0</span>)
        <span class="kw">return</span> <span class="dv">-1</span>;
    <span class="kw">else</span>
        <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="kw">template</span>&lt;<span class="kw">typename</span> t&gt;
<span class="kw">struct</span> f1 {
    T <span class="kw">operator</span>()(T x) {
        <span class="kw">return</span> even(x) * x + sgn(x);
    }
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;limits&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">template</span>&lt;<span class="kw">typename</span> T, <span class="kw">typename</span> F&gt;
<span class="dt">void</span> test(F f) {
    cout &lt;&lt; <span class="st">&quot;[&quot;</span> &lt;&lt; (<span class="dt">int</span>)numeric_limits&lt;T&gt;::min() &lt;&lt; <span class="st">&quot;,&quot;</span> &lt;&lt; (<span class="dt">int</span>)numeric_limits&lt;T&gt;::max() &lt;&lt; <span class="st">&quot;]&quot;</span> &lt;&lt; endl;
    T x = numeric_limits&lt;T&gt;::min();
    <span class="kw">do</span> {
        T y = f(f(x));
        <span class="kw">if</span> (y != (T)-x)
            cout &lt;&lt; (<span class="dt">int</span>)x &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; (<span class="dt">int</span>)y &lt;&lt; endl;
        x++;
    } <span class="kw">while</span> (x != numeric_limits&lt;T&gt;::min());

    cout &lt;&lt; endl;
}

<span class="dt">void</span> main() {
    test&lt;<span class="dt">signed</span> <span class="dt">char</span>&gt;(f1&lt;<span class="dt">signed</span> <span class="dt">char</span>&gt;());
    test&lt;<span class="dt">signed</span> <span class="dt">short</span>&gt;(f1&lt;<span class="dt">signed</span> <span class="dt">short</span>&gt;());
    test&lt;<span class="dt">int</span>&gt;(f1&lt;<span class="dt">int</span>&gt;());

    test&lt;<span class="dt">signed</span> <span class="dt">char</span>&gt;(f2&lt;<span class="dt">signed</span> <span class="dt">char</span>&gt;());
    test&lt;<span class="dt">signed</span> <span class="dt">short</span>&gt;(f2&lt;<span class="dt">signed</span> <span class="dt">short</span>&gt;());
    test&lt;<span class="dt">int</span>&gt;(f2&lt;<span class="dt">int</span>&gt;());
}</code></pre></div>
<pre><code>[-128,127]
127 127

[-32768,32767]
32767 32767

[-2147483648,2147483647]
2147483647 2147483647</code></pre>
<p>&#36825;&#32467;&#26524;&#35828;&#26126;&#65292;&#38500;&#20102; x &#20026;&#25972;&#25968;&#30340;&#19978;&#38480;&#26102;&#65292;&#32467;&#26524;&#27491;&#30830;&#12290;&#20294;&#22240;&#20026;&#27809;&#26377;&#39069;&#22806;&#30340;&#29366;&#24577;&#65292;&#30456;&#20449;&#36825;&#20010;&#36793;&#30028;&#38382;&#39064;&#24212;&#35813;&#19981;&#33021;&#35299;&#20915;&#12290;</p>
<p>&#31532;&#20108;&#39064;&#27604;&#36739;&#31616;&#21333;&#65292;&#21482;&#38656;&#35201;&#21033;&#29992; -(-x) = x &#30340;&#29305;&#28857;&#65292;&#26080;&#35770; x &#20026;&#27491;&#25110;&#36127;&#65292;&#32463;&#36807;&#36825;&#20004;&#27425;&#26144;&#23556;&#65292;&#24635;&#20250;&#26377;&#19968;&#27425;&#20026;&#27491;&#25968;&#65292;&#19968;&#27425;&#20026;&#36127;&#25968;&#12290;&#25152;&#20197;&#21487;&#20197;&#20889;&#19968;&#20010;&#20989;&#25968;&#65292;&#22312; x &#20026;&#27491;&#25968;&#26102; (&#25110;&#36127;&#25968;&#26102;) &#35745;&#31639;&#20854;&#20498;&#25968;:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> g(<span class="dt">float</span> x) {
    <span class="kw">return</span> x &gt; <span class="dv">0</span> ? <span class="fl">-1.0f</span> / x : -x;
}</code></pre></div>
</dd>
</dl></li>
</ul>
</dd>
<dt>LeetCode solutions | MaskRay &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#35265; <a href="https://github.com/4ker/LeetCode">4ker/LeetCode</a>&#12290;</p>
<p>read online: <a href="http://tangzx.qiniudn.com/notes/leetcode-maskray/index.html" class="uri">http://tangzx.qiniudn.com/notes/leetcode-maskray/index.html</a></p>
<p>refs and see also</p>
<ul>
<li><a href="http://maskray.me/blog/2014-06-29-leetcode-solutions" class="hearts">LeetCode solutions | MaskRay</a></li>
</ul>
<dl>
<dt><a href="https://leetcode.com/problems/add-two-numbers/">Add Two Numbers | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><ul>
<li>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</li>
<li>Output: 7 -&gt; 0 -&gt; 8</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#26102;&#38388;&#22797;&#26434;&#24230; O(m+n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(1)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        ListNode dummy(<span class="dv">-1</span>);                                 <span class="co">// &#22836;&#33410;&#28857;</span>
        ListNode *prev = &amp;dummy;
        <span class="dt">int</span> carry = <span class="dv">0</span>;
        <span class="kw">for</span> (ListNode *pa = l1, *pb = l2;
             pa != <span class="kw">nullptr</span> || pb != <span class="kw">nullptr</span>;
             pa = pa == <span class="kw">nullptr</span> ? <span class="kw">nullptr</span> : pa-&gt;next,       <span class="co">// &#36825;&#20004;&#20010;&#8220;&#19979;&#19968;&#27493;&#8221;&#19981;&#35201;&#22826;&#36190;&#65281;</span>
             pb = pb == <span class="kw">nullptr</span> ? <span class="kw">nullptr</span> : pb-&gt;next,
             prev = prev-&gt;next) {
            <span class="dt">int</span> ai = pa == <span class="kw">nullptr</span> ? <span class="dv">0</span> : pa-&gt;val;
            <span class="dt">int</span> bi = pb == <span class="kw">nullptr</span> ? <span class="dv">0</span> : pb-&gt;val;
            <span class="dt">int</span> value = (ai + bi + carry) % <span class="dv">10</span>;
            carry = (ai + bi + carry) / <span class="dv">10</span>;
            prev-&gt;next = <span class="kw">new</span> ListNode(value);               <span class="co">// &#23614;&#25554;&#27861;</span>
        }
        <span class="kw">if</span> (carry &gt; <span class="dv">0</span>)
            prev-&gt;next = <span class="kw">new</span> ListNode(carry);
        <span class="kw">return</span> dummy.next;
    }
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        ListNode *r = NULL, *p = NULL;
        <span class="dt">int</span> c = <span class="dv">0</span>;
        <span class="kw">while</span> (l1 || l2) {
            <span class="kw">if</span> (l1) {
                c += l1-&gt;val;
                l1 = l1-&gt;next;
            }
            <span class="kw">if</span> (l2) {
                c += l2-&gt;val;
                l2 = l2-&gt;next;
            }
            <span class="kw">auto</span> x = <span class="kw">new</span> ListNode(c%<span class="dv">10</span>);
            c /= <span class="dv">10</span>;
            <span class="kw">if</span> (! r)                    <span class="co">// &#36825;&#37324;&#21487;&#20197;&#23545;&#27604;&#20986;&#19978;&#38754;&#30340; dummy node &#22810;&#20040;&#24039;&#22937;</span>
                r = p = x;
            <span class="kw">else</span> {
                p-&gt;next = x;
                p = p-&gt;next;
            }
        }
        <span class="kw">if</span> (c)
            p-&gt;next = <span class="kw">new</span> ListNode(c);
        <span class="kw">return</span> r;
    }
};</code></pre></div>
<p>&#19968;&#20010;&#31867;&#20284;&#30340;&#39064;&#65306;</p>
<dl>
<dt><a href="https://leetcode.com/problems/add-binary/">Add Binary | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#26102;&#38388;&#22797;&#26434;&#24230; O(n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(1)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    string addBinary(string a, string b) {
        <span class="dt">const</span> size_t n = max( a.size(), b.size() );
        string result;
        result.reserve( n<span class="dv">+1</span> );
        result.resize( n );
        reverse(a.begin(), a.end());
        reverse(b.begin(), b.end());
        <span class="dt">int</span> carry = <span class="dv">0</span>;
        <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; n; i++) {
            <span class="dt">int</span> ai = i &lt; a.size() ? a[i] - <span class="st">&#39;0&#39;</span> : <span class="dv">0</span>;
            <span class="dt">int</span> bi = i &lt; b.size() ? b[i] - <span class="st">&#39;0&#39;</span> : <span class="dv">0</span>;
            <span class="dt">int</span> val = (ai + bi + carry) % <span class="dv">2</span>;
            carry = (ai + bi + carry) / <span class="dv">2</span>;
            result[i] = val + <span class="st">&#39;0&#39;</span>;
        }
        <span class="kw">if</span> (carry == <span class="dv">1</span>) {
            result.push_back( <span class="st">&#39;1&#39;</span> );
        }
        reverse( result.begin(), result.end() );
        <span class="kw">return</span> result;
    }
};</code></pre></div>
<p>&#36824;&#26377;&#19968;&#20010;&#31867;&#20284;&#30340;&#39064;&#65292;&#36825;&#20010;&#21487;&#20197;&#25552;&#21069;&#36864;&#20986;&#65288;&#22240;&#20026;&#19981;&#26159;&#20004;&#20010;&#25968;&#30456;&#21152;&#65289;&#65306;</p>
<dl>
<dt><a href="https://leetcode.com/problems/plus-one/">Plus One | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>&#36825;&#20010;&#30452;&#35266;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    vector&lt;<span class="dt">int</span>&gt; plusOne(vector&lt;<span class="dt">int</span>&gt; &amp;digits) {
        add(digits, <span class="dv">1</span>);
        <span class="kw">return</span> digits;
    }
<span class="kw">private</span>:
    <span class="co">// 0 &lt;= digit &lt;= 9</span>
    <span class="dt">void</span> add(vector&lt;<span class="dt">int</span>&gt; &amp;digits, <span class="dt">int</span> digit) {
        <span class="dt">int</span> c = digit;  <span class="co">// carry, &#36827;&#20301;</span>

        <span class="kw">for</span> (<span class="kw">auto</span> it = digits.rbegin(); it != digits.rend(); ++it) {
            *it += c;
            c = *it / <span class="dv">10</span>;
            *it %= <span class="dv">10</span>;
            <span class="kw">if</span>( !c ) { <span class="kw">return</span>; } <span class="co">// &#27809;&#26377; carry &#23601;&#36864;&#20986;&#21679;</span>
        }

        <span class="kw">if</span> (c &gt; <span class="dv">0</span>) digits.insert(digits.begin(), <span class="dv">1</span>);
    }
};</code></pre></div>
<p>&#36825;&#20010;&#19981;&#22826;&#22909;&#29702;&#35299;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    vector&lt;<span class="dt">int</span>&gt; plusOne(vector&lt;<span class="dt">int</span>&gt; &amp;a) {
        <span class="kw">using</span> <span class="kw">namespace</span> std::placeholders;
        <span class="kw">if</span> (find_if(a.begin(), a.end(), bind(not_equal_to&lt;<span class="dt">int</span>&gt;(), _1, <span class="dv">9</span>)) == a.end()) {
            a.assign(a.size()<span class="dv">+1</span>, <span class="dv">0</span>);
            a[<span class="dv">0</span>] = <span class="dv">1</span>;
        } <span class="kw">else</span> {
            <span class="dt">int</span> i = a.size();
            <span class="kw">while</span> (++a[--i] &gt;= <span class="dv">10</span>)
                a[i] -= <span class="dv">10</span>;
        }
        <span class="kw">return</span> a;
    }
};</code></pre></div>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt><a href="https://leetcode.com/problems/reverse-linked-list/">Reverse Linked List | LeetCode OJ</a> &#9829;&#65039; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    ListNode* reverseList(ListNode* x) {
        ListNode *y = <span class="dv">0</span>, *t;    <span class="co">// &#21021;&#22987;&#20026; 0</span>
        <span class="kw">while</span> (x) {
            t = x-&gt;next;        <span class="co">// &#20445;&#23384;&#21518;&#38754;&#21487;&#20197;&#25191;&#34892;&#30340;&#20869;&#23481;</span>
            x-&gt;next = y;        <span class="co">// &#39072;&#20498;&#26041;&#21521;&#65292;&#25351;&#21521;&#19978;&#19968;&#20010;&#22836;&#25351;&#38024;</span>
            y = x;              <span class="co">// &#26356;&#26032;&#22836;&#25351;&#38024;</span>
            x = t;              <span class="co">// &#19979;&#19968;&#27493;</span>
        }
        <span class="kw">return</span> y;
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/reverse-linked-list-ii/">Reverse Linked List II | LeetCode OJ</a> &#9829;&#65039; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#38590;&#22312;&#38656;&#35201;&#22312;&#25351;&#23450;&#33539;&#22260;&#20869; reverse&#12290;</p>
<p>&#24050;&#32463;&#20445;&#35777;&#20102;&#65306;1 &#8804; m &#8804; n &#8804; length of list&#12290;</p>
<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:</p>
<pre><code>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,
return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.

&#21021;&#22987;&#65306;
    1   -&gt;  2   -&gt;  3   -&gt;  4   -&gt;  5   -&gt;  NULL

&#25805;&#20316;&#65306;
        +-------------------+
        |                   |
        |                   V
    1 -&gt;+   2   &lt;-  3   &lt;-  4       5   -&gt;  NULL
            |                       ^
            |                       |
            +-----------------------+

&#32467;&#26524;&#65306;
    1   -&gt;  4   -&gt;  3   -&gt;  2   -&gt;  5   -&gt;  NULL

dummy.next = &amp;1
prev = &amp;dummy

    1   -&gt;  2   -&gt;  3   -&gt;  4   -&gt;  5   -&gt;  NULL
    ^
    |
    prev, head2


            +-----------------------+
            |                       |
            |                       V
    1   -&gt;  2   -&gt;  3   -&gt;  4   -&gt;  5   -&gt;  NULL
    ^       ^       ^       ^
    |       |       |       |
    head2   prev &lt;- cur     |
            |               |
            +---------------+</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#36845;&#20195;&#29256;&#65292;&#26102;&#38388;&#22797;&#26434;&#24230; O(n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(1)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    ListNode *reverseBetween(ListNode *head, <span class="dt">int</span> m, <span class="dt">int</span> n) {
        ListNode dummy(<span class="dv">-1</span>);
        dummy.next = head;

        ListNode *prev = &amp;dummy;
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m<span class="dv">-1</span>; ++i)
            prev = prev-&gt;next;

        ListNode *head2 = prev;                 <span class="co">// head2 &#25351;&#21521;&#21464;&#21270;&#21306;&#22495;&#20043;&#21069;&#30340;&#19968;&#20010;&#20803;&#32032;</span>
        prev            = head2-&gt;next;
        ListNode *cur   = prev-&gt;next;
        <span class="kw">for</span> (<span class="dt">int</span> i = m; i &lt; n; ++i) {
            prev-&gt;next = cur-&gt;next;             <span class="co">// &#20445;&#23384;</span>
            cur-&gt;next = head2-&gt;next;            <span class="co">// &#36825;&#26159;&#20445;&#23384;&#20102;&#30340;&#8221;&#26032;&#8220;&#22836;&#65292;&#20063;&#23601;&#26159;&#19978;&#19968;&#20010;&#33410;&#28857;&#65292;&#31532;&#19968;&#27425;&#35843;&#29992;&#30340;&#26102;&#20505;&#65292;&#24688;&#22909;&#26159; &amp;5</span>
            head2-&gt;next = cur;                  <span class="co">// &#22836;&#25554;&#27861;</span>
            cur = prev-&gt;next;                   <span class="co">// &#24674;&#22797;</span>
        }

        <span class="kw">return</span> dummy.next;
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/lru-cache/">LRU Cache | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.</p>
<p><code>set(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>&#20026;&#20102;&#20351;&#26597;&#25214;&#12289;&#25554;&#20837;&#21644;&#21024;&#38500;&#37117;&#26377;&#36739;&#39640;&#30340;&#24615;&#33021;&#65292;&#25105;&#20204;&#20351;&#29992;&#19968;&#20010;&#21452;&#21521;&#38142;&#34920; (<code>std::list</code>) &#21644;&#19968;&#20010;&#21704;&#24076;&#34920; (<code>std::unordered_map</code>)&#65292;&#22240;&#20026;&#65306;</p>
<ul>
<li>&#21704;&#24076;&#34920;&#20445;&#23384;&#27599;&#20010;&#33410;&#28857;&#30340;&#22320;&#22336;&#65292;&#21487;&#20197;&#22522;&#26412;&#20445;&#35777;&#22312; O(1) &#26102;&#38388;&#20869;&#26597;&#25214;&#33410;&#28857;</li>
<li>&#21452;&#21521;&#38142;&#34920;&#25554;&#20837;&#21644;&#21024;&#38500;&#25928;&#29575;&#39640;&#65292;&#21333;&#21521;&#38142;&#34920;&#25554;&#20837;&#21644;&#21024;&#38500;&#26102;&#65292;&#36824;&#35201;&#26597;&#25214;&#33410;&#28857;&#30340;&#21069;&#39537;&#33410;&#28857;</li>
</ul>
<p>&#20855;&#20307;&#23454;&#29616;&#32454;&#33410;&#65306;</p>
<ul>
<li>&#36234;&#38752;&#36817;&#38142;&#34920;&#22836;&#37096;&#65292;&#34920;&#31034;&#33410;&#28857;&#19978;&#27425;&#35775;&#38382;&#36317;&#31163;&#29616;&#22312;&#26102;&#38388;&#26368;&#30701;&#65292;&#23614;&#37096;&#30340;&#33410;&#28857;&#34920;&#31034;&#26368;&#36817;&#35775;&#38382;&#26368;&#23569;}</li>
<li>&#35775;&#38382;&#33410;&#28857;&#26102;&#65292;&#22914;&#26524;&#33410;&#28857;&#23384;&#22312;&#65292;&#25226;&#35813;&#33410;&#28857;&#20132;&#25442;&#21040;&#38142;&#34920;&#22836;&#37096;&#65292;&#21516;&#26102;&#26356;&#26032; hash &#34920;&#20013;&#35813;&#33410;&#28857;&#30340;&#22320;&#22336;}</li>
<li>&#25554;&#20837;&#33410;&#28857;&#26102;&#65292;&#22914;&#26524; cache &#30340; size &#36798;&#21040;&#20102;&#19978;&#38480; capacity&#65292;&#21017;&#21024;&#38500;&#23614;&#37096;&#33410;&#28857;&#65292;&#21516;&#26102;&#35201;&#22312; hash &#34920;&#20013;&#21024;&#38500;&#23545;&#24212;&#30340;&#39033;&#65307;&#26032;&#33410;&#28857;&#25554;&#20837;&#38142;&#34920;&#22836;&#37096;}</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> LRUCache {
<span class="kw">public</span>:
    LRUCache(<span class="dt">int</span> capacity) : c(capacity) {}

    <span class="dt">void</span> touch(<span class="dt">int</span> key) {
        pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; x = *s[key];
        a.erase(s[key]);
        a.push_front(x);
        s[x.first] = a.begin();
    }

    <span class="dt">int</span> get(<span class="dt">int</span> key) {
        <span class="kw">if</span> (! s.count(key))
            <span class="kw">return</span> <span class="dv">-1</span>;
        touch(key);
        <span class="kw">return</span> a.begin()-&gt;second;
    }

    <span class="dt">void</span> set(<span class="dt">int</span> key, <span class="dt">int</span> value) {
        <span class="kw">if</span> (s.count(key)) {
            touch(key);
            a.begin()-&gt;second = value;
        } <span class="kw">else</span> {
            <span class="kw">if</span> (s.size() &gt;= c) {
                s.erase(a.rbegin()-&gt;first);
                a.pop_back();
            }
            a.push_front(make_pair(key, value));
            s[key] = a.begin();
        }
    }

<span class="kw">private</span>:
    map&lt;<span class="dt">int</span>, list&lt;pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; &gt;::iterator&gt; s;
    list&lt;pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; &gt; a;
    <span class="dt">int</span> c;
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/valid-palindrome/">Valid Palindrome | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>&#36825;&#20010;&#24456;&#24039;&#22937;&#65292;&#31227;&#21160;&#21040;&#24038;&#20391;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">bool</span> isPalindrome(string s) {
        <span class="dt">int</span> i = <span class="dv">0</span>, j = <span class="dv">0</span>;
        <span class="kw">for</span> (; i &lt; s.size(); i++)
            <span class="kw">if</span> (isalnum(s[i]))
                s[j++] = s[i];
        <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; --j; i++)
            <span class="kw">if</span> (tolower(s[i]) != tolower(s[j]))
                <span class="kw">return</span> <span class="kw">false</span>;
        <span class="kw">return</span> <span class="kw">true</span>;
    }
};</code></pre></div>
<p>&#36825;&#20010;&#19981;&#20250;&#20462;&#25913; s&#65288;&#34429;&#28982;&#26159;&#19968;&#20010;&#25335;&#36125;&#65292;&#26080;&#25152;&#35859;&#20462;&#25913;&#65289;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">bool</span> isPalindrome(string s) {
        <span class="dt">int</span> left = <span class="dv">0</span>, right = s.size()<span class="dv">-1</span>;
        <span class="kw">while</span>( left &lt; right ) {
            <span class="kw">while</span>( !::isalnum(s[left])  &amp;&amp; left<span class="dv">+1</span> &lt;= right ) { ++left;  }
            <span class="kw">while</span>( !::isalnum(s[right]) &amp;&amp; right<span class="dv">-1</span> &gt;= left ) { --right; }
            <span class="kw">if</span>( left &lt; right ) {
                <span class="kw">if</span>( ::tolower(s[left]) != ::tolower(s[right]) ) {
                    <span class="kw">return</span> <span class="kw">false</span>;
                }
            }
            ++left;
            --right;
        }
        <span class="kw">return</span> <span class="kw">true</span>;
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/longest-palindromic-substring/">Longest Palindromic Substring | LeetCode OJ</a> &#9829;&#65039; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#20808;&#29702;&#35299;&#19979;&#21861;&#26159; Longest substring <code class="fold">@</code></dt>
<dd><p>Nil.</p>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Longest_common_substring_problem">Longest common substring problem - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
</dl>
<p><strong>Difficulty: Medium</strong></p>
<p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>
<ul>
<li><dl>
<dt>&#24605;&#36335;&#19968;&#65306;&#26292;&#21147;&#26522;&#20030;&#65292;&#20197;&#27599;&#20010;&#20803;&#32032;&#20026;&#20013;&#38388;&#20803;&#32032;&#65292;&#21516;&#26102;&#20174;&#24038;&#21491;&#20986;&#21457;&#65292;&#22797;&#26434;&#24230; O(n^2) <code class="fold">@</code></dt>
<dd><p>&#36825;&#20010;&#25928;&#29575;&#24182;&#19981;&#20302;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#24605;&#36335;&#20108;&#65306;&#35760;&#24518;&#21270;&#25628;&#32034;&#65292;&#22797;&#26434;&#24230; O(n^2)&#12290;&#35774; <code>f[i][j]</code> &#34920;&#31034; <code>[i,j]</code> &#20043;&#38388;&#30340;&#26368;&#38271;&#22238;&#25991;&#23376;&#20018; <code class="fold">@</code></dt>
<dd><p>&#36882;&#25512;&#26041;&#31243;&#22914;&#19979;&#65306;</p>
<pre><code>f[i][j] = if (i == j) S[i]
          if (S[i] == S[j] &amp;&amp; f[i+1][j-1] == S[i+1][j-1]) S[i][j]
          else max(f[i+1][j-1], f[i][j-1], f[i+1][j])</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#26102;&#38388;&#22797;&#26434;&#24230; O(n^2)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(n^2)</span>
<span class="kw">typedef</span> string::const_iterator Iterator;

<span class="kw">namespace</span> std {
<span class="kw">template</span>&lt;&gt;
<span class="kw">struct</span> hash&lt;pair&lt;Iterator, Iterator&gt;&gt; {
    size_t <span class="kw">operator</span>()(pair&lt;Iterator, Iterator&gt; <span class="dt">const</span>&amp; p) <span class="dt">const</span> {
        <span class="kw">return</span> ((size_t) &amp;(*p.first)) ^ ((size_t) &amp;(*p.second));
    }
};
}

<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    string longestPalindrome(string <span class="dt">const</span>&amp; s) {
        cache.clear();
        <span class="kw">return</span> cachedLongestPalindrome(s.begin(), s.end());
    }

<span class="kw">private</span>:
    unordered_map&lt;pair&lt;Iterator, Iterator&gt;, string&gt; cache;

    string longestPalindrome(Iterator first, Iterator last) {
        size_t length = distance(first, last);

        <span class="kw">if</span> (length &lt; <span class="dv">2</span>) <span class="kw">return</span> string(first, last);

        <span class="kw">auto</span> s = cachedLongestPalindrome(next(first), prev(last));

        <span class="kw">if</span> (s.length() == length - <span class="dv">2</span> &amp;&amp; *first == *prev(last))
            <span class="kw">return</span> string(first, last);

        <span class="kw">auto</span> s1 = cachedLongestPalindrome(next(first), last);
        <span class="kw">auto</span> s2 = cachedLongestPalindrome(first, prev(last));

        <span class="co">// return max(s, s1, s2)</span>
        <span class="kw">if</span> (s.size() &gt; s1.size()) <span class="kw">return</span> s.size() &gt; s2.size() ? s : s2;
        <span class="kw">else</span> <span class="kw">return</span> s1.size() &gt; s2.size() ? s1 : s2;
    }

    string cachedLongestPalindrome(Iterator first, Iterator last) {
        <span class="kw">auto</span> key = make_pair(first, last);
        <span class="kw">auto</span> pos = cache.find(key);

        <span class="kw">if</span> (pos != cache.end()) <span class="kw">return</span> pos-&gt;second;
        <span class="kw">else</span> <span class="kw">return</span> cache[key] = longestPalindrome(first, last);
    }
};</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>&#24605;&#36335;&#19977;&#65306;&#21160;&#35268;&#65292;&#22797;&#26434;&#24230; O(n^2)&#12290;&#35774;&#29366;&#24577;&#20026; <code>f(i,j)</code>&#65292;&#34920;&#31034;&#21306;&#38388; <code>[i,j]</code> &#26159;&#21542;&#20026;&#22238;&#25991;&#20018; <code class="fold">@</code></dt>
<dd><p>&#21017;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#20026;</p>
<pre><code>                    true                                        i=j
f(i,j)      =       S[i]=S[j]                                   j = i + 1
                    S[i]=S[j] and f(i+1, j-1)                   j &gt; i + 1</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#21160;&#35268;&#65292;&#26102;&#38388;&#22797;&#26434;&#24230; O(n^2)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(n^2)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    string longestPalindrome(<span class="dt">const</span> string&amp; s) {
        <span class="dt">const</span> <span class="dt">int</span> n = s.size();
        <span class="dt">bool</span> f[n][n];
        fill_n(&amp;f[<span class="dv">0</span>][<span class="dv">0</span>], n * n, <span class="kw">false</span>);
        size_t max_len = <span class="dv">1</span>, start = <span class="dv">0</span>;  <span class="co">// &#26368;&#38271;&#22238;&#25991;&#23376;&#20018;&#30340;&#38271;&#24230;&#65292;&#36215;&#28857;</span>

        <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; s.size(); i++) {
            f[i][i] = <span class="kw">true</span>;
            <span class="kw">for</span> (size_t j = <span class="dv">0</span>; j &lt; i; j++) {            <span class="co">// &#21306;&#38388;&#65306;[j, i]</span>
                <span class="co">// &#36825;&#20010; f[j+1][i-1] &#20915;&#23450;&#20102; i &#30340;&#36941;&#21382;&#39034;&#24207;&#65292;j &#26080;&#25152;&#35859;&#65292;&#22240;&#20026;&#19978;&#19968;&#23618;&#30340;&#37117;&#26159;&#35745;&#31639;&#36807;&#30340;</span>
                f[j][i] = ( s[j] == s[i] &amp;&amp; (i - j &lt; <span class="dv">2</span> || f[j + <span class="dv">1</span>][i - <span class="dv">1</span>]) );
                <span class="kw">if</span> (f[j][i] &amp;&amp; max_len &lt; (i - j + <span class="dv">1</span>)) {
                    max_len = i - j + <span class="dv">1</span>;
                    start = j;
                }
            }
        }
        <span class="kw">return</span> s.substr(start, max_len);
    }
};</code></pre></div>
<p>Soulmachine &#35828;&#29992; vector &#20250;&#36229;&#26102; <code>vector&lt;vector&lt;bool&gt; &gt; f(n, vector&lt;bool&gt;(n, false));</code>&#65292;&#20272;&#35745;&#26159; <code>vector&lt;bool&gt;</code> &#23547;&#22336;&#25928;&#29575;&#22826;&#20302;&#23548;&#33268;&#12290;&#20854;&#23454;&#25442;&#25104; <code>vector&lt;vector&lt;int&gt;&gt; f</code> &#23601;&#22909;&#20102;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>&#24605;&#36335;&#22235;&#65306;Manacher&#8217;s Algorithm, &#22797;&#26434;&#24230; O(n)&#12290; <code class="fold">@</code></dt>
<dd><p>&#35814;&#32454;&#35265; <a href="http://articles.leetcode.com/longest-palindromic-substring-part-ii">Longest Palindromic Substring Part II &#8211; LeetCode</a>&#12290;&#65288;&#19979;&#25991;&#26377;&#25688;&#24405;&#12290;&#65289;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Longest Palindromic Substring</span>
<span class="co">// Manacher&#39;s algorithm</span>

<span class="ot">#define FOR(i, a, b) for (decltype(b) i = (a); i &lt; (b); i++)</span>
<span class="ot">#define REP(i, n) FOR(i, 0, n)</span>

<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    string longestPalindrome(string s) {
        string a(<span class="dv">2</span>*s.size()<span class="dv">+1</span>, <span class="st">&#39;.&#39;</span>);
        vector&lt;<span class="dt">int</span>&gt; z(<span class="dv">2</span>*s.size()<span class="dv">+1</span>);
        REP(i, s.size())
            a[<span class="dv">2</span>*i<span class="dv">+1</span>] = s[i];
        <span class="kw">for</span> (<span class="dt">int</span> f, g = <span class="dv">0</span>, i = <span class="dv">0</span>; i &lt; a.size(); i++)
            <span class="kw">if</span> (i &lt; g &amp;&amp; z[<span class="dv">2</span>*f-i] != g-i)
                z[i] = min(z[<span class="dv">2</span>*f-i], g-i);
            <span class="kw">else</span> {
                f = i;
                g = max(g, i);
                <span class="kw">while</span> (g &lt; a.size() &amp;&amp; <span class="dv">2</span>*f-g &gt;= <span class="dv">0</span> &amp;&amp; a[g] == a[<span class="dv">2</span>*f-g]) g++;
                z[i] = g-f;
            }
        <span class="dt">int</span> x = max_element(z.begin(), z.end()) - z.begin();
        <span class="kw">return</span> s.substr((x-z[x]<span class="dv">+1</span>)/<span class="dv">2</span>, z[x]<span class="dv">-1</span>);
    }
};</code></pre></div>
</dd>
<dt>LeetCode &#19978;&#38754;&#30340;&#20998;&#26512;&#20063;&#25402;&#26377;&#24847;&#24605; <code class="fold">@</code></dt>
<dd><pre><code>Stated more formally below:
    Define P[ i, j ] &#8592; true iff the substring Si &#8230; Sj is a palindrome, otherwise false.

Therefore,
    P[ i, j ] &#8592; ( P[ i+1, j-1 ] and Si = Sj )

The base cases are:
    P[ i, i ] &#8592; true
    P[ i, i+1 ] &#8592; ( Si = Si+1 )</code></pre>
<p>This yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on&#8230;</p>
<p>This gives us a run time complexity of O(N2) and uses O(N2) space to store the table.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">string longestPalindromeDP(string s) {
    <span class="dt">int</span> n = s.length();
    <span class="dt">int</span> longestBegin = <span class="dv">0</span>;
    <span class="dt">int</span> maxLen = <span class="dv">1</span>;
    <span class="dt">bool</span> table[<span class="dv">1000</span>][<span class="dv">1000</span>] = {<span class="kw">false</span>};
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
        table[i][i] = <span class="kw">true</span>;
    }
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n<span class="dv">-1</span>; i++) {
        <span class="kw">if</span> (s[i] == s[i<span class="dv">+1</span>]) {
            table[i][i<span class="dv">+1</span>] = <span class="kw">true</span>;
            longestBegin = i;
            maxLen = <span class="dv">2</span>;
        }
    }
    <span class="kw">for</span> (<span class="dt">int</span> len = <span class="dv">3</span>; len &lt;= n; len++) {
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n-len<span class="dv">+1</span>; i++) {
            <span class="dt">int</span> j = i+len<span class="dv">-1</span>;
            <span class="kw">if</span> (s[i] == s[j] &amp;&amp; table[i<span class="dv">+1</span>][j<span class="dv">-1</span>]) {
                table[i][j] = <span class="kw">true</span>;
                longestBegin = i;
                maxLen = len;
            }
        }
    }
    <span class="kw">return</span> s.substr(longestBegin, maxLen);
}</code></pre></div>
<p>&#25110;&#32773;&#65292;&#20174;&#20013;&#24515;&#20687;&#20004;&#36793;&#25193;&#24352;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">string expandAroundCenter(string s, <span class="dt">int</span> c1, <span class="dt">int</span> c2) {
    <span class="dt">int</span> l = c1, r = c2;
    <span class="dt">int</span> n = s.length();
    <span class="kw">while</span> (l &gt;= <span class="dv">0</span> &amp;&amp; r &lt;= n<span class="dv">-1</span> &amp;&amp; s[l] == s[r]) {
        l--;
        r++;
    }
    <span class="kw">return</span> s.substr(l<span class="dv">+1</span>, r-l<span class="dv">-1</span>);
}

string longestPalindromeSimple(string s) {
    <span class="dt">int</span> n = s.length();
    <span class="kw">if</span> (n == <span class="dv">0</span>) <span class="kw">return</span> <span class="st">&quot;&quot;</span>;
    string longest = s.substr(<span class="dv">0</span>, <span class="dv">1</span>);  <span class="co">// a single char itself is a palindrome</span>
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n<span class="dv">-1</span>; i++) {
        string p1 = expandAroundCenter(s, i, i);
        <span class="kw">if</span> (p1.length() &gt; longest.length())
            longest = p1;

        string p2 = expandAroundCenter(s, i, i<span class="dv">+1</span>);
        <span class="kw">if</span> (p2.length() &gt; longest.length())
            longest = p2;
    }
    <span class="kw">return</span> longest;
}</code></pre></div>
<p>An O(N) Solution (Manacher&#8217;s Algorithm)&#65292;TODO</p>
</dd>
</dl></li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="http://articles.leetcode.com/longest-palindromic-substring-part-ii">Longest Palindromic Substring Part II &#8211; LeetCode</a></li>
</ul>
</dd>
<dt><a href="https://leetcode.com/problems/regular-expression-matching/">Regular Expression Matching | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#36882;&#24402;&#29256;&#65292;&#26102;&#38388;&#22797;&#26434;&#24230; O(n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(1)</span>

<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">bool</span> isMatch(<span class="dt">const</span> string&amp; s, <span class="dt">const</span> string&amp; p) {
        <span class="kw">return</span> isMatch(s.c_str(), p.c_str());
    }
<span class="kw">private</span>:
    <span class="dt">bool</span> isMatch(<span class="dt">const</span> <span class="dt">char</span> *s, <span class="dt">const</span> <span class="dt">char</span> *p) {
        <span class="kw">if</span> ( *p == <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span> ) { <span class="kw">return</span> *s == <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>; }

        <span class="co">// next char is not &#39;*&#39;, then must match current character</span>
        <span class="kw">if</span> (*(p + <span class="dv">1</span>) != <span class="st">&#39;*&#39;</span>) {
            <span class="kw">if</span> (*p == *s || (*p == <span class="st">&#39;.&#39;</span> &amp;&amp; *s != <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>))
                <span class="kw">return</span> isMatch(s + <span class="dv">1</span>, p + <span class="dv">1</span>);
            <span class="kw">else</span>
                <span class="kw">return</span> <span class="kw">false</span>;
        } <span class="kw">else</span> { <span class="co">// next char is &#39;*&#39;</span>
            <span class="kw">while</span> (*p == *s || (*p == <span class="st">&#39;.&#39;</span> &amp;&amp; *s != <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>)) {
                <span class="kw">if</span> (isMatch(s, p + <span class="dv">2</span>))
                    <span class="kw">return</span> <span class="kw">true</span>;
                s++;
            }
            <span class="kw">return</span> isMatch(s, p + <span class="dv">2</span>);
        }
    }
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Regular Expression Matching</span>
<span class="ot">#define REP(i, n) for (int i = 0; i &lt; (n); i++)</span>

<span class="kw">class</span> Solution {
<span class="kw">private</span>:
    <span class="kw">struct</span> State {
        <span class="dt">int</span> c;
        <span class="dt">bool</span> epsf, epsb;
        State() : c(<span class="dv">-2</span>), epsf(<span class="kw">false</span>), epsb(<span class="kw">false</span>) {}
    };
<span class="kw">public</span>:
    <span class="dt">bool</span> isMatch(<span class="dt">const</span> <span class="dt">char</span> *s, <span class="dt">const</span> <span class="dt">char</span> *p) {
        vector&lt;State&gt; states(<span class="dv">1</span>);
        <span class="kw">while</span> (*p) {
            states.back().c = *p == <span class="st">&#39;.&#39;</span> ? <span class="dv">-1</span> : *p;
            states.emplace_back();
            <span class="kw">if</span> (*++p == <span class="st">&#39;*&#39;</span>) {
                states.back().epsb = <span class="kw">true</span>;
                states[states.size()<span class="dv">-2</span>].epsf = <span class="kw">true</span>;
                p++;
            }
        }

        vector&lt;<span class="dt">bool</span>&gt; f(states.size()), ff(states.size());
        f[<span class="dv">0</span>] = <span class="kw">true</span>;
        <span class="kw">for</span> (;; s++) {
            REP(i, states.size())
                <span class="kw">if</span> (f[i]) {
                    <span class="kw">if</span> (states[i].epsf)
                        f[i<span class="dv">+1</span>] = <span class="kw">true</span>;
                    <span class="kw">if</span> (states[i].epsb)
                        f[i<span class="dv">-1</span>] = <span class="kw">true</span>;
                }
            <span class="kw">if</span> (! *s) <span class="kw">break</span>;
            fill(ff.begin(), ff.end(), <span class="kw">false</span>);
            REP(i, states.size())
                <span class="kw">if</span> (f[i] &amp;&amp; (states[i].c == <span class="dv">-1</span> || states[i].c == *s))
                    ff[i<span class="dv">+1</span>] = <span class="kw">true</span>;
            f.swap(ff);
        }
        <span class="kw">return</span> f.back();
    }
};</code></pre></div>
<p>compile error.</p>
</dd>
<dt><a href="https://leetcode.com/problems/longest-common-prefix/">Longest Common Prefix | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>&#22797;&#26434;&#24230;&#37117;&#26159; O(n1+n2+&#8230;)</p>
<p>&#32437;&#21521;&#25195;&#25551;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Longest Common Prefix</span>
<span class="ot">#define FOR(i, a, b) for (decltype(b) i = (a); i &lt; (b); i++)</span>
<span class="ot">#define REP(i, n) FOR(i, 0, n)</span>

<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    string longestCommonPrefix(vector&lt;string&gt; &amp;strs) {
        <span class="kw">if</span> (strs.empty()) <span class="kw">return</span> <span class="st">&quot;&quot;</span>;
        <span class="dt">int</span> r = <span class="dv">0</span>;
        <span class="kw">for</span>(;;) {
            <span class="dt">char</span> c = strs[<span class="dv">0</span>][r];
            REP(i, strs.size())
                <span class="kw">if</span> (! strs[i][r] || strs[i][r] != c)
                    <span class="kw">return</span> strs[<span class="dv">0</span>].substr(<span class="dv">0</span>, r);
            r++;
        }
    }
};</code></pre></div>
<p>&#25110;&#32773;&#65292;&#27178;&#21521;&#25195;&#25551;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#27178;&#21521;&#25195;&#25551;&#65292;&#27599;&#20010;&#23383;&#31526;&#20018;&#19982;&#31532; 0 &#20010;&#23383;&#31526;&#20018;&#65292;&#20174;&#24038;&#21040;&#21491;&#27604;&#36739;&#65292;&#30452;&#21040;&#36935;&#21040;&#19968;&#20010;&#19981;&#21305;&#37197;&#65292;&#28982;&#21518;&#32487;&#32493;&#19979;&#19968;&#20010;&#23383;&#31526;&#20018;</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    string longestCommonPrefix(vector&lt;string&gt; &amp;strs) {
        <span class="kw">if</span> (strs.empty()) <span class="kw">return</span> <span class="st">&quot;&quot;</span>;
        <span class="dt">int</span> right_most = strs[<span class="dv">0</span>].size() - <span class="dv">1</span>;
        <span class="kw">for</span> (size_t i = <span class="dv">1</span>; i &lt; strs.size(); i++)
            <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= right_most; j++)
                <span class="kw">if</span> (strs[i][j] != strs[<span class="dv">0</span>][j])                   <span class="co">// &#19981;&#20250;&#36234;&#30028;&#65292;&#35831;&#21442;&#32771;string::[]&#30340;&#25991;&#26723;</span>
                    right_most = j - <span class="dv">1</span>;

        <span class="kw">return</span> strs[<span class="dv">0</span>].substr(<span class="dv">0</span>, right_most + <span class="dv">1</span>);
    }
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Valid Parentheses</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">bool</span> isValid(string s) {
        stack&lt;<span class="dt">char</span>&gt; st;
        <span class="dt">char</span> cc;
        <span class="kw">for</span> (<span class="kw">auto</span> c: s)
            <span class="kw">switch</span> (c) {
            <span class="kw">case</span> <span class="st">&#39;(&#39;</span>: <span class="kw">case</span> <span class="st">&#39;[&#39;</span>: <span class="kw">case</span> <span class="st">&#39;{&#39;</span>:
                st.push(c);
                <span class="kw">break</span>;
            <span class="kw">case</span> <span class="st">&#39;)&#39;</span>: <span class="kw">case</span> <span class="st">&#39;]&#39;</span>: <span class="kw">case</span> <span class="st">&#39;}&#39;</span>:
                <span class="kw">if</span> (st.empty() || (cc = st.top(), st.pop(), cc<span class="dv">+1</span> != c &amp;&amp; cc<span class="dv">+2</span> != c))
                    <span class="kw">return</span> <span class="kw">false</span>;
            }
        <span class="kw">return</span> st.empty();
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/recover-binary-search-tree/">Recover Binary Search Tree | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p>Note:</p>
<p>A solution using O(n) space is pretty straight forward. <strong>Could you devise (<code>[d&#618;'va&#618;z]</code>&#65292;&#24819;&#20986;) a constant space solution?</strong></p>
<p>O(n) &#31354;&#38388;&#30340;&#35299;&#27861;&#26159;&#65292;&#24320;&#19968;&#20010;&#25351;&#38024;&#25968;&#32452;&#65292;&#20013;&#24207;&#36941;&#21382;&#65292;&#23558;&#33410;&#28857;&#25351;&#38024;&#20381;&#27425;&#23384;&#25918;&#21040;&#25968;&#32452;&#37324;&#65292;&#28982;&#21518;&#23547;&#25214;&#20004;&#22788;&#36870;&#21521;&#30340;&#20301;&#32622;&#65292;&#20808;&#20174;&#21069;&#24448;&#21518;&#25214;&#31532;&#19968;&#20010;&#36870;&#24207;&#30340;&#20301;&#32622;&#65292;&#28982;&#21518;&#20174;&#21518;&#24448;&#21069;&#25214;&#31532;&#20108;&#20010;&#36870;&#24207;&#30340;&#20301;&#32622;&#65292;&#20132;&#25442;&#36825;&#20004;&#20010;&#25351;&#38024;&#30340;&#20540;&#12290;</p>
<p>&#20013;&#24207;&#36941;&#21382;&#19968;&#33324;&#38656;&#35201;&#29992;&#21040;&#26632;&#65292;&#31354;&#38388;&#20063;&#26159; O(n) &#30340;&#65292;&#22914;&#20309;&#25165;&#33021;&#19981;&#20351;&#29992;&#26632;&#65311;Morris &#20013;&#24207;&#36941;&#21382;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Recover Binary Search Tree</span>
<span class="co">// Morris in-order traversal</span>

<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">void</span> recoverTree(TreeNode *p) {
        TreeNode *u = NULL, *v, *l= NULL;
        <span class="kw">while</span> (p) {
            TreeNode *q = p-&gt;left;
            <span class="kw">if</span> (q) {
                <span class="kw">while</span> (q-&gt;right &amp;&amp; q-&gt;right != p)
                    q = q-&gt;right;
                <span class="kw">if</span> (! q-&gt;right) {
                    q-&gt;right = p;
                    p = p-&gt;left;
                    <span class="kw">continue</span>;
                }
                q-&gt;right = NULL;
            }
            <span class="kw">if</span> (l &amp;&amp; l-&gt;val &gt; p-&gt;val)
                <span class="kw">if</span> (! u)
                    u = l, v = p;
                <span class="kw">else</span>
                    v = p;
            l = p;
            p = p-&gt;right;
        }
        swap(u-&gt;val, v-&gt;val);
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/same-tree/">Same Tree | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">bool</span> isSameTree(TreeNode *p, TreeNode *q) {
        <span class="kw">if</span> (!p &amp;&amp; !q) <span class="kw">return</span> <span class="kw">true</span>;
        <span class="kw">if</span> (!p || !q) <span class="kw">return</span> <span class="kw">false</span>;
        <span class="kw">return</span> p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
    }
};</code></pre></div>
<p>&#36845;&#20195;&#65311;&#37027;&#23601;&#29992; stack&#65292;&#20808; push &#20004;&#20010;&#25351;&#38024;&#65292;&#28982;&#21518;&#27599;&#27425;&#21462;&#20986;&#20004;&#20010;&#65292;&#36827;&#34892;&#27604;&#36739;&#12290;</p>
</dd>
<dt><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">Flatten Binary Tree to Linked List | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><pre><code>     1(root)
    / \
   2   5
  / \   \
 3   4   6

     1(root)
    / \
(x)2   5
  / \   \
 3   4   6

     1(root)
    /
   2
  / \
 3   4(x)
      \
       5
        \
         6

     1
      \
       2(root)
      / \
     3   4
          \
           5
            \
             6

     1
      \
       2(root)
      /
  (x)3
      \
       4
        \
         5
          \
           6

     1
      \
       2
        \
         3
          \
           4
            \
             5
              \
               6</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Flatten Binary Tree to Linked List</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">void</span> flatten(TreeNode *root) {
        <span class="kw">for</span> (; root; root = root-&gt;right)
            <span class="kw">if</span> (root-&gt;left) {
                TreeNode *x = root-&gt;left;
                <span class="kw">while</span> (x-&gt;right) x = x-&gt;right;      <span class="co">// &#25214;&#21040;&#34900;&#25509;&#28857;</span>
                x-&gt;right = root-&gt;right;             <span class="co">// &#25226; root &#31896;&#36148;&#36807;&#26469;</span>
                root-&gt;right = root-&gt;left;           <span class="co">// &#24038;&#20391;&#25918;&#21040;&#21491;&#20391;</span>
                root-&gt;left = NULL;                  <span class="co">// &#24038;&#20391;&#32622;&#31354;</span>
            }
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">Minimum Depth of Binary Tree | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#36882;&#24402;&#29256;&#65292;&#26102;&#38388;&#22797;&#26434;&#24230;O(n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230;O(logn)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> minDepth(<span class="dt">const</span> TreeNode *root) {
        <span class="kw">return</span> minDepth(root, <span class="kw">false</span>);
    }
<span class="kw">private</span>:
    <span class="dt">static</span> <span class="dt">int</span> minDepth(<span class="dt">const</span> TreeNode *root, <span class="dt">bool</span> hasbrother) {
        <span class="kw">if</span> (!root) <span class="kw">return</span> hasbrother ? INT_MAX : <span class="dv">0</span>;

        <span class="kw">return</span> <span class="dv">1</span> + min( minDepth(root-&gt;left, root-&gt;right ),
                        minDepth(root-&gt;right, root-&gt;left ) );
    }
};</code></pre></div>
<p>&#25105;&#27809;&#26377;&#30475;&#25026;&#30340;&#36845;&#20195;&#29256;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#36845;&#20195;&#29256;&#65292;&#26102;&#38388;&#22797;&#26434;&#24230; O(n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(logn)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> minDepth(TreeNode* root) {
        <span class="kw">if</span> ( !root ) { <span class="kw">return</span> <span class="dv">0</span>; }

        <span class="dt">int</span> result = INT_MAX;

        stack&lt;pair&lt;TreeNode*, <span class="dt">int</span>&gt;&gt; s;
        s.push(make_pair(root, <span class="dv">1</span>));

        <span class="kw">while</span> (!s.empty()) {
            <span class="kw">auto</span> node = s.top().first;
            <span class="kw">auto</span> depth = s.top().second;
            s.pop();

            <span class="kw">if</span> (node-&gt;left == <span class="kw">nullptr</span> &amp;&amp; node-&gt;right == <span class="kw">nullptr</span>)
                result = min(result, depth);

            <span class="kw">if</span> (node-&gt;left &amp;&amp; result &gt; depth) <span class="co">// &#28145;&#24230;&#25511;&#21046;&#65292;&#21098;&#26525;</span>
                s.push(make_pair(node-&gt;left, depth + <span class="dv">1</span>));

            <span class="kw">if</span> (node-&gt;right &amp;&amp; result &gt; depth) <span class="co">// &#28145;&#24230;&#25511;&#21046;&#65292;&#21098;&#26525;</span>
                s.push(make_pair(node-&gt;right, depth + <span class="dv">1</span>));
        }

        <span class="kw">return</span> result;
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">Maximum Depth of Binary Tree | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> maxDepth(TreeNode* root) {
        <span class="kw">if</span>( !root ) { <span class="kw">return</span> <span class="dv">0</span>; }
        <span class="kw">return</span> max( maxDepth(root-&gt;left), maxDepth(root-&gt;right) ) + <span class="dv">1</span>;
    }
};</code></pre></div>
<p><a href="https://leetcode.com/problems/path-sum/">Path Sum | LeetCode OJ</a> <code class="fold">@</code></p>
</dd>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#26102;&#38388;&#22797;&#26434;&#24230; O(n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(logn)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">bool</span> hasPathSum(TreeNode *root, <span class="dt">int</span> sum) {
        <span class="kw">if</span> ( !root ) { <span class="kw">return</span> <span class="kw">false</span>; }                              <span class="co">// &#30446;&#26631;&#36824;&#27809;&#23436;&#25104;&#65292;&#23601;&#27809;&#36335;&#20102;&#12290;</span>

        <span class="kw">if</span> ( !root-&gt;left &amp;&amp; !root-&gt;right ) {                        <span class="co">// &#26368;&#21518;&#19968;&#27425;&#26426;&#20250;</span>
            <span class="kw">return</span> sum == root-&gt;val;
        }

        <span class="kw">return</span> hasPathSum(  root-&gt;left, sum - root-&gt;val ) ||        <span class="co">// &#20132;&#32473;&#19979;&#38754;&#30340;&#20154;&#26469;&#22788;&#29702;</span>
               hasPathSum( root-&gt;right, sum - root-&gt;val );
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/path-sum-ii/">Path Sum II | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#26102;&#38388;&#22797;&#26434;&#24230; O(n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(logn)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; pathSum(TreeNode *root, <span class="dt">int</span> sum) {
        vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; result;
        vector&lt;<span class="dt">int</span>&gt; cur;                                                <span class="co">// &#20013;&#38388;&#32467;&#26524;</span>
        pathSum(root, sum, cur, result);
        <span class="kw">return</span> result;
    }
<span class="kw">private</span>:
    <span class="dt">void</span> pathSum(TreeNode *root, <span class="dt">int</span> gap, vector&lt;<span class="dt">int</span>&gt; &amp;cur, vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; &amp;result) {
        <span class="kw">if</span> ( !root ) { <span class="kw">return</span>; }
        cur.push_back( root-&gt;val );
        <span class="kw">if</span> ( !root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val == gap ) {
            result.push_back( cur );                            <span class="co">// &#19981;&#21487; return&#65281;&#65281;</span>
        }
        pathSum( root-&gt;left,  gap - root-&gt;val, cur, result );   <span class="co">// &#36827;&#21435;&#21518;&#20250;&#36824;&#21407; cur</span>
        pathSum( root-&gt;right, gap - root-&gt;val, cur, result );   <span class="co">// &#25152;&#20197;&#19981;&#25026;&#25285;&#24515;&#19978;&#38754;&#30340;&#22788;&#29702;&#20250;&#24433;&#21709;&#21040;&#36825;&#37324;</span>
        cur.pop_back();
    }
};</code></pre></div>
<p>&#36825;&#37324;&#30340; <code>cur.pop_back()</code> &#26159;&#24517;&#39035;&#30340;&#65292;&#38500;&#38750;&#20320;&#26356;&#25913;&#20989;&#25968;&#31614;&#21517;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> pathSum(TreeNode *root, <span class="dt">int</span> gap, vector&lt;<span class="dt">int</span>&gt; cur, vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; &amp;result) {</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/merge-sorted-array/">Merge Sorted Array | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>&#25105;&#30340;&#26041;&#27861;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">void</span> merge(vector&lt;<span class="dt">int</span>&gt;&amp; nums1, <span class="dt">int</span> m, vector&lt;<span class="dt">int</span>&gt;&amp; nums2, <span class="dt">int</span> n) {
        vector&lt;<span class="dt">int</span>&gt; result(m+n);
        <span class="dt">int</span> i = <span class="dv">0</span>, j = <span class="dv">0</span>, k = <span class="dv">0</span>;
        <span class="kw">while</span>( i &lt; m &amp;&amp; j &lt; n ) {
            <span class="kw">if</span> ( nums1[i] &lt; nums2[j] ) {
                result[k++] = nums1[i++];
            } <span class="kw">else</span> {
                result[k++] = nums2[j++];
            }
        }
        <span class="kw">while</span>( i &lt; m ) { result[k++] = nums1[i++]; }
        <span class="kw">while</span>( j &lt; n ) { result[k++] = nums2[j++]; }
        nums1.swap( result );
    }
};</code></pre></div>
<p>Maskray &#30340;&#65306;&#65288;&#27809;&#26377;&#29992;&#39069;&#22806;&#30340;&#31354;&#38388;&#65281;&#65289;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">void</span> merge(vector&lt;<span class="dt">int</span>&gt; &amp;a, <span class="dt">int</span> m, vector&lt;<span class="dt">int</span>&gt; &amp;b, <span class="dt">int</span> n) {
        vector&lt;<span class="dt">int</span>&gt; c(m+n);
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>, j = <span class="dv">0</span>; i &lt; m || j &lt; n; )
            <span class="kw">if</span> (j == n || i &lt; m &amp;&amp; a[i] &lt; b[j]) {
                c[i+j] = a[i];
                ++i;
            } <span class="kw">else</span> {
                c[i+j] = b[j];
                ++j;
            }
        a.swap(c);
    }
};</code></pre></div>
<p>Soulmachine &#30340;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#26102;&#38388;&#22797;&#26434;&#24230; O(m+n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(1)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">void</span> merge(vector&lt;<span class="dt">int</span>&gt;&amp; A, <span class="dt">int</span> m, vector&lt;<span class="dt">int</span>&gt;&amp; B, <span class="dt">int</span> n) {
        <span class="dt">int</span> ia = m - <span class="dv">1</span>, ib = n - <span class="dv">1</span>, icur = m + n - <span class="dv">1</span>;
        <span class="kw">while</span>(ia &gt;= <span class="dv">0</span> &amp;&amp; ib &gt;= <span class="dv">0</span>) {
            A[icur--] = A[ia] &gt;= B[ib] ? A[ia--] : B[ib--];
        }
        <span class="kw">while</span>(ib &gt;= <span class="dv">0</span>) {
            A[icur--] = B[ib--];
        }
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/merge-two-sorted-lists/">Merge Two Sorted Lists | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#26102;&#38388;&#22797;&#26434;&#24230; O(min(m,n))&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(1)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
        <span class="kw">if</span> ( !l1 ) { <span class="kw">return</span> l2; }
        <span class="kw">if</span> ( !l2 ) { <span class="kw">return</span> l1; }
        ListNode dummy(<span class="dv">-1</span>);
        ListNode *p = &amp;dummy;
        <span class="kw">for</span> ( ; l1 &amp;&amp; l2; p = p-&gt;next) {        <span class="co">// &#36824;&#26377;&#33410;&#28857;&#21487;&#20197;&#25340;&#25509;</span>
            <span class="kw">if</span> ( l1-&gt;val &lt; l2-&gt;val ) {
                p-&gt;next = l1;
                l1 = l1-&gt;next;
            } <span class="kw">else</span> {
                p-&gt;next = l2;
                l2 = l2-&gt;next;
            }
        }
        p-&gt;next = l1 ? l1 : l2;                 <span class="co">// &#21738;&#36793;&#36824;&#21097;&#19979;&#65311;</span>
        <span class="kw">return</span> dummy.next;
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/first-missing-positive/">First Missing Positive | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>Given an unsorted integer array, find the first missing positive integer.</p>
<pre><code>For example,
Given [1,2,0] return 3,
and [3,4,-1,1] return 2.</code></pre>
<p>Your algorithm should run in O(n) time and uses constant space.</p>
<p>&#26412;&#36136;&#19978;&#26159;&#26742;&#25490;&#24207;(bucket sort)&#65292;&#27599;&#24403; <code>A[i]!= i+1</code> &#30340;&#26102;&#20505;&#65292;&#23558; <code>A[i]</code> &#19982; <code>A[A[i]-1]</code> &#20132;&#25442;&#65292;&#30452;&#21040;&#26080;&#27861;&#20132;&#25442;&#20026;&#27490;&#65292;&#32456;&#27490;&#26465;&#20214;&#26159; <code>A[i]== A[A[i]-1]</code>&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// First Missing Positive</span>
<span class="ot">#define REP(i, n) for (int i = 0; i &lt; (n); i++)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> firstMissingPositive(vector&lt;<span class="dt">int</span>&gt; &amp;a) {
        <span class="dt">int</span> n = a.size();
        REP(i, n)
            <span class="kw">while</span> (<span class="dv">0</span> &lt; a[i] &amp;&amp; a[i] &lt;= n &amp;&amp; a[a[i]<span class="dv">-1</span>] != a[i])  <span class="co">// a[i] &#30340;&#20301;&#32622;&#19981;&#23545;</span>
                swap(a[a[i]<span class="dv">-1</span>], a[i]);                          <span class="co">// &#37027;&#25105;&#20204;&#25226;&#23427;&#25918;&#21040;&#27491;&#30830;&#30340;&#20301;&#32622; a[i]-1</span>
        REP(i, n)
            <span class="kw">if</span> (a[i] != i<span class="dv">+1</span>)
                <span class="kw">return</span> i<span class="dv">+1</span>;
        <span class="kw">return</span> n<span class="dv">+1</span>;
    }
};</code></pre></div>
<p>&#20854;&#23454;&#25152;&#26377;&#30340;&#36923;&#36753;&#21482;&#26159;&#65306;</p>
<ol style="list-style-type: decimal">
<li><code>1 &lt;= a[i] &lt;= n</code> &#30340;&#20301;&#32622;&#26377;&#27809;&#26377;&#27491;&#30830;&#25670;&#25918;&#65311;&#65288;&#24212;&#35813;&#25918;&#22312; <code>a[i]-1</code> &#30340;&#20301;&#32622;&#65289;</li>
<li>&#27809;&#26377;&#27491;&#30830;&#25670;&#25918;&#30340;&#35805;&#65288;<code>a[i] != a[a[i]-1]</code>&#65289;&#65292;&#37027;&#23601;&#25918;&#21040;&#27491;&#30830;&#30340;&#20301;&#32622;&#65306;<code>swap(a[a[i]-1], a[i])</code></li>
<li><p>&#36825;&#26679;&#20043;&#21518;&#65292;&#24635;&#36824;&#26377;&#20803;&#32032;&#27809;&#26377;&#27491;&#30830;&#34987;&#25670;&#25918;</p>
<ol style="list-style-type: decimal">
<li>&#21487;&#33021;&#26159;&#34987;&#25250;&#20102;&#20301;&#32622;</li>
<li>&#20063;&#21487;&#33021;&#26159;&#20182;&#20204;&#19981;&#22312; 1 &lt;= n &#30340;&#33539;&#22260;&#20869;</li>
</ol></li>
</ol>
<pre><code>1   2   0
&#32622;&#25442;
1   2   0
&#30475;&#26159;&#21542;&#21305;&#37197;
1   2   ?
        ^ &#22833;&#37197;

3   4  -1   1
&#32622;&#25442;
-1  4   3   1
-1  1   3   4
-1  1   3   4
&#30475;&#26159;&#21542;&#21305;&#37197;
-1  1   3   4
^ &#22833;&#37197;

1   3   5   4
1   5   3   4
    ^

2   4   3   6   5   7
4   2   3   7   5   6
^</code></pre>
</dd>
<dt><a href="https://leetcode.com/problems/sort-colors/">Sort Colors | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note:</p>
<p>You are not suppose to use the library&#8217;s sort function for this problem.</p>
<p>&#22914;&#27492;&#31616;&#21333;&#65292;&#23601;&#26159;&#19968;&#20010;&#35745;&#25968;&#25490;&#24207;&#65288;counting sort&#65289;&#65292;&#32780;&#24050;&#12290;</p>
<p>A rather straight forward solution is a two-pass algorithm using counting sort.</p>
<p>First, iterate the array counting number of 0&#8217;s, 1&#8217;s, and 2&#8217;s, then overwrite array with total number of 0&#8217;s, then 1&#8217;s and followed by 2&#8217;s.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">void</span> sortColors(vector&lt;<span class="dt">int</span>&gt; &amp;a) {
        <span class="dt">int</span> c[<span class="dv">3</span>] = {};
        <span class="kw">for</span> (<span class="kw">auto</span> x: a)
            c[x]++;
        fill_n(a.begin(), c[<span class="dv">0</span>], <span class="dv">0</span>);             <span class="co">//  for (int i = 0, index = 0; i &lt; 3; i++)</span>
        fill_n(a.begin()+c[<span class="dv">0</span>], c[<span class="dv">1</span>], <span class="dv">1</span>);        <span class="co">//      for (int j = 0; j &lt; counts[i]; j++)</span>
        fill_n(a.begin()+c[<span class="dv">0</span>]+c[<span class="dv">1</span>], c[<span class="dv">2</span>], <span class="dv">2</span>);   <span class="co">//          A[index++] = i;</span>
    }
};</code></pre></div>
<p>Follow up:</p>
<p>Could you come up with an one-pass algorithm using only constant space?</p>
<p>&#29992; partition &#30340;&#26041;&#27861;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// red, white, blue</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">void</span> sortColors(vector&lt;<span class="dt">int</span>&gt; &amp;a) {
        <span class="kw">for</span> (<span class="dt">int</span> r = <span class="dv">0</span>, w = <span class="dv">0</span>, b = a.size(); w &lt; b; )
            <span class="kw">if</span> (a[w] == <span class="dv">0</span>)
                swap(a[r++], a[w++]);
            <span class="kw">else</span> <span class="kw">if</span> (a[w] == <span class="dv">2</span>)
                swap(a[--b], a[w]);
            <span class="kw">else</span>
                w++;
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/search-for-a-range/">Search for a Range | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Search for a Range</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    vector&lt;<span class="dt">int</span>&gt; searchRange(vector&lt;<span class="dt">int</span>&gt; &amp;a, <span class="dt">int</span> target) {
        <span class="dt">int</span> l = <span class="dv">0</span>, m = a.size(), h = a.size();
        <span class="kw">while</span> (l &lt; m) {
            <span class="dt">int</span> x = l+m &gt;&gt; <span class="dv">1</span>;
            <span class="kw">if</span> (a[x] &lt; target) l = x<span class="dv">+1</span>;
            <span class="kw">else</span> m = x;
        }
        vector&lt;<span class="dt">int</span>&gt; r;
        <span class="kw">if</span> (l == a.size() || a[l] != target) {
            r.push_back(<span class="dv">-1</span>);
            r.push_back(<span class="dv">-1</span>);
        } <span class="kw">else</span> {
            <span class="kw">while</span> (m &lt; h) {
                <span class="dt">int</span> x = m+h &gt;&gt; <span class="dv">1</span>;
                <span class="kw">if</span> (a[x] &lt;= target) m = x<span class="dv">+1</span>;
                <span class="kw">else</span> h = x;
            }
            r.push_back(l);
            r.push_back(m<span class="dv">-1</span>);
        }
        <span class="kw">return</span> r;
    }
};</code></pre></div>
<p>&#29992; STL&#65306;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &#26102;&#38388;&#22797;&#26434;&#24230; O(logn)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230; O(1)</span>
<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    vector&lt;<span class="dt">int</span>&gt; searchRange(vector&lt;<span class="dt">int</span>&gt;&amp; nums, <span class="dt">int</span> target) {
        <span class="dt">const</span> <span class="dt">int</span> l = distance(nums.begin(), lower_bound(nums.begin(), nums.end(), target));
        <span class="dt">const</span> <span class="dt">int</span> u = distance(nums.begin(), prev(upper_bound(nums.begin(), nums.end(), target)));
        <span class="kw">if</span> (nums[l] != target) <span class="co">// not found</span>
            <span class="kw">return</span> vector&lt;<span class="dt">int</span>&gt; { <span class="dv">-1</span>, <span class="dv">-1</span> };
        <span class="kw">else</span>
            <span class="kw">return</span> vector&lt;<span class="dt">int</span>&gt; { l, u };
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/search-a-2d-matrix/">Search a 2D Matrix | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">bool</span> searchMatrix(vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; &amp;a, <span class="dt">int</span> b) {
        <span class="dt">int</span> m = a.size(), n = a[<span class="dv">0</span>].size(), l = <span class="dv">0</span>, h = m*n<span class="dv">-1</span>;
        <span class="kw">while</span> (l &lt;= h) {
            <span class="dt">int</span> m = l+h &gt;&gt; <span class="dv">1</span>;
            <span class="dt">int</span> &amp;bb = a[m/n][m%n];
            <span class="kw">if</span> (bb &lt; b) {
                l = m<span class="dv">+1</span>;
            } <span class="kw">else</span> <span class="kw">if</span> (bb &gt; b){
                h = m<span class="dv">-1</span>;
            } <span class="kw">else</span> {
                <span class="kw">return</span> <span class="kw">true</span>;
            }
        }
        <span class="kw">return</span> <span class="kw">false</span>;
    }
};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">bool</span> searchMatrix(vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; &amp;a, <span class="dt">int</span> b) {
        <span class="dt">int</span> m = a.size(), n = a[<span class="dv">0</span>].size(), l = <span class="dv">0</span>, h = m*n;
        <span class="kw">while</span> (l &lt; h) {
            <span class="dt">int</span> m = l+h &gt;&gt; <span class="dv">1</span>;
            <span class="kw">if</span> (a[m/n][m%n] &lt; b) {
                l = m<span class="dv">+1</span>;
            } <span class="kw">else</span> {
                h = m;
            }
        }
        <span class="kw">return</span> l &lt; m*n &amp;&amp; a[l/n][l%n] == b;
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/word-ladder/">Word Ladder | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>Given two words (beginWord and endWord), and a dictionary&#8217;s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</p>
<ul>
<li>Only one letter can be changed at a time</li>
<li>Each intermediate word must exist in the word list</li>
</ul>
<p>For example,</p>
<pre><code>Given:
beginWord = &quot;hit&quot;
endWord = &quot;cog&quot;
wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</code></pre>
<p>As one shortest transformation is &#8220;hit&#8221; -&gt; &#8220;hot&#8221; -&gt; &#8220;dot&#8221; -&gt; &#8220;dog&#8221; -&gt; &#8220;cog&#8221;, return its length 5.</p>
<p>Note:</p>
<ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
</ul>
<p>&#29992;&#21333;&#38431;&#21015;&#12289;&#21452;&#38431;&#21015;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Word Ladder</span>
<span class="ot">#define FOR(i, a, b) for (int i = (a); i &lt; (b); i++)</span>
<span class="ot">#define REP(i, n) for (int i = 0; i &lt; (n); i++)</span>

<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> ladderLength(string start, string end, unordered_set&lt;string&gt; &amp;dict) {
        unordered_map&lt;string, <span class="dt">int</span>&gt; d;
        queue&lt;string&gt; q;
        d[start] = <span class="dv">0</span>;
        dict.insert(end);
        <span class="kw">for</span> (q.push(start); ! q.empty(); ) {
            string i = q.front();
            <span class="dt">int</span> dd = d[i];
            q.pop();
            REP(j, i.size()) {
                <span class="dt">char</span> cc = i[j];
                FOR(c, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;z&#39;</span><span class="dv">+1</span>) {
                    i[j] = c;
                    <span class="kw">if</span> (dict.count(i)) {
                        dict.erase(i);
                        q.push(i);
                        d[i] = dd<span class="dv">+1</span>;
                    }
                }
                i[j] = cc;
            }
        }
        <span class="kw">return</span> d.count(end) ? d[end]<span class="dv">+1</span> : <span class="dv">0</span>;
    }
};

<span class="co">///</span> hamming distance trick

<span class="kw">class</span> Solution {
    <span class="dt">bool</span> hamming_one(<span class="dt">const</span> string &amp;a, <span class="dt">const</span> string &amp;b) {
        <span class="dt">int</span> i = <span class="dv">0</span>, j = a.size();
        <span class="kw">while</span> (i &lt; j &amp;&amp; a[i] == b[i]) i++;
        <span class="kw">while</span> (i &lt; j &amp;&amp; a[j<span class="dv">-1</span>] == b[j<span class="dv">-1</span>]) j--;
        <span class="kw">return</span> i == j<span class="dv">-1</span>;
    }
<span class="kw">public</span>:
    <span class="dt">int</span> ladderLength(string start, string end, unordered_set&lt;string&gt; &amp;dict) {
        unordered_map&lt;string, <span class="dt">int</span>&gt; d;
        unordered_map&lt;string, vector&lt;string&gt;&gt; left, right;
        queue&lt;string&gt; q;
        d[start] = <span class="dv">0</span>;
        dict.erase(start);
        dict.insert(end);
        <span class="dt">int</span> n = start.length();
        <span class="kw">for</span> (<span class="kw">auto</span> &amp;x: dict) {
            string l = x.substr(<span class="dv">0</span>, n/<span class="dv">2</span>), r = x.substr(n/<span class="dv">2</span>);
            left[l].push_back(r);
            right[r].push_back(l);
        }
        <span class="kw">for</span> (q.push(start); ! q.empty(); ) {
            string x = q.front(), l = x.substr(<span class="dv">0</span>, n/<span class="dv">2</span>), r = x.substr(n/<span class="dv">2</span>);
            <span class="dt">int</span> dd = d[x];
            q.pop();
            <span class="kw">if</span> (left.count(l))
                <span class="kw">for</span> (<span class="kw">auto</span> &amp;y: left[l])
                    <span class="kw">if</span> (hamming_one(r, y)) {
                        string z = l+y;
                        <span class="kw">if</span> (dict.count(z)) {
                            dict.erase(z);
                            q.push(z);
                            d[z] = dd<span class="dv">+1</span>;
                        }
                    }
            <span class="kw">if</span> (right.count(r))
                <span class="kw">for</span> (<span class="kw">auto</span> &amp;y: right[r])
                    <span class="kw">if</span> (hamming_one(l, y)) {
                        string z = y+r;
                        <span class="kw">if</span> (dict.count(z)) {
                            dict.erase(z);
                            q.push(z);
                            d[z] = dd<span class="dv">+1</span>;
                        }
                    }
        }
        <span class="kw">return</span> d.count(end) ? d[end]<span class="dv">+1</span> : <span class="dv">0</span>;
    }
};

<span class="co">///</span> bidirectional BFS + hamming distance trick

<span class="kw">class</span> Solution {
    <span class="dt">bool</span> hamming_one(<span class="dt">const</span> string &amp;a, <span class="dt">const</span> string &amp;b) {
        <span class="dt">int</span> i = <span class="dv">0</span>, j = a.size();
        <span class="kw">while</span> (i &lt; j &amp;&amp; a[i] == b[i]) i++;
        <span class="kw">while</span> (i &lt; j &amp;&amp; a[j<span class="dv">-1</span>] == b[j<span class="dv">-1</span>]) j--;
        <span class="kw">return</span> i == j<span class="dv">-1</span>;
    }
<span class="kw">public</span>:
    <span class="dt">int</span> ladderLength(string start, string end, unordered_set&lt;string&gt; &amp;dict) {
        unordered_map&lt;string, vector&lt;string&gt;&gt; left, right;
        <span class="dt">int</span> n = start.length(), d = <span class="dv">1</span>;
        dict.insert(start);
        dict.insert(end);
        <span class="kw">for</span> (<span class="kw">auto</span> &amp;x: dict) {
            string l = x.substr(<span class="dv">0</span>, n/<span class="dv">2</span>), r = x.substr(n/<span class="dv">2</span>);
            left[l].push_back(r);
            right[r].push_back(l);
        }
        dict.erase(start);
        dict.erase(end);
        unordered_set&lt;string&gt; q0{start}, q1{end};
        <span class="kw">while</span> (! q0.empty()) {
            <span class="kw">if</span> (q0.size() &gt; q1.size()) {
                swap(q0, q1);
                <span class="kw">continue</span>;
            }
            d++;
            unordered_set&lt;string&gt; next;
            <span class="kw">for</span> (<span class="kw">auto</span> &amp;x: q0) {
                string l = x.substr(<span class="dv">0</span>, n/<span class="dv">2</span>), r = x.substr(n/<span class="dv">2</span>);
                <span class="kw">if</span> (left.count(l))
                    <span class="kw">for</span> (<span class="kw">auto</span> &amp;y: left[l])
                        <span class="kw">if</span> (hamming_one(r, y)) {
                            string z = l+y;
                            <span class="kw">if</span> (q1.count(z))
                                <span class="kw">return</span> d;
                            <span class="kw">if</span> (dict.count(z)) {
                                dict.erase(z);
                                next.insert(z);
                            }
                        }
                <span class="kw">if</span> (right.count(r))
                    <span class="kw">for</span> (<span class="kw">auto</span> &amp;y: right[r])
                        <span class="kw">if</span> (hamming_one(l, y)) {
                            string z = y+r;
                            <span class="kw">if</span> (q1.count(z))
                                <span class="kw">return</span> d;
                            <span class="kw">if</span> (dict.count(z)) {
                                dict.erase(z);
                                next.insert(z);
                            }
                        }
            }
            q0.swap(next);
            q0.swap(q1);
        }
        <span class="kw">return</span> <span class="dv">0</span>;
    }
};</code></pre></div>
</dd>
<dt><a href="https://leetcode.com/problems/word-ladder-ii/">Word Ladder II | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>&#29992;&#21333;&#38431;&#21015;&#12289;&#21452;&#38431;&#21015;&#65292;&#25110;&#32773;&#22270;&#30340;&#24191;&#25628;&#12290;</p>
</dd>
<dt><a href="https://leetcode.com/problems/jump-game/">Jump Game | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>For example:</p>
<pre><code>A = [2,3,1,1,4], return true.
A = [3,2,1,0,4], return false.</code></pre>
</dd>
<dt><a href="https://leetcode.com/problems/edit-distance/">Edit Distance | LeetCode OJ</a> <code class="fold">@</code></dt>
<dd><p>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<ul>
<li><ol style="list-style-type: lower-alpha">
<li>Insert a character</li>
</ol></li>
<li><ol start="2" style="list-style-type: lower-alpha">
<li>Delete a character</li>
</ol></li>
<li><ol start="3" style="list-style-type: lower-alpha">
<li>Replace a character</li>
</ol></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define REP(i, n) for (int i = 0; i &lt; (n); i++)</span>

<span class="kw">class</span> Solution {
<span class="kw">public</span>:
    <span class="dt">int</span> minDistance(string a, string b) {
        vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; f(<span class="dv">2</span>, vector&lt;<span class="dt">int</span>&gt;(b.size()<span class="dv">+1</span>));
        iota(f[<span class="dv">0</span>].begin(), f[<span class="dv">0</span>].end(), <span class="dv">0</span>);
        REP(i, a.size()) {
            f[i<span class="dv">+1</span>&amp;<span class="dv">1</span>][<span class="dv">0</span>] = i<span class="dv">+1</span>;
            REP(j, b.size())
                f[i<span class="dv">+1</span>&amp;<span class="dv">1</span>][j<span class="dv">+1</span>] = a[i] == b[j] ? f[i&amp;<span class="dv">1</span>][j] : min(min(f[i&amp;<span class="dv">1</span>][j], f[i&amp;<span class="dv">1</span>][j<span class="dv">+1</span>]), f[i<span class="dv">+1</span>&amp;<span class="dv">1</span>][j]) + <span class="dv">1</span>;
        }
        <span class="kw">return</span> f[a.size()&amp;<span class="dv">1</span>][b.size()];
    }
};</code></pre></div>
</dd>
</dl>
</dd>
<dt>Finals <code class="fold">@</code></dt>
<dd><dl>
<dt>&#38754;&#35797;&#24517;&#20250;&#20869;&#23481;&#20043;&#8212;&#8212;&#25805;&#20316;&#31995;&#32479; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>refs and see also</p>
<ul>
<li><a href="http://blog.csdn.net/liuqiyao_01/article/details/38962323" class="hearts">&#38754;&#35797;&#24517;&#20250;&#20869;&#23481;&#20043;&#8212;&#8212;&#25805;&#20316;&#31995;&#32479; - 671coder&#30340;&#19987;&#26639; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
</ul>
</dd>
<dt>nonstriater/Learn-Algorithms: &#31639;&#27861;&#23398;&#20064;&#31508;&#35760; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#20108;&#21449;&#26597;&#25214;&#26641; <code class="fold">@</code></dt>
<dd><p>&#20108;&#21449;&#26597;&#25214;&#26641;&#65288;Binary search tree&#65289;&#65292;&#20063;&#21483;<code>&#26377;&#24207;&#20108;&#21449;&#26641; (Ordered binary tree)</code>, <code>&#25490;&#24207;&#20108;&#21449;&#26641; (Sorted binary tree)</code>&#12290;&#26159;&#25351;&#19968;&#20010;&#31354;&#26641;&#25110;&#32773;&#20855;&#26377;&#19979;&#21015;&#24615;&#36136;&#30340;&#20108;&#21449;&#26641;&#65306;</p>
<ol style="list-style-type: decimal">
<li>&#33509;&#20219;&#24847;&#33410;&#28857;&#30340;&#24038;&#23376;&#26641;&#19981;&#20026;&#31354;&#65292;&#21017;&#24038;&#23376;&#26641;&#19978;&#25152;&#26377;&#30340;&#33410;&#28857;&#20540;&#23567;&#20110;&#23427;&#30340;&#26681;&#33410;&#28857;&#20540;</li>
<li>&#33509;&#20219;&#24847;&#33410;&#28857;&#30340;&#21491;&#23376;&#26641;&#19981;&#20026;&#31354;&#65292;&#21017;&#21491;&#23376;&#26641;&#19978;&#25152;&#26377;&#33410;&#28857;&#30340;&#20540;&#22343;&#22823;&#20110;&#23427;&#30340;&#26681;&#33410;&#28857;&#30340;&#20540;</li>
<li>&#20219;&#24847;&#33410;&#28857;&#24038;&#21491;&#23376;&#26641;&#20063;&#20026;&#20108;&#21449;&#26597;&#25214;&#26641;</li>
<li>&#27809;&#26377;&#38190;&#20540;&#30456;&#31561;&#30340;&#33410;&#28857;</li>
</ol>
<p>&#21024;&#38500;&#33410;&#28857;,&#38656;&#35201;&#37325;&#24314;&#25490;&#24207;&#26641;</p>
<ul>
<li>&#21024;&#38500;&#33410;&#28857;&#26159;&#21494;&#23376;&#33410;&#28857;&#65288;&#20998;&#25903;&#20026;0&#65289;&#65292;&#32467;&#26500;&#19981;&#30772;&#22351;</li>
<li>&#21024;&#38500;&#33410;&#28857;&#21482;&#26377;&#19968;&#20010;&#20998;&#25903;(&#20998;&#25903;&#20026;1)&#65292;&#32467;&#26500;&#20063;&#19981;&#30772;&#22351;</li>
<li>&#21024;&#38500;&#33410;&#28857;&#26377;2&#20010;&#20998;&#25903;&#65292;&#27492;&#26102;&#21024;&#38500;&#33410;&#28857;
<ul>
<li>&#24605;&#36335;&#19968;&#65306; &#36873;&#24038;&#23376;&#26641;&#30340;&#26368;&#22823;&#33410;&#28857;&#65292;&#25110;&#21491;&#23376;&#26641;&#26368;&#23567;&#33410;&#28857;&#26367;&#25442;</li>
</ul></li>
</ul>
</dd>
<dt>&#20280;&#23637;&#26641; (splay tree) <code class="fold">@</code></dt>
<dd><p>&#20280;&#23637;&#26641;&#26159;&#19968;&#31181;&#33258;&#24179;&#34913;&#30340;&#20108;&#21449;&#25490;&#24207;&#26641;&#12290;&#20026;&#20160;&#20040;&#38656;&#35201;&#36825;&#20123;&#33258;&#24179;&#34913;&#30340;&#20108;&#21449;&#25490;&#24207;&#26641;&#65311;</p>
<p>n &#20010;&#33410;&#28857;&#30340;&#23436;&#20840;&#20108;&#21449;&#26641;&#65292;&#20854;&#26597;&#25214;&#65292;&#21024;&#38500;&#30340;&#22797;&#26434;&#24230;&#37117;&#26159; O(logN), &#20294;&#26159;&#22914;&#26524;&#39057;&#32321;&#30340;&#25554;&#20837;&#21024;&#38500;&#65292;&#23548;&#33268;&#20108;&#21449;&#26641;&#36864;&#21270;&#25104;&#19968;&#20010; n &#20010;&#33410;&#28857;&#30340;&#21333;&#38142;&#34920;&#65292;&#20063;&#23601;&#26159;&#25554;&#20837;&#65292;&#26597;&#25214;&#22797;&#26434;&#24230;&#36235;&#20110; O(N)&#65292;&#20026;&#20102;&#20811;&#26381;&#36825;&#20010;&#32570;&#28857;&#65292;&#20986;&#29616;&#20102;&#24456;&#22810;&#20108;&#21449;&#26597;&#25214;&#26641;&#30340;&#21464;&#24418;&#65292;&#22914; AVL &#26641;&#65292;&#32418;&#40657;&#26641;&#65292;&#20197;&#21450;&#25509;&#19979;&#26469;&#20171;&#32461;&#30340; &#20280;&#23637;&#26641; (splay tree)&#12290;</p>
</dd>
<dt>B &#26641; <code class="fold">@</code></dt>
<dd><p>&#24179;&#34913;&#26597;&#25214;&#26641;&#65292;&#19968;&#31181;&#22810;&#36335;&#26597;&#25214;&#26641;&#12290;</p>
<p>&#33021;&#20445;&#35777;&#25968;&#25454;&#25554;&#20837;&#21644;&#21024;&#38500;&#24773;&#20917;&#19979;&#65292;&#20219;&#28982;&#20445;&#25345;&#25191;&#34892;&#25928;&#29575;&#12290;</p>
<p>&#19968;&#20010; M &#38454;&#30340; B &#26641;&#28385;&#36275;&#65306;</p>
<ol style="list-style-type: decimal">
<li>&#27599;&#20010;&#33410;&#28857;&#26368;&#22810; M &#20010;&#23376;&#33410;&#28857;</li>
<li>&#38500;&#36319;&#33410;&#28857;&#21644;&#21494;&#33410;&#28857;&#22806;&#65292;&#20854;&#23427;&#27599;&#20010;&#33410;&#28857;&#33267;&#23569;&#26377; M/2 &#20010;&#23401;&#23376;</li>
<li>&#26681;&#33410;&#28857;&#33267;&#23569; 2 &#20010;&#33410;&#28857;</li>
<li>&#25152;&#26377;&#21494;&#33410;&#28857;&#22312;&#21516;&#19968;&#23618;&#65292;&#21494;&#33410;&#28857;&#19981;&#21253;&#21547;&#20219;&#20309;&#20851;&#38190;&#23383;&#20449;&#24687;</li>
<li>&#26377; k &#20010;&#20851;&#38190;&#23383;&#30340;&#39029;&#33410;&#28857;&#21253;&#21547; k+1 &#20010;&#23401;&#23376;</li>
</ol>
<p>&#20063;&#23601;&#26159;&#35828;&#65306;&#26681;&#33410;&#28857;&#21040;&#27599;&#20010;&#21494;&#33410;&#28857;&#30340;&#36335;&#24452;&#38271;&#24230;&#37117;&#26159;&#30456;&#21516;&#30340;&#12290;</p>
</dd>
<dt>B+ &#26641; <code class="fold">@</code></dt>
<dd><p>mysql &#32034;&#24341;&#20351;&#29992; B+ &#26641;&#30340;&#25968;&#25454;&#32467;&#26500;</p>
</dd>
<dt>&#36203;&#22827;&#26364;&#32534;&#30721; Huffman <code class="fold">@</code></dt>
<dd><p>&#36825;&#26159;&#19968;&#20010;&#32463;&#20856;&#30340;&#21387;&#32553;&#31639;&#27861;&#12290;&#36890;&#36807;<code>&#23383;&#31526;&#20986;&#29616;&#30340;&#39057;&#29575;</code>&#65292;<code>&#20248;&#20808;&#32423;</code>&#65292;<code>&#20108;&#21449;&#26641;</code>&#36827;&#34892;&#30340;&#21387;&#32553;&#31639;&#27861;&#12290;</p>
<p>&#23545;&#19968;&#20010;&#23383;&#31526;&#20018;&#65292;&#35745;&#31639;&#27599;&#20010;&#23383;&#31526;&#20986;&#29616;&#30340;&#27425;&#25968;, &#25226;&#36825;&#20123;&#23383;&#31526;&#25918;&#21040;&#20248;&#20808;&#38431;&#21015;&#65288;priority queue&#65289;&#36825;&#36825;&#20010; priority queue &#36716;&#20986;&#20108;&#21449;&#26641;</p>
<p>&#38656;&#35201;&#19968;&#20010;&#23383;&#31526;&#32534;&#30721;&#34920;&#26469;&#35299;&#30721;, &#36890;&#36807;&#20108;&#21449;&#26641;&#24314;&#31435; huffman &#32534;&#30721;&#21644;&#35299;&#30721;&#30340;&#23383;&#20856;&#34920;</p>
</dd>
<dt>&#23383;&#20856;&#26641; trie (&#21069;&#32512;&#26641;&#65292;&#21333;&#35789;&#26597;&#25214;&#26641;) <code class="fold">@</code></dt>
<dd><p>trie&#65292;&#21448;&#31216;&#20026;&#21069;&#32512;&#26641;&#25110;&#23383;&#20856;&#26641;&#65292;&#26159;&#19968;&#31181;&#26377;&#24207;&#26641;&#65292;&#29992;&#20110;&#20445;&#23384;&#20851;&#32852;&#25968;&#32452;&#12290;</p>
<ol style="list-style-type: decimal">
<li>&#38500;&#26681;&#33410;&#28857;&#19981;&#21253;&#21547;&#23383;&#31526;&#65292;&#27599;&#20010;&#33410;&#28857;&#37117;&#21253;&#21547;&#19968;&#20010;&#23383;&#31526;</li>
<li>&#20174;&#26681;&#33410;&#28857;&#21040;&#26576;&#19968;&#20010;&#33410;&#28857;&#65292;&#36335;&#24452;&#19978;&#32463;&#36807;&#30340;&#23383;&#31526;&#36830;&#25509;&#36215;&#26469;&#65292;&#20026;&#35813;&#33410;&#28857;&#23545;&#24212;&#30340;&#23383;&#31526;&#20018;</li>
<li>&#27599;&#20010;&#33410;&#28857;&#30340;&#25152;&#26377;&#23376;&#33410;&#28857;&#21253;&#21547;&#30340;&#23383;&#31526;&#37117;&#19981;&#30456;&#21516;&#65288;&#20445;&#35777;&#27599;&#20010;&#33410;&#28857;&#23545;&#24212;&#30340;&#23383;&#31526;&#20018;&#37117;&#19981;&#19968;&#26679;&#65289;</li>
</ol>
<p>&#27604;&#22914;&#65306;</p>
<pre><code>                    / \
                   / | \
                  t  a  i
                /  \     \
               o    e     n
                   /|\    /
                  a d n  n</code></pre>
<p>&#19978;&#38754;&#30340; Trie &#26641;&#65292;&#21487;&#20197;&#34920;&#31034;&#23383;&#31526;&#20018;&#38598;&#21512;{&#8220;a&#8221;, &#8220;to&#8221;, &#8220;tea&#8221;, &#8220;ted&#8221;, &#8220;ten&#8221;, &#8220;i&#8221;, &#8220;in&#8221;, &#8220;inn&#8221;} &#12290;</p>
<p>trie &#26641;&#25226;&#27599;&#20010;&#20851;&#38190;&#23383;&#20445;&#23384;&#22312;&#19968;&#26465;&#36335;&#24452;&#19978;&#65292;&#32780;&#19981;&#26159;&#19968;&#20010;&#33410;&#28857;&#20013;&#12290;&#20004;&#20010;&#26377;&#20844;&#20849;&#21069;&#32512;&#30340;&#20851;&#38190;&#23383;&#65292;&#22312; Trie &#26641;&#20013;&#21069;&#32512;&#37096;&#20998;&#30340;&#36335;&#24452;&#30456;&#21516;&#65292;&#25152;&#20197; Trie &#26641;&#21448;&#21483;&#20570;&#21069;&#32512;&#26641;&#65288;Prefix Tree&#65289;&#12290;</p>
<p>&#23376;&#26641;&#29992;&#25968;&#32452;&#23384;&#20648;&#65292;&#28010;&#36153;&#31354;&#38388;&#65307;&#22914;&#26524;&#31995;&#32479;&#20013;&#23384;&#22312;&#22823;&#37327;&#23383;&#31526;&#20018;&#65292;&#19988;&#36825;&#20123;&#23383;&#31526;&#20018;&#22522;&#26412;&#27809;&#26377;&#20844;&#20849;&#21069;&#32512;&#65292;trie&#26641;&#23558;&#28040;&#32791;&#22823;&#37327;&#20869;&#23384;&#12290;&#22914;&#26524;&#29992;&#38142;&#34920;&#23384;&#20648;&#65292;&#26597;&#35810;&#26102;&#38656;&#35201;&#36941;&#21382;&#38142;&#34920;&#65292;&#26597;&#35810;&#25928;&#29575;&#26377;&#25152;&#38477;&#20302;</p>
<p>trie &#26641;&#30340;&#22686;&#21152;&#21644;&#21024;&#38500;&#37117;&#27604;&#36739;&#40635;&#28902;&#65292;&#20294;&#32034;&#24341;&#26412;&#36523;&#23601;&#26159;&#20889;&#23569;&#35835;&#22810;&#65292;&#26159;&#21542;&#32771;&#34385;&#28155;&#21152;&#21024;&#38500;&#30340;&#22797;&#26434;&#24230;&#19978;&#21319;&#65292;&#20381;&#38752;&#20855;&#20307;&#22330;&#26223;&#20915;&#23450;&#12290;</p>
<p>&#23427;&#30340;&#20248;&#28857;&#26159;&#65306;</p>
<ol style="list-style-type: decimal">
<li>&#25554;&#20837;&#21644;&#26597;&#35810;&#30340;&#25928;&#29575;&#24456;&#39640;&#65292;&#37117;&#26159; O(m), &#20854;&#20013; m &#26159;&#24453;&#25554;&#20837; / &#26597;&#35810;&#30340;&#23383;&#31526;&#20018;&#30340;&#38271;&#24230;</li>
<li>Trie &#26641;&#21487;&#20197;&#23545;&#20851;&#38190;&#23383;&#25353;&#23383;&#20856;&#24207;&#25490;&#24207;</li>
<li>&#21033;&#29992;&#23383;&#31526;&#20018;&#30340;&#20844;&#20849;&#21069;&#32512;&#26469;&#26368;&#22823;&#38480;&#24230;&#22320;&#20943;&#23569;&#26080;&#35859;&#30340;&#23383;&#31526;&#20018;&#27604;&#36739;, &#25552;&#39640;&#26597;&#35810;&#25928;&#29575;</li>
</ol>
<p>&#32570;&#28857;&#65306;</p>
<ol style="list-style-type: decimal">
<li>trie &#26641;&#27604;&#36739;&#36153;&#20869;&#23384;&#31354;&#38388;&#65292;&#22312;&#22788;&#29702;&#22823;&#25968;&#25454;&#26102;&#20250;&#20869;&#23384;&#21507;&#32039;</li>
<li>&#24403; hash &#20989;&#25968;&#36739;&#22909;&#26102;&#65292;Hash &#26597;&#35810;&#25928;&#29575;&#27604; trie &#26356;&#20248;</li>
</ol>
<p>&#20856;&#22411;&#24212;&#29992;&#26159;&#65306;&#21069;&#32512;&#26597;&#35810;,&#23383;&#31526;&#20018;&#26597;&#35810;&#65292;&#25490;&#24207;</p>
<ul>
<li>&#29992;&#20110;&#32479;&#35745;&#65292;&#25490;&#24207;&#21644;&#20445;&#23384;&#22823;&#37327;&#30340;&#23383;&#31526;&#20018;&#65288;&#20294;&#19981;&#20165;&#38480;&#20110;&#23383;&#31526;&#20018;&#65289;</li>
<li>&#32463;&#24120;&#34987;&#25628;&#32034;&#24341;&#25806;&#31995;&#32479;&#29992;&#20110;&#25991;&#26412;&#35789;&#39057;&#32479;&#35745;</li>
<li>&#25490;&#24207;&#22823;&#37327;&#23383;&#31526;&#20018;</li>
<li>&#29992;&#20110;&#32034;&#24341;&#32467;&#26500;</li>
<li>&#25935;&#24863;&#35789;&#36807;&#28388;</li>
</ul>
<p>&#23454;&#38469;&#24212;&#29992;&#38382;&#39064;</p>
<ol style="list-style-type: decimal">
<li><p>&#32473;&#20320;100000&#20010;&#38271;&#24230;&#19981;&#36229;&#36807;10&#30340;&#21333;&#35789;&#12290;&#23545;&#20110;&#27599;&#19968;&#20010;&#21333;&#35789;&#65292;&#25105;&#20204;&#35201;&#21028;&#26029;&#20182;&#20986;&#27809;&#20986;&#29616;&#36807;&#65292;&#22914;&#26524;&#20986;&#29616;&#20102;&#65292;&#27714;&#31532;&#19968;&#27425;&#20986;&#29616;&#22312;&#31532;&#20960;&#20010;&#20301;&#32622;</p>
<p>&#20998;&#26512;&#24605;&#36335;&#19968;&#65306;trie &#26641; &#65292;&#25214;&#21040;&#36825;&#20010;&#23383;&#31526;&#20018;&#26597;&#35810;&#25805;&#20316;&#23601;&#21487;&#20197;&#20102;&#65292;&#22914;&#20309;&#30693;&#36947;&#20986;&#29616;&#30340;&#31532;&#19968;&#20010;&#20301;&#32622;&#21602;&#65311;&#25105;&#20204;&#21487;&#20197;&#22312; trie &#26641;&#20013;&#21152;&#19968;&#20010;&#23383;&#27573;&#26469;&#35760;&#24405;&#24403;&#21069;&#23383;&#31526;&#20018;&#31532;&#19968;&#27425;&#20986;&#29616;&#30340;&#20301;&#32622;&#12290;</p></li>
<li><p>&#24050;&#30693; n &#20010;&#30001;&#23567;&#20889;&#23383;&#27597;&#26500;&#25104;&#30340;&#24179;&#22343;&#38271;&#24230;&#20026; 10 &#30340;&#21333;&#35789;, &#21028;&#26029;&#20854;&#20013;&#26159;&#21542;&#23384;&#22312;&#26576;&#20010;&#20018;&#20026;&#21478;&#19968;&#20010;&#20018;&#30340;&#21069;&#32512;&#23376;&#20018;</p></li>
<li><p>&#32473;&#20986; N &#20010;&#21333;&#35789;&#32452;&#25104;&#30340;&#29087;&#35789;&#34920;&#65292;&#20197;&#21450;&#19968;&#31687;&#20840;&#29992;&#23567;&#20889;&#33521;&#25991;&#20070;&#20889;&#30340;&#25991;&#31456;&#65292;&#35831;&#20320;&#25353;&#26368;&#26089;&#20986;&#29616;&#30340;&#39034;&#24207;&#20889;&#20986;&#25152;&#26377;&#19981;&#22312;&#29087;&#35789;&#34920;&#20013;&#30340;&#29983;&#35789;&#12290;</p>
<p>&#20998;&#26512;&#65306;trie &#26641;&#26597;&#35810;&#21333;&#35789;&#30340;&#24212;&#29992;&#12290;&#20808;&#24314;&#31435; N &#20010;&#29087;&#35789;&#30340;&#21069;&#32512;&#26641;&#65292;&#28982;&#21518;&#25353;&#25991;&#31456;&#30340;&#21333;&#35789;&#19968;&#27425;&#26597;&#35810;&#12290;</p></li>
<li><p>&#32473;&#20986;&#19968;&#20010;&#35789;&#20856;&#65292;&#20854;&#20013;&#30340;&#21333;&#35789;&#20026;&#19981;&#33391;&#21333;&#35789;&#12290;&#21333;&#35789;&#22343;&#20026;&#23567;&#20889;&#23383;&#27597;&#12290;&#20877;&#32473;&#20986;&#19968;&#27573;&#25991;&#26412;&#65292;&#25991;&#26412;&#30340;&#27599;&#19968;&#34892;&#20063;&#30001;&#23567;&#20889;&#23383;&#27597;&#26500;&#25104;&#12290;&#21028;&#26029;&#25991;&#26412;&#20013;&#26159;&#21542;&#21547;&#26377;&#20219;&#20309;&#19981;&#33391;&#21333;&#35789;&#12290;&#20363;&#22914;&#65292;&#33509; rob &#26159;&#19981;&#33391;&#21333;&#35789;&#65292;&#37027;&#20040;&#25991;&#26412; problem &#21547;&#26377;&#19981;&#33391;&#21333;&#35789;&#12290;</p>
<p>&#20998;&#26512;&#65306;&#20808;&#29992;&#19981;&#33391;&#21333;&#35789;&#24314;&#31435; trie &#26641;&#65292;&#28982;&#21518;&#36807;&#28388;&#25991;&#26412; (&#27599;&#20010;&#21333;&#35789;&#37117;&#22312; trie &#26641;&#19978;&#26597;&#35810;&#65292;&#26597;&#35810;&#30340;&#22797;&#26434;&#24230; O(1), &#25928;&#29575;&#38750;&#24120;&#39640;)&#65292;&#36825;&#27491;&#26159;<code>&#25935;&#24863;&#35789;&#36807;&#28388;&#31995;&#32479; (&#25110;&#22403; &#22334;&#35780;&#35770;&#31995;&#32479;)</code>&#30340;&#21407;&#29702;&#12290;</p></li>
<li><p>&#32473;&#20320; N &#20010;&#20114;&#19981;&#30456;&#21516;&#30340;&#20165;&#30001;&#19968;&#20010;&#21333;&#35789;&#26500;&#25104;&#30340;&#33521;&#25991;&#21517;&#65292;&#35753;&#20320;&#23558;&#23427;&#20204;&#25353;&#23383;&#20856;&#24207;&#20174;&#23567;&#21040;&#22823;&#25490;&#24207;&#36755;&#20986;</p>
<p>&#20998;&#26512;&#65306;&#36825;&#26159; trie &#26641;&#25490;&#24207;&#30340;&#20856;&#22411;&#24212;&#29992;&#65292;&#24314;&#31435; N &#20010;&#21333;&#35789;&#30340; trie &#26641;&#65292;&#28982;&#21518;&#32447;&#24207;&#36941;&#21382;&#25972;&#20010;&#26641;&#65292;&#23601;&#21487;&#20197;&#36798;&#21040;&#25928;&#26524;&#12290;</p></li>
</ol>
</dd>
<dt>&#21518;&#32512;&#26641;&#65288;suffix tree&#65289; <code class="fold">@</code></dt>
<dd><p>&#21518;&#32512;&#26641;&#30340;&#24212;&#29992;</p>
<p>&#21487;&#20197;&#35299;&#20915;&#24456;&#22810;&#23383;&#31526;&#20018;&#30340;&#38382;&#39064;</p>
<ol style="list-style-type: decimal">
<li>&#26597;&#25214;&#23383;&#31526;&#20018; S1 &#26159;&#21542;&#22312;&#23383;&#31526;&#20018; S &#20013;</li>
<li>&#25351;&#23450;&#23383;&#31526;&#20018; S1 &#22312;&#23383;&#31526;&#20018; S &#20013;&#20986;&#29616;&#30340;&#27425;&#25968;</li>
<li>&#23383;&#31526;&#20018; S &#20013;&#30340;&#26368;&#38271;&#37325;&#22797;&#23376;&#20018;</li>
<li>2 &#20010;&#23383;&#31526;&#20018;&#30340;&#26368;&#38271;&#20844;&#20849;&#37096;&#20998;</li>
</ol>
</dd>
<dt>&#25968;&#25454;&#24211;&#31995;&#32479;&#20013;&#30340;&#31639;&#27861; <code class="fold">@</code></dt>
<dd><p>&#26368;&#36817;&#24320;&#22987;&#35835;&#12298;&#25968;&#25454;&#24211;&#31995;&#32479;&#23454;&#29616;&#12299;&#36825;&#26412;&#20070;&#65292;&#25152;&#20197;&#23601;&#24819;&#21040;&#25226;&#25968;&#25454;&#24211;&#37324;&#38754;&#29992;&#21040;&#30340;&#25968;&#25454;&#32467;&#26500;&#21644;&#31639;&#27861;&#20570;&#19968;&#20010;&#26803;&#29702;&#12290;&#23601;&#26377;&#20102;&#36825;&#20123;&#25991;&#23383;&#12290;</p>
<p>&#30005;&#26799;&#31639;&#27861;</p>
<p>B &#26641;&#32034;&#24341;</p>
<p>R &#26641;&#32034;&#24341;</p>
<p>&#20301;&#22270;&#32034;&#24341;</p>
<p>&#19968;&#36255;&#31639;&#27861;</p>
<p>&#20108;&#36255;&#31639;&#27861;</p>
<p>&#22522;&#20110;&#25490;&#24207;</p>
<p>&#22522;&#20110;&#25955;&#21015;</p>
<p>&#36830;&#25509;&#26641;</p>
<p>&#21160;&#24577;&#35268;&#21010;</p>
<p>&#36138;&#23146;&#31639;&#27861;</p>
<p>&#20998;&#24067;&#24335;&#24182;&#34892;&#25968;&#25454;&#24211;&#20013;&#30340;&#20219;&#21153;&#20998;&#37197;&#31639;&#27861;</p>
<p>&#24182;&#34892;&#31639;&#27861;</p>
<p>&#25968;&#25454;&#25366;&#25496;</p>
<p>&#21457;&#29616;&#39057;&#32321;&#39033;&#38598;&#30340;&#31639;&#27861;</p>
<p>&#21457;&#29616;&#36817;&#20284;&#21830;&#21697;&#30340;&#31639;&#27861;</p>
<p>PageRank</p>
<p>refs and see also</p>
<ul>
<li>&#12298;&#25968;&#25454;&#24211;&#31995;&#32479;&#23454;&#29616;&#12299;</li>
<li>&#12298;redis &#35774;&#35745;&#19982;&#23454;&#29616;&#12299;</li>
</ul>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="https://github.com/nonstriater/Learn-Algorithms">nonstriater/Learn-Algorithms: &#31639;&#27861;&#23398;&#20064;&#31508;&#35760;</a></li>
</ul>
</dd>
<dt>&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#27010;&#29575;&#35770;&#38382;&#39064; &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#20551;&#35774;&#26377;&#19968;&#20010;&#30828;&#24065;&#65292;&#25243;&#20986;&#23383;&#65288;&#32972;&#38754;&#65289;&#21644;&#33457;&#65288;&#27491;&#38754;&#65289;&#30340;&#27010;&#29575;&#37117;&#26159;0.5&#65292;&#32780;&#19988;&#27599;&#27425;&#25243;&#30828;&#24065;&#19982;&#21069;&#27425;&#32467;&#26524;&#26080;&#20851;&#12290;&#29616;&#22312;&#20570;&#19968;&#20010;&#28216;&#25103;&#65292;&#36830;&#32493;&#22320;&#25243;&#36825;&#20010;&#30828;&#24065;&#65292;&#30452;&#21040;&#36830;&#32493;&#20986;&#29616;&#20004;&#27425;&#23383;&#20026;&#27490;&#65292;&#38382;&#24179;&#22343;&#35201;&#25243;&#22810;&#23569;&#27425;&#25165;&#33021;&#32467;&#26463;&#28216;&#25103;&#65311;&#27880;&#24847;&#65292;&#19968;&#26086;&#36830;&#32493;&#25243;&#20986;&#20004;&#20010;&#8220;&#23383;&#8221;&#21521;&#19978;&#28216;&#25103;&#23601;&#32467;&#26463;&#20102;&#65292;&#19981;&#29992;&#32487;&#32493;&#25243;&#12290;</p>
<p>&#20551;&#35774;&#36830;&#32493;&#25243; 2 &#27425;&#27491;&#38754;&#30340;&#26399;&#26395;&#20026; E</p>
<pre><code>E = 0.5 * 0.5 * 2     (&#31532;&#19968;&#27425;&#25243;&#20102;&#27491;&#65292; &#31532;&#20108;&#27425;&#20063;&#25243;&#20102;&#27491;&#65292;&#21017;&#25243;&#20004;&#27425;&#32467;&#26463;&#20102;&#65292;&#27425;&#25968;&#26159;&#20004;&#27425;)
  + 0.5 * 0.5 * (E + 2)&#65288;&#31532;&#19968;&#27425;&#25243;&#20102;&#27491;&#65292; &#31532;&#20108;&#27425;&#25243;&#20102;&#21453;&#65292;&#21069;&#38754;&#26080;&#25928;&#20102;&#65292;&#20174;&#22836;&#24320;&#22987;&#65292;&#37027;&#20040;&#20877;&#20986;&#29616;&#20004;&#20010;&#27491;&#38754;&#65292;&#27425;&#25968;&#26159; E+2&#65289;
  + 0.5 * (E + 1)      (&#31532;&#19968;&#27425;&#25243;&#20102;&#21453;&#65292; &#21069;&#38754;&#26080;&#25928;&#20102;&#65292;&#20174;&#22836;&#24320;&#22987;&#65292;&#37027;&#20040;&#20877;&#20986;&#29616;&#20004;&#20010;&#27491;&#38754;&#27425;&#25968;&#26159; E+1&#65289;</code></pre>
<p>E = 6</p>
<p>&#21516;&#29702;&#21487;&#20197;&#25512;&#31639;&#36830;&#32493;&#19977;&#20010;&#27491;&#38754;&#65292;&#36830;&#32493;&#21453;&#27491;&#65292;&#27491;&#21453;&#65292;&#31561;&#31561;&#25152;&#26377;&#24773;&#20917;&#37117;&#21487;&#20197;&#35745;&#31639;&#12290;</p>
<blockquote>
<p>&#35874;&#35874;&#21161;&#25945;&#65292;</p>
<p>&#27604;&#22914;&#19977;&#20010;&#27491;&#38754;&#24212;&#35813;&#23601;&#26159;&#36825;&#22235;&#31181;&#24773;&#20917;&#20998;&#26512;&#20102;&#25226;&#65311;(&#21453;&#27491;&#20197;&#36935;&#21040;&#21453;&#23601;&#35201;&#20174;&#22836;&#24320;&#22987;&#24324;&#20102;)</p>
<ul>
<li><ol style="list-style-type: decimal">
<li>&#27491;&#27491;&#27491;</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>&#27491;&#27491;&#21453; + E</li>
</ol></li>
<li><ol start="3" style="list-style-type: decimal">
<li>&#27491;&#21453; + E</li>
</ol></li>
<li><ol start="4" style="list-style-type: decimal">
<li>&#21453; + E</li>
</ol></li>
</ul>
</blockquote>
<p>&#21516;&#29702;&#31639;&#19968;&#26679;&#36830;&#32493;&#19977;&#20010;&#27491;&#38754;&#30340;&#26399;&#26395; E</p>
<pre><code>E = 0.5 * 0.5 * 0.5 * 3
  + 0.5 * 0.5 * 0.5 * (E + 3)
  + 0.5 * 0.5 + (E + 2)
  + 0.5 * (E + 1)</code></pre>
<p>&#24471;&#21040; E = 14&#65292;&#19977;&#20010;&#36830;&#32493;&#27491;&#38754;&#30340;&#26399;&#26395;&#26159; 14 &#27425;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://blog.csdn.net/wangran51/article/details/8882088">&#25243;&#30828;&#24065; &#30452;&#21040;&#36830;&#32493;&#20986;&#29616;&#20004;&#27425;&#23383;&#20026;&#27490; - VergiL Wang&#30340;&#19987;&#26639; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
<li><a href="http://www.jiuzhang.com/qa/2125/" class="hearts">&#27010;&#29575;&#35770;&#38382;&#39064;</a></li>
</ul>
</dd>
<dt>&#24590;&#20040;&#25214;&#20013;&#23567;&#20844;&#21496;&#26657;&#25307;&#30340;&#32844;&#20301;&#65311; <code class="fold">@</code></dt>
<dd><p>&#22823;&#20844;&#21496;&#21487;&#20197;&#21435;&#20182;&#20204;&#32593;&#31449;&#25237;&#65292;&#19981;&#36807;&#37027;&#20123;&#19981;&#30693;&#21517;&#30340;&#20013;&#23567;&#20844;&#21496;&#30340;&#26657;&#25307;&#32844;&#20301;&#24590;&#20040;&#25214;&#21602;&#65311;Indeed &#20043;&#31867;&#30340;&#19978;&#38754;&#25628;&#20160;&#20040;&#20851;&#38190;&#35789;&#65311;</p>
<blockquote>
<p>angellist</p>
</blockquote>
</dd>
<dt>&#12304;&#32622;&#39030;&#12305; &#20026;&#20160;&#20040;&#19981;&#38656;&#35201;&#23398;&#20064;&#36138;&#24515;&#27861; <code class="fold">@</code></dt>
<dd><p>&#22240;&#27492;&#65292;&#36138;&#24515;&#27861;&#21487;&#20197;&#35828;&#65292;&#26159;&#19968;&#31181;&#8220;&#30446;&#20809;&#30701;&#27973;&#8221;&#30340;&#31639;&#27861;&#12290;&#19968;&#33324;&#22312;&#31639;&#27861;&#38382;&#39064;&#20013;&#65292;&#21487;&#20197;&#20351;&#29992;&#36138;&#24515;&#31639;&#27861;&#30340;&#38382;&#39064;&#65292;&#20854;&#36138;&#24515;&#31574;&#30053;&#24448;&#24448;&#37117;&#27604;&#36739;&#22797;&#26434;&#65292;&#19968;&#33324;&#20154;&#26159;&#24819;&#19981;&#21040;&#30340;&#12290;&#32780;&#20320;&#23481;&#26131;&#24819;&#21040;&#30340;&#37027;&#20123;&#36138;&#24515;&#31574;&#30053;&#65292;&#24448;&#24448;&#37117;&#26159;&#38169;&#30340;&#12290;</p>
<dl>
<dt>&#38754;&#35797;&#22522;&#26412;&#19981;&#20250;&#32771; <code class="fold">@</code></dt>
<dd><p>&#36138;&#24515;&#27861;&#30340;&#38382;&#39064;&#65292;&#38754;&#35797;&#22522;&#26412;&#19981;&#20250;&#32771;&#65292;&#22240;&#20026;&#31561;&#21516;&#20110;&#32771;&#26234;&#21147;&#39064;&#25110;&#32773;&#26159;&#32972;&#35829;&#39064;&#12290;&#19968;&#20010;&#38754;&#35797;&#23448;&#24819;&#35201;&#33258;&#24049;&#20973;&#31354;&#21019;&#36896;&#20986;&#19968;&#20010;&#38754;&#35797;&#39064;&#26159;&#20351;&#29992;&#36138;&#24515;&#31639;&#27861;&#30340;&#65292;&#26159;&#38750;&#24120;&#22256;&#38590;&#30340;&#12290;&#65288;&#21442;&#35265; LintCode &#19978;&#30340;&#36138;&#24515;&#31639;&#27861;&#30340;&#39064;&#30446;&#25152;&#21344;&#27604;&#20363;&#21487;&#30693;&#65289;&#12290;&#26082;&#28982;&#22914;&#27492;&#65292;&#22914;&#26524;&#38754;&#35797;&#20013;&#34987;&#38382;&#21040;&#20102;&#36138;&#24515;&#31639;&#27861;&#65292;&#37027;&#20040;&#19968;&#23450;&#26159;&#19968;&#36947;&#32463;&#20856;&#30340;&#36138;&#24515;&#38382;&#39064;&#65292;&#36825;&#31867;&#38382;&#39064;&#65292;&#25105;&#20204;&#21487;&#20197;&#31216;&#20043;&#20026;&#32972;&#35829;&#39064;&#12290;&#22240;&#20026;&#22823;&#22810;&#25968;&#21516;&#23398;&#65288;&#38500;&#20102;&#26234;&#21830;&#24456;&#39640;&#65292;&#25110;&#32773;&#26377;&#31639;&#27861;&#31454;&#36187;&#32463;&#21382;&#30340;&#37027;&#19968;&#25209;&#65289;&#65292;&#26159;&#19981;&#21487;&#33021;&#22312;&#38754;&#35797;&#30340;&#26102;&#20505;&#24819;&#24471;&#20986;&#35299;&#27861;&#30340;&#12290;</p>
<p>&#20030;&#20960;&#20010;&#20363;&#23376;&#65306;Gas Station (http://www.lintcode.com/en/problem/gas-station/)&#65292;&#36825;&#20010;&#39064;&#30340;&#20570;&#27861;&#26159;&#65292;&#20174;&#20219;&#24847;&#31449;&#28857;&#20986;&#21457;&#65292;&#36208;&#19968;&#22280;&#65292;&#25214;&#21040;&#36825;&#19968;&#22280;&#37324;&#21097;&#20313;Gas&#26368;&#23569;&#30340;&#37027;&#19968;&#31449;&#65292;&#28982;&#21518;&#20174;&#36825;&#19968;&#31449;&#20986;&#21457;&#36208;&#19968;&#22280;&#65292;&#22914;&#26524;&#22312;&#36825;&#19968;&#31449;&#20986;&#21457;&#21487;&#20197;&#39034;&#21033;&#36208;&#23436;&#20840;&#31243;&#65292;&#37027;&#20040;&#23601;&#21487;&#20197;&#34892;&#65292;&#21542;&#21017;&#23601;&#19981;&#21487;&#34892;&#12290;&#20687;&#36825;&#26679;&#30340;&#31639;&#27861;&#65292;&#26159;&#38656;&#35201;&#36827;&#34892;&#25968;&#23398;&#35777;&#26126;&#26469;&#35777;&#26126;&#20854;&#27491;&#30830;&#24615;&#30340;&#65292;&#38754;&#35797;&#23448;&#26159;&#27809;&#26377;&#33021;&#21147;&#20986;&#36825;&#26679;&#30340;&#38754;&#35797;&#39064;&#30340;&#12290;</p>
<p>&#20174;&#21478;&#22806;&#19968;&#20010;&#35282;&#24230;&#26469;&#35828;&#65292;&#36138;&#24515;&#31639;&#27861;&#30340;&#39064;&#65292;&#23545;&#20110;&#31243;&#24207;&#30340;&#23454;&#29616;&#33021;&#21147;&#35201;&#27714;&#24182;&#19981;&#39640;&#65292;&#20063;&#36829;&#32972;&#20102;&#20844;&#21496;&#36890;&#36807;&#31639;&#27861;&#39064;&#38754;&#35797;&#20027;&#35201;&#26159;&#24076;&#26395;&#32771;&#23519;&#22823;&#23478;&#30340;&#31243;&#24207;&#23454;&#29616;&#33021;&#21147;&#36825;&#19968;&#28857;&#12290;&#25152;&#20197;&#38754;&#35797;&#23448;&#21644;&#20844;&#21496;&#20063;&#37117;&#19981;&#20542;&#21521;&#20110;&#23558;&#36138;&#24515;&#31639;&#27861;&#20316;&#20026;&#38754;&#35797;&#30340;&#31639;&#27861;&#38382;&#39064;&#12290;</p>
</dd>
<dt>&#27809;&#26377;&#36890;&#29992;&#24615; <code class="fold">@</code></dt>
<dd><p>&#20108;&#20998;&#27861;&#65292;&#21160;&#24577;&#35268;&#21010;&#31639;&#27861;&#65292;&#20998;&#27835;&#31639;&#27861;&#65292;&#25628;&#32034;&#31639;&#27861;&#31561;&#31561;&#65292;&#24456;&#22810;&#30340;&#31639;&#27861;&#37117;&#26159;&#20855;&#26377;&#36890;&#29992;&#24615;&#30340;&#12290;&#20063;&#23601;&#26159;&#35828;&#65292;&#22312;&#39064;&#30446; A &#37324;&#65292;&#20320;&#29992;&#20102;&#36825;&#20010;&#31639;&#27861;&#65292;&#22312;&#20854;&#20182;&#30340;&#39064;&#30446; B &#37324;&#65292;&#20320;&#21487;&#33021;&#23436;&#20840;&#21487;&#20197;&#29992;&#19968;&#26679;&#30340;&#31639;&#27861;&#21644;&#24605;&#36335;&#21435;&#35299;&#20915;&#12290;</p>
<p>&#32780;&#36138;&#24515;&#27861;&#65292;&#20182;&#19981;&#26159;&#8220;&#19968;&#20010;&#31639;&#27861;&#8221;&#65292;&#32780;&#26159;&#8220;&#19968;&#31867;&#31639;&#27861;&#8221;&#30340;&#32479;&#31216;&#12290;&#25152;&#20197;&#22522;&#26412;&#30340;&#24773;&#20917;&#23601;&#26159;&#65292;&#20320;&#22312;&#39064;&#30446;A&#37324;&#29992;&#20102;&#26576;&#20010;&#36138;&#24515;&#31639;&#27861;&#35299;&#20915;&#20102;&#36825;&#20010;&#38382;&#39064;&#65292;&#28982;&#21518;&#36825;&#20010;&#39064;&#20013;&#29992;&#21040;&#30340;&#36138;&#24515;&#27861;&#65292;&#27704;&#36828;&#20063;&#25214;&#19981;&#21040;&#31532;&#20108;&#20010;&#39064;&#29992;&#31867;&#20284;&#30340;&#26041;&#27861;&#26469;&#35299;&#20915;&#12290;</p>
</dd>
<dt>&#36138;&#24515;&#26159;&#21160;&#24577;&#35268;&#21010;&#30340;&#23376;&#38598;&#20040;? <code class="fold">@</code></dt>
<dd><p>&#21482;&#35201;&#38382;&#39064;&#30340;&#35299;&#20915;&#26041;&#26696;&#26377;&#26368;&#20248;&#23376;&#32467;&#26500;&#65292;&#24182;&#19988;&#26080;&#21518;&#25928;&#24615;&#23601;&#21487;&#20197;&#35748;&#20026;&#26159;&#21160;&#24577;&#35268;&#21010;&#12290;</p>
<p>&#20294;&#26159;&#20320;&#36825;&#26679;&#38382;&#24182;&#27809;&#26377;&#20160;&#20040;&#24847;&#20041;&#65292;&#22240;&#20026;&#21160;&#24577;&#35268;&#21010;&#30495;&#27491;&#30340;&#30446;&#30340;&#36824;&#26159;&#20381;&#36182;&#31354;&#38388;&#25442;&#26102;&#38388;&#65292;&#32780;&#36138;&#24515;&#31574;&#30053;&#19981;&#26159;&#12290;</p>
<p>&#20030;&#20010;&#31616;&#21333;&#30340;&#20363;&#23376;&#26469;&#35828;&#65292;&#27714;&#21333;&#28304;&#26368;&#30701;&#36335;&#30340; Dijkstra &#31639;&#27861;&#65292;&#20320;&#21487;&#20197;&#35748;&#20026;&#23427;&#26159;&#19968;&#20010;&#36138;&#24515;&#31639;&#27861;&#65292;&#22240;&#20026;&#26681;&#25454;&#23450;&#20041;&#65288;Di &#34920;&#31034;&#28304;&#28857;&#21040;&#33410;&#28857; i &#30340;&#26368;&#30701;&#36335;&#38271;&#24230;&#65289;&#65306;</p>
<p>Dj = min{ Dj, Di+ Matrix[i][j] }</p>
<p>&#23427;&#27599;&#27425;&#36845;&#20195;&#37117;&#24456;&#26080;&#33041;&#22320;&#36873;&#19968;&#26465;&#26368;&#36817;&#30340;&#36335;&#20986;&#21457;&#65292;&#25152;&#20197;&#35748;&#20026;&#26159;&#19968;&#20010;&#36138;&#24515;&#31574;&#30053;&#12290;&#20294;&#26159;&#23427;&#21448;&#26377;&#25928;&#22320;&#23558;&#37325;&#21472;&#30340;&#26368;&#20248;&#23376;&#32467;&#26500;&#38382;&#39064;&#29992;&#19968;&#20010;&#36741;&#21161;&#25968;&#32452; D &#23384;&#20648;&#20102;&#36215;&#26469;&#65292;&#24182;&#19988;&#27809;&#26377;&#21518;&#25928;&#24615;&#65292;&#25152;&#20197;&#20063;&#26159;&#19968;&#20010;&#21160;&#24577;&#35268;&#21010;&#31639;&#27861;&#12290;</p>
</dd>
<dt>&#22914;&#20309;&#29702;&#35299;&#21160;&#24577;&#35268;&#21010;&#65311; :TODO: <code class="fold">@</code></dt>
<dd><p>TODO</p>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/2100/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
<li><a href="http://www.jiuzhang.com/qa/2099/">&#65288;&#26080;&#26435;&#38480;&#65289;&#20960;&#20010;&#24517;&#39035;&#8220;&#32972;&#35829;&#8221;&#30340;&#36138;&#24515;&#31639;&#27861;&#39064;</a></li>
<li><a href="https://www.zhihu.com/question/34414760">&#36138;&#24515;&#26159;&#21160;&#24577;&#35268;&#21010;&#30340;&#23376;&#38598;&#20040;? - &#30693;&#20046;</a></li>
<li><a href="https://www.zhihu.com/question/39948290">&#22914;&#20309;&#29702;&#35299;&#21160;&#24577;&#35268;&#21010;&#65311; - &#30693;&#20046;</a></li>
<li><a href="http://wenku.baidu.com/view/f20777a7b0717fd5370cdc05.html">&#31532;10&#35762; &#36138;&#24515;&#31639;&#27861;&#30340;&#20363;&#23376;_&#22270;&#25991;_&#30334;&#24230;&#25991;&#24211;</a></li>
<li><a href="https://www.zhihu.com/question/22112710?sort=created">&#36138;&#24515;&#31639;&#27861;&#22914;&#20309;&#20307;&#29616;&#22312;&#38669;&#22827;&#26364;&#32534;&#30721;&#20013;&#65311; - &#30693;&#20046;</a></li>
<li><a href="http://www.cnblogs.com/yuchenlin/p/4382027.html">&#12304;&#31639;&#27861;&#23398;&#20064;&#31508;&#35760;&#12305;25.&#36138;&#24515;&#27861; &#22343;&#20998;&#32440;&#29260;&#38382;&#39064;&#30340;&#20998;&#26512; - &#38632;&#23576;&#20043;&#26519; - &#21338;&#23458;&#22253;</a></li>
<li><a href="https://www.zhihu.com/question/27883948">&#22343;&#20998;&#32440;&#29260;&#38382;&#39064;&#20026;&#20160;&#20040;&#21487;&#20197;&#29992;&#36138;&#24515;&#27861;&#24471;&#21040;&#20840;&#23616;&#26368;&#20248;&#35299;&#65311; - &#30693;&#20046;</a></li>
<li><a href="http://blog.csdn.net/a925907195/article/details/41314549">&#36138;&#24515;&#31639;&#27861;&#21450;&#20960;&#20010;&#32463;&#20856;&#20363;&#23376; - a925907195&#30340;&#19987;&#26639; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
</ul>
</dd>
<dt>resume &#19978;&#38656;&#35201;&#20889; objective &#21527; <code class="fold">@</code></dt>
<dd><p>&#21548;&#20061;&#31456;&#30340;&#35762;&#24231;&#35828;&#35201;&#20889;&#65292;&#20294;&#26159;&#20061;&#31456;&#32473;&#30340;&#31616;&#21382;&#37324;&#21448;&#27809;&#26377; objective&#12290;&#26159;&#19981;&#26159;&#36716;&#19987;&#19994;&#30340;&#24517;&#38656;&#20889;&#65311;</p>
<p><strong>&#35201;&#12290;</strong></p>
</dd>
<dt>&#22810;&#20010;&#38754;&#35797;&#32463;&#39564;&#36148;&#27719;&#24635; <code class="fold">@</code></dt>
<dd><ul>
<li>&#31532;&#19968;&#26723;&#27425;: Dropbox, Square, Pinterest, Facebook, LinkedIn, Google, Twitter, Apple</li>
<li>&#31532;&#20108;&#26723;&#27425;: Zynga, Yelp, Netflix, Skype, VMWare, Salesforce, Groupon, Paypal, Evernote, Box.net, Quora, A9.com, 126Lab, Palantir</li>
<li><p>&#31532;&#19977;&#26723;&#27425;: Oracle, EMC, eBay, Intuit, NetApp, NetSuite, Yahoo, Adobe, Autodesk, Symantec, Riverbed, Quantcast, Concur, Aster Data, Citrix, EA&#31561;</p>
<p>&#31639;&#19978;&#28286;&#21306;&#20197;&#22806;&#20844;&#21496;&#65292; Amazon, Micriosoft &#21487;&#20197;&#25490;&#22312;&#31532;&#20108;&#26723;&#27425; Expedia, RedHat, RackSpace, Akamai, Bloomberg &#31561;&#21487;&#20197;&#25490;&#22312;&#31532;&#19977;&#26723;&#27425;&#12290;</p>
<p>Dropbox &#21019;&#22987;&#20154; Drew Houston &#22312; 2013 &#24180; MIT &#30340;&#27605;&#19994;&#20856;&#31036;&#19978;&#35762;&#30340;&#24456;&#22909;&#65306;&#8220;&#19990;&#30028;&#19978;&#21482;&#26377;&#19968;&#20010;&#22909;&#33713;&#22366;&#65292;&#19968;&#20010;&#30789;&#35895;&#65292;&#22914;&#26524;&#20320;&#24819;&#24453;&#22312;&#19994;&#30028;&#26368;&#22909;&#30340;&#22280;&#23376;&#65292;&#37027;&#23601;&#25644;&#23478;&#65281;&#8221;&#25105;&#34987;&#20182;&#35828;&#26381;&#65292;&#25237;&#31616;&#21382;&#30340;&#26102;&#20505;&#30596;&#20934;&#20102; FLGT(&#19994;&#30028;&#26368;&#28779;&#30340;&#22235;&#23478;&#20844;&#21496;&#65292; Facebook, LinkedIn, Google, Twitter) &#21644;&#19968;&#20247;&#28779;&#29190;&#30340;&#21021;&#21019;&#20844;&#21496;&#12290;</p>
<p>&#26368;&#36817;&#32454;&#35835;&#26410;&#26469;&#20844;&#21496; LinkedIn &#30340;&#21019;&#22987;&#20154; Reid Hoffman &#30340;&#26032;&#20070; The Start-up of You&#65292;&#37324;&#38754;&#35762;&#21040;&#27714;&#32844;&#19977;&#29255;&#25340;&#22270;&#65306;&#20320;&#30340;&#36164;&#28304; / &#33021;&#21147;&#65288;your assets&#65289;&#65292;&#20320;&#30340;&#24535;&#21521; / &#20215;&#20540;&#35266;&#65288;your aspirations/values) &#21644;&#24066;&#22330;&#29616;&#23454;&#65288;market reality&#65289;&#65292;&#20849;&#21516;&#32452;&#25104;&#20320;&#30340;&#26680;&#24515;&#31454;&#20105;&#21147;&#12290;&#25152;&#20197;&#25105;&#21435;&#23581;&#35797;&#20114;&#32852;&#32593;&#22823;&#20844;&#21496;&#65292;&#21313;&#25237;&#20843;&#20013;&#65292;&#20294;&#26159;&#20854;&#20182;&#30340;&#21162;&#21147;&#24456;&#22810;&#37117;&#28010;&#36153;&#20102;&#65292;&#22914;&#26524;&#24403;&#26102;&#26089;&#23601;&#30475;&#20102;&#36825;&#26412;&#20070;&#22810;&#22909;&#12290;&#20851;&#20110;&#36825;&#26412;&#20070;&#21644;&#23427;&#30340;&#20316;&#32773;&#65292;&#20197;&#21518;&#20250;&#20889;&#21478;&#19968;&#31687;&#25991;&#31456;&#35814;&#36848;&#65292;&#36825;&#37324;&#20808;&#38534;&#37325;&#25512;&#33616;&#32473;&#22823;&#23478;&#12290;</p></li>
</ul>
<dl>
<dt>&#26368;&#21518;&#26469;&#19968;&#28857;&#24178;&#36135;&#21543;&#65292;&#32473;&#26412;&#19987;&#19994;&#30340;&#20154;&#30475; <code class="fold">@</code></dt>
<dd><dl>
<dt>Google &#39064;&#30446;&#65306; <code class="fold">@</code></dt>
<dd><ol style="list-style-type: decimal">
<li>MST of a all connected graph. Need to use Fibo heap to reduce complexity.</li>
<li>Game of Life, one transition (sub O(n^2) solution).</li>
<li>String compressor that turns 123abkkkkc to 123ab5xkc. Decompressor is already written and must remain unchanged. (messy code)</li>
<li>Youtube mash design, how to do a video version of Mark&#8217;s FaceMash.</li>
</ol>
<p>&#39064;&#20840;&#37117;&#27809;&#35265;&#36807;&#65292;rej</p>
</dd>
<dt>Facebook &#39064;&#30446;&#65306; <code class="fold">@</code></dt>
<dd><p>&#30005;&#35805;</p>
<ol style="list-style-type: decimal">
<li>Big Integer multiplication. (Optimization required, how to do 8 digits*8 digits, etc).</li>
<li>Binary tree level order traversal. (leetcode original)</li>
<li>&#20063;&#26159; leetcode &#21407;&#39064;&#65292;&#19981;&#35760;&#24471;&#20102;</li>
</ol>
<p>Onsite</p>
<ol style="list-style-type: decimal">
<li>Given 1-&gt;a, 2-&gt;b &#8230; 26-&gt;z. 126 -&gt; az or lf or abf (bfs/dfs not accepted, need to use DP or some tricky method)</li>
<li>Binary tree serialization/de-serialization (&#36825;&#36947;&#39064;pinterest&#20063;&#38382;&#20102;&#65289;</li>
<li>Permutation with duplicate</li>
<li>Range maximum query, pre-processing in O(n) and query in O(1)</li>
</ol>
<p>&#39064;&#31572;&#23569;&#20102;&#19968;&#36947;&#65292;rej</p>
</dd>
</dl>
</dd>
<dt>&#20854;&#20182;&#37325;&#35201;&#39064;&#30446;&#21644;&#25216;&#24039;&#65306;</dt>
<dd><p>2Sum 3Sum, rotate LinkedList, minimum path sum, combinations</p>
<p>&#27880;&#37325;&#32451;&#20064; tree &#30340; recursion &#25628;&#32034;, dp, greedy, two/three pointers, stack. &#35895;&#27468;&#30340;&#39064;&#26159;&#24456;&#38590;&#21047;&#21040;&#30340;&#65292;&#35201;&#38752;&#36816;&#27668;&#65292;&#20854;&#20182;&#24456;&#22810;&#20844;&#21496;&#65288;&#23588;&#20854;&#26159;&#20122;&#39532;&#36874;&#20026;&#39318;&#65289;&#37117;&#21487;&#20197;&#38752;&#21047;&#39064;&#22823;&#24133;&#25552;&#39640;&#32988;&#31639;&#12290; &#36164;&#28304;&#65306;leetcode.com, geeksforgeeks.com, glassdoor.com, CC150</p>
<p>BTW&#65292;&#20170;&#24180;&#20960;&#23478;&#30340;&#30805;&#22763; package &#37117;&#24046;&#19981;&#22810;&#65292;&#22823;&#32422;&#26159; 115k base + 160-170k &#65288;RSU &#32929;&#31080;&#20998;4 &#24180; + signing + reloc)&#65292;&#22914;&#26524;&#27809;&#26377; competing offer &#27604;&#36739;&#38590;negotiate&#12290;&#25105;&#30340; O &#23478;offer &#26159; 114k base + 4000 &#32929;&#26399;&#26435;&#20998;&#22235;&#24180; + 15k signing + 10k reloc&#65292;&#22312;&#31561; LinkedIn&#21457; official offer &#20043;&#21069;&#65292;&#25104;&#21151;&#30340;&#24819;&#21150;&#27861;&#25226; deadline &#24310;&#38271;&#20102;&#20004;&#27425;&#65292;&#21464;&#25104; Standing offer&#65292;&#22914;&#26524;&#19981;&#36825;&#20040;&#24178;&#65292;&#20182;&#20204;&#26159;&#24895;&#24847;&#28072;&#19968;&#28857; base &#30340;&#12290;</p>
<p>&#25353;&#29031;&#25105;&#20010;&#20154;&#30340;&#29702;&#35299;&#65292;&#23398;&#29983;&#34987;&#22823;&#20844;&#21496;&#20998;&#20004;&#31867;&#65292;&#31532;&#19968;&#31867;&#26159;&#8220;&#21517;&#26657; GPA3.8 &#20197;&#19978;&#8221;&#30340;&#65292;&#31532;&#20108;&#31867;&#26159;else&#12290;&#20316;&#20026; else &#30340;&#20195;&#34920;&#65292;&#25105;&#19981;&#24471;&#19981;&#35828;&#65292;GPA3.8 &#20197;&#19978;&#30495;&#30340;&#24456;&#38590;&#65292;&#31532;&#19968;&#31867;&#20204;&#30830;&#23454;&#30830;&#23454;&#26377;&#29305;&#26435;&#20808;&#34987;&#32771;&#34385;&#65292;&#20294;&#26412;&#25991;&#27491;&#26159;&#29486;&#32473;&#24191;&#22823; else &#20204;&#30340;&#12290;</p>
<p>&#38754;&#35797;&#36825;&#20010;&#19996;&#35199;&#65292;&#20854;&#23454;&#26159;&#27809;&#27861;&#20934;&#22791;&#30340;&#65292;&#20840;&#38752;&#32463;&#39564;&#12290;&#25105;&#27809;&#26377;&#21738;&#20010;&#38382;&#39064;&#22312;&#31532;&#19968;&#27425;&#34987;&#38382;&#30340;&#26102;&#20505;&#23601;&#33021;&#31572;&#30340;&#24456;&#23436;&#32654;&#65292;&#25105;&#30456;&#20449;&#35841;&#20063;&#19981;&#33021;&#12290;&#20174;&#21435;&#24180; 6 &#26376;&#36319;&#20154;&#23478;&#20171;&#32461;&#33258;&#24049;&#37117;&#35201;&#30933;&#30933;&#24052;&#24052;&#65292;&#21040;&#29616;&#22312;&#22522;&#26412;&#25105;&#34384;&#38754;&#35797;&#23448;&#65292;&#22823;&#22823;&#23567;&#23567;&#30340;&#30005;&#38754;&#19968;&#30334;&#26469;&#27425;&#65292;onsite &#21313;&#26469;&#27425;&#65292;&#30952;&#21402;&#30340;&#19981;&#21482;&#26159;&#22068;&#30382;&#65292;&#36824;&#26377;&#33080;&#30382;&#12290;&#20854;&#23454;&#38754;&#35797;&#30340;&#26368;&#39640;&#22885;&#20041;&#23601;&#26159;&#21402;&#30528;&#33080;&#30382;&#21561;&#29275;&#36924;&#65292;&#24182;&#29992;&#20016;&#23500;&#30340;&#21561;&#29275;&#36924;&#32463;&#39564;&#20445;&#35777;&#19981;&#34987;&#25286;&#31359;&#21363;&#21487;&#12290;&#24403;&#28982;&#20102;&#65292;&#30693;&#35782;&#36824;&#26159;&#35201;&#26377;&#19968;&#20123;&#65292;&#27605;&#31455;&#26159;&#25216;&#26415;&#32844;&#20301;&#65292;&#32780;&#19988;&#35201;&#23545; Coding &#26377;&#19968;&#33108;&#28909;&#24773;&#12290;&#24403;&#28982;&#20102;&#65292;&#36824;&#35201;&#20064;&#24815;&#27599;&#22825;&#21507; subway&#12290;</p>
<p>&#22312;&#36825;&#37324;&#25105;&#24819;&#35828;&#19968;&#35828;&#32769;&#20013;&#65292;&#25105;&#25152;&#35828;&#30340;&#32769;&#20013;&#26159;&#25351;&#29616;&#22312; 40-50 &#23681;&#65292;30 &#22810;&#23681;&#30340;&#26102;&#20505;&#20174;&#22269;&#20869;&#30452;&#25509;&#36339;&#27133;&#36807;&#26469;&#30340;&#20013;&#22269;&#36719;&#24037;&#65292;&#38169;&#20102;&#65292;&#26159; &#25105;&#20204;&#36825;&#20799; &#36719;&#24037;&#12290;&#25105;&#21435; qualcomm &#21644; amazon onsite &#37117;&#26159;&#26685;&#21040;&#20102;&#32769;&#20013;&#25163;&#37324;&#12290;&#25105;&#29616;&#22312;&#20063;&#19981;&#26126;&#30333;&#20026;&#20160;&#20040;&#21482;&#26377;&#20013;&#22269;&#20154;&#30475;&#19981;&#19978;&#20013;&#22269;&#20154;&#65292;&#32780;&#20154;&#23478;&#38463;&#19977;&#37117;&#26159;&#21482;&#24110;&#38463;&#19977;&#12290;&#25105;&#22312; qualcomm &#26368;&#21518;&#19968;&#20010;&#38754;&#30340;&#32769;&#20013;&#38382;&#25105;&#65292;&#26377;&#27809;&#26377;&#23398;&#36807; OS&#65292;&#25105;&#35828;&#25105;&#33258;&#23398;&#30340;&#12290;&#20182;&#35828;&#20320;&#27809;&#26377;&#20570;&#36807;&#37027;&#20123; project &#20063;&#35828;&#20320;&#23398;&#36807;&#65311;&#25105;&#35828;&#20320;&#21487;&#20197;&#38382;&#21834;&#65292;&#30475;&#30475;&#25105;&#20250;&#19981;&#20250;&#12290;&#32467;&#26524;&#36825; B &#38382;&#20102;&#25105;&#19968;&#22534;&#25105;&#22238;&#26469; google &#37117;&#26597;&#19981;&#21040;&#30340;&#39740;&#38382;&#39064;&#65292;&#36824;&#38382;&#25105; how to simulate garbage collector in C? &#30475;&#25105;&#19981;&#20250;&#21448;&#24471;&#24847;&#27915;&#27915;&#30340;&#21453;&#38382;&#25105;&#65292;&#20320;&#27809;&#23398;&#36807; OS &#36824;&#24819;&#25214; SWE &#30340;&#24037;&#20316;? &#25105;&#23601;&#35828;&#25105;&#30340;&#35838;&#37117;&#26159; application level &#30340;&#12290;&#20182;&#25805;&#30528;&#27987;&#37325;&#30340;&#19981;&#30693;&#21738;&#30340;&#26041;&#35328;&#33108;&#35828;&#20102;&#19968;&#21477;&#35753;&#25105;&#19968;&#36744;&#23376;&#37117;&#24536;&#19981;&#20102;&#30340;&#35805;&#65306;If I wanna build a applicaiton, I will go to hign school and ask them &#8220;Who wanna do some funny stuff?&#8221;. Why I hire you? &#25105;&#25830;&#65292;&#25105;&#24403;&#26102;&#30495;&#24819;&#19968;&#21475;&#22823;&#27987;&#30192;&#21520;&#20182;&#33080;&#19978;&#28982;&#21518;&#22823;&#39554;&#25105;&#21435;&#20320;&#22823;&#29239;&#30340;&#12290;&#20294;&#26159;&#25105;&#36824;&#26159;&#24525;&#20303;&#20102;&#65292;&#34429;&#28982;&#25105;&#20174;&#20182;&#30524;&#30555;&#37324;&#20063;&#33021;&#30475;&#21040;&#25105;&#30524;&#37324;&#20882;&#20986;&#30340;&#28779;&#20809;&#12290;Amazon &#20063;&#26159;&#19968;&#26679;&#30340;&#65292;&#22312;&#20854;&#20182;&#38754;&#35797;&#23448;&#37117;&#34987;&#25105;&#25240;&#26381;&#20043;&#21518;&#65292;&#20182;&#21448;&#38382;&#25105;&#20026;&#20160;&#20040; EE &#30340;&#19981;&#22909;&#22909;&#23398; EE&#65292;CS &#30340;&#22522;&#30784;&#35838;&#20320;&#37117;&#27809;&#23398;&#36807;&#20113;&#20113;&#8230;. &#25105;&#24403;&#26102;&#20197;&#20026;&#25105;&#38754;&#30340;&#21487;&#20197;&#65292;&#22240;&#20026;&#20182;&#30340;&#39064;&#34987;&#25105;&#20570;&#23436;&#20102;&#65292;&#25105;&#36824;&#25361;&#20102;&#20182;&#19968;&#20010;&#38169;&#35823;&#12290;&#20107;&#21518;&#25105;&#24863;&#35273;&#25361;&#20182;&#30340;&#38169;&#36825;&#19968;&#19979;&#35753;&#20182;&#20915;&#23450;&#27609;&#25105;&#30340;&#65292;&#35201;&#19981;&#28982;&#65292;&#23601;&#26159;&#21644;&#25105;&#31454;&#20105;&#30340;&#20154;&#36807;&#20110; NB &#20102;&#12290;</p>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/788/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>&#32654;&#22242; 2015 &#26657;&#25307;&#38754;&#32463; - &#36719;&#20214;&#30740;&#21457;&#23703; (&#25343;&#21040; offer) <code class="fold">@</code></dt>
<dd><p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/751/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>Linkedin &#38754;&#32463;&#21512;&#38598; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#38754;&#32463; 1 <code class="fold">@</code></dt>
<dd><p>&#28982;&#21518;&#23601;&#26159;&#24320;&#22987;&#20570;&#39064;&#65292;&#20004;&#20010;&#39064;&#30446;&#12290;</p>
<p>&#31532;&#19968;&#20010;&#26159;&#20004;&#20010;&#21333;&#35789;&#26368;&#30701;&#36317;&#31163;&#65292;&#22312;&#29256;&#19978;&#30475;&#21040;&#24456;&#22810;&#20154;&#37117;&#35828;&#36807;&#36825;&#20010;&#39064;&#30446;&#65292;&#24212;&#35813;&#26159;L&#23478;&#32463;&#24120;&#38754;&#30340;&#12290;&#26412;&#26469;&#20197;&#20026;&#21482;&#35201;&#23454;&#29616;&#19968;&#20010;&#20989;&#25968;&#65292;&#21738;&#37324;&#30693;&#36947;&#26159;&#23454;&#29616;&#20004;&#20010;&#20989;&#25968;&#65292;&#31532;&#19968;&#20010;&#26159;&#20570;&#27714;&#26368;&#30701;&#36317;&#31163;&#30340;&#20934;&#22791;&#24037;&#20316;&#65292;&#23454;&#29616;&#31867;&#30340;&#21021;&#22987;&#21270;&#65307;&#31532;&#20108;&#20010;&#25165;&#26159;&#30495;&#27491;&#30340;&#27714;&#26368;&#30701;&#36317;&#31163;&#30340;&#20989;&#25968;&#12290;&#20889;&#31532;&#20108;&#20010;&#20989;&#25968;&#30340;&#26102;&#20505;&#65292;&#36824;&#24536;&#35760;&#21028;&#26029;&#21333;&#35789;&#26159;&#21542;&#22312;&#23383;&#20856;&#20013;&#20986;&#29616;&#36807;&#65292;&#24184;&#22909;&#38754;&#35797;&#23448;&#26377;&#25552;&#37266;&#12290;</p>
<p>&#31532;&#20108;&#39064;&#23601;&#26159; leetcode &#19978;&#30340;&#20840;&#25490;&#21015;&#65292;&#27809;&#26377;&#37325;&#22797;&#20803;&#32032;&#30340;&#12290;</p>
</dd>
<dt>&#38754;&#32463; 2 <code class="fold">@</code></dt>
<dd><p>&#31532;&#20108;&#39064;&#20063;&#27604;&#36739;&#24120;&#35265;,CC150 &#21407;&#39064;, &#25214;&#20457;&#23383;&#31526;&#20018;&#22312;&#19968;&#27573;&#25991;&#23383;&#20013;&#26368;&#36817;&#30340;&#36317;&#31163;:</p>
<p>&#30452;&#25509;&#29992; CC150 &#35299;&#27861;, &#29992;&#20004;&#20010; index &#27604;&#36739;&#24471;&#20986; Math.abs(index1-index2), update &#26368;&#23567;&#36317;&#31163;. &#20889;&#22909;&#21518;&#25552;&#31034;&#35201;&#26159; cat dog cloud dog dog dog&#8230;&#8230;, &#21363;&#21518;&#38754;&#26377; million &#20010; dog, &#26159;&#21542;&#19981;&#29992;&#27604;&#36739;&#25972;&#20010;&#25991;&#31456;. &#22238;&#31572;&#35828;&#29992; map &#25552;&#26089;&#23384;&#20648;&#27599;&#20010;&#21333;&#35789;&#30340; index, &#28982;&#21518;&#22312; map &#20013;&#25214;&#21040;&#21333;&#35789;&#27604;&#36739;, &#22312;&#35752;&#35770;&#21518;&#26368;&#22351;&#24773;&#20917;&#19979;&#22797;&#26434;&#24230;&#20063;&#26159; O(n).</p>
<p>&#30001;&#20110;&#27809;&#26377;&#26102;&#38388;&#20889;&#20195;&#30721;&#20102;&#25152;&#20197;&#36825;&#26679;&#32467;&#36895;&#20102;.</p>
</dd>
<dt>&#38754;&#32463; 3 <code class="fold">@</code></dt>
<dd><p>&#23601;&#19968;&#36947;&#39064;&#65292;&#32463;&#20856;&#30340;&#27714;minimum word distance. &#20294;&#26159;&#19968;&#24320;&#22987;&#26377;&#25402;&#22810;&#26377;&#20851;ML&#30340;&#32454;&#33410;&#39064;</p>
<p>&#23454;&#29616; BlockingQueue &#30340; take() &#21644; put()</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">public</span> interface BlockingQueue&lt;T&gt;
{
    <span class="co">/** </span>Retrieve <span class="kw">and</span> remove the head of the queue, waiting <span class="kw">if</span> no elements
    are present. */

    T take();

    <span class="co">/** </span>Add the given element to the end of the queue, waiting <span class="kw">if</span> necessary
    <span class="kw">for</span> space to become available. */
    <span class="dt">void</span> put (T obj);
}</code></pre></div>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/747/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>Google 15 Fall SDE I &#23454;&#20064;&#29983;&#30005;&#38754; <code class="fold">@</code></dt>
<dd><p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/749/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>G &#23478;&#38754;&#32463;&#39064;&#65292;&#30697;&#38453;&#26368;&#23567; <code class="fold">@</code></dt>
<dd><p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/344/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>Compress String &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#32473;&#19968;&#20010; string&#65292;&#35201;&#27714;&#21387;&#32553;&#21518;&#26368;&#30701;&#12290;&#27604;&#22914;&#35828;&#23545;&#20110; aaaa&#65292;<code>4[a]</code> &#32943;&#23450;&#35201;&#27604; <code>2[aa]</code> &#35201;&#22909;&#12290;&#25105;&#38500;&#20102;&#26292;&#21147;&#26522;&#20030; substring &#20197;&#22806;&#24819;&#19981;&#21040;&#20219;&#20309;&#20854;&#20182;&#26041;&#27861;&#65292;&#35831;&#38382;&#21161;&#25945;&#26377;&#27809;&#26377;&#20854;&#20182;&#24819;&#27861;&#65311;</p>
<p>&#26412;&#38382;&#39064;&#21487;&#20197;&#31616;&#21270;&#25104; S = a[substring], &#27714;&#26368;&#22823;&#30340;a&#12290;</p>
<p>&#22914;&#26524;&#23398;&#36807; KMP &#31639;&#27861;&#30340;&#65292;&#27714;&#20986; S &#30340; next &#25968;&#32452;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">n = len(S)
    j = next[n]
<span class="kw">while</span>   n % (n - j) != <span class="dv">0</span>:
        j = next[j]

    a = n / (n - j)</code></pre></div>
<p>&#36825;&#26159;&#30001; next &#25968;&#32452;&#30340;&#24615;&#36136;&#20915;&#23450;&#30340;&#65292;&#21487;&#20197;&#20808;&#23398;&#19968;&#19979; KMP &#31639;&#27861;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/1439/#">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>&#26080;&#23454;&#20064;&#24320;&#28304;&#32463;&#39564; GPA &#19981;&#39640;&#30340;&#23567;&#30805;&#30340; FLAGBR Offer &#32463; <code class="fold">@</code></dt>
<dd><p>&#25343;&#20102; FLAGR &#30340; offer&#65292;B &#23478;&#20027;&#21160; cancel &#20102; onsite&#12290;&#38750;&#24120;&#24184;&#36816;&#65292;&#38754;&#20102;&#30340;&#20844;&#21496;&#37117;&#25343;&#20102; offer&#65292;&#26368;&#32456;&#21435;&#20102;&#26368;&#21916;&#27426;&#30340; F &#23478;&#65292;&#22810;&#35201;&#20102;&#19968;&#28857; sign on&#65292;&#22240;&#20026;&#31351;&#30340;&#22826;&#20037;&#20102;&#65292;&#24613;&#38656;&#28857;&#38065;&#26469;&#29609;&#12290;&#23545;&#20110;package &#26469;&#35828;&#65292;&#22522;&#26412;&#37117;&#26159;&#26631;&#20934; package&#65292;&#24320;&#22987;&#30340;&#26102;&#20505; F &#26368;&#22810;&#65292;&#21518;&#26469; G &#32473;&#21152;&#20102;&#19981;&#23569;&#65292;&#26368;&#32456;&#25298;&#32477;G &#30340;&#26102;&#20505;&#36824;&#35201;&#20877;&#32473;&#21152;&#65292;&#24863;&#35273; G &#24456;&#21916;&#27426;&#25250; F &#30340;&#20154;&#21834;&#65281;&#38065;&#22810;&#38065;&#23569;&#19981;&#22826;&#30475;&#37325;&#65292;&#21453;&#27491;&#20063;&#19981;&#20934;&#22791;&#38271;&#26399;&#20570;&#30721;&#20892;&#12290;&#33258;&#24049;&#24863;&#35273;&#30340; hiring bar &#30340;&#25490;&#24207;&#65306; facebook=linkedin&gt;google&gt;amazon, &#24403;&#28982;&#65292;&#38590;&#24230;&#26159;&#38543;&#30528;&#26102;&#38388;&#25913;&#21464;&#30340;&#65292;&#25307;&#20154;&#22810;&#30340;&#26102;&#20505;&#23481;&#26131;&#65292;&#19981;&#24590;&#20040;&#25307;&#20154;&#30340;&#26102;&#20505;&#23601;&#24456;&#38590;&#12290;</p>
<p>Facebook</p>
<p>&#31614;&#20102; offer&#65292;&#23601;&#19981;&#36879;&#38706;&#39064;&#20102;&#65292;&#24635;&#20043;&#24863;&#35273; facebook &#30340; bar &#26368;&#39640;&#65292;&#38754;&#35797;&#39064;&#30340;&#38590;&#24230;&#19981;&#21516;&#20154;&#24046;&#21035;&#24456;&#22823;&#65292;&#39064;&#30446;&#31616;&#21333;&#19981;&#19968;&#23450;&#23601;&#26377; offer&#65292;&#39064;&#30446;&#38590;&#20063;&#26410;&#24517;&#27809; offer&#65292;&#19981;&#22909;&#35828;&#12290;</p>
<pre><code>&#31532;&#19968;&#39064;&#65306;&#36138;&#24515;

    Given a number, can you remove k digits from the number so that the new
    formatted number is smallest possible.
    input: n = 1432219, k = 3
    output: 1219

&#31532;&#20108;&#39064;&#65306;DP

    BT(binary tree), want to find the LIS(largest independent set) of the BT
    LIS: if the current node is in the set, then its chilren should not be in
    the set. So that the set has the largest number of nodes.

&#30005;&#38754;2&#65306;

    &#31532;&#19968;&#39064;&#65306;Median of Two Sorted Arrays
    &#31532;&#20108;&#39064;&#65306;DP&#65292;&#19968;&#20010;&#20108;&#32500;&#25968;&#32452;&#65292;&#20803;&#32032;&#26159; 0 &#25110; 1&#65292;&#25214;&#20986;&#26368;&#22823;&#30340;&#30001; 1 &#26500;&#25104;&#30340;&quot;X&quot;&#24418;&#29366;

onsite:

1. print all subsets
   system design(N topics, publishers, subscribers, scalability, distributed)
   the most frequent urls in the past minute, hour, day
2. manager interview
   code review
3. shortest path between two nodes of a tree(no parent pointer)
4. machine learning(&#19981;&#25026;)
5. machine learning(&#19981;&#25026;)

Rocket Fuel&#26159;&#33258;&#24049;&#25237;&#30340;&#65292;&#22240;&#20026;&#22312;&#32593;&#19978;&#30475;&#21040;code challenge&#25402;&#26377;&#24847;&#24605;&#12290;onsite&#30340;&#26102;&#20505;&#20102;
&#35299;&#21040;&#20182;&#23478;&#26368;&#36817;&#35201;&#25644;&#36827;&#26032;&#27004;&#37324;&#65292;&#24212;&#35813;&#25307;&#20154;&#24456;&#22810;&#65292;&#22823;&#23478;&#21487;&#20197;&#35797;&#19968;&#35797;&#65292;&#39064;&#30446;&#19981;&#31616;&#21333;

Google:

&#30005;&#38754;&#65306;
remove duplicate lines of a file(what if the file is very large which could
not be held in the main memory)

&#24320;&#20851;&#28783;&#38382;&#39064;
Trapping Rain Water(leetcode)
sometimes a program works, sometimes it does not. Possible reasons

onsite:
1. clone directed graph(recursive, non-recursive)
   longest common suffix of two linked list
   data structure design
2. how many (m, n) pairs such that m*m+n*n&lt;N
   &#32447;&#32034;&#21270;&#20108;&#21449;&#26641;
3. &#21028;&#26029;&#19968;&#20010;&#28857;&#26159;&#21542;&#22312;&#19968;&#20010;&#20984;&#22810;&#36793;&#24418;&#20869;, O(n), O(logn)
4. group items(BFS)
   MapReduce(filter a collection of documents, the words which occur more
than 5000 times)

google &#38754;&#30340;&#19981;&#22909;&#65292;&#22240;&#20026;&#23454;&#22312;&#26159;&#22826;&#32047;&#20102;&#65292;&#24184;&#36816;&#30340;&#26159;&#36824;&#26159;&#32473; offer &#20102;&#12290;

linkedin

&#30005;&#38754; 1&#65306;

&#31532;&#19968;&#39064;&#65306;&#32473;&#19968;&#20010; words list, &#36755;&#20837;&#20004;&#20010;&#21333;&#35789;&#65292;&#25214;&#20986;&#36825;&#20004;&#20010;&#21333;&#35789;&#22312; list &#20013;&#30340;&#26368;&#36817;&#36317;&#31163; (&#20808;
&#20889;&#20102;&#19968;&#20010;&#27809;&#26377;&#39044;&#22788;&#29702;&#30340;&#65292;&#21448;&#20889;&#20102;&#19968;&#20010;&#39044;&#22788;&#29702;&#24314; index &#30340;)
[&#39;green&#39;, &#39;blue&#39;, &#39;orange&#39;, &#39;purple&#39;, &#39;green&#39;]  f.distance(list, &#39;blue&#39;, &#39; green&#39;) # output 1

&#31532;&#20108;&#39064;&#65306;&#31867;&#20284; binary search &#30340;&#19968;&#39064;&#65292;&#35201;&#27880;&#24847; boundary case

&#30005;&#38754;2&#65306;

binary tree level order traversal, &#20889;&#20102;&#19977;&#31181;&#26041;&#27861;&#12290;&#12290;&#12290;(BFS &#29992; arraylist&#65292;&#31867;&#20284; DFS&#65292;BFS &#29992; queue)

onsite:
1. romanToInt, intToRoman,
   N points, m nearst ones
2. &#21452;&#21521;&#38142;&#34920;&#65292;&#27599;&#20010;node&#21487;&#33021;&#37117;&#26377;&#29238;&#33410;&#28857;&#21644;&#23376;&#33410;&#28857;&#65292;&#27599;&#20010;&#29238;&#23376;&#33410;&#28857;&#21448;&#26159;&#19968;&#20010;&#38142;&#34920;&#12290;&#25226;&#23427;&#25293;&#25153;&#65292;&#39034;&#24207;&#38543;&#24847;&#65292;O(1)&#31354;&#38388;&#22797;&#26434;&#24230;
   edit distance
3. system deisign: design amazon product page
4. project presentation
5. group fit

LinkedIn &#24456;&#19981;&#38169;&#65292;&#39135;&#22530;&#24456;&#22909;&#21507;&#65292;&#24182;&#27809;&#26377;&#20256;&#35828;&#20013;&#30340;&#37027;&#20040;&#22810;&#21360;&#24230;&#20154;&#65292;&#22269;&#20154;&#25402;&#22810;&#30340;&#12290;&#21548; hr &#35828;
linkedin &#20170;&#24180;&#35201;&#25193;&#22823;&#25216;&#26415;&#22242;&#38431;&#65292;&#22823;&#23478;&#21487;&#20197;&#25237;&#19968;&#19979;</code></pre>
<p>&#25214;&#24037;&#20316;&#32463;&#39564;&#65306;</p>
<ul>
<li>&#19981;&#35201;&#25226;&#25112;&#32447;&#25289;&#30340;&#22826;&#38271;&#65292;2 &#20010;&#26376;&#26368;&#22909;&#65292;&#26102;&#38388;&#20037;&#20102;&#23601;&#27809;&#26377;&#28608;&#24773;&#20102;&#65292;&#25928;&#26524;&#21453;&#20498;&#19981;&#22909;&#12290;&#20934;&#22791;&#30340;&#26102;&#20505;&#35201;&#20840;&#21147;&#20197;&#36212;&#65292;concentration</li>
<li>&#23433;&#25490;&#38754;&#35797;&#26368;&#22909;&#19981;&#35201;&#25226;&#25152;&#26377;&#20844;&#21496;&#25918;&#22312;&#21516;&#19968;&#21608;&#65292;&#23454;&#22312;&#26159;&#22826;&#32047;&#20102;&#65292;&#26368;&#22909;&#26159;&#20004;&#20010; onsite &#20043;&#38388;&#38388;&#38548;&#20004;&#22825;</li>
<li>&#23545;&#20110;&#30007;&#29983;&#26469;&#35828;&#65292;&#20934;&#22791;&#38754;&#35797;&#26080;&#32842;&#30340;&#26102;&#20505;&#21487;&#20197;&#20570;&#20570;&#20463;&#21351;&#25745;&#21644;&#21367;&#33145;&#65292;&#21363;&#20351;&#25343;&#19981;&#21040; offer &#36824;&#33021;&#32451;&#20986;&#33016;&#32908;&#21644;&#33145;&#32908;~</li>
<li>CC150 &#38543;&#20415;&#30475;&#30475;&#23601;&#34892;&#20102;&#65292;leetcode &#35201;&#8220;&#22909;&#22909;&#8221;&#20570; (&#34701;&#20250;&#36143;&#36890;)&#65292;&#38754;&#35797;&#19968;&#23478;&#20844;&#21496;&#20043;&#21069;&#30475;&#30475;&#30456;&#24212;&#30340;&#38754;&#32463;&#65292;&#36275;&#22815;&#20102;</li>
<li>&#22914;&#26524;&#19981;&#26159;&#25630; acm &#30340;&#65292;leetcode &#33267;&#23569;&#35201;&#21047;&#19968;&#36941;&#20877;&#21435;&#38754; flag&#12290;&#21047;&#20960;&#36941;&#19981;&#20851;&#38190;&#65292;&#20851;&#38190;&#26159;&#35201;&#26377;&#25552;&#39640;</li>
<li>&#25552;&#39640;&#20004;&#26041;&#38754;&#65306;
<ol style="list-style-type: decimal">
<li>coding &#33021;&#21147;&#65306;&#20250;&#20570;&#30340;&#39064;&#33021;&#20889;&#20986; bug free&#65292;&#31616;&#27905;&#21487;&#35835;&#24615;&#22909;&#30340;&#20195;&#30721;</li>
<li>&#31639;&#27861;&#65292;&#35299;&#20915;&#38382;&#39064;&#30340;&#33021;&#21147;&#65306;&#27809;&#35265;&#36807;&#30340;&#39064;&#65292;&#19968;&#27493;&#19968;&#27493;&#24819;&#21040;&#38754;&#35797;&#23448;&#24819;&#35201;&#30340;&#26041;&#27861;</li>
</ol></li>
<li>coding &#33021;&#21147;&#65306;&#20889;&#30340;&#31243;&#24207;&#36234;&#30701;&#36234;&#22909;&#65292;&#24605;&#36335;&#28165;&#26970;&#65292;&#23481;&#26131;&#30475;&#25026;&#65307;&#21487;&#20197;&#20889;&#22810;&#20010;&#20989;&#25968;&#65292;&#21487;&#35835;&#24615;&#22909;&#24456;&#22810;&#65292;&#20889;&#36215;&#26469;&#20063;&#23481;&#26131;&#65307;&#20105;&#21462;&#19968;&#36941;&#20889;&#23436;&#23601; OK&#65292;&#19981;&#35201;&#25913;&#26469;&#25913;&#21435;&#65307;&#25105;&#24863;&#35273; coding &#33021;&#21147;&#30340;&#37325;&#35201;&#24615;&#34987;&#22823;&#23478;&#20005;&#37325;&#20302;&#20272;&#20102;&#65292;&#24456;&#22810;&#20154;&#21482;&#20851;&#24515;&#31639;&#27861;&#65292;&#20854;&#23454;&#33021;&#25226;&#31243;&#24207;&#20889;&#30340;&#24178;&#20928;&#28418;&#20142;&#25165;&#26159;&#26368;&#20851;&#38190;&#30340;&#12290;</li>
<li>&#31639;&#27861;&#65292;&#35299;&#20915;&#38382;&#39064;&#30340;&#33021;&#21147;&#65306;&#21363;&#20351;&#35265;&#36807;&#30340;&#39064;&#20063;&#35201;&#19968;&#28857;&#19968;&#28857;&#30340;&#20998;&#26512;&#65292;&#38754;&#35797;&#23448;&#30475;&#37325;&#30340;&#26159;&#20998;&#26512;&#21644;&#20132;&#27969;&#30340;&#36807;&#31243;&#65292;&#32780;&#19981;&#26159;&#26368;&#32456;&#30340; solution&#65307;&#19981;&#35201;&#21482;&#30693;&#36947;&#22810;&#20570;&#39064;&#65292;&#35201;&#22810;&#24605;&#32771;&#65292;&#36825;&#20010;&#21644;&#39640;&#32771;&#19968;&#26679;&#65292;&#32763;&#26469;&#35206;&#21435;&#23601;&#26159;&#20960;&#31181;&#31867;&#22411;&#30340;&#39064;&#65292;&#25353;&#29031;&#31867;&#22411;&#26469;&#20570;&#65292;&#24456;&#24555;&#23601;&#29087;&#32451;&#20102;</li>
<li>&#21644;&#38754;&#35797;&#23448;&#32842;&#30340;&#24320;&#24515;&#24456;&#20851;&#38190;&#65292;&#35201;&#34920;&#29616;&#20986;&#31215;&#26497;&#65292;&#20048;&#35266;&#65292;&#38451;&#20809;&#65292;&#28909;&#29233;&#29983;&#27963;&#65292;&#35753;&#38754;&#35797;&#23448; enjoy &#38754;&#35797;&#36807;&#31243;&#65292;&#21916;&#27426;&#21644;&#20320;&#19968;&#36215;&#24037;&#20316;</li>
<li>&#19981;&#35201;&#25265;&#24616;&#65292;&#19981;&#35201;&#32473;&#33258;&#24049;&#25214;&#20511;&#21475;</li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/794/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>Facebook onsite &#38754;&#32463; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#31532;&#19968;&#36718; <code class="fold">@</code></dt>
<dd><p>&#32769;&#21360;&#65292;&#19978;&#26469;&#19968;&#36947;&#39064;&#65292;&#35762;&#20102;&#21322;&#22825;&#25105;&#25165;&#24324;&#26126;&#30333;&#12290;&#31867;&#20284;&#25163;&#26426;&#25353;&#38190;&#65292;&#27604;&#22914;&#25163;&#26426;&#25353;&#38190;&#19978; 2 &#23545;&#24212; &#8216;abc&#8217;, &#28982;&#21518;&#26681;&#25454;&#8216;abc&#8217;&#30340;&#39034;&#24207;&#65292;&#25171;&#20986; a &#35201;&#25353;&#19968;&#19979;&#38190;&#65292;b &#35201;&#25353;&#20004;&#19979;&#38190;&#65292;c &#35201;&#25353;&#19977;&#19979;&#38190;&#12290;&#32473;&#20320;&#20004;&#20010;&#25968;&#32452;: <code>keySize[]</code> &#27599;&#20010; element &#20195;&#34920;&#33021;&#23384;&#25918;&#30340;&#26368;&#22810; character&#65292;<code>frequency[]</code> &#27599;&#20010; element &#20195;&#34920;&#27599;&#20010; character &#20986;&#29616;&#30340;&#39057;&#29575;&#12290;&#35201;&#31639;&#20986;&#26368;&#23569;&#30340;&#25353;&#38190;&#27425;&#25968;&#12290;</p>
<p>Follow up 1: &#24590;&#20040;&#33021;&#25552;&#39640;&#25928;&#29575;&#12290;</p>
<p>Follup up 2: &#22914;&#26524;&#35201;&#27714; character &#25918;&#22312;&#25353;&#38190;&#19978;&#30340;&#39034;&#24207;&#26159; order &#30340;&#65292;&#31867;&#20284;&#20110;&#25163;&#26426; shang &#30340;&#23383;&#27597;&#25353;&#38190;&#65292;&#36825;&#26679;&#26368;&#23569;&#25353;&#38190;&#27425;&#25968;&#26159;&#22810;&#23569;&#12290;</p>
</dd>
<dt>&#31532;&#20108;&#36718; <code class="fold">@</code></dt>
<dd><p>&#36824;&#26159;&#20010;&#28889;&#21360;&#65306; &#31532;&#19968;&#39064;&#65306;rotated sorted array search. &#35753;&#21518;&#35201;&#27714; cut branch&#12290; &#31532;&#20108;&#39064;&#65306; sort an array contains only 3 element&#65292;&#31867;&#20284; leetcode &#30340; sort colors&#12290; follow up: what if there are N element? &#27809;&#24819;&#20986;&#26469;&#65292; hint &#26159;&#21487;&#20197;&#20351;&#29992; extra memery&#12290;</p>
</dd>
<dt>&#31532;&#19977;&#36718; <code class="fold">@</code></dt>
<dd><p>&#31616;&#21382;&#38382;&#39064;&#20026;&#20027;&#65292;&#38382;&#20102;&#19968;&#36947; code&#65306; check the first bad version.</p>
<p>&#32467;&#26524;&#36824;&#26159;&#36330;&#20102;&#12290;&#38382;&#39064;&#24212;&#35813;&#20986;&#22312;&#31532;&#19968;&#36718;&#38754;&#35797;&#19978;&#65292;code &#20889;&#20102;&#22909;&#20037;&#25165;&#20889;&#20986;&#26469;&#65292;follow up &#20063;&#27809;&#31572;&#19978;&#12290;&#20854;&#23454;&#39064;&#30446;&#20063;&#19981;&#31639;&#24456;&#38590;&#65292;&#22823;&#23478;&#22909;&#36816;&#21543;&#12290;</p>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/760/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>&#24494;&#36719; ots&#65292;&#24050;&#25346;&#65292;&#27714;&#20998;&#26512;&#19968;&#36947;&#39064; <code class="fold">@</code></dt>
<dd><p>&#26368;&#36817;&#20570;&#24494;&#36719;&#30340; OTS&#65292;&#19968;&#20849;&#19977;&#36947;&#39064;&#12290;</p>
<ol style="list-style-type: decimal">
<li>&#32473;&#20320;&#19968;&#20010;&#26102;&#38047;&#65292;&#36820;&#22238;&#19968;&#20010; palindrome &#30340;&#26102;&#38388;&#12290;&#27604;&#22914; 1:01&#65292;12:21</li>
<li>&#25490;&#24207; 2d &#25968;&#21015;&#65292;&#36820;&#22238;&#36127;&#25968;&#30340;&#25968;&#37327;&#12290;</li>
<li>&#30896;&#21040;&#19968;&#39064;&#31639;&#26159;&#31995;&#32479;&#35774;&#35745;&#39064;&#21543;&#12290;&#21482;&#26377;&#20004;&#19977;&#21477;&#35805;&#65306;&#29992;&#29087;&#24713;&#30340;&#35821;&#35328;&#20889;&#19968;&#20010; email &#30340; api &#26381;&#21153;&#12290;&#20889;&#20986;&#23454;&#29616;&#30340;&#22330;&#26223;&#20197;&#21450;&#38656;&#35201;&#29992;&#21040;&#21738;&#20123;&#21442;&#25968;&#12290;</li>
</ol>
<p>&#24050;&#25346;&#65292;&#20272;&#35745;&#26159;&#25346;&#22312;&#31532;&#19977;&#39064;&#12290;&#21069;&#20004;&#39064;&#37117;&#20570;&#36807;&#24046;&#19981;&#22810;&#30340;&#12290;&#31532;&#19977;&#39064;&#19981;&#26159;&#24456;&#25026;&#39064;&#30446;&#35201;&#25105;&#20570;&#20160;&#20040;&#65292;&#22240;&#20026;&#26159;&#22312;&#32447;&#38754;&#35797;&#65292;&#27809;&#27861;&#21644;&#38754;&#35797;&#23448;&#20132;&#27969;&#12290;&#19981;&#26159;&#24456;&#28165;&#26970;&#38656;&#35201;&#20889;&#20160;&#20040;&#12290;&#12290;&#12290;&#27714;&#22823;&#23478;&#19968;&#36215;&#35752;&#35770;&#19979;&#12290;&#25105;&#29992;java&#20889;&#20102;&#20010;&#20960;&#20010;&#25509;&#21475;&#12290;&#28982;&#21518;&#20170;&#22825;&#25509;&#21040;&#36890;&#30693;&#38754;&#35797;&#25346;&#20102;&#12290;&#19981;&#26159;&#24456;&#28165;&#26970;&#24212;&#35813;&#24590;&#20040;&#20570;&#36825;&#31181;&#39064;&#12290;&#25105;&#24403;&#26102;&#20195;&#30721;&#22823;&#27010;&#22914;&#19979;</p>
<p>&#27604;&#22914; &#25105;&#23454;&#29616;&#20102; get email &#30340; api&#65292;&#20294;&#19981;&#30693;&#36947;&#20855;&#20307; api &#37324;&#38754;&#35813;&#20889;&#20123;&#20160;&#20040;&#12290;&#38656;&#35201;&#36830;&#25968;&#25454;&#24211;&#36824;&#26159;&#21861;&#30340;&#65311;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> user {
    <span class="dt">int</span> userID;
    String userName;
}

<span class="kw">class</span> email {
    <span class="dt">int</span> emailID;
    String emailAddress;
    String subject;
    Date timestamp;
    String content;
    <span class="dt">int</span> from_userID;
    <span class="dt">int</span> to_userID;
}

<span class="kw">public</span> List getEmail (<span class="dt">int</span> userID) {
    <span class="kw">return</span> db.getEmail(userID)
}

<span class="kw">public</span> List getEmail (<span class="dt">int</span> userID, Date startDate, Date endDate) {
    <span class="kw">return</span> db.getEmail(userID, startDate, endDate);
}

<span class="kw">public</span> List getEmail (<span class="dt">int</span> userID, <span class="dt">int</span> getEmailNum) {
    <span class="kw">return</span> db.getEmail(userID, getEmailNum);
}</code></pre></div>
<p>&#33258;&#24049;&#30475;&#30528;&#24863;&#35273;&#37117;&#19981;&#24590;&#20040;&#31526;&#21512;&#35201;&#27714;&#12290;&#33021;&#26377;&#20154;&#25351;&#28857;&#19968;&#19979;&#27491;&#30830;&#20889;&#27861;&#25913;&#22914;&#20309;&#20889;&#21527;&#65311;&#35874;&#35874;&#20102;&#65281;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/1861/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>&#31532;&#19968;&#22530;&#35838; Design Twitter <code class="fold">@</code></dt>
<dd><p>&#23384;&#22312; NoSQL DB &#30340; Tweet &#26159;&#27599;&#19968;&#20010; Tweet &#23545;&#24212;&#19968;&#34892;&#21527;&#65292;&#36824;&#26159;&#27599;&#20010;&#29992;&#25143;&#23545;&#24212;&#19968;&#34892;&#65311;&#36825;&#26679;&#30340;&#35805; row key &#26159;&#20160;&#20040;&#21602;&#65311;&#26159; user_id&#65311;&#22914;&#26524;&#26159;&#65292;&#28982;&#21518; column key &#26159; tweet id&#65292;&#22240;&#32780;&#21487;&#20197;&#25903;&#25345;&#33539;&#22260;&#26597;&#25214;&#65311;&#22914;&#26524;&#26159;&#33539;&#22260;&#26597;&#25214;&#30340;&#35805;&#65292;timeline &#30340;&#35831;&#27714;&#20026;&#20160;&#20040;&#38656;&#35201; n &#27425;&#30340; DB &#35775;&#38382;&#26102;&#38388;&#65288;mentioned in p41 in the slides&#65289;&#65311;</p>
<p>&#27599;&#20010;&#29992;&#25143;&#19968;&#34892;&#65292;&#28982;&#21518;&#26377;&#26080;&#38480;&#21015;&#12290;</p>
<pre><code>row_key = user_id
column_key &#21487;&#20197;&#26159;tweet_id&#65292;&#20063;&#21487;&#20197;&#26159;&#19968;&#22534;&#25968;&#25454;&#30340;&#32452;&#21512;&#65292;&#27604;&#22914;tweet_id + timestamp&#12290;
column_key &#21487;&#20197;&#25903;&#25345;&#33539;&#22260;&#26597;&#25214;&#12290;</code></pre>
<p>P41 &#36825;&#37324;&#35828;&#30340;&#26159;&#65292;&#24403;&#20320;&#38656;&#35201;&#26500;&#24314;&#19968;&#20010; NewsFeed &#30340;&#26102;&#20505;&#65288;&#20320;&#20851;&#27880;&#30340; N &#20010;&#22909;&#21451;&#30340;&#25152;&#26377;&#26032;&#40092;&#20107;&#27719;&#24635;&#65289;&#65292;&#38656;&#35201; N &#27425; DB &#35831;&#27714;&#21435;&#20998;&#21035;&#35831;&#27714;&#27599;&#20010;&#22909;&#21451;&#30340;&#26368;&#36817; 100 &#26465; tweets &#28982;&#21518;&#20877;&#24402;&#24182;&#21040;&#19968;&#36215;&#12290;&#35831;&#27714;&#26576;&#19968;&#20010;&#29992;&#25143;&#30340; timeline &#26159;&#19968;&#27425; Query&#65292;&#35831;&#27714; N &#20010;&#29992;&#25143;&#65292;&#23601;&#26159; N &#27425;&#12290;&#36825;&#37324;&#30340; N &#35828;&#30340;&#26159;&#20320;&#30340;&#22909;&#21451;&#20010;&#25968;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/1914/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>&#24212;&#23626;&#29983;&#22269;&#20869;&#25214;&#22269;&#22806;&#24037;&#20316;&#27714;&#32844;&#32593;&#31449;&#26377;&#21738;&#20123; <code class="fold">@</code></dt>
<dd><p>&#25105;&#26159;&#19968;&#21517;&#22269;&#20869;&#30340;&#24212;&#23626;&#30805;&#22763;&#27605;&#19994;&#29983;&#65292;&#20061;&#26376;&#35201;&#24320;&#22987;&#25237;&#31616;&#21382;&#20102;&#12290;&#38382;&#19968;&#19979;&#65292;&#24819;&#30452;&#25509;&#25214;&#22269;&#22806;&#24037;&#20316;&#30340;&#35805;&#65292;&#26377;&#21738;&#20123;&#22909;&#30340;&#32593;&#31449;&#21487;&#20197;&#25512;&#33616;&#65311;&#30446;&#21069;&#21482;&#30475;&#21040;&#20102; google &#26377;&#27491;&#24335;&#30340;&#20840;&#29699;&#25307;&#32856;&#36884;&#24452;&#65292;&#20854;&#23427;&#20844;&#21496;&#30340;&#22914;&#20309;&#33021;&#30475;&#21040;&#65311;linkedin &#31561;&#19978;&#38754;&#30340;&#32844;&#20301;&#26159;&#19981;&#26159;&#37117;&#26159;&#38024;&#23545;&#26377;&#22312;&#32654;&#22269;&#24037;&#20316;&#36164;&#26684;&#30340;&#25165;&#33021;&#30003;&#35831;&#65311;</p>
<p><a href="http://stackoverflow.com/jobs?med=site-ui&amp;ref=jobs-tab" class="uri">http://stackoverflow.com/jobs?med=site-ui&amp;ref=jobs-tab</a></p>
<p>&#35874;&#35874;&#21862;&#65292;&#35831;&#38382; VISA SPONSOR &#26159;&#19981;&#26159;&#25351;&#21487;&#20197;&#25552;&#20379;&#25277;&#31614;&#35777;&#30340;&#26426;&#20250;&#65311;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/1945/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>yahoo &#38754;&#35797;&#32463;&#39564; <code class="fold">@</code></dt>
<dd><p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/778/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>&#33150;&#35759;&#38754;&#32463;&#65292;&#25343;&#21040; offer <code class="fold">@</code></dt>
<dd><p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/733/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>&#19996;&#37034;&#32769;&#24072;&#31532;&#20108;&#33410;&#35838; Friendship &#30456;&#20851;&#30340;&#38382;&#39064; <code class="fold">@</code></dt>
<dd><p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/1878/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>&#21097;&#19979;&#19981;&#21040;&#19968;&#20491;&#26376;&#26178;&#38291; interview &#35531;&#21839;&#24590;&#40636;&#28310;&#20633;? <code class="fold">@</code></dt>
<dd><p>&#24050;&#32147;&#21047;&#38988;&#19968;&#38499;&#23376;. &#20294;&#26159;&#19968;&#20123;&#27604;&#36611;&#38627;&#30340;&#21644; graph, DP &#37117;&#36996;&#19981;&#34892;, &#26377;&#20160;&#40636;&#22909;&#24314;&#35696;?</p>
<p>&#37027;&#23601;&#19981;&#35201;&#30475; Graph &#21644; DP &#36825;&#31867;&#32771;&#24471;&#24456;&#23569;&#30340;&#38382;&#39064;&#12290;&#22810;&#30475; DFS / BFS &#36825;&#31867;&#38382;&#39064;&#12290;</p>
</dd>
<dt>Uber &#38754;&#35797;&#39064; &#25151;&#23627;&#31363;&#36156; House Robber II &#9829;&#65039; <code class="fold">@</code></dt>
<dd><p>&#23567;&#20599;&#25214;&#21040;&#20102;&#19968;&#20010;&#26032;&#30340;&#20599;&#30423;&#22320;&#28857;&#65292;&#36825;&#20010;&#22320;&#21306;&#30340;&#25151;&#23376;&#32452;&#25104;&#20102;&#19968;&#20010;&#29615;&#65292;&#22914;&#26524;&#23567;&#20599;&#21516;&#26102;&#20599;&#31363;&#20102;&#20004;&#20010;&#30452;&#25509;&#30456;&#37051;&#30340;&#25151;&#23376;&#65292;&#23601;&#20250;&#35302;&#21457;&#35686;&#25253;&#22120;&#12290;&#22312;&#19981;&#35302;&#21457;&#35686;&#25253;&#22120;&#30340;&#24773;&#20917;&#19979;&#65292;&#27714;&#23567;&#20599;&#21487;&#20197;&#25250;&#21040;&#30340;&#26368;&#22810;&#30340; money&#12290;</p>
<dl>
<dt>&#35299;&#39064;&#24605;&#36335;</dt>
<dd><p>&#26412;&#39064;&#26159; House Robber &#30340; follow up&#12290;</p>
<p>House Robber-i &#20013;&#25151;&#23376;&#25490;&#21015;&#25104;&#19968;&#20010;&#24207;&#21015;&#65292;&#29992;&#21160;&#24577;&#35268;&#21010;&#23601;&#21487;&#20197;&#65292;&#19978;&#36807;&#12298;&#20061;&#31456;&#31639;&#27861;&#24378;&#21270;&#29677;&#12299;&#30340;&#21516;&#23398;&#24212;&#35813;&#37117;&#24050;&#32463;&#20250;&#20570;&#21862;&#12290;</p>
<p>&#25353;&#29031;&#35838;&#22530;&#19978;&#35762;&#36807;&#30340;&#21160;&#24577;&#35268;&#21010;&#22235;&#35201;&#32032;&#35828;&#35828; dp &#29366;&#24577;&#30340;&#23450;&#20041;&#65306;</p>
<ul>
<li>df[i] &#34920;&#31034;&#21069; i &#20010;&#25151;&#23376;&#33021;&#33719;&#24471;&#30340;&#26368;&#22823;&#20215;&#20540;&#65292;</li>
<li>dp[i] = max(dp[i-2] + nums[i], dp[i-1])&#12290;</li>
</ul>
<p>&#32780;&#22312;&#26412;&#39064;&#20013;&#65292;&#25151;&#23376;&#38590;&#28857;&#22312;&#20110;&#25490;&#21015;&#25104;&#19968;&#20010;&#29615;&#12290;&#23545;&#20110;&#29615;&#19978;&#30340;&#38382;&#39064;&#65292;&#26377;&#19968;&#20010;&#23567;&#25216;&#24039;&#23601;&#26159;&#23601;&#26159;&#25286;&#29615;&#65306;<strong>&#25226;&#29615;&#23637;&#25104;&#19968;&#26465;&#30452;&#32447;</strong>&#12290;</p>
<p>&#26412;&#39064;&#20013;&#65292;&#21487;&#20197;&#20808;&#20551;&#35774;&#25151;&#23376;&#25490;&#25104;&#19968;&#26465;&#30452;&#32447;&#65292;&#20174; 0 &#21040; n-1&#65292;&#37027;&#20040;&#25105;&#20204;&#22914;&#26524;&#29992;&#21407;&#26469;&#30340;&#21160;&#24577;&#35268;&#21010;&#31639;&#27861;&#27714;&#24471;&#30340;&#26368;&#20248;&#35299;&#21487;&#33021;&#21516;&#26102;&#21462;&#21040;&#25151;&#23376; 0 &#21644;&#25151;&#23376; n-1&#65292;&#32780;&#22240;&#20026; 0 &#21644; n-1 &#22312;&#26412;&#39064;&#20013;&#26159;&#36830;&#22312;&#19968;&#36215;&#30340;&#65292;&#19981;&#33021;&#21516;&#26102;&#21462;&#21040;&#12290;&#20063;&#23601;&#26159;&#35828;&#65292;&#25105;&#20204;&#35201;&#20998;&#20004;&#31181;&#24773;&#20917;&#65306;&#35201;&#20040;&#19981;&#20599;&#25151;&#23376; 0&#65288;&#27492;&#26102;&#25151;&#23376; n-1 &#26159;&#21542;&#20599;&#26410;&#30693;&#65289;&#65292;&#35201;&#20040;&#19981;&#20599;&#25151;&#23376; n-1&#12290;&#22522;&#20110;&#36825;&#20004;&#31181;&#24773;&#20917;&#65292;&#25105;&#20204;&#23545;&#19981;&#21547;&#25151;&#23376; 0 &#30340;&#24207;&#21015;&#20570;&#19968;&#27425;&#21160;&#24577;&#35268;&#21010;&#65292;&#23545;&#19981;&#21547;&#25151;&#23376; n-1 &#30340;&#24207;&#21015;&#20570;&#19968;&#27425;&#21160;&#24577;&#35268;&#21010;&#65292;&#21462;&#36739;&#22823;&#20540;&#23601;&#21487;&#12290;</p>
<p>&#21442;&#32771;&#31243;&#24207; <a href="http://www.jiuzhang.com/solutions/house-robber-ii/" class="uri">http://www.jiuzhang.com/solutions/house-robber-ii/</a></p>
<p>&#38754;&#35797;&#23448;&#35282;&#24230;&#20998;&#26512;&#65306;&#26412;&#39064;&#26159;&#19968;&#20010; follow up&#65292;&#22312;&#35299;&#20915; robber-i &#30340;&#24773;&#20917;&#19979;&#65292;&#23545;&#20110;&#29615;&#30340;&#29305;&#27530;&#24615;&#32473;&#20986;&#35299;&#20915;&#26041;&#27861;&#65292;&#23454;&#29616; O(n) &#31639;&#27861;&#21487;&#20197;&#36798;&#21040; hire&#12290;</p>
<p>LC &#30456;&#20851;&#32852;&#31995;&#39064;&#65306;https://lintcode.com/problems/house-robber/</p>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/1767/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>&#24590;&#20040;&#20934;&#22791;&#22810;&#32447;&#31243;&#30340;&#38382;&#39064; <code class="fold">@</code></dt>
<dd><p>&#26368;&#36817;&#22909;&#22810;&#26379;&#21451;&#38754;&#35797;&#37117;&#34987;&#38382;&#21040;&#20102;&#32447;&#31243;&#30340;&#38382;&#39064;&#65292;&#27604;&#22914;&#35753;&#20320;&#20889;&#19968;&#20010;&#27604;&#36739;&#31616;&#21333;&#30340;&#23383;&#31526;&#20018;&#22788;&#29702;&#30340;&#31243;&#24207;&#65292;&#21487;&#33021;&#28041;&#21450;&#21040;&#21704;&#24076;&#34920;&#20043;&#31867;&#30340;&#65292;&#28982;&#21518;&#32039;&#25509;&#30528;&#38382;&#20320;&#22914;&#26524;&#22810;&#32447;&#31243;&#24590;&#20040;&#23454;&#29616;&#65311;&#25110;&#32773;&#38382;&#20320;&#32447;&#31243;&#22914;&#20309;&#25165;&#33021;&#23433;&#20840;&#12290;</p>
<p>&#22240;&#20026;&#20851;&#20110;&#32447;&#31243;&#21482;&#20102;&#35299;&#29983;&#20135;&#32773;&#28040;&#36153;&#32773;&#65292;&#24179;&#26102;&#24037;&#20316;&#20013;&#29992;&#30340;&#20063;&#19981;&#22810;&#65292;&#35831;&#38382;&#26377;&#20851;&#20110;&#26368;&#36817;&#39057;&#32321;&#20986;&#29616;&#30340;&#22810;&#32447;&#31243;&#38382;&#39064;&#24212;&#35813;&#24590;&#20040;&#20934;&#22791;&#65311;&#26377;&#20160;&#20040;&#26448;&#26009;&#25110;&#32773;&#25512;&#33616;&#20040;&#65311;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/1280/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>&#24494;&#36719;&#38754;&#32463; <code class="fold">@</code></dt>
<dd><p>&#36825;&#23478;&#38754;&#35797;&#36718;&#25968;&#36739;&#22810;&#65292;&#20174;&#23398;&#26657;&#24320;&#22987;&#65292;&#38754;&#20102;&#24456;&#22810;&#32463;&#20856;&#38382;&#39064;&#12290;&#25968;&#32452;&#37324;&#25214;&#26368;&#22823;&#21644;&#30340;&#24207;&#21015;&#65292;&#20309;&#26102;&#20080;&#21334;&#32929;&#31080;&#65292;&#20004;&#20010;&#38142;&#34920;&#26159;&#21542;&#26377;&#20844;&#20849; Node&#65292;&#20108;&#20998;&#26597;&#25214;&#65288;&#25968;&#32452;&#24456;&#22823;&#65292;&#20320;&#38656;&#35201;&#32771;&#34385; sort &#25104;&#26412;&#65292;&#20160;&#20040;&#26102;&#20505; sort &#25165;&#26377;&#24847;&#20041;&#65292; &#27604;&#22914;&#20320; query &#30340;&#27425;&#25968;&#24456;&#22810;&#24456;&#22810;&#65292;&#37027;&#20040;&#19968;&#27425;&#24615;sort &#19968;&#19979;&#26159;&#26377;&#24517;&#35201;&#30340;&#65289;&#65292;&#20108;&#20301;&#24050;&#25490;&#24207;&#30697;&#38453;&#20013;&#22914;&#20309;&#24555;&#36895;&#26597;&#25214;&#19968;&#20010;&#25968;&#65292;&#35745;&#31639;&#27888;&#21202;&#23637;&#24320;&#65292;&#35745;&#31639; <code>N*M</code> &#30697;&#38453;&#30340;&#25152;&#26377;&#23376;&#30697;&#38453;&#12290;&#24494;&#36719;&#24456;&#27880;&#37325;&#20889;&#23436; code &#20197;&#21518;&#27979;&#35797;&#65292;&#19968;&#23450;&#35201;&#30041;&#20123;&#26102;&#38388;&#32473;&#27979;&#35797;&#65292;&#19968;&#33324;&#26469;&#35828;&#30333;&#26495;&#19978;&#20889;&#30340; code &#23567;&#27611;&#30149;&#37117;&#20250;&#26377;&#22909;&#20960;&#22788;&#65292;&#36890;&#36807;&#33258;&#24049;&#27979;&#35797;&#26159;&#21487;&#20197;&#25913;&#36807;&#26469;&#30340;&#12290;</p>
<p>&#19968;&#20123;&#25805;&#20316;&#31995;&#32479;&#21407;&#29702;&#65292;&#25105;&#19981;&#20250;&#65292;&#36873;&#25321;&#19981;&#20316;&#31572;&#65292;&#24863;&#35273;&#27809;&#29978;&#24433;&#21709;&#12290;</p>
<p>&#25105;&#22240;&#20026;&#38271;&#26102;&#38388;&#19981;&#29992; C++&#65292;&#21487;&#20197;&#35828;&#30446;&#21069;&#24050;&#32463;&#19981;&#20250; C++&#65292;&#21482;&#20250; JAVA&#65292;&#36215;&#21021;&#24456;&#34394;&#65292;&#20294;&#26159;&#21518;&#26469;&#24494;&#36719;&#23545;&#19981;&#32534;&#31243;&#35821;&#35328;&#35201;&#27714;&#24456;&#26494;&#65292;&#37325;&#35201;&#30340;&#26159;&#35299;&#37322;&#38382;&#39064;&#35201;&#35299;&#37322;&#24471;&#24456;&#28165;&#26970;&#12290;&#25152;&#26377;&#38754;&#35797;&#23448;&#37117;&#24605;&#36335;&#24456;&#28165;&#26224;&#65292;&#12304;&#20320;&#35299;&#37322;&#19981;&#28165;&#26970;&#65292;&#20182;&#20250;&#30452;&#25509;&#25171;&#26029;&#20320;&#65292;&#19981;&#35201;&#24819;&#30528;&#31946;&#24324;&#12305;&#12290;&#22914;&#26524;&#19981;&#28165;&#26970;&#65292;&#30452;&#25509;&#25215;&#35748;&#65292;&#36825;&#26159;&#25105;&#20174;&#24050;&#32463;&#25343;&#21040;&#20840;&#32844;&#30340;&#26379;&#21451;&#37027;&#20799;&#21548;&#26469;&#30340;&#32463;&#39564;&#65292;&#31639;&#26159;&#24494;&#36719;&#30340;&#39118;&#26684;&#21543;&#12290;</p>
<p>&#12304;&#26102;&#38388;&#22797;&#26434;&#24230;&#65292;&#24403;&#28982;&#65292;&#27599;&#19968;&#27493;&#25805;&#20316;&#37117;&#20250;&#38382;&#20320;&#26102;&#38388;&#22797;&#26434;&#24230;&#12305;&#65292;&#36867;&#19981;&#25481;&#30340;&#12290;&#23545;&#21704;&#24076;&#34920;&#65292;&#26377;&#19968;&#20010;&#38754;&#35797;&#23448;&#34920;&#29616;&#20986;&#26126;&#26174;&#30340;&#19981;&#21916;&#27426;&#65292;&#36825;&#26102;&#20505;&#25105;&#25442;&#24605;&#36335;&#20102;&#65292;&#34429;&#28982;&#37027;&#36947;&#39064;&#30446;&#21704;&#24076;&#34920;&#20570;&#24456;&#23481;&#26131;&#65292;&#20294;&#26159;&#27809;&#21150;&#27861;&#65292;&#20154;&#23478;&#26159;&#38754;&#35797;&#23448;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/796/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>&#38754;&#35797;&#26102;&#22914;&#20309;&#26377;&#26465;&#29702;&#30340;&#32452;&#32455; test case &#21834; <code class="fold">@</code></dt>
<dd><p>Test case &#26377;&#20197;&#19979;&#20960;&#31181;</p>
<ol style="list-style-type: decimal">
<li>&#36793;&#30028;&#25968;&#25454;&#65292;&#27604;&#22914; n = 0 &#36825;&#20123;&#36793;&#30028;&#24773;&#20917;</li>
<li>&#29305;&#27530;&#25968;&#25454;&#65292;&#27604;&#22914;&#38142;&#34920;&#20013;&#25105;&#20204;&#21024;&#33410;&#28857;&#38656;&#35201;&#21024;&#38500; head &#30340;&#26102;&#20505;</li>
<li>&#22823;&#25968;&#25454;&#65292;&#19968;&#33324;&#27979;&#35797;&#31639;&#27861;&#25928;&#29575;</li>
</ol>
<p>&#38754;&#35797;&#30340;&#26102;&#20505;&#65292;&#25105;&#20204;&#21482;&#38656;&#35201;&#32473;&#20986;&#36793;&#30028;&#25968;&#25454;&#65292;&#29305;&#27530;&#25968;&#25454;&#65292;&#21644;&#19968;&#20123;&#26222;&#36890;&#25968;&#25454;&#21363;&#21487;&#12290;</p>
</dd>
<dt>&#35910;&#29923;&#38754;&#35797;&#39064; :&#20998;&#27573;&#31570;&#25490;: <code class="fold">@</code></dt>
<dd><p>&#32473;&#23450; 10G &#20010;&#26080;&#31526;&#21495;&#25972;&#25968; (32 &#20301;)&#65292;&#22914;&#20309;&#33021;&#22815;&#26368;&#24555;&#22320;&#22312;&#19968;&#21488;&#20869;&#23384;&#20026; 2G &#30340;&#26426;&#22120;&#19978;&#25214;&#21040;&#36825;&#20123;&#25968;&#25454;&#20013;&#30340;&#20013;&#20301;&#25968; (&#27604;&#19968;&#21322;&#25968;&#25454;&#22823;&#65292;&#27604;&#21478;&#19968;&#21322;&#25968;&#25454;&#23567;)&#65292;&#36825;&#20010;&#24863;&#35273;&#20284;&#26366;&#30456;&#35782;&#65292;&#21448;&#24819;&#19981;&#20986;&#26159;&#21738;&#20010;&#26041;&#38754;&#30340;&#30693;&#35782;, &#21161;&#25945;&#32769;&#24072;&#33021;&#21542;&#35299;&#31572;&#19979;&#65311;</p>
<p>&#36825;&#20010;&#26159;&#21476;&#33891;&#30340;&#19981;&#33021;&#22312;&#21476;&#33891;&#30340;&#39064;&#30446;&#20102;&#12290;&#24120;&#29992;&#20570;&#27861;&#23601;&#26159;&#12304;&#20998;&#27573;&#26742;&#25490;&#12305;</p>
<p>&#26356;&#35814;&#32454;&#30340;&#21487;&#20197;&#30475;&#36825;&#20010;&#25991;&#31456;&#65292;&#25105;&#23601;&#19981;&#22797;&#21046;&#36807;&#26469;&#20102;&#12290;</p>
<p><a href="http://www.cnblogs.com/avril/archive/2012/04/20/2460805.html" class="uri">http://www.cnblogs.com/avril/archive/2012/04/20/2460805.html</a></p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.cnblogs.com/avril/archive/2012/04/20/2460805.html">10G &#20010;&#25972;&#25968;&#25214;&#20986;&#20013;&#20301;&#25968;&#65292;&#20869;&#23384;&#38480;&#21046;&#20026; 2G - Avril - &#21338;&#23458;&#22253;</a></li>
</ul>
</dd>
<dt>leetcode &#38754;&#35797;&#39064; 38 &#27927;&#29260;&#30340;&#25216;&#24039; <code class="fold">@</code></dt>
<dd><p>&#26377;&#19968;&#21103;&#25169;&#20811;&#26377; 2n &#24352;&#29260;&#65292;&#29992; <code>1,2,..2*n</code> &#20195;&#34920;&#27599;&#19968;&#24352;&#29260;&#65292;&#19968;&#27425;&#27927;&#29260;&#20250;&#25226;&#29260;&#20998;&#25104;&#20004;&#22534;&#65292; 1,2..n &#21644; n+1&#8230;2n&#12290;&#28982;&#21518;&#20877;&#20132;&#21449;&#30340;&#27927;&#22312;&#19968;&#36215;&#65306;n+1, 1, n+2, 2, &#8230; n, 2n&#12290;&#38382;&#25353;&#29031;&#36825;&#31181;&#25216;&#24039;&#27927;&#29260;&#65292;&#27927;&#22810;&#23569;&#27425;&#33021;&#22815;&#27927;&#22238;&#25169;&#20811;&#26368;&#21021;&#30340;&#29366;&#24577;&#65306;1,2,&#8230;2n&#12290;</p>
<p>&#20197; 1 2 3 4 5 6 &#20026;&#20363;&#65292;&#27927;&#19968;&#27425;&#20043;&#21518;&#20026; 4 1 5 2 6 3 &#12290;&#23558;&#20004;&#25490;&#25968;&#32452;&#23545;&#27604;&#30475;&#65306;</p>
<p>1 2 3 4 5 6 4 1 5 2 6 3</p>
<p>&#25968;&#23383; 1 &#30340;&#19979;&#38754;&#26159; 4&#65292;&#20195;&#34920;&#27599;&#19968;&#27425;&#27927;&#29260;&#21518; 1 &#36825;&#20010;&#20301;&#32622;&#30340;&#25968;&#20250;&#34987; 4 &#36825;&#20010;&#20301;&#32622;&#30340;&#25968;&#26367;&#20195;&#65292;&#25509;&#30528;&#30475;&#25968;&#23383; 4&#65292;4 &#19979;&#38754;&#26159; 2&#65292;&#20195;&#34920;&#27599;&#19968;&#27425;&#27927;&#29260;&#21518; 4 &#36825;&#20010;&#20301;&#32622;&#30340;&#25968;&#20250;&#34987; 2 &#26367;&#20195;&#65292;&#20877;&#30475; 2&#65292;2 &#19979;&#38754;&#26159; 1&#65292;2 &#36825;&#20010;&#20301;&#32622;&#30340;&#25968;&#23383;&#20250;&#34987; 1 &#26367;&#20195;&#12290;&#27492;&#26102;&#65292;1 4 2 &#24418;&#25104;&#19968;&#20010;&#29615;&#65292;&#20195;&#34920;&#36825;&#19977;&#20010;&#20301;&#32622;&#19978;&#30340;&#25968;&#20877;&#27599;&#19968;&#27425;&#27927;&#29260;&#21518;&#65292;&#24490;&#29615;&#20132;&#26367;&#65292;&#24182;&#19988;&#22312;&#27927; 3 &#27425;&#20197;&#21518;&#65292;&#21508;&#33258;&#22238;&#21040;&#26368;&#21021;&#30340;&#20301;&#32622;&#12290;&#29992;&#21516;&#26679;&#30340;&#26041;&#27861;&#21487;&#20197;&#25214;&#21040; 3 5 6 &#26159;&#19968;&#20010;&#24490;&#29615;&#65292;&#24490;&#29615;&#33410;&#38271;&#24230;&#20026; 3&#12290;&#30001;&#27492;&#21487;&#20197;&#30693;&#36947;&#65292;&#22312;&#32463;&#36807;&#20102; LCM(3,3)=3 &#27425;&#27927;&#29260;&#21518;&#65292;&#25152;&#26377;&#25968;&#37117;&#22238;&#21040;&#21407;&#20301;&#65292;&#36825;&#37324; LCM &#26159;&#26368;&#23567;&#20844;&#20493;&#25968;&#30340;&#24847;&#24605;&#12290;&#20110;&#26159;&#31639;&#27861;&#20026;&#65292;&#26681;&#25454;&#19968;&#27425;&#27927;&#29260;&#30340;&#32467;&#26524;&#65292;&#25214;&#21040;&#25152;&#26377;&#30340;&#24490;&#29615;&#33410;&#65292;&#31572;&#26696;&#20026;&#25152;&#26377;&#24490;&#29615;&#33410;&#38271;&#24230;&#30340;&#26368;&#23567;&#20844;&#20493;&#25968;&#12290;</p>
<p>&#38754;&#35797;&#23448;&#35282;&#24230;&#65306;</p>
<p>&#36825;&#20010;&#39064;&#30446;&#30340;&#32771;&#23519;&#28857;&#22312;&#20110;&#25214;&#35268;&#24459;&#12290;&#19981;&#36807;&#22914;&#26524;&#26377;&#19968;&#23450;&#32622;&#25442;&#32676;&#30340;&#29702;&#35770;&#22522;&#30784;&#30340;&#21516;&#23398;&#65292;&#26159;&#21487;&#20197;&#27604;&#36739;&#36731;&#26494;&#30340;&#35299;&#20915;&#36825;&#20010;&#38382;&#39064;&#30340;&#12290;&#26377;&#20852;&#36259;&#30340;&#21516;&#23398;&#21487;&#20197;&#26597;&#30475;&#31163;&#25955;&#25968;&#23398;&#30340;&#30456;&#20851;&#20070;&#31821;&#20013;&#32622;&#25442;&#32676;&#30340;&#30693;&#35782;&#28857;&#12290;</p>
<p>1 2 3 4 | 5 6 7 8 5 1 6 2 6 3 8 4</p>
<p>1-&gt;5-&gt;6-&gt;3-&gt;6 2-&gt;1-&gt;5-&gt;6-&gt;3-&gt;6</p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/877/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>leetcode &#38754;&#35797;&#39064; 40 &#19981;&#29992;&#38500;&#27861;&#27714;&#31215; <code class="fold">@</code></dt>
<dd><p>&#32473;&#23450;&#19968;&#20010;&#25968;&#32452; <code>A[1..n]</code>&#65292;&#27714;&#25968;&#32452; <code>B[1..n]</code>&#65292;&#20351;&#24471; <code>B[i] = A[1] * A[2] .. * A[i-1] * A[i+1] .. * A[n]</code>&#12290;&#35201;&#27714;&#19981;&#35201;&#20351;&#29992;&#38500;&#27861;&#65292;&#19988;&#22312; O(n) &#30340;&#26102;&#38388;&#20869;&#23436;&#25104;&#65292;&#20351;&#29992; O(1) &#30340;&#39069;&#22806;&#31354;&#38388;&#65288;&#19981;&#21253;&#21547; B &#25968;&#32452;&#25152;&#21344;&#31354;&#38388;&#65289;&#12290;</p>
<p>&#35745;&#31639;&#21069;&#32512;&#20056;&#31215; <code>Prefix[i] = A[1] * A[2] .. A[i]</code>&#65292;&#35745;&#31639;&#21518;&#32512;&#20056;&#31215; <code>Suffix[i] = A[i] * A[i+1] .. A[n]</code>&#65292;&#26131;&#30693;&#65292;<code>B[i] = Prefix[i - 1] * Suffix[i + 1]</code>&#12290;&#23454;&#38469;&#19978;&#26080;&#38656;&#23454;&#38469;&#26500;&#36896;&#20986; Prefix &#21644; Suffix &#25968;&#32452;&#65292;&#21033;&#29992; B &#25968;&#32452;&#20174;&#24038;&#21040;&#21491;&#36941;&#21382;&#19968;&#27425;&#24471;&#21040; <code>Prefix[i]</code>&#65292;&#28982;&#21518;&#20174;&#21491;&#21040;&#24038;&#36941;&#21382;&#19968;&#27425;&#65292;&#35745;&#31639;&#20986;&#25152;&#35201;&#27714;&#30340; B &#25968;&#32452;&#12290;</p>
<p>&#38754;&#35797;&#23448;&#35282;&#24230;&#65306;</p>
<p>&#36825;&#31181;&#20174;&#21069;&#21040;&#21518;&#36941;&#21382;&#21644;&#20174;&#21518;&#21040;&#21069;&#20877;&#36941;&#21382;&#19968;&#27425;&#30340;&#26041;&#27861;&#65288;Foward-Backward-Traverse&#65289;&#22312;&#24456;&#22810;&#39064;&#30446;&#20013;&#37117;&#26377;&#20511;&#37492;&#12290;&#22914;&#20061;&#31456;&#31639;&#27861;&#38754;&#35797;&#39064;31 &#23376;&#25968;&#32452;&#30340;&#26368;&#22823;&#24046;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/875/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>Perfect Squares &#36825;&#36947;&#39064;&#30340;&#24605;&#24819;&#21450;&#29366;&#24577;&#36716;&#31227;&#26041;&#31243;&#24590;&#20040;&#24819;&#65311; <code class="fold">@</code></dt>
<dd><p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/2126/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>&#20851;&#20110; design Google suggestion sharding &#30340;&#38382;&#39064; <code class="fold">@</code></dt>
<dd><p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/1858/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>&#26681;&#25454;&#23383;&#31526;&#20018;&#34920;&#36798;&#24335;&#35745;&#31639;&#23383;&#31526;&#20018; <code class="fold">@</code></dt>
<dd><p>yahoo onsite &#39064;&#30446;&#65292;&#32473;&#20986;&#34920;&#36798;&#24335;&#65292;&#30001;&#25968;&#23383;&#21644;&#25324;&#21495;&#32452;&#25104;&#65292;&#25968;&#23383;&#34920;&#31034;&#25324;&#21495;&#37324;&#38754;&#30340;&#20869;&#23481;&#65288;&#21487;&#20197;&#26159;&#23383;&#31526;&#20018;&#25110;&#32773;&#21478;&#19968;&#20010;&#34920;&#36798;&#24335;&#65289;&#37325;&#22797;&#30340;&#27425;&#25968;&#65292;&#34920;&#36798;&#24335;&#21644;&#23383;&#31526;&#20018;&#21487;&#20197;&#28151;&#21512;&#65292;&#27604;&#22914;&#65306;</p>
<pre><code>3[abc] =&gt; abcabcabc
4[ac]dy =&gt; acacacacdy
3[2[ad]3[pf]]xyz =&gt; adadpfpfpfadadpfpfpfadadpfpfpfxyz</code></pre>
<p>&#23581;&#35797;&#29992;&#20102;&#36882;&#24402;&#21457;&#29616;&#20570;&#19981;&#20986;&#26469;&#12290;&#12290;&#28982;&#21518;&#29992; stack &#35299;&#20915;&#20102;&#19968;&#37096;&#20998; case&#65292;&#20294;&#26159;&#21478;&#19968;&#37096;&#20998; case &#19981;&#36866;&#29992;&#12290;&#12290;&#12290;&#27714;&#39640;&#20154;&#25351;&#28857;&#65292;&#19975;&#20998;&#24863;&#35874;&#65281;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/2019/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
<dl>
<dt>&#23558;&#19968;&#20010;&#23383;&#31526;&#20018;&#24418;&#24335;&#30340;&#21313;&#36827;&#21046;&#25968;&#36716;&#25442;&#25104; 7 &#36827;&#21046;&#30340;&#23383;&#31526;&#20018; <code class="fold">@</code></dt>
<dd><p>&#20363;&#22914;: &#21313;&#36827;&#21046;&#30340; &#8220;123&#8221; &#36716;&#20026;&#19971;&#36827;&#21046;&#30340; &#8220;174&#8221;&#12290;</p>
<p>follow up: &#22914;&#20309;&#20462;&#25913;&#20351;&#20043;&#21487;&#20197;&#28385;&#36275;&#20219;&#24847;&#36827;&#21046;&#38388;&#30340;&#36716;&#25442;&#12290;</p>
<pre><code>123 / 7 = 17(&#21830;).....4(&#20313;&#25968;)
17 / 7 = 2(&#21830;).....3(&#20313;&#25968;)
2 / 7 = 0(&#21830;).....2(&#20313;&#25968;)</code></pre>
<p>&#25152;&#20197;&#23545;&#24212;&#30340; 7 &#36827;&#21046;&#26159; &#8220;234&#8221;&#65292; 2 * 49 + 3 * 7 + 4 = 123&#65288;10 &#36827;&#21046;&#65289;</p>
<p>&#21516;&#29702;79&#65306;</p>
<pre><code>79 / 7 = 11(&#21830;).....2(&#20313;&#25968;)
11 / 7= 1(&#21830;).....4(&#20313;&#25968;)
1 / 7 = 0(&#21830;).....1(&#20313;&#25968;)</code></pre>
<p>&#25152;&#20197;&#23545;&#24212;&#30340; 7 &#36827;&#21046;&#26159; &#8220;142&#8221;&#65292; 1 * 49 + 4 * 7 + 2 = 79&#65288;10 &#36827;&#21046;&#65289;</p>
<p>&#25152;&#20197; 10 &#36827;&#21046;&#36716;&#25442;&#25104; B &#36827;&#21046;&#65292;&#23601;&#26159;&#38500; B &#21462;&#20313;&#20498;&#24207;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/1394/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
</dl>
</dd>
<dt>&#31383;&#21475;&#31867; two pointer <code class="fold">@</code></dt>
<dd><p>&#22312;&#35838;&#38388;&#20013;&#30340;&#31383;&#21475;&#31867; two pointer&#65292;minimum-size-subarray-sum &#36825;&#36947;&#39064;&#20013;&#25552;&#21040;&#20102;&#31383;&#21475;&#31867;&#21644; sliding windows &#30340;&#21306;&#21035;&#65292;&#35831;&#38382;&#36825;&#20010;&#21306;&#21035;&#22312;&#21738;&#65311;&#29616;&#22312;&#19981;&#35760;&#24471;&#19978;&#35838;&#24590;&#20040;&#35762;&#30340;&#20102;&#12290;&#12290;&#12290;</p>
</dd>
<dt>&#32447;&#27573;&#26641; (Segment Tree&#12289;Binary Indexed Tree)&#12289;Trie&#12289;Union Find &#36825;&#20123;&#29305;&#27530;&#25968;&#25454;&#32467;&#26500;&#38656;&#35201;&#25484;&#25569;&#21040;&#20160;&#20040;&#31243;&#24230; <code class="fold">@</code></dt>
<dd><p>&#22914;&#39064;&#65292;&#32447;&#27573;&#26641;(Segment Tree&#12289;Binary Indexed Tree)&#12289;Trie&#12289;Union Find&#36825;&#20123;&#29305;&#27530;&#25968;&#25454;&#32467;&#26500;&#38656;&#35201;&#25484;&#25569;&#21527;&#65311;&#22914;&#26524;&#38656;&#35201;&#30340;&#35805;&#65292;&#38656;&#35201;&#25484;&#25569;&#21040;&#20160;&#20040;&#31243;&#24230;&#65311;&#20250;&#29992;&#12289;&#30693;&#36947;&#21407;&#29702;&#12289;&#20250;&#23454;&#29616;&#31561;&#31561;&#12290;</p>
<p>&#22914;&#26524;&#20320;&#19978;&#30340;&#26159;&#24378;&#21270;&#29677;&#20320;&#24314;&#35758;&#20570;&#19968;&#20570; Ladder &#37324;&#38754;&#32447;&#27573;&#26641;&#30456;&#20851;&#30340;&#39064;&#30446;&#12290;</p>
<p>LintCode &#32447;&#27573;&#26641;&#30340;&#39064;&#30446;&#65306; http://www.lintcode.com/en/tag/segment-tree/</p>
<p>&#25105;&#35273;&#24471;&#24182;&#19981;&#26159;&#22826;&#37325;&#35201;&#65292;&#39318;&#20808;&#32447;&#27573;&#26641;&#32771;&#30340;&#39057;&#29575;&#19981;&#39640;&#65292;&#22914;&#26524;&#19968;&#20123;&#39640;&#39057;&#31639;&#27861;&#20320;&#25484;&#25569;&#30340;&#24456;&#22909;&#20102;&#65292;&#23398;&#19968;&#19979;&#24403;&#28982;&#26356;&#22909;&#65292;&#19981;&#20809;&#20809;&#32447;&#27573;&#26641;&#30340;&#38382;&#39064;&#21487;&#20197;&#35299;&#20915;&#65292;&#20854;&#20182;&#24456;&#22810;&#38382;&#39064;&#20063;&#33021;&#29992;&#32447;&#27573;&#26641;&#20248;&#21270;&#65292;&#32943;&#23450;&#33021;&#20026;&#20320;&#38754;&#35797;&#21152;&#20998;&#12290;&#20854;&#20182;&#39640;&#39057;&#31639;&#27861;&#36824;&#27809;&#25484;&#25569;&#22909;&#65292;&#24314;&#35758;&#21487;&#20197;&#25918;&#19968;&#25918;&#12290;</p>
<p>&#19968;&#33324;&#32447;&#27573;&#26641;&#29992;&#20110;&#35299;&#20915;&#19982;&#21306;&#38388;&#26377;&#20851;&#30340;&#38382;&#39064;&#65292;Lintcode &#19978;&#22914;&#26524;&#20570;&#36807;&#20102;&#22522;&#30784;&#32447;&#27573;&#26641;&#39064;&#30446;&#36824;&#21487;&#20197;&#20570;&#20854;&#20182;&#30340;&#22914;&#65306;</p>
<ul>
<li>http://www.lintcode.com/zh-cn/problem/interval-minimum-number/</li>
<li>http://www.lintcode.com/zh-cn/problem/interval-sum/</li>
<li>http://www.lintcode.com/zh-cn/problem/interval-sum-ii/</li>
<li>http://www.lintcode.com/zh-cn/problem/count-of-smaller-number/</li>
<li>http://www.lintcode.com/zh-cn/problem/count-of-smaller-number-before-itself/</li>
</ul>
<p>&#25105;&#37117;&#25214;&#23436;&#20043;&#21518;&#25165;&#21457;&#29616; Lintcode &#30340; Tags&#65288;&#26631;&#31614;&#65289;&#21151;&#33021;&#36824;&#26159;&#24456;&#22909;&#29992;&#30340;&#65281;</p>
</dd>
<dt>leetcode &#38754;&#35797;&#39064; 29 &#23376;&#30697;&#38453;&#30340;&#26368;&#22823;&#20844;&#32422;&#25968; <code class="fold">@</code></dt>
<dd><p>&#32473;&#23450; <code>n*n</code> &#30340;&#30697;&#38453;&#65292;&#38656;&#35201;&#26597;&#35810;&#20219;&#24847;&#23376;&#30697;&#38453;&#20013;&#25152;&#26377;&#25968;&#23383;&#30340;&#26368;&#22823;&#20844;&#32422;&#25968;&#12290;&#35831;&#32473;&#20986;&#19968;&#31181;&#35774;&#35745;&#24605;&#36335;&#65292;&#23545;&#30697;&#38453;&#36827;&#34892;&#39044;&#22788;&#29702;&#65292;&#21152;&#36895;&#26597;&#35810;&#12290;&#39069;&#22806;&#30340;&#31354;&#38388;&#22797;&#26434;&#24230;&#35201;&#27714; O(n^2) &#20197;&#20869;&#12290;</p>
<p>&#26500;&#24314;&#20108;&#32500;&#32447;&#27573;&#26641;&#12290;&#39044;&#22788;&#29702;&#26102;&#38388; O(n^2)&#65292;&#27599;&#27425;&#26597;&#35810; O(log n)</p>
<p>&#38754;&#35797;&#23448;&#35282;&#24230;&#65306;</p>
<pre><code>&#36825;&#20010;&#39064;&#30446;&#38656;&#35201;&#20855;&#22791;&#19968;&#23450;&#30340;&#25968;&#25454;&#32467;&#26500;&#21151;&#24213;&#12290;&#32447;&#27573;&#26641; (Interval Tree) &#21487;&#20197;&#35299;&#20915;&#30340;&#38382;&#39064;&#26159;
&#37027;&#20123;&#28385;&#36275;&#32467;&#21512;&#24459;&#30340;&#36816;&#31639;&#12290;&#26368;&#22823;&#20844;&#32422;&#25968;&#26159;&#19968;&#20010;&#28385;&#36275;&#32467;&#21512;&#24459;&#30340;&#36816;&#31639;&#12290;&#25152;&#20197;&#26377;&#65292;
GCD(A,B,C,D) = GCD(GCD(A,B), GCD(C, D)) &#12290;&#21516;&#26679;&#20855;&#22791;&#32467;&#21512;&#24459;&#30340;&#36816;&#31639;&#26377;
PI,SUM,XOR(&#31215;, &#21644;, &#24322;&#25110;)&#12290;&#32447;&#27573;&#26641;&#30340;&#22522;&#26412;&#24605;&#24819;&#26159;&#65292;&#23558;&#21306;&#38388; [1,n] &#26597;&#20998;&#20026; [1, n/2],
[n/2+1,n] &#36825;&#20004;&#20010;&#23376;&#21306;&#38388;&#65292;&#28982;&#21518;&#27599;&#20010;&#23376;&#21306;&#38388;&#32487;&#32493;&#20570;&#20108;&#20998;&#65292;&#30452;&#21040;&#21306;&#38388;&#38271;&#24230;&#20026; 1&#12290;&#22312;&#27599;&#20010;
&#21306;&#38388;&#19978;&#32500;&#25252;&#36825;&#20010;&#21306;&#38388;&#30340;&#36816;&#31639;&#32467;&#26524;&#65288;&#22914; GCD,SUM)&#65292;&#38656;&#35201;&#26597;&#35810;&#26576;&#19968;&#27573;&#21306;&#38388;&#30340;&#32467;&#26524;&#26102;&#65292;&#23558;&#35813;
&#21306;&#38388;&#26144;&#23556;&#21040;&#32447;&#27573;&#26641;&#19978;&#30340;&#33509;&#24178;&#19981;&#30456;&#20132;&#30340;&#21306;&#38388;&#65292;&#23558;&#36825;&#20123;&#21306;&#38388;&#30340;&#32467;&#26524;&#21512;&#24182;&#36215;&#26469;&#21017;&#24471;&#21040;&#20102;&#31572;&#26696;&#12290;
&#21487;&#20197;&#35777;&#26126;&#20219;&#20309;&#19968;&#20010;&#21306;&#38388;&#21487;&#20197;&#26144;&#23556;&#21040;&#32447;&#27573;&#26641;&#19978;&#19981;&#36229;&#36807; O(log n) &#20010;&#21306;&#38388;&#12290;&#19978;&#38754;&#20171;&#32461;&#30340;&#26159;
&#19968;&#32500;&#30340;&#32447;&#27573;&#26641;&#65292;&#23545;&#20110;&#20108;&#32500;&#30340;&#24773;&#20917;&#65292;&#21487;&#20197;&#37319;&#29992;&#22235;&#20998;&#25110;&#32773;&#27178;&#32437;&#21078;&#20998;&#30340;&#26041;&#27861;&#26469;&#26500;&#24314;&#32447;&#27573;&#26641;&#12290;</code></pre>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/886/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574;IT&#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>MISC <code class="fold">@</code></dt>
<dd><p>&#27492;&#39064;&#30340;&#26368;&#20248;&#31639;&#27861;&#26159;&#36138;&#24515;&#12290;&#22312;&#23454;&#38469;&#38754;&#35797;&#36807;&#31243;&#20013;&#65292;&#31508;&#32773;&#35748;&#20026;&#21482;&#38656;&#35201;&#24819;&#21040;&#36138;&#24515;&#31639;&#27861;&#65292;&#24182;&#32473;&#20986;&#31639;&#27861;&#26694;&#26550;&#65292;&#23601;&#21487;&#20197;&#36798;&#21040;&#12304;hire&#12305;&#30340;&#31243;&#24230;&#12290;&#33021;&#22312;&#30701;&#26102;&#38388;&#20869;&#23436;&#25104;&#31243;&#24207;&#65292;&#21487;&#20197;&#36798;&#21040;&#12304;strong hire&#12305;&#12290;</p>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://www.jiuzhang.com/qa/796/">&#38382;&#31572; | &#20061;&#31456;&#31639;&#27861; - &#24110;&#21161;&#26356;&#22810;&#20013;&#22269;&#20154;&#25214;&#21040;&#22909;&#24037;&#20316;&#65292;&#30789;&#35895;&#39030;&#23574; IT &#20225;&#19994;&#24037;&#31243;&#24072;&#23454;&#26102;&#22312;&#32447;&#25480;&#35838;&#20026;&#20320;&#20256;&#25480;&#38754;&#35797;&#25216;&#24039;</a></li>
</ul>
</dd>
<dt>AVL &#26641;&#65292;&#32418;&#40657;&#26641;&#65292;B &#26641;&#65292;B+ &#26641;&#65292;Trie &#26641;&#37117;&#20998;&#21035;&#24212;&#29992;&#22312;&#21738;&#20123;&#29616;&#23454;&#22330;&#26223;&#20013;&#65311; <code class="fold">@</code></dt>
<dd><p>AVL &#26641;: &#26368;&#26089;&#30340;&#24179;&#34913;&#20108;&#21449;&#26641;&#20043;&#19968;&#12290;&#24212;&#29992;&#30456;&#23545;&#20854;&#20182;&#25968;&#25454;&#32467;&#26500;&#27604;&#36739;&#23569;&#12290;windows &#23545;&#36827;&#31243;&#22320;&#22336;&#31354;&#38388;&#30340;&#31649;&#29702;&#29992;&#21040;&#20102; AVL &#26641;&#12290;AVL &#26159;&#19968;&#31181;&#39640;&#24230;&#24179;&#34913;&#30340;&#20108;&#21449;&#26641;&#65292;&#25152;&#20197;&#36890;&#24120;&#30340;&#32467;&#26524;&#26159;&#65292;&#32500;&#25252;&#36825;&#31181;&#39640;&#24230;&#24179;&#34913;&#25152;&#20184;&#20986;&#30340;&#20195;&#20215;&#27604;&#20174;&#20013;&#33719;&#24471;&#30340;&#25928;&#29575;&#25910;&#30410;&#36824;&#22823;&#65292;&#25925;&#32780;&#23454;&#38469;&#30340;&#24212;&#29992;&#19981;&#22810;&#65292;&#26356;&#22810;&#30340;&#22320;&#26041;&#26159;&#29992;&#36861;&#27714;&#23616;&#37096;&#32780;&#19981;&#26159;&#38750;&#24120;&#20005;&#26684;&#25972;&#20307;&#24179;&#34913;&#30340;&#32418;&#40657;&#26641;&#12290;&#24403;&#28982;&#65292;&#22914;&#26524;&#22330;&#26223;&#20013;&#23545;&#25554;&#20837;&#21024;&#38500;&#19981;&#39057;&#32321;&#65292;&#21482;&#26159;&#23545;&#26597;&#25214;&#29305;&#21035;&#26377;&#35201;&#27714;&#65292;AVL &#36824;&#26159;&#20248;&#20110;&#32418;&#40657;&#30340;&#12290;</p>
<p>&#32418;&#40657;&#26641;: &#24179;&#34913;&#20108;&#21449;&#26641;&#65292;&#24191;&#27867;&#29992;&#22312; C++ &#30340; STL &#20013;&#12290;map &#21644; set &#37117;&#26159;&#29992;&#32418;&#40657;&#26641;&#23454;&#29616;&#30340;&#12290;&#36824;&#26377;</p>
<ul>
<li>&#33879;&#21517;&#30340; linux &#36827;&#31243;&#35843;&#24230; Completely Fair Scheduler, &#29992;&#32418;&#40657;&#26641;&#31649;&#29702;&#36827;&#31243;&#25511;&#21046;&#22359;</li>
<li>epoll &#22312;&#20869;&#26680;&#20013;&#30340;&#23454;&#29616;&#65292;&#29992;&#32418;&#40657;&#26641;&#31649;&#29702;&#20107;&#20214;&#22359;</li>
<li>nginx &#20013;&#65292;&#29992;&#32418;&#40657;&#26641;&#31649;&#29702; timer &#31561;</li>
<li>Java &#30340; TreeMap &#23454;&#29616;</li>
</ul>
<p>B/B+ &#26641;&#29992;&#22312;&#30913;&#30424;&#25991;&#20214;&#32452;&#32455; &#25968;&#25454;&#32034;&#24341;&#21644;&#25968;&#25454;&#24211;&#32034;&#24341;</p>
<p>Trie &#26641;&#65306;&#23383;&#20856;&#26641;&#65292;&#29992;&#22312;&#32479;&#35745;&#21644;&#25490;&#24207;&#22823;&#37327;&#23383;&#31526;&#20018; (&#22330;&#26223;&#33258;&#24049; yy = =)&#65292;trie &#26641;&#30340;&#19968;&#20010;&#20856;&#22411;&#24212;&#29992;&#26159;&#21069;&#32512;&#21305;&#37197;&#65292;&#27604;&#22914;&#19979;&#38754;&#36825;&#20010;&#24456;&#24120;&#35265;&#30340;&#22330;&#26223;&#65292;&#22312;&#25105;&#20204;&#36755;&#20837;&#26102;&#65292;&#25628;&#32034;&#24341;&#25806;&#20250;&#32473;&#20104;&#25552;&#31034;&#65292;&#36824;&#26377;&#27604;&#22914; IP &#36873;&#36335;&#65292;&#20063;&#26159;&#21069;&#32512;&#21305;&#37197;&#65292;&#19968;&#23450;&#31243;&#24230;&#20250;&#29992;&#21040; trie&#12290;</p>
<p>&#32418;&#40657;&#26641;&#65292;AVL &#26641;&#31616;&#21333;&#26469;&#35828;&#37117;&#26159;&#29992;&#26469;&#25628;&#32034;&#30340;&#21591;&#12290;</p>
<dl>
<dt>AVL &#26641;</dt>
<dd><p>&#24179;&#34913;&#20108;&#21449;&#26641;&#65292;&#19968;&#33324;&#26159;&#29992;&#24179;&#34913;&#22240;&#23376;&#24046;&#20540;&#20915;&#23450;&#24182;&#36890;&#36807;&#26059;&#36716;&#26469;&#23454;&#29616;&#65292;&#24038;&#21491;&#23376;&#26641;&#26641;&#39640;&#24046;&#19981;&#36229;&#36807; 1&#65292;&#37027;&#20040;&#21644;&#32418;&#40657;&#26641;&#27604;&#36739;&#23427;&#26159;&#20005;&#26684;&#30340;&#24179;&#34913;&#20108;&#21449;&#26641;&#65292;&#24179;&#34913;&#26465;&#20214;&#38750;&#24120;&#20005;&#26684;&#65288;&#26641;&#39640;&#24046;&#21482;&#26377; 1&#65289;&#65292;&#21482;&#35201;&#25554;&#20837;&#25110;&#21024;&#38500;&#19981;&#28385;&#36275;&#19978;&#38754;&#30340;&#26465;&#20214;&#23601;&#35201;&#36890;&#36807;&#26059;&#36716;&#26469;&#20445;&#25345;&#24179;&#34913;&#12290;&#30001;&#20110;&#26059;&#36716;&#26159;&#38750;&#24120;&#32791;&#36153;&#26102;&#38388;&#30340;&#12290;&#25105;&#20204;&#21487;&#20197;&#25512;&#20986; AVL &#26641;&#36866;&#21512;&#29992;&#20110;&#25554;&#20837;&#21024;&#38500;&#27425;&#25968;&#27604;&#36739;&#23569;&#65292;&#20294;&#26597;&#25214;&#22810;&#30340;&#24773;&#20917;&#12290;</p>
</dd>
<dt>&#32418;&#40657;&#26641;</dt>
<dd><p>&#24179;&#34913;&#20108;&#21449;&#26641;&#65292;&#36890;&#36807;&#23545;&#20219;&#20309;&#19968;&#26465;&#20174;&#26681;&#21040;&#21494;&#23376;&#30340;&#31616;&#21333;&#36335;&#24452;&#19978;&#21508;&#20010;&#33410;&#28857;&#30340;&#39068;&#33394;&#36827;&#34892;&#32422;&#26463;&#65292;&#30830;&#20445;&#27809;&#26377;&#19968;&#26465;&#36335;&#24452;&#20250;&#27604;&#20854;&#20182;&#36335;&#24452;&#38271; 2 &#20493;&#65292;&#22240;&#32780;&#26159;&#36817;&#20284;&#24179;&#34913;&#30340;&#12290;&#25152;&#20197;&#30456;&#23545;&#20110;&#20005;&#26684;&#35201;&#27714;&#24179;&#34913;&#30340; AVL &#26641;&#26469;&#35828;&#65292;&#23427;&#30340;&#26059;&#36716;&#20445;&#25345;&#24179;&#34913;&#27425;&#25968;&#36739;&#23569;&#12290;&#29992;&#20110;&#25628;&#32034;&#26102;&#65292;&#25554;&#20837;&#21024;&#38500;&#27425;&#25968;&#22810;&#30340;&#24773;&#20917;&#19979;&#25105;&#20204;&#23601;&#29992;&#32418;&#40657;&#26641;&#26469;&#21462;&#20195; AVL&#12290;</p>
<p>&#65288;&#29616;&#22312;&#37096;&#20998;&#22330;&#26223;&#20351;&#29992;&#36339;&#34920;&#26469;&#26367;&#25442;&#32418;&#40657;&#26641;&#65292;&#21487;&#25628;&#32034;&#8220;&#20026;&#21861; redis &#20351;&#29992;&#36339;&#34920; (skiplist) &#32780;&#19981;&#26159;&#20351;&#29992; red-black&#65311;&#8221;&#65289;</p>
<dl>
<dt><a href="https://www.zhihu.com/question/20202931">&#20026;&#21861; redis &#20351;&#29992;&#36339;&#34920; (skiplist) &#32780;&#19981;&#26159;&#20351;&#29992; red-black&#65311; - &#30693;&#20046;</a> <code class="fold">@</code></dt>
<dd><p>&#22312; server &#31471;&#65292;&#23545;&#24182;&#21457;&#21644;&#24615;&#33021;&#26377;&#35201;&#27714;&#30340;&#24773;&#20917;&#19979;&#65292;&#22914;&#20309;&#36873;&#25321;&#21512;&#36866;&#30340;&#25968;&#25454;&#32467;&#26500;&#65288;&#36825;&#37324;&#26159;&#36339;&#36291;&#34920;&#21644;&#32418;&#40657;&#26641;&#65289;&#12290;</p>
<p>&#22914;&#26524;&#21333;&#32431;&#27604;&#36739;&#24615;&#33021;&#65292;&#36339;&#36291;&#34920;&#21644;&#32418;&#40657;&#26641;&#21487;&#20197;&#35828;&#30456;&#24046;&#19981;&#22823;&#65292;&#20294;&#26159;&#21152;&#19978;&#24182;&#21457;&#30340;&#29615;&#22659;&#23601;&#19981;&#19968;&#26679;&#20102;&#65292;&#22914;&#26524;&#35201;&#26356;&#26032;&#25968;&#25454;&#65292;&#36339;&#36291;&#34920;&#38656;&#35201;&#26356;&#26032;&#30340;&#37096;&#20998;&#23601;&#27604;&#36739;&#23569;&#65292;&#38145;&#30340;&#19996;&#35199;&#20063;&#23601;&#27604;&#36739;&#23569;&#65292;&#25152;&#20197;&#19981;&#21516;&#32447;&#31243;&#20105;&#38145;&#30340;&#20195;&#20215;&#23601;&#30456;&#23545;&#23569;&#20102;&#65292;&#32780;&#32418;&#40657;&#26641;&#26377;&#20010;&#24179;&#34913;&#30340;&#36807;&#31243;&#65292;&#29301;&#28041;&#21040;&#22823;&#37327;&#30340;&#33410;&#28857;&#65292;&#20105;&#38145;&#30340;&#20195;&#20215;&#20063;&#23601;&#30456;&#23545;&#36739;&#39640;&#20102;&#12290;&#24615;&#33021;&#20063;&#23601;&#19981;&#22914;&#21069;&#32773;&#20102;&#12290;</p>
</dd>
</dl>
</dd>
<dt>B &#26641;&#65292;B+ &#26641;</dt>
<dd><p>&#23427;&#20204;&#29305;&#28857;&#26159;&#19968;&#26679;&#30340;&#65292;&#26159;&#22810;&#36335;&#26597;&#25214;&#26641;&#65292;&#19968;&#33324;&#29992;&#20110;&#25968;&#25454;&#24211;&#31995;&#32479;&#20013;&#65292;&#20026;&#20160;&#20040;&#65292;&#22240;&#20026;&#23427;&#20204;&#20998;&#25903;&#22810;&#23618;&#25968;&#23569;&#21591;&#65292;&#37117;&#30693;&#36947;&#30913;&#30424; IO &#26159;&#38750;&#24120;&#32791;&#26102;&#30340;&#65292;&#32780;&#20687;&#22823;&#37327;&#25968;&#25454;&#23384;&#20648;&#22312;&#30913;&#30424;&#20013;&#25152;&#20197;&#25105;&#20204;&#35201;&#26377;&#25928;&#30340;&#20943;&#23569;&#30913;&#30424; IO &#27425;&#25968;&#36991;&#20813;&#30913;&#30424;&#39057;&#32321;&#30340;&#26597;&#25214;&#12290;</p>
<p>B+ &#26641;&#26159; B &#26641;&#30340;&#21464;&#31181;&#26641;&#65292;&#26377; n &#26869;&#23376;&#26641;&#30340;&#33410;&#28857;&#20013;&#21547;&#26377; n &#20010;&#20851;&#38190;&#23383;&#65292;&#27599;&#20010;&#20851;&#38190;&#23383;&#19981;&#20445;&#23384;&#25968;&#25454;&#65292;&#21482;&#29992;&#26469;&#32034;&#24341;&#65292;&#25968;&#25454;&#37117;&#20445;&#23384;&#22312;&#21494;&#23376;&#33410;&#28857;&#12290;&#26159;&#20026;&#25991;&#20214;&#31995;&#32479;&#32780;&#29983;&#30340;&#12290;</p>
</dd>
<dt>Trie &#26641;</dt>
<dd><p>&#21448;&#21517;&#21333;&#35789;&#26597;&#25214;&#26641;&#65292;&#19968;&#31181;&#26641;&#24418;&#32467;&#26500;&#65292;&#24120;&#29992;&#26469;&#25805;&#20316;&#23383;&#31526;&#20018;&#12290;&#23427;&#26159;&#19981;&#21516;&#23383;&#31526;&#20018;&#30340;&#30456;&#21516;&#21069;&#32512;&#21482;&#20445;&#23384;&#19968;&#20221;&#12290;&#30456;&#23545;&#30452;&#25509;&#20445;&#23384;&#23383;&#31526;&#20018;&#32943;&#23450;&#26159;&#33410;&#30465;&#31354;&#38388;&#30340;&#65292;&#20294;&#26159;&#23427;&#20445;&#23384;&#22823;&#37327;&#23383;&#31526;&#20018;&#26102;&#20250;&#24456;&#32791;&#36153;&#20869;&#23384;&#65288;&#26159;&#20869;&#23384;&#65289;&#12290;&#31867;&#20284;&#30340;&#26377;&#21069;&#32512;&#26641; (prefix tree)&#65292;&#21518;&#32512;&#26641; (suffix tree)&#65292;radix tree(patricia tree, compact prefix tree)&#65292;crit-bit tree&#65288;&#35299;&#20915;&#32791;&#36153;&#20869;&#23384;&#38382;&#39064;&#65289;&#65292;&#20197;&#21450;&#21069;&#38754;&#35828;&#30340; double array trie&#12290;</p>
<p>&#31616;&#21333;&#30340;&#34917;&#20805;&#19979;&#25105;&#20102;&#35299;&#24212;&#29992;</p>
<ul>
<li>&#21069;&#32512;&#26641;&#65306;&#23383;&#31526;&#20018;&#24555;&#36895;&#26816;&#32034;&#65292;&#23383;&#31526;&#20018;&#25490;&#24207;&#65292;&#26368;&#38271;&#20844;&#20849;&#21069;&#32512;&#65292;&#33258;&#21160;&#21305;&#37197;&#21069;&#32512;&#26174;&#31034;&#21518;&#32512;&#12290;</li>
<li>&#21518;&#32512;&#26641;&#65306;&#26597;&#25214;&#23383;&#31526;&#20018; s1 &#22312; s2 &#20013;&#65292;&#23383;&#31526;&#20018; s1 &#22312; s2 &#20013;&#20986;&#29616;&#30340;&#27425;&#25968;&#65292;&#23383;&#31526;&#20018; s1,s2 &#26368;&#38271;&#20844;&#20849;&#37096;&#20998;&#65292;&#26368;&#38271;&#22238;&#25991;&#20018;&#12290;</li>
<li>radix tree&#65306;linux &#20869;&#26680;&#65292;nginx&#12290;</li>
</ul>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="https://www.zhihu.com/question/30527705">AVL &#26641;&#65292;&#32418;&#40657;&#26641;&#65292;B &#26641;&#65292;B+ &#26641;&#65292;Trie &#26641;&#37117;&#20998;&#21035;&#24212;&#29992;&#22312;&#21738;&#20123;&#29616;&#23454;&#22330;&#26223;&#20013;&#65311; - &#30693;&#20046;</a></li>
</ul>
</dd>
<dt>&#25968;&#25454;&#32467;&#26500;&#19982;&#31639;&#27861;&#20013;&#65292;&#26641;&#19968;&#33324;&#20250;&#24212;&#29992;&#22312;&#21738;&#20123;&#26041;&#38754;&#65311;&#20026;&#20160;&#20040;&#65311; <code class="fold">@</code></dt>
<dd><p>&#26641;&#30340;&#19968;&#20010;&#22823;&#31867;&#26159;&#33258;&#24179;&#34913;&#20108;&#21449;&#25628;&#32034;&#26641; (self-balanced BST), &#21464;&#31181;&#29305;&#21035;&#22810;:</p>
<ul>
<li>RB &#26641;&#26159;&#27599;&#20010;&#33410;&#28857;&#26159;&#32418;&#33394;&#25110;&#32773;&#40657;&#33394;, &#39068;&#33394;&#38548;&#20195;&#36951;&#20256;</li>
<li>AVL &#26641;&#26159;&#27599;&#20010;&#33410;&#28857;&#21253;&#21547;&#24179;&#34913;&#22240;&#23376;, &#31561;&#20110;&#24038;&#39640;-&#21491;&#39640;</li>
<li>Splay &#26641;&#26159;&#27599;&#20010;&#33410;&#28857;&#24102;&#20010;&#29238;&#33410;&#28857;&#30340;&#25351;&#38024;</li>
<li>Treap &#26159;&#27599;&#20010;&#33410;&#28857;&#37117;&#24102;&#20010;&#38543;&#26426;&#30340; priority number, parent priority &gt;= child priority</li>
</ul>
<p>&#8230; (&#20854;&#23454;&#35828;&#30333;&#20102;&#37117;&#26159;&#20026;&#20102;&#26041;&#20415;&#24179;&#34913;&#25805;&#20316;&#32473;&#33410;&#28857;&#38468;&#21152;&#19968;&#20010;&#23383;&#27573;)</p>
<p>&#33258;&#24179;&#34913;&#20108;&#21449;&#25628;&#32034;&#26641;&#22312;&#38754;&#35797;&#20013;&#32463;&#24120;&#20986;&#29616;, &#20294;&#20570;&#32593;&#39029;&#30340;&#20114;&#32852;&#32593;&#30721;&#20892;&#21364;&#24456;&#23569;&#29992;&#24471;&#19978;&#8230; &#22914;&#26524;&#26159;&#24403; Map &#29992;, &#24448;&#24448;&#36824;&#19981;&#22914;&#30452;&#25509;&#19978;&#21704;&#24076;&#34920;. &#22914;&#26524;&#26159;&#24403;&#25490;&#24207;&#29992;, &#19981;&#22914;&#30452;&#25509;&#29992;&#25490;&#24207;&#31639;&#27861;&#8230; &#19981;&#36807;&#20063;&#26377;&#26377;&#29992;&#30340;&#26102;&#20505;, &#20363;&#22914;&#26597;&#25214;&#19968;&#20010;&#25968;&#23383;&#30340;&#19978;&#19979;&#30028;.</p>
<p>&#26641;&#30340;&#21478;&#19968;&#20010;&#22823;&#31867;&#26159; Trie, &#29305;&#28857;&#26159;&#33021;&#20445;&#35777;&#23383;&#20856;&#24207;, &#23384;&#20648;&#35789;&#20856;&#30340;&#31354;&#38388;&#21387;&#32553;&#29575;&#39640;, &#33021;&#20570;&#21069;&#32512;&#25628;&#32034;. &#22312;&#27491;&#21017;&#21305;&#37197;, &#25968;&#25454;&#21387;&#32553;, &#26500;&#24314;&#32034;&#24341;&#37117;&#21487;&#33021;&#29992;&#21040;. Trie &#20063;&#26377;&#19981;&#23569;&#21464;&#31181;:</p>
<ul>
<li>Double Array - trie &#30340;&#19968;&#20010;&#32463;&#20856;&#23454;&#29616; (&#36825;&#23454;&#29616;&#20854;&#23454;&#19981;&#31639;&#26641;, &#20063;&#19981;&#36866;&#21512;&#22788;&#29702;&#38750; ascii &#23383;&#31526;&#30340;&#24773;&#20917;)</li>
<li>Patricia Trie (Radix-Tree) - &#27599;&#20010;&#33410;&#28857;&#21487;&#20197;&#23384;&#19968;&#27573;&#23383;&#31526;&#20018;&#32780;&#19981;&#38480;&#20110;&#19968;&#20010;&#23383;&#31526;</li>
<li>Judy Array - &#22522;&#20110; 256-ary radix tree, &#29992;&#20102; 20 &#31181;&#21387;&#32553;&#26041;&#24335;, &#26497;&#20854;&#22797;&#26434;&#8230;</li>
<li>Burst Trie - &#22914;&#26524;&#19968;&#20010;&#23376;&#26641;&#36275;&#22815;&#23567;, &#23601;&#29992; binary &#22534;&#30340;&#26041;&#24335;&#23384;&#20648;, &#19981;&#36807;&#21387;&#32553;&#25928;&#26524;&#19968;&#33324;</li>
<li>HAT Trie - &#21387;&#32553;&#29575;&#39640;&#32780;&#19988;&#19981;&#23481;&#26131;&#20986;&#29616; CPU cache miss, &#26597;&#36895;&#25509;&#36817;&#21704;&#24076;&#34920;&#32780;&#32791;&#20869;&#23384;&#23569;&#24471;&#22810;. &#33410;&#28857;&#21487;&#20197;&#26159;&#20197;&#19979;&#19977;&#31181;&#20043;&#19968;: Array Hash, &#24207;&#21015;&#21270;&#30340; Bucket, &#20256;&#32479; Trie node</li>
<li>MARISA Trie - &#21387;&#32553;&#29575;&#26368;&#39640;, &#25903;&#25345; mmap &#36733;&#20837;, &#20063;&#26159;&#29992;&#20102;&#24456;&#22810;&#21387;&#32553;&#25216;&#24039;&#30340;&#22797;&#26434;&#23454;&#29616;, &#23601;&#26159;&#26500;&#24314;&#27604;&#36739;&#33457;&#26102;&#38388;, &#20063;&#19981;&#33021;&#21160;&#24577;&#26356;&#26032;</li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="https://www.zhihu.com/question/20176446">&#25968;&#25454;&#32467;&#26500;&#19982;&#31639;&#27861;&#20013;&#65292;&#26641;&#19968;&#33324;&#20250;&#24212;&#29992;&#22312;&#21738;&#20123;&#26041;&#38754;&#65311;&#20026;&#20160;&#20040;&#65311; - &#30693;&#20046;</a></li>
</ul>
</dd>
<dt>&#29992;&#38142;&#34920;&#30340;&#30446;&#30340;&#26159;&#20160;&#20040;&#65311;&#30465;&#31354;&#38388;&#36824;&#26159;&#30465;&#26102;&#38388;&#65311; <code class="fold">@</code></dt>
<dd><p>&#38142;&#34920;&#30340;&#20248;&#28857;&#38500;&#20102;&#12300;&#25554;&#20837;&#21024;&#38500;&#19981;&#38656;&#35201;&#31227;&#21160;&#20854;&#20182;&#20803;&#32032;&#12301;&#20043;&#22806;&#65292;&#36824;&#22312;&#20110;&#23427;&#26159;&#19968;&#20010;&#23616;&#37096;&#21270;&#32467;&#26500;&#12290;&#23601;&#26159;&#35828;&#24403;&#20320;&#25343;&#21040;&#38142;&#34920;&#30340;&#19968;&#20010; node &#20043;&#21518;&#65292;&#19981;&#38656;&#35201;&#22826;&#22810;&#20854;&#23427;&#25968;&#25454;&#65292;&#23601;&#21487;&#20197;&#23436;&#25104;&#25554;&#20837;&#65292;&#21024;&#38500;&#30340;&#25805;&#20316;&#12290;&#32780;&#20854;&#23427;&#30340;&#25968;&#25454;&#32467;&#26500;&#19981;&#34892;&#12290;&#27604;&#22914;&#35828; array&#65292;&#20320;&#21482;&#25343;&#21040;&#19968;&#20010; item &#26159;&#26029;&#19981;&#25954;&#20570;&#25554;&#20837;&#21024;&#38500;&#30340;&#12290;</p>
<p>&#24403;&#28982;&#20102;&#65292;&#23616;&#37096;&#21270;&#36825;&#20010;&#22909;&#22788;&#21482;&#26377; intrusive&#65288;&#20405;&#20837;&#30340;&#65307;&#25171;&#25200;&#30340;&#65289;&#38142;&#34920;&#25165;&#26377;&#65292;&#23601;&#26159;&#24517;&#39035; prev/next &#23884;&#20837;&#22312;&#25968;&#25454;&#32467;&#26500;&#20013;&#12290;&#20687; STL &#21644; Java &#37027;&#31181;&#35774;&#35745;&#26159;&#22833;&#36133;&#20102;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="https://www.zhihu.com/question/31082722">&#29992;&#38142;&#34920;&#30340;&#30446;&#30340;&#26159;&#20160;&#20040;&#65311;&#30465;&#31354;&#38388;&#36824;&#26159;&#30465;&#26102;&#38388;&#65311; - &#30693;&#20046;</a></li>
</ul>
</dd>
<dt>Graph (abstract data type) <code class="fold">@</code></dt>
<dd><p>In computer science, a graph is an abstract data type that is meant to implement the undirected graph and directed graph concepts from mathematics.</p>
<p>The basic operations provided by a graph data structure G usually include:</p>
<ul>
<li>adjacent(G, x, y): tests whether there is an edge from the vertices x to y;</li>
<li>neighbors(G, x): lists all vertices y such that there is an edge from the vertices x to y;</li>
<li>add_vertex(G, x): adds the vertex x, if it is not there;</li>
<li>remove_vertex(G, x): removes the vertex x, if it is there;</li>
<li>add_edge(G, x, y): adds the edge from the vertices x to y, if it is not there;</li>
<li>remove_edge(G, x, y): removes the edge from the vertices x to y, if it is there;</li>
<li>get_vertex_value(G, x): returns the value associated with the vertex x;</li>
<li>set_vertex_value(G, x, v): sets the value associated with the vertex x to v.</li>
</ul>
<p>Structures that associate values to the edges usually also provide:</p>
<ul>
<li>get_edge_value(G, x, y): returns the value associated with the edge (x, y);</li>
<li>set_edge_value(G, x, y, v): sets the value associated with the edge (x, y) to v.</li>
</ul>
<dl>
<dt>Adjacency List</dt>
<dd><p>Vertices are stored as records or objects, and every vertex stores <strong>a list of adjacent vertices</strong>. This data structure allows the storage of additional data on the vertices. Additional data can be stored if edges are also stored as objects, in which case each vertex stores its incident edges and each edge stores its incident vertices.</p>
</dd>
<dt>Adjancy Matrix</dt>
<dd><p>A two-dimensional matrix, in which the rows represent source vertices and columns represent destination vertices. Data on edges and vertices must be stored externally. Only the cost for one edge can be stored between each pair of vertices.</p>
</dd>
<dt>Incidence matrix</dt>
<dd><p>A two-dimensional Boolean matrix, in which the rows represent the vertices and columns represent the edges. The entries indicate whether the vertex at a row is incident to the edge at a column.</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/90/Labeled_undirected_graph.svg/375px-Labeled_undirected_graph.svg.png" alt="An undirected graph." />
<p class="caption">An undirected graph.</p>
</div>
<p>For example the incidence matrix of the undirected graph shown on the right is a matrix consisting of 4 rows (corresponding to the four vertices, 1-4) and 4 columns (corresponding to the four edges, e1-e4):</p>
<div class="figure">
<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/99f6e54a9f49d5a3ae4c25e396d8b7c153cdaa07" />

</div>
</dd>
</dl>
<div class="figure">
<img src="http://whudoc.qiniudn.com/2016/firefox_2016-09-06_11-26-02.png" />

</div>
<p><strong>Adjacency lists are generally preferred because they efficiently represent sparse graphs. An adjacency matrix is preferred if the graph is dense, that is the number of edges |E| is close to the number of vertices squared, |V|<sup>2</sup>, or if one must be able to quickly look up if there is an edge connecting two vertices.</strong></p>
<p>refs and see also</p>
<ul>
<li><a href="http://web.cecs.pdx.edu/~sheard/course/Cs163/Doc/Graphs.html">Graphs in Computer Science</a></li>
<li><a href="https://en.wikipedia.org/wiki/Adjacency_list">Adjacency list - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Adjacency_matrix">Adjacency matrix - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Incidence_matrix">Incidence matrix - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type)">Graph (abstract data type) - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
<dt>trees <code class="fold">@</code></dt>
<dd><dl>
<dt>Spanning tree <code class="fold">@</code></dt>
<dd><p>In the mathematical field of graph theory, <strong>a spanning tree T of an undirected graph G is a subgraph that is a tree which includes all of the vertices of G</strong>. In general, a graph may have several spanning trees, but a graph that is not connected will not contain a spanning tree (but see Spanning forests below). If all of the edges of G are also edges of a spanning tree T of G, then G is a tree and is identical to T (that is, <strong>a tree has a unique spanning tree and it is itself</strong>).</p>
<p>Several pathfinding algorithms, including Dijkstra&#8217;s algorithm and the <code>A*</code> search algorithm, internally <strong>build a spanning tree as an intermediate step in solving the problem</strong>.</p>
<dl>
<dt>Definitions</dt>
<dd><p><strong>A tree is a connected undirected graph with no cycles</strong>. It is a spanning tree of a graph G if it spans G (that is, it includes every vertex of G) and is a subgraph of G (every edge in the tree belongs to G). A spanning tree of a connected graph G can also be defined as a maximal set of edges of G that contains no cycle, or as a minimal set of edges that connect all vertices.</p>
</dd>
</dl>
<p>minimal/minimum spanning tree</p>
<p>In some cases, it is easy to calculate t(G) directly:</p>
<ul>
<li>If G is itself a tree, then t(G) = 1.</li>
<li>When G is the cycle graph Cn with n vertices, then t(G) = n.</li>
<li>For a complete graph with n vertices, Cayley&#8217;s formula gives the number of spanning trees as n<sup>n&#8722;2</sup>.</li>
<li>If G is the complete bipartite graph K<sub>p,q</sub>, then t(G) = p<sup>q-1</sup>q<sup>p-1</sup>.</li>
<li>For the n-dimensional hypercube graph&#8230;</li>
</ul>
<p>arbitrary tree?</p>
<p>see <a href="https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem">Kirchhoff&#8217;s theorem - Wikipedia, the free encyclopedia</a>.</p>
<dl>
<dt>Prim&#8217;s algorithm <code class="fold">@</code></dt>
<dd><p>In computer science, Prim&#8217;s algorithm is <strong>a greedy algorithm</strong> that <strong>finds a minimum spanning tree for a weighted undirected graph</strong>. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. The algorithm operates by building this tree one vertex at a time, from an arbitrary starting vertex, at each step adding the cheapest possible connection from the tree to another vertex.</p>
</dd>
</dl>
</dd>
<dt>Self-balancing binary search tree <code class="fold">@</code></dt>
<dd><p>In computer science, a self-balancing (or height-balanced) binary search tree is any node-based binary search tree that automatically keeps its height (maximal number of levels below the root) small in the face of arbitrary item insertions and deletions.</p>
<p>The red&#8211;black tree, which is a type of self-balancing binary search tree, was called symmetric binary B-tree and was renamed but can still be confused with the generic concept of self-balancing binary search tree because of the initials.</p>
</dd>
<dt>AVL tree <code class="fold">@</code></dt>
<dd><p>d(height(left), height(right)) = { -1, 0, 1 }, left-heavy, right-heavy, balanced.</p>
</dd>
<dt>Splay tree <code class="fold">@</code></dt>
<dd><p>A splay&#65288;&#23637;&#24320;&#65289; tree is a self-adjusting binary search tree with the additional property that recently accessed elements are quick to access again. It performs basic operations such as insertion, look-up and removal in O(log n) amortized time. For many sequences of non-random operations, splay trees perform better than other search trees, even when the specific pattern of the sequence is unknown. The splay tree was invented by Daniel Sleator and Robert Tarjan in 1985.</p>
<dl>
<dt>Advantages <code class="fold">@</code></dt>
<dd><p>Good performance for a splay tree depends on the fact that it is <strong>self-optimizing</strong>, in that frequently accessed nodes will move nearer to the root where they can be accessed more quickly. The worst-case height&#8212;though unlikely&#8212;is O(n), with the average being O(log n). Having frequently used nodes near the root is an advantage for many practical applications (also see <strong>Locality of reference</strong>), and is particularly useful for implementing caches and garbage collection algorithms.</p>
<dl>
<dt>Locality of reference <code class="fold">@</code></dt>
<dd><p>In computer science, locality of reference, also known as the principle of locality, is a term for the phenomenon in which the same values, or related storage locations, are frequently accessed, depending on the memory access pattern. There are two basic types of reference locality &#8211; temporal and spatial locality. Temporal locality refers to the reuse of specific data, and/or resources, within a relatively small time duration. Spatial locality refers to the use of data elements within relatively close storage locations. Sequential locality, a special case of spatial locality, occurs when data elements are arranged and accessed linearly, such as, traversing the elements in a one-dimensional array.</p>
<p>Locality is merely one type of predictable behavior that occurs in computer systems. Systems that exhibit strong locality of reference are great candidates for performance optimization through the use of techniques such as the caching, prefetching for memory and advanced branch predictors at the pipelining stage of processor core.</p>
<p>There are several different types of locality of reference:</p>
<ul>
<li>Temporal locality</li>
<li>Spatial locality</li>
<li>Memory locality</li>
<li>Branch locality</li>
<li>Equidistant locality</li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Locality_of_reference">Locality of reference - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
</dl>
<p>Advantages include:</p>
<ul>
<li>Comparable performance: Average-case performance is as efficient as other trees.</li>
<li>Small memory footprint: Splay trees <strong>do not need to store any bookkeeping data</strong>.</li>
</ul>
</dd>
<dt>Disadvantages <code class="fold">@</code></dt>
<dd><p>The most significant disadvantage of splay trees is that <strong>the height of a splay tree can be linear</strong>. For example, this will be the case after accessing all n elements in non-decreasing order. Since the height of a tree corresponds to the worst-case access time, this means that the actual cost of an operation can be high. However the amortized access cost of this worst case is logarithmic, O(log n). Also, the expected access cost can be reduced to O(log n) by using a randomized variant.</p>
<p>The representation of splay trees can <strong>change even when they are accessed in a &#8216;read-only&#8217; manner</strong> (i.e.&#160;by find operations). This complicates the use of such splay trees in a multi-threaded environment. Specifically, extra management is needed if multiple threads are allowed to perform find operations concurrently. This also makes them <strong>unsuitable for general use in purely functional programming</strong>, although they can be used in limited ways to implement priority queues even there.</p>
</dd>
</dl>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Splay_tree_zig.svg/1064px-Splay_tree_zig.svg.png" alt="zig" />
<p class="caption">zig</p>
</div>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/f/fd/Zigzig.gif" alt="zig zig" />
<p class="caption">zig zig</p>
</div>
<dl>
<dt>C++ &#23454;&#29616; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;functional&gt;</span>

<span class="ot">#ifndef SPLAY_TREE</span>
<span class="ot">#define SPLAY_TREE</span>

<span class="kw">template</span>&lt; <span class="kw">typename</span> T, <span class="kw">typename</span> Comp = std::less&lt; T &gt; &gt;
<span class="kw">class</span> splay_tree {
<span class="kw">private</span>:
  Comp comp;
  <span class="dt">unsigned</span> <span class="dt">long</span> p_size;

  <span class="kw">struct</span> node {
    node *left, *right;
    node *parent;
    T key;
    node( <span class="dt">const</span> T&amp; init = T( ) ) : left( <span class="dv">0</span> ), right( <span class="dv">0</span> ), parent( <span class="dv">0</span> ), key( init ) { }
    ~node( ) {
      <span class="kw">if</span>( left ) <span class="kw">delete</span> left;
      <span class="kw">if</span>( right ) <span class="kw">delete</span> right;
      <span class="kw">if</span>( parent ) <span class="kw">delete</span> parent;
    }
  } *root;

  <span class="dt">void</span> left_rotate( node *x ) {
    node *y = x-&gt;right;
    <span class="kw">if</span>(y) {
      x-&gt;right = y-&gt;left;
      <span class="kw">if</span>( y-&gt;left ) y-&gt;left-&gt;parent = x;
      y-&gt;parent = x-&gt;parent;
    }

    <span class="kw">if</span>( !x-&gt;parent ) root = y;
    <span class="kw">else</span> <span class="kw">if</span>( x == x-&gt;parent-&gt;left ) x-&gt;parent-&gt;left = y;
    <span class="kw">else</span> x-&gt;parent-&gt;right = y;
    <span class="kw">if</span>(y) y-&gt;left = x;
    x-&gt;parent = y;
  }

  <span class="dt">void</span> right_rotate( node *x ) {
    node *y = x-&gt;left;
    <span class="kw">if</span>(y) {
      x-&gt;left = y-&gt;right;
      <span class="kw">if</span>( y-&gt;right ) y-&gt;right-&gt;parent = x;
      y-&gt;parent = x-&gt;parent;
    }
    <span class="kw">if</span>( !x-&gt;parent ) root = y;
    <span class="kw">else</span> <span class="kw">if</span>( x == x-&gt;parent-&gt;left ) x-&gt;parent-&gt;left = y;
    <span class="kw">else</span> x-&gt;parent-&gt;right = y;
    <span class="kw">if</span>(y) y-&gt;right = x;
    x-&gt;parent = y;
  }

  <span class="dt">void</span> splay( node *x ) {
    <span class="kw">while</span>( x-&gt;parent ) {
      <span class="kw">if</span>( !x-&gt;parent-&gt;parent ) {
        <span class="kw">if</span>( x-&gt;parent-&gt;left == x ) right_rotate( x-&gt;parent );
        <span class="kw">else</span> left_rotate( x-&gt;parent );
      } <span class="kw">else</span> <span class="kw">if</span>( x-&gt;parent-&gt;left == x &amp;&amp; x-&gt;parent-&gt;parent-&gt;left == x-&gt;parent ) {
        right_rotate( x-&gt;parent-&gt;parent );
        right_rotate( x-&gt;parent );
      } <span class="kw">else</span> <span class="kw">if</span>( x-&gt;parent-&gt;right == x &amp;&amp; x-&gt;parent-&gt;parent-&gt;right == x-&gt;parent ) {
        left_rotate( x-&gt;parent-&gt;parent );
        left_rotate( x-&gt;parent );
      } <span class="kw">else</span> <span class="kw">if</span>( x-&gt;parent-&gt;left == x &amp;&amp; x-&gt;parent-&gt;parent-&gt;right == x-&gt;parent ) {
        right_rotate( x-&gt;parent );
        left_rotate( x-&gt;parent );
      } <span class="kw">else</span> {
        left_rotate( x-&gt;parent );
        right_rotate( x-&gt;parent );
      }
    }
  }

  <span class="dt">void</span> replace( node *u, node *v ) {
    <span class="kw">if</span>( !u-&gt;parent ) root = v;
    <span class="kw">else</span> <span class="kw">if</span>( u == u-&gt;parent-&gt;left ) u-&gt;parent-&gt;left = v;
    <span class="kw">else</span> u-&gt;parent-&gt;right = v;
    <span class="kw">if</span>( v ) v-&gt;parent = u-&gt;parent;
  }

  node* subtree_minimum( node *u ) {
    <span class="kw">while</span>( u-&gt;left ) u = u-&gt;left;
    <span class="kw">return</span> u;
  }

  node* subtree_maximum( node *u ) {
    <span class="kw">while</span>( u-&gt;right ) u = u-&gt;right;
    <span class="kw">return</span> u;
  }
<span class="kw">public</span>:
  splay_tree( ) : root( <span class="dv">0</span> ), p_size( <span class="dv">0</span> ) { }

  <span class="dt">void</span> insert( <span class="dt">const</span> T &amp;key ) {
    node *z = root;
    node *p = <span class="dv">0</span>;

    <span class="kw">while</span>( z ) {
      p = z;
      <span class="kw">if</span>( comp( z-&gt;key, key ) ) z = z-&gt;right;
      <span class="kw">else</span> z = z-&gt;left;
    }

    z = <span class="kw">new</span> node( key );
    z-&gt;parent = p;

    <span class="kw">if</span>( !p ) root = z;
    <span class="kw">else</span> <span class="kw">if</span>( comp( p-&gt;key, z-&gt;key ) ) p-&gt;right = z;
    <span class="kw">else</span> p-&gt;left = z;

    splay( z );
    p_size++;
  }

  node* find( <span class="dt">const</span> T &amp;key ) {
    node *z = root;
    <span class="kw">while</span>( z ) {
      <span class="kw">if</span>( comp( z-&gt;key, key ) ) z = z-&gt;right;
      <span class="kw">else</span> <span class="kw">if</span>( comp( key, z-&gt;key ) ) z = z-&gt;left;
      <span class="kw">else</span> <span class="kw">return</span> z;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
  }

  <span class="dt">void</span> erase( <span class="dt">const</span> T &amp;key ) {
    node *z = find( key );
    <span class="kw">if</span>( !z ) <span class="kw">return</span>;

    splay( z );

    <span class="kw">if</span>( !z-&gt;left ) replace( z, z-&gt;right );
    <span class="kw">else</span> <span class="kw">if</span>( !z-&gt;right ) replace( z, z-&gt;left );
    <span class="kw">else</span> {
      node *y = subtree_minimum( z-&gt;right );
      <span class="kw">if</span>( y-&gt;parent != z ) {
        replace( y, y-&gt;right );
        y-&gt;right = z-&gt;right;
        y-&gt;right-&gt;parent = y;
      }
      replace( z, y );
      y-&gt;left = z-&gt;left;
      y-&gt;left-&gt;parent = y;
    }

    <span class="kw">delete</span> z;
    p_size--;
  }

  <span class="dt">const</span> T&amp; minimum( ) { <span class="kw">return</span> subtree_minimum( root )-&gt;key; }
  <span class="dt">const</span> T&amp; maximum( ) { <span class="kw">return</span> subtree_maximum( root )-&gt;key; }

  <span class="dt">bool</span> empty( ) <span class="dt">const</span> { <span class="kw">return</span> root == <span class="dv">0</span>; }
  <span class="dt">unsigned</span> <span class="dt">long</span> size( ) <span class="dt">const</span> { <span class="kw">return</span> p_size; }
};

<span class="ot">#endif </span><span class="co">// SPLAY_TREE</span></code></pre></div>
</dd>
</dl>
</dd>
<dt>B-tree <code class="fold">@</code></dt>
<dd><p>In computer science, a B-tree is a self-balancing tree data structure that keeps data sorted and allows searches, sequential access, insertions, and deletions in logarithmic time. The B-tree is a generalization of a binary search tree in that a node can have more than two children (Comer 1979, p.&#160;123). Unlike self-balancing binary search trees, the B-tree is <strong>optimized for systems that read and write large blocks of data</strong>. B-trees are a good example of <strong>a data structure for external memory</strong>. It is commonly used in databases and filesystems.</p>
<dl>
<dt>multi-way search tree</dt>
<dd>A multiway tree is a tree that can have more than two children. A multiway tree of order m (or an m-way tree) is one in which a tree can have m children.
</dd>
</dl>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/B-tree.svg/600px-B-tree.svg.png" alt="A B-tree (Bayer &amp; McCreight 1972) of order 5 (Knuth 1998)." />
<p class="caption">A B-tree (Bayer &amp; McCreight 1972) of order 5 (Knuth 1998).</p>
</div>
<dl>
<dt>Etymology <code class="fold">@</code></dt>
<dd><blockquote>
<p>The origin of &#8220;B-tree&#8221; has never been explained by the authors. As we shall see, &#8220;balanced,&#8221; &#8220;broad,&#8221; or &#8220;bushy&#8221; might apply. Others suggest that the &#8220;B&#8221; stands for Boeing. Because of his contributions, however, it seems appropriate to think of B-trees as &#8220;Bayer&#8221;-trees. (Comer 1979, p.&#160;123 footnote 1)</p>
</blockquote>
</dd>
<dt>Advantages of B-tree usage for databases <code class="fold">@</code></dt>
<dd><p>The B-tree uses all of the ideas described above. In particular, a B-tree:</p>
<ul>
<li>keeps keys in sorted order for sequential traversing</li>
<li>uses a hierarchical index to minimize the number of disk reads</li>
<li>uses partially full blocks to speed insertions and deletions</li>
<li>keeps the index balanced with an elegant recursive algorithm</li>
</ul>
<p>In addition, a B-tree minimizes waste by making sure the interior nodes are at least half full. A B-tree can handle an arbitrary number of insertions and deletions.</p>
</dd>
<dt>Disadvantages of B-trees <code class="fold">@</code></dt>
<dd><p>maximum key length cannot be changed without completely rebuilding the database. This led to many database systems truncating full human names to 70 characters.</p>
</dd>
</dl>
<p>According to Knuth&#8217;s definition, <strong>a B-tree of order m</strong> is a tree which satisfies the following properties:</p>
<ul>
<li>Every node has at most m children.</li>
<li>Every non-leaf node (except root) has at least &#8968;m/2&#8969; (ceil of m/2) children.</li>
<li>The root has at least two children if it is not a leaf node.</li>
<li>A non-leaf node with k children contains k&#8722;1 keys.</li>
<li>All leaves appear in the same level</li>
</ul>
<p>It can be shown (by induction for example) that a B-tree of height h with all its nodes completely filled has n= mh+1&#8722;1 entries. Hence, the best case height of a B-tree is: log<sub>m</sub><sup>n+1</sup>.</p>
<div class="figure">
<img src="https://en.wikipedia.org/wiki/File:B_tree_insertion_example.png" alt="(A B Tree insertion example with each iteration. The nodes of this B tree have at most 3 children (Knuth order 3)." />
<p class="caption">(A B Tree insertion example with each iteration. The nodes of this B tree have at most 3 children (Knuth order 3).</p>
</div>
</dd>
<dt>Red&#8211;black tree <code class="fold">@</code></dt>
<dd><p>A red&#8211;black tree is a kind of self-balancing binary search tree. Each node of the binary tree has an extra bit, and that bit is often interpreted as the color (red or black) of the node. These color bits are used to ensure the tree remains approximately balanced during insertions and deletions.</p>
<p>Balance is preserved by painting each node of the tree with one of two colors (typically called &#8216;red&#8217; and &#8216;black&#8217;) in a way that satisfies certain properties, which collectively constrain how unbalanced the tree can become in the worst case. When the tree is modified, the new tree is subsequently rearranged and repainted to restore the coloring properties. The properties are designed in such a way that this <strong>rearranging and recoloring can be performed efficiently</strong>.</p>
<p>The balancing of the tree is not perfect, but it is good enough to allow it to guarantee <strong>searching in O(log n) time</strong>, where n is the total number of elements in the tree. The insertion and deletion operations, along with the tree rearrangement and recoloring, are also performed in O(log n) time.</p>
<p>Tracking the color of each node requires only 1 bit of information per node because there are only two colors. The tree does not contain any other data specific to its being a red&#8211;black tree so its memory footprint is almost identical to a classic (uncolored) binary search tree. In many cases the additional bit of information can be stored at no additional memory cost.</p>
<p>The leaf nodes of red&#8211;black trees do not contain data. These leaves need not be explicit in computer memory&#8212;a null child pointer can encode the fact that this child is a leaf&#8212;but it simplifies some algorithms for operating on red&#8211;black trees if the leaves really are explicit nodes. To save memory, sometimes a single sentinel node performs the role of all leaf nodes; all references from internal nodes to leaf nodes then point to the sentinel node.</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/750px-Red-black_tree_example.svg.png" alt="An example of a red&#8211;black tree" />
<p class="caption">An example of a red&#8211;black tree</p>
</div>
<p>properties</p>
<ol>
<li>A node is either red or black.</li>
<li><strong>The root is black</strong>. This rule is sometimes omitted. Since the root can always be changed from red to black, but not necessarily vice versa, this rule has little effect on analysis.</li>
<li><strong>All leaves (NIL) are black.</strong></li>
<li><strong>If a node is red, then both its children are black.</strong></li>
<li>Every path from a given node to any of its descendant NIL nodes contains <strong>the same number of black nodes</strong>. Some definitions: the number of black nodes from the root to a node is the node&#8217;s &#12304;black depth; the uniform number of black nodes in all paths from root to the leaves is called the &#12304;black-height&#12305; of the red&#8211;black tree.</li>
</ol>
<p>These constraints enforce a critical property of red&#8211;black trees: the path from the root to the farthest leaf is no more than twice as long as the path from the root to the nearest leaf. The result is that the tree is roughly height-balanced. Since operations such as inserting, deleting, and finding values require worst-case time proportional to the height of the tree, this theoretical upper bound on the height allows red&#8211;black trees to be efficient in the worst case, unlike ordinary binary search trees.</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Red-black_tree_example_%28B-tree_analogy%29.svg/640px-Red-black_tree_example_%28B-tree_analogy%29.svg.png" alt="The same red&#8211;black tree as in the example above, seen as a B-tree." />
<p class="caption">The same red&#8211;black tree as in the example above, seen as a B-tree.</p>
</div>
<p>The red&#8211;black tree is then structurally equivalent to a B-tree of order 4, with a minimum fill factor of 33% of values per cluster with a maximum capacity of 3 values.</p>
<p>This B-tree type is still more general than a red&#8211;black tree though, as it allows ambiguity in a red&#8211;black tree conversion&#8212;multiple red&#8211;black trees can be produced from an equivalent B-tree of order 4.</p>
<dl>
<dt>Insertion <code class="fold">@</code></dt>
<dd><p>RB-tree properties:</p>
<ul>
<li>property 3 (all leaves are black) always holds.</li>
<li>property 4 (both children of every red node are black) is threatened only by adding a red node, repainting a black node red, or a rotation.</li>
<li>property 5 (all paths from any given node to its leaf nodes contain the same number of black nodes) is threatened only by adding a black node, repainting a red node black (or vice versa), or a rotation.</li>
</ul>
<dl>
<dt>N: &#24403;&#21069; node&#65292;P&#65306;parent node&#65292;G&#65306;grandparent node&#65292;U&#65306;uncle node&#12290; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> node *grandparent(<span class="kw">struct</span> node *n)
{
    <span class="kw">if</span> ((n != NULL) &amp;&amp; (n-&gt;parent != NULL))
        <span class="kw">return</span> n-&gt;parent-&gt;parent;
    <span class="kw">else</span>
        <span class="kw">return</span> NULL;
}

<span class="kw">struct</span> node *uncle(<span class="kw">struct</span> node *n)
{
    <span class="kw">struct</span> node *g = grandparent(n);
    <span class="kw">if</span> (g == NULL)
        <span class="kw">return</span> NULL; <span class="co">// No grandparent means no uncle</span>
    <span class="kw">if</span> (n-&gt;parent == g-&gt;left)
        <span class="kw">return</span> g-&gt;right;
    <span class="kw">else</span>
        <span class="kw">return</span> g-&gt;left;
}

<span class="kw">struct</span> node *sibling(<span class="kw">struct</span> node *n)
{
    <span class="kw">if</span> ((n == NULL) || (n-&gt;parent == NULL))
        <span class="kw">return</span> NULL; <span class="co">// no parent means no sibling</span>
    <span class="kw">if</span> (n == n-&gt;parent-&gt;left)
        <span class="kw">return</span> n-&gt;parent-&gt;right;
    <span class="kw">else</span>
        <span class="kw">return</span> n-&gt;parent-&gt;left;
}</code></pre></div>
</dd>
</dl>
<p>There are several cases of red&#8211;black tree insertion to handle:</p>
<ol style="list-style-type: decimal">
<li><dl>
<dt>N is the root node, i.e., first node of red&#8211;black tree <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> insert_case1(<span class="kw">struct</span> node *n)
{
    <span class="kw">if</span> (n-&gt;parent == NULL)
        n-&gt;color = BLACK;
    <span class="kw">else</span>
        insert_case2(n);
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>P is black <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> insert_case2(<span class="kw">struct</span> node *n)
{
    <span class="kw">if</span> (n-&gt;parent-&gt;color == BLACK)
        <span class="kw">return</span>; <span class="co">/* Tree is still valid */</span>
    <span class="kw">else</span>
        insert_case3(n);
}</code></pre></div>
<p>The current node&#8217;s parent P is black, so property 4 (both children of every red node are black) is not invalidated. In this case, the tree is still valid. Property 5 (all paths from any given node to its leaf nodes contain the same number of black nodes) is not threatened, because the current node N has two black leaf children, but because N is red, the paths through each of its children have the same number of black nodes as the path through the leaf it replaced, which was black, and so this property remains satisfied.</p>
<p>Note: In the following cases it can be assumed that N has a grandparent node G, because its parent P is red, and if it were the root, it would be black. Thus, N also has an uncle node U, although it may be a leaf in cases 4 and 5.</p>
</dd>
</dl></li>
<li><dl>
<dt>P &amp; U are red <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Red-black_tree_insert_case_3.svg/600px-Red-black_tree_insert_case_3.svg.png" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> insert_case3(<span class="kw">struct</span> node *n)
{
    <span class="kw">struct</span> node *u = uncle(n), *g;

    <span class="kw">if</span> ((u != NULL) &amp;&amp; (u-&gt;color == RED)) {
        n-&gt;parent-&gt;color = BLACK;
        u-&gt;color = BLACK;
        g = grandparent(n);
        g-&gt;color = RED;
        insert_case1(g);
    } <span class="kw">else</span> {
        insert_case4(n);
    }
}</code></pre></div>
<p>Note: In the remaining cases, it is assumed that the parent node P is the left child of its parent. If it is the right child, left and right should be reversed throughout cases 4 and 5. The code samples take care of this.</p>
</dd>
</dl></li>
<li><dl>
<dt>N is added to right of left child of grandparent, or N is added to left of right child of grandparent (P is red and U is black) <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="https://en.wikipedia.org/wiki/File:Red-black_tree_insert_case_4.svg" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> insert_case4(<span class="kw">struct</span> node *n)
{
    <span class="kw">struct</span> node *g = grandparent(n);

    <span class="kw">if</span> ((n == n-&gt;parent-&gt;right) &amp;&amp; (n-&gt;parent == g-&gt;left)) {
        rotate_left(n-&gt;parent);

        <span class="co">/*</span>
<span class="co">         * rotate_left can be the below because of already having *g =  grandparent(n)</span>
<span class="co">         *</span>
<span class="co">         * struct node *saved_p=g-&gt;left, *saved_left_n=n-&gt;left;</span>
<span class="co">         * g-&gt;left=n;</span>
<span class="co">         * n-&gt;left=saved_p;</span>
<span class="co">         * saved_p-&gt;right=saved_left_n;</span>
<span class="co">         *</span>
<span class="co">         * and modify the parent&#39;s nodes properly</span>
<span class="co">         */</span>

        n = n-&gt;left;

    } <span class="kw">else</span> <span class="kw">if</span> ((n == n-&gt;parent-&gt;left) &amp;&amp; (n-&gt;parent == g-&gt;right)) {
        rotate_right(n-&gt;parent);

        <span class="co">/*</span>
<span class="co">         * rotate_right can be the below to take advantage of already having *g =  grandparent(n)</span>
<span class="co">         *</span>
<span class="co">         * struct node *saved_p=g-&gt;right, *saved_right_n=n-&gt;right;</span>
<span class="co">         * g-&gt;right=n;</span>
<span class="co">         * n-&gt;right=saved_p;</span>
<span class="co">         * saved_p-&gt;left=saved_right_n;</span>
<span class="co">         *</span>
<span class="co">         */</span>

        n = n-&gt;right;
    }
    insert_case5(n);
}</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>N is added to left of left child of grandparent, or N is added to right of right child of grandparent (P is red and U is black) <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Red-black_tree_insert_case_5.svg/600px-Red-black_tree_insert_case_5.svg.png" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> insert_case5(<span class="kw">struct</span> node *n)
{
    <span class="kw">struct</span> node *g = grandparent(n);

    n-&gt;parent-&gt;color = BLACK;
    g-&gt;color = RED;
    <span class="kw">if</span> (n == n-&gt;parent-&gt;left)
        rotate_right(g);
    <span class="kw">else</span>
        rotate_left(g);
}</code></pre></div>
<p>Note that inserting is actually in-place, since all the calls above use tail recursion.</p>
</dd>
</dl></li>
</ol>
</dd>
<dt>Removal :TODO: <code class="fold">@</code></dt>
<dd><p>todo.</p>
</dd>
</dl>
<p>&#21487;&#38752;&#24615;&#12289;&#31283;&#23450;&#24615;</p>
</dd>
<dt>k-d tree <code class="fold">@</code></dt>
<dd><p>In computer science, a k-d tree (short for <strong>k-dimensional tree</strong>) is a space-partitioning data structure for organizing points in a k-dimensional space. k-d trees are a useful data structure for several applications, such as searches involving a multidimensional search key (e.g.&#160;range searches and nearest neighbor searches). k-d trees are a special case of binary space partitioning trees.</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/b/b6/3dtree.png" alt="A 3-dimensional k-d tree. The first split (the red vertical plane) cuts the root cell (white) into two subcells, each of which is then split (by the green horizontal planes) into two subcells. Finally, those four cells are split (by the four blue vertical planes) into two subcells. Since there is no more splitting, the final eight are called leaf cells." />
<p class="caption">A 3-dimensional k-d tree. The first split (the red vertical plane) cuts the root cell (white) into two subcells, each of which is then split (by the green horizontal planes) into two subcells. Finally, those four cells are split (by the four blue vertical planes) into two subcells. Since there is no more splitting, the final eight are called leaf cells.</p>
</div>
<p>The k-d tree is a <strong>binary tree</strong> in which every node is a k-dimensional point. Every non-leaf node can be thought of as implicitly generating a splitting hyperplane that divides the space into two parts, known as half-spaces. Points to the left of this hyperplane are represented by the left subtree of that node and points right of the hyperplane are represented by the right subtree. The hyperplane direction is chosen in the following way: every node in the tree is associated with one of the k-dimensions, with the hyperplane perpendicular to that dimension&#8217;s axis. So, for example, if for a particular split the &#8220;x&#8221; axis is chosen, all points in the subtree with a smaller &#8220;x&#8221; value than the node will appear in the left subtree and all points with larger &#8220;x&#8221; value will be in the right subtree. In such a case, the hyperplane would be set by the x-value of the point, and its normal would be the unit x-axis.</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bf/Kdtree_2d.svg/555px-Kdtree_2d.svg.png" alt="k-d tree decomposition for the point set (2,3), (5,4), (9,6), (4,7), (8,1), (7,2)." />
<p class="caption">k-d tree decomposition for the point set (2,3), (5,4), (9,6), (4,7), (8,1), (7,2).</p>
</div>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/25/Tree_0001.svg/555px-Tree_0001.svg.png" alt="The resulting k-d tree." />
<p class="caption">The resulting k-d tree.</p>
</div>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/K-d_tree">k-d tree - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/B-tree">B-tree - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red&#8211;black tree - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Spanning_tree">Spanning tree - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">Self-balancing binary search tree - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Splay_tree">Splay tree - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Binary_search_tree">Binary search tree - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/AVL_tree">AVL tree - Wikipedia, the free encyclopedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Prim%27s_algorithm">Prim&#8217;s algorithm - Wikipedia, the free encyclopedia</a></li>
<li><a href="http://faculty.cs.niu.edu/~freedman/340/340notes/340multi.htm">Mutli-way Trees</a></li>
</ul>
</dd>
<dt>Hash Function <code class="fold">@</code></dt>
<dd><p>A hash function is any function that can be used to map data of arbitrary size to data of fixed size. The values returned by a hash function are called hash values, hash codes, hash sums, or simply hashes.</p>
<dl>
<dt>Perfect hashing</dt>
<dd><p>A hash function that is <strong>injective</strong>&#8212;that is, maps each valid input to a different hash value&#8212;is said to be perfect. With such a function one can directly locate the desired entry in a hash table, without any additional searching.</p>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Hash_function">Hash function - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
<dt>Dijkstra&#8217;s algorithm <code class="fold">@</code></dt>
<dd><p>Dijkstra&#8217;s algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif" alt="Dijkstra&#8217;s algorithm to find the shortest path between a and b. It picks the unvisited vertex with the lowest distance, calculates the distance through it to each unvisited neighbor, and updates the neighbor&#8217;s distance if smaller. Mark visited (set to red) when done with neighbors." />
<p class="caption">Dijkstra&#8217;s algorithm to find the shortest path between a and b. It picks the unvisited vertex with the lowest distance, calculates the distance through it to each unvisited neighbor, and updates the neighbor&#8217;s distance if smaller. Mark visited (set to red) when done with neighbors.</p>
</div>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/2/23/Dijkstras_progress_animation.gif" />

</div>
<pre><code> 1  function Dijkstra(Graph, source):
 2
 3      create vertex set Q
 4
 5      for each vertex v in Graph:             // Initialization
 6          dist[v] &#8592; INFINITY                  // Unknown distance from source to v
 7          prev[v] &#8592; UNDEFINED                 // Previous node in optimal path from source
 8          add v to Q                          // All nodes initially in Q (unvisited nodes)
 9
10      dist[source] &#8592; 0                        // Distance from source to source
11
12      while Q is not empty:
13          u &#8592; vertex in Q with min dist[u]    // Source node will be selected first
14          remove u from Q
15
16          for each neighbor v of u:           // where v is still in Q.
17              alt &#8592; dist[u] + length(u, v)
18              if alt &lt; dist[v]:               // A shorter path to v has been found
19                  dist[v] &#8592; alt
20                  prev[v] &#8592; u
21
22      return dist[], prev[]</code></pre>
<p>If we are only interested in a shortest path between vertices source and target, we can terminate the search after line 13 if u = target. Now we can read the shortest path from source to target by reverse iteration:</p>
<pre><code> 1  S &#8592; empty sequence
 2  u &#8592; target
 3  while prev[u] is defined:                  // Construct the shortest path with a stack S
 4      insert u at the beginning of S         // Push the vertex onto the stack
 5      u &#8592; prev[u]                            // Traverse from target to source
 6  insert u at the beginning of S             // Push the source onto the stack</code></pre>
<p>Using a priority queue</p>
<pre><code> 1  function Dijkstra(Graph, source):
 2      dist[source] &#8592; 0                                // Initialization
 3
 4      create vertex set Q
 5
 6      for each vertex v in Graph:
 7          if v &#8800; source
 8              dist[v] &#8592; INFINITY                      // Unknown distance from source to v
 9              prev[v] &#8592; UNDEFINED                     // Predecessor of v
10
11         Q.add_with_priority(v, dist[v])
12
13
14      while Q is not empty:                           // The main loop
15          u &#8592; Q.extract_min()                         // Remove and return best vertex
16          for each neighbor v of u:                   // only v that is still in Q
17              alt = dist[u] + length(u, v)
18              if alt &lt; dist[v]
19                  dist[v] &#8592; alt
20                  prev[v] &#8592; u
21                  Q.decrease_priority(v, alt)
22
23     return dist[], prev[]</code></pre>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra&#8217;s algorithm - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
<dt><code>A*</code> search algorithm <code class="fold">@</code></dt>
<dd><p>In computer science, <code>A*</code> (pronounced as &#8220;A star&#8221;) is a computer algorithm that is widely used in pathfinding and graph traversal, the process of plotting an efficiently traversable path between multiple points, called nodes. Noted for its performance and accuracy, it enjoys widespread use. However, in practical travel-routing systems, it is generally outperformed by algorithms which can pre-process the graph to attain better performance, although other work has found <code>A*</code> to be superior to other approaches.</p>
<p><code>A*</code> achieves better performance by using heuristics to guide its search.</p>
<p><code>A*</code> selects the path that minimizes: f(n) = g(n) + h(n), n: node, g: cost dist, h: heuristic dist.</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/5/5d/Astar_progress_animation.gif" />

</div>
<div class="figure">
<img src="https://en.wikipedia.org/wiki/File:AstarExampleEn.gif" alt="Key: green: start; blue: goal; orange: visited" />
<p class="caption">Key: green: start; blue: goal; orange: visited</p>
</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">function A*(start, goal)
    <span class="co">// The set of nodes already evaluated.</span>
    closedSet := {}
    <span class="co">// The set of currently discovered nodes still to be evaluated.</span>
    <span class="co">// Initially, only the start node is known.</span>
    openSet := {start}
    <span class="co">// For each node, which node it can most efficiently be reached from.</span>
    <span class="co">// If a node can be reached from many nodes, cameFrom will eventually contain the</span>
    <span class="co">// most efficient previous step.</span>
    cameFrom := the empty map

    <span class="co">// For each node, the cost of getting from the start node to that node.</span>
    gScore := map with <span class="kw">default</span> value of Infinity
    <span class="co">// The cost of going from start to start is zero.</span>
    gScore[start] := <span class="dv">0</span>
    <span class="co">// For each node, the total cost of getting from the start node to the goal</span>
    <span class="co">// by passing by that node. That value is partly known, partly heuristic.</span>
    fScore := map with <span class="kw">default</span> value of Infinity
    <span class="co">// For the first node, that value is completely heuristic.</span>
    fScore[start] := heuristic_cost_estimate(start, goal)

    <span class="kw">while</span> openSet is <span class="kw">not</span> empty
        current := the node in openSet having the lowest fScore[] value
        <span class="kw">if</span> current = goal
            <span class="kw">return</span> reconstruct_path(cameFrom, current)

        openSet.Remove(current)
        closedSet.Add(current)
        <span class="kw">for</span> each neighbor of current
            <span class="kw">if</span> neighbor in closedSet
                <span class="kw">continue</span>        <span class="co">// Ignore the neighbor which is already evaluated.</span>
            <span class="co">// The distance from start to a neighbor</span>
            tentative_gScore := gScore[current] + dist_between(current, neighbor)
            <span class="kw">if</span> neighbor <span class="kw">not</span> in openSet  <span class="co">// Discover a new node</span>
                openSet.Add(neighbor)
            <span class="kw">else</span> <span class="kw">if</span> tentative_gScore &gt;= gScore[neighbor]
                <span class="kw">continue</span>        <span class="co">// This is not a better path.</span>

            <span class="co">// This path is the best until now. Record it!</span>
            cameFrom[neighbor] := current
            gScore[neighbor] := tentative_gScore
            fScore[neighbor] := gScore[neighbor] + heuristic_cost_estimate(neighbor, goal)

    <span class="kw">return</span> failure

function reconstruct_path(cameFrom, current)
    total_path := [current]
    <span class="kw">while</span> current in cameFrom.Keys:
        current := cameFrom[current]
        total_path.append(current)
    <span class="kw">return</span> total_path</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/A*_search_algorithm"><code>A*</code> search algorithm - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
<dt>Travelling salesman problem <code class="fold">@</code></dt>
<dd><p>The travelling salesman problem (TSP) asks the following question: Given a list of <strong>cities</strong> and the <strong>distances</strong> between each pair of cities, what is the <strong>shortest possible route that visits each city exactly once and returns to the origin city</strong>? It is an NP-hard problem in combinatorial optimization, important in operations research and theoretical computer science.</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/GLPK_solution_of_a_travelling_salesman_problem.svg/330px-GLPK_solution_of_a_travelling_salesman_problem.svg.png" alt="Solution of a travelling salesman problem" />
<p class="caption">Solution of a travelling salesman problem</p>
</div>
<p><strong>TSP can be modelled as an undirected weighted graph</strong>, such that cities are the graph&#8217;s vertices, paths are the graph&#8217;s edges, and a path&#8217;s distance is the edge&#8217;s length. It is a minimization problem starting and finishing at a specified vertex after having visited each other vertex exactly once. Often, the model is a complete graph (i.e.&#160;each pair of vertices is connected by an edge). If no path exists between two cities, adding an arbitrarily long edge will complete the graph without affecting the optimal tour.</p>
<dl>
<dt>Exact algorithms</dt>
<dd><p>try all permutations (ordered combinations) -&gt; brute force, O(n!)</p>
</dd>
<dt>Heuristic and approximation algorithms</dt>
<dd><p>NN &#36817;&#37051;&#27861;</p>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">Travelling salesman problem - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
</dl>
</dd>
<dt>Blog Posts <code class="fold">@</code></dt>
<dd><ul>
<li><dl>
<dt>C++ &#23454;&#29616;&#30340; B+ &#26641; <code class="fold">@</code></dt>
<dd><p>refs and see also</p>
<ul>
<li><a href="https://github.com/ghostrong/algorithm/blob/master/bptree.c">algorithm/bptree.c at master &#183; ghostrong/algorithm</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>OJ &#24037;&#20855; <code class="fold">@</code></dt>
<dd><p>getx.h</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="kw">namespace</span> oj {

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
T get(istream &amp; is = cin) {
    T val;
    is &gt;&gt; val;
    <span class="kw">return</span> val;
}

}</code></pre></div>
<p>link-list.h</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> LinkList {
<span class="kw">public</span>:
    T val;
    LinkList* next;
    LinkList(T _val = <span class="dv">0</span>): val(_val), next(NULL) {}
};

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
ostream&amp; <span class="kw">operator</span>&lt;&lt;(ostream&amp; o, LinkList&lt;T&gt;* head){
    <span class="kw">while</span>(head){
        o&lt;&lt;head-&gt;val;
        <span class="kw">if</span>(head-&gt;next) o&lt;&lt;<span class="st">&quot;-&gt;&quot;</span>;
        head = head-&gt;next;
    }
    <span class="kw">return</span> o;
}</code></pre></div>
<p>pair.h</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> T1, <span class="kw">class</span> T2&gt;
istream &amp; <span class="kw">operator</span>&gt;&gt; (istream &amp; is, pair&lt;T1, T2&gt;&amp; p) {
    T1 k;
    T2 v;
    is &gt;&gt; k &gt;&gt; v;
    p.first = k;
    p.second = v;
    <span class="kw">return</span> is;
}

<span class="kw">template</span>&lt;<span class="kw">typename</span> T1, <span class="kw">typename</span> T2&gt;
ostream &amp; <span class="kw">operator</span>&lt;&lt; (ostream &amp; o, pair&lt;T1, T2&gt;&amp; p) {
    <span class="kw">return</span> o &lt;&lt; <span class="st">&#39;&lt;&#39;</span> &lt;&lt; p.first &lt;&lt; <span class="st">&quot;,&quot;</span> &lt;&lt; p.second &lt;&lt; <span class="st">&#39;&gt;&#39;</span>;
}</code></pre></div>
<p>set.h, map.h</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;sstream&gt;</span>
<span class="ot">#include &lt;set&gt;</span>
<span class="ot">#include &lt;unordered_set&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// set</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
istream&amp; <span class="kw">operator</span>&gt;&gt;(istream&amp; is, set&lt;T&gt;&amp; st){
    string s; getline(is, s);
    stringstream ss(s);
    T v;
    <span class="kw">while</span>(ss&gt;&gt;v){
        st.insert(v);
    }
    <span class="kw">return</span> is;
}
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
ostream&amp; <span class="kw">operator</span>&lt;&lt;(ostream&amp; o, set&lt;T&gt;&amp; st){
    size_t i = st.size() - <span class="dv">1</span>;
    <span class="kw">typename</span> set&lt;T&gt;::iterator it;
    o&lt;&lt;<span class="st">&quot;{&quot;</span>;
    <span class="kw">for</span>(it = st.begin(); it != st.end(); ++it, --i){
        o&lt;&lt;*it;
        <span class="kw">if</span>(i) o&lt;&lt;<span class="st">&#39;,&#39;</span>;
    }
    <span class="kw">return</span> o&lt;&lt;<span class="st">&quot;}&quot;</span>;
}

<span class="co">// map</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> T1, <span class="kw">typename</span> T2&gt;
istream &amp; <span class="kw">operator</span>&gt;&gt;(istream &amp; is, map&lt;T1, T2&gt;&amp; m) {
    string s;
    getline(is, s);
    stringstream ss(s);
    T1 k;
    T2 v;
    <span class="kw">while</span>(ss &gt;&gt; k &gt;&gt; v){
        m[k] = v;
    }
    <span class="kw">return</span> is;
}
<span class="kw">template</span>&lt;<span class="kw">typename</span> T1, <span class="kw">typename</span> T2&gt;
ostream&amp; <span class="kw">operator</span>&lt;&lt;(ostream&amp; o, <span class="dt">const</span> map&lt;T1, T2&gt;&amp; c) {
    o &lt;&lt; <span class="st">&quot;{&quot;</span>;
    <span class="kw">for</span>(<span class="kw">auto</span> pr : c) o &lt;&lt; pr &lt;&lt; <span class="st">&#39; &#39;</span>;
    <span class="kw">return</span> o &lt;&lt; <span class="st">&quot;</span><span class="ch">\b</span><span class="st">}&quot;</span>;
}</code></pre></div>
<p>vector.h</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
ostream &amp; <span class="kw">operator</span>&lt;&lt; (ostream &amp; o, <span class="dt">const</span> vector&lt;T&gt;&amp; v){
    o &lt;&lt; <span class="st">&quot;[&quot;</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;v.size(); ++i){
        o &lt;&lt; v[i];
        <span class="kw">if</span>(i&lt;v.size()<span class="dv">-1</span>) o&lt;&lt; <span class="st">&#39;,&#39;</span>;
    }
    <span class="kw">return</span> o &lt;&lt; <span class="st">&quot;]&quot;</span>;
}

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
istream &amp; <span class="kw">operator</span>&gt;&gt;(istream &amp; is, vector&lt;T&gt;&amp; v){
    string s; getline(is, s);
    stringstream ss(s);
    T tmp;
    <span class="kw">while</span>(ss &gt;&gt; tmp){
        v.push_back(tmp);
    }
    <span class="kw">return</span> is;
}</code></pre></div>
<p>refs and see also</p>
<ul>
<li><a href="https://github.com/harttle/oj.h/tree/master/lib">oj.h/lib at master &#183; harttle/oj.h</a></li>
</ul>
</dd>
</dl></li>
<li><p><a href="https://www.tianmaying.com/tutorial/MS2015_Dec2_2">&#24494;&#36719; 2015 &#26657;&#22253;&#25307;&#32856; Dec2 #2 Have Lunch Together | &#22825;&#30721;&#33829; - &#26032;&#19968;&#20195;&#25216;&#26415;&#23398;&#20064;&#26381;&#21153;&#24179;&#21488;</a></p></li>
<li><dl>
<dt><a href="https://www.douban.com/note/332117149/">LeetCode&#65306; &#19968;&#20123;&#32534;&#31243;&#24515;&#24471;</a> <code class="fold">@</code></dt>
<dd><p>LeetCode &#23545;&#22522;&#30784;&#25968;&#25454;&#32467;&#26500;&#21644;&#22522;&#30784;&#31639;&#27861;&#26159;&#24456;&#22909;&#30340;&#35757;&#32451;&#21644;&#32771;&#26597;&#12290;</p>
<dl>
<dt>&#65288;1&#65289;&#28041;&#21450;&#30340;&#37325;&#35201;&#25968;&#25454;&#32467;&#26500;&#65306;</dt>
<dd>&#25968;&#32452;&#65288;&#19968;&#32500;&#65292;&#22810;&#32500;&#65289;&#65292;&#38142;&#34920;&#65292;&#26632;&#65292;&#38431;&#21015;&#65292;&#20108;&#21449;&#26641;&#65292;&#26080;&#21521;&#22270;&#65292;&#25955;&#21015;&#65292;&#12290;&#12290;&#12290;
</dd>
<dt>&#65288;2&#65289;&#28041;&#21450;&#30340;&#37325;&#35201;&#31639;&#27861;&#25216;&#26415;&#65306;</dt>
<dd>&#36138;&#24515;&#65292;&#21160;&#24577;&#35268;&#21010;&#65292;&#20998;&#27835;&#65288;&#36882;&#24402;&#65289;&#65292;&#22238;&#28335;&#65288;&#21098;&#26525;&#65289;&#65292;&#25628;&#32034;&#65288;&#24191;&#25628;&#65292;&#28145;&#25628;&#65289;&#65292;&#12290;&#12290;&#12290;
</dd>
</dl>
<p>&#21047;&#39064;&#21518;&#30340;&#19968;&#20123;&#20307;&#20250;&#65288;&#20197;&#19979;&#35828;&#27861;&#19981;&#32477;&#23545;&#65289;&#65306;</p>
<ul>
<li>1&#65292;&#19968;&#33324;&#26469;&#35828;&#65292;&#36138;&#24515;&#30340;&#26102;&#38388;&#22797;&#26434;&#24230;&#22312; O(n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230;&#26159; O(1) &#25110; O(n) &#12290;</li>
<li>2&#65292;&#21160;&#35268;&#38656;&#35201;&#35760;&#24405;&#34920;&#65288;&#26631;&#35760;&#25968;&#32452;&#65289;&#65292;&#26102;&#38388;&#22797;&#26434;&#24230;&#32463;&#24120;&#26159; O(n<sup>2</sup>)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230;&#20063;&#36890;&#24120;&#26159; O(n<sup>2</sup>) &#12290;</li>
<li>3&#65292;&#22238;&#28335;&#24456;&#24120;&#35265;&#65292;&#37325;&#28857;&#26159;&#30830;&#23450;&#20309;&#26102;&#25214;&#21040;&#19968;&#20010;&#35299;&#12289;&#20309;&#26102;&#36864;&#20986;&#12289;&#36234;&#30028;&#26102;&#22914;&#20309;&#22788;&#29702;&#65307;&#36890;&#24120;&#38656;&#35201;&#19968;&#20010;&#32447;&#24615;&#32467;&#26500;&#26469;&#20445;&#23384;&#21069;&#38754;&#30340;&#29366;&#24577;&#65292;&#20197;&#20415;&#22238;&#28335;&#26102;&#20351;&#29992;&#12290;</li>
<li>4&#65292;&#22914;&#26524;&#36138;&#24515;&#12289;&#21160;&#35268;&#31561;&#26041;&#27861;&#37117;&#34892;&#19981;&#36890;&#65292;&#36890;&#24120;&#23601;&#32771;&#34385;&#25628;&#32034;&#26469;&#35299;&#20915;&#12290;</li>
<li>5&#65292;&#32447;&#24615;&#26102;&#38388;&#22797;&#26434;&#24230;&#19968;&#33324;&#36890;&#36807;&#36138;&#24515;&#26041;&#27861;&#23454;&#29616;&#65307;&#26377;&#26102;&#20505;&#65292;&#38656;&#35201;&#20511;&#21161; HASH &#32467;&#26500;&#65288;&#22914; unordered_map&#65289;&#12290;</li>
<li>6&#65292;&#21033;&#29992;&#22909;&#26632; (stack)&#65281;&#24456;&#22810;&#38382;&#39064;&#36890;&#36807;&#26632;&#33021;&#22815;&#22312; O(n) &#26102;&#38388;&#20869;&#35299;&#20915;&#12290;</li>
<li>7&#65292;&#28145;&#24230;&#20248;&#20808;&#25628;&#32034;&#19968;&#33324;&#26159;&#36882;&#24402;&#30340;&#65292;&#25968;&#25454;&#36807;&#22823;&#26102;&#65292;&#36882;&#24402;&#28145;&#24230;&#22826;&#22823;&#20986;&#29616;&#38382;&#39064;&#65307;&#24191;&#24230;&#20248;&#20808;&#25628;&#32034;&#19968;&#33324;&#20511;&#21161;&#38431;&#21015;&#65292;&#19968;&#33324;&#19981;&#38656;&#35201;&#36882;&#24402;&#12290;</li>
<li>8&#65292;&#21021;&#22987;&#21270;&#25968;&#32452;&#26102;&#65292;memset(address, value, n_bytes) (&#21253;&#21547;&#22312; cstring.h) &#26159;&#38024;&#23545;&#8220;&#23383;&#33410;&#8221;&#36171;&#20540;&#65281;&#25152;&#20197;&#38500;&#38750;&#26159;&#21333;&#23383;&#33410;&#20803;&#32032;&#65292;&#25110;&#32773;&#21021;&#20540;&#20026; 0 &#25110;&#32773; -1&#65292;&#21542;&#21017;&#19981;&#35201;&#29992; memset &#21021;&#22987;&#21270;&#65307;&#20351;&#29992; vector &#27604;&#36739;&#26041;&#20415;&#12290;</li>
<li>9&#65292;&#24517;&#35201;&#26102;&#65292;&#20351;&#29992; unordered_map, unordered_set &#31561; C++ &#23481;&#22120;&#12290;</li>
<li>10&#65292;&#24517;&#35201;&#26102;&#65292;&#21033;&#29992;&#31867;&#21464;&#37327;&#31616;&#21270;&#20256;&#21442;&#12290;</li>
<li>11&#65292;&#21160;&#35268;&#30340;&#20851;&#38190;&#26159;&#25214;&#21040;&#36716;&#31227;&#26041;&#31243;&#65307;&#22240;&#27492;&#21160;&#35268;&#30340;&#23376;&#38382;&#39064;&#20855;&#26377;&#8220;&#32047;&#31215;&#8221;&#24615;&#36136;&#12290;</li>
<li>12&#65292;&#36138;&#24515;&#19981;&#21516;&#20110;&#21160;&#35268;&#65292;&#36138;&#24515;&#30340;&#23376;&#38382;&#39064;&#19981;&#26159;&#8220;&#32047;&#31215;&#24615;&#8220;&#65292;&#32780;&#26159;&#20855;&#26377;&#8220;&#20915;&#23450;&#24615;&#8221;&#12290;</li>
<li>13&#65292;&#20889;&#20195;&#30721;&#26368;&#37325;&#35201;&#30340;&#26159;&#24605;&#36335;&#28165;&#26970;&#12289;&#21487;&#29702;&#35299;&#24615;&#65292;&#32780;&#19981;&#26159;&#32416;&#32467;&#21464;&#37327;&#23569;&#12289;&#20195;&#30721;&#30701;&#31561;&#26080;&#20851;&#32039;&#35201;&#30340;&#38382;&#39064;&#12290;</li>
<li>14&#65292;&#30001;&#20110;&#21333;&#38142;&#34920;&#21482;&#33021;&#20174;&#21069;&#21521;&#21518;&#36941;&#21382;&#65292;&#22240;&#27492;&#25805;&#20316;&#26102;&#32463;&#24120;&#38656;&#35201;&#20445;&#23384;&#25152;&#20851;&#24515;&#32467;&#28857;&#30340;&#21069;&#36235;&#32467;&#28857;&#12290;</li>
<li>15&#65292;&#22788;&#29702;&#38142;&#34920;&#35201;&#26102;&#21051;&#27880;&#24847;&#26816;&#26597;&#31354;&#25351;&#38024; NULL&#12290;</li>
<li>16&#65292;&#25968;&#32452;&#26816;&#32034;&#12289;&#23450;&#20301;&#24555;&#65307;&#38142;&#34920;&#25554;&#20837;&#12289;&#21024;&#38500;&#24555;&#65288;&#19981;&#38656;&#35201;&#31227;&#21160;&#25968;&#25454;&#65289;&#12290;</li>
<li>17&#65292;vector, string &#30340;&#24615;&#36136;&#37117;&#20542;&#21521;&#20110;&#25968;&#32452;&#65307;List &#30340;&#24615;&#36136;&#20542;&#21521;&#20110;&#38142;&#34920;&#12290;</li>
<li>18&#65292;&#20108;&#21449;&#26641;&#38382;&#39064;&#30340;&#22522;&#30784;&#26159;&#36941;&#21382;&#26041;&#27861;&#65306;&#21069;&#24207; / &#20013;&#24207; / &#21518;&#32493;&#65292;&#36882;&#24402;&#19982;&#38750;&#36882;&#24402;&#37117;&#24456;&#37325;&#35201;&#12290;</li>
<li>19&#65292;&#20851;&#20110;&#20108;&#21449;&#26641;&#30340;&#38382;&#39064;&#65292;&#26377;&#20123;&#26159;&#33258;&#39030;&#21521;&#19979;&#30340;&#65307;&#20063;&#26377;&#20123;&#26159;&#33258;&#24213;&#21521;&#19978;&#30340;&#65292;&#22914;&#26816;&#26597;&#24179;&#34913;&#20108;&#21449;&#26641;&#12290;&#36890;&#24120;&#36825;&#20004;&#31867;&#38382;&#39064;&#37117;&#21487;&#20197;&#36890;&#36807;&#36882;&#24402;&#12289;&#38750;&#36882;&#24402;&#20004;&#31181;&#26041;&#27861;&#35299;&#20915;&#12290;</li>
<li>20&#65292;&#20108;&#21449;&#26641;&#38750;&#36882;&#24402;&#36941;&#21382;&#65306;&#21069;&#24207;&#36941;&#21382;&#26368;&#31616;&#21333;&#65292;&#24403;&#21069;&#32467;&#28857;&#27809;&#26377;&#24038;&#20799;&#23376;&#26102;&#65292;&#26632;&#39030;&#23601;&#26159;&#19979;&#19968;&#20010;&#32467;&#28857;&#65307;&#20013;&#24207;&#36941;&#21382;&#38656;&#35201;&#20808;&#23558;&#24403;&#21069;&#32467;&#28857;&#65288;&#39030;&#28857;&#65289;&#20837;&#26632;&#65292;&#24403;&#21069;&#32467;&#28857;&#27809;&#26377;&#24038;&#20799;&#23376;&#26102;&#65292;&#35775;&#38382;&#26632;&#39030;&#65292;&#24182;&#19988;&#26632;&#20869;&#32467;&#28857;&#30340;&#22836;&#19968;&#20010;&#38750;&#31354;&#21491;&#20799;&#23376;&#26159;&#19979;&#19968;&#20010;&#32467;&#28857;&#65307;&#21518;&#24207;&#36941;&#21382;&#26368;&#21518;&#35775;&#38382;&#26681;&#32467;&#28857;&#65292;&#25152;&#20197;&#65292;&#39030;&#28857;&#19981;&#20165;&#35201;&#20837;&#26632;&#65292;&#32780;&#19988;&#35201;&#35760;&#24405;&#26159;&#21542;&#35775;&#38382;&#20102;&#23427;&#30340;&#21491;&#20799;&#23376;&#65292;&#21482;&#26377;&#35775;&#38382;&#20102;&#39030;&#28857;&#30340;&#21491;&#20799;&#23376;&#20043;&#21518;&#25165;&#33021;&#35775;&#38382;&#23427;&#33258;&#24049;&#12290;</li>
<li>21&#65292;&#35768;&#22810;&#38382;&#39064;&#38656;&#35201;&#24212;&#29992;&#20108;&#21449;&#26641;&#36941;&#21382;&#26041;&#27861;&#65292;&#26377;&#20123;&#38382;&#39064;&#38656;&#35201;&#22312;&#32467;&#28857;&#20837;&#26632;&#30340;&#21516;&#26102;&#20445;&#23384;&#24403;&#21069;&#29366;&#24577;&#65288;&#22914;&#27714;&#26368;&#38271;&#36335;&#24452;&#65289;&#12290;</li>
<li>22&#65292;&#20108;&#21449;&#26641; Level &#36941;&#21382;&#30340;&#26412;&#36136;&#26159;&#24191;&#24230;&#20248;&#20808;&#25628;&#32034;&#65292;&#38656;&#35201;&#21033;&#29992;&#38431;&#21015;&#12290;</li>
<li>23&#65292;&#20851;&#20110;&#8221;&#22270;&#8220;&#65292;LeetCode &#21482;&#26377;&#19968;&#36947;&#36941;&#21382;&#39064;&#30446;&#65292;&#38656;&#35201;&#21040;&#20854;&#20182;&#22320;&#26041;&#34917;&#20805;&#19968;&#19979;&#12290;</li>
<li>24&#65292;&#26377;&#20123;&#26041;&#27861;&#34429;&#28982; AC &#20102;&#65292;&#20294;&#24182;&#19981;&#19968;&#23450;&#26159;&#26368;&#20248;&#32654;&#30340;&#12290;</li>
</ul>
<p>&#65288;&#26410;&#23436;&#24453;&#32493;&#65289;</p>
<p>&#34917;&#20805;&#65306;&#22810;&#30475;&#19968;&#20123;&#32463;&#20856;&#31639;&#27861;&#30340;&#24605;&#36335;&#65292;&#30528;&#37325;&#29702;&#35299;&#31639;&#27861;&#26412;&#36136;&#36824;&#26159;&#24456;&#26377;&#24517;&#35201;&#30340;&#12290;&#27605;&#31455;&#65292;&#25968;&#25454;&#32467;&#26500;+&#31639;&#27861;&#36824;&#26159;&#26680;&#24515;&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt><a href="http://norvig.com/sudoku.html">Solving Every Sudoku Puzzle</a> <code class="fold">@</code></dt>
<dd><pre><code> A1 A2 A3| A4 A5 A6| A7 A8 A9    4 . . |. . . |8 . 5     4 1 7 |3 6 9 |8 2 5
 B1 B2 B3| B4 B5 B6| B7 B8 B9    . 3 . |. . . |. . .     6 3 2 |1 5 8 |9 4 7
 C1 C2 C3| C4 C5 C6| C7 C8 C9    . . . |7 . . |. . .     9 5 8 |7 2 4 |3 1 6
---------+---------+---------    ------+------+------    ------+------+------
 D1 D2 D3| D4 D5 D6| D7 D8 D9    . 2 . |. . . |. 6 .     8 2 5 |4 3 7 |1 6 9
 E1 E2 E3| E4 E5 E6| E7 E8 E9    . . . |. 8 . |4 . .     7 9 1 |5 8 6 |4 3 2
 F1 F2 F3| F4 F5 F6| F7 F8 F9    . . . |. 1 . |. . .     3 4 6 |9 1 2 |7 5 8
---------+---------+---------    ------+------+------    ------+------+------
 G1 G2 G3| G4 G5 G6| G7 G8 G9    . . . |6 . 3 |. 7 .     2 8 9 |6 4 3 |5 7 1
 H1 H2 H3| H4 H5 H6| H7 H8 H9    5 . . |2 . . |. . .     5 7 3 |2 9 1 |6 8 4
 I1 I2 I3| I4 I5 I6| I7 I8 I9    1 . 4 |. . . |. . .     1 6 4 |8 7 5 |2 9 3</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">&quot;4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......&quot;</span>

<span class="co">&quot;&quot;&quot;</span>
<span class="co">400000805</span>
<span class="co">030000000</span>
<span class="co">000700000</span>
<span class="co">020000060</span>
<span class="co">000080400</span>
<span class="co">000010000</span>
<span class="co">000603070</span>
<span class="co">500200000</span>
<span class="co">104000000&quot;&quot;&quot;</span>

<span class="co">&quot;&quot;&quot;</span>
<span class="co">4 . . |. . . |8 . 5</span>
<span class="co">. 3 . |. . . |. . .</span>
<span class="co">. . . |7 . . |. . .</span>
<span class="co">------+------+------</span>
<span class="co">. 2 . |. . . |. 6 .</span>
<span class="co">. . . |. 8 . |4 . .</span>
<span class="co">. . . |. 1 . |. . .</span>
<span class="co">------+------+------</span>
<span class="co">. . . |6 . 3 |. 7 .</span>
<span class="co">5 . . |2 . . |. . .</span>
<span class="co">1 . 4 |. . . |. . .</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
<dl>
<dt>Constraint Propagation <code class="fold">@</code></dt>
<dd><p>The function parse_grid calls assign(values, s, d). We could implement this as values[s] = d, but we can do more than just that. Those with experience solving Sudoku puzzles know that there are two important strategies that we can use to make progress towards filling in all the squares:</p>
<ol style="list-style-type: decimal">
<li>If a square has only one possible value, then eliminate that value from the square&#8217;s peers.</li>
<li>If a unit has only one possible place for a value, then put the value there.</li>
</ol>
<p>As an example of strategy (1) if we assign 7 to A1, yielding {&#8216;A1&#8217;: &#8216;7&#8217;, &#8216;A2&#8217;:&#8216;123456789&#8217;, &#8230;}, we see that A1 has only one value, and thus the 7 can be removed from its peer A2 (and all other peers), giving us {&#8216;A1&#8217;: &#8216;7&#8217;, &#8216;A2&#8217;: &#8216;12345689&#8217;, &#8230;}. As an example of strategy (2), if it turns out that none of A3 through A9 has a 3 as a possible value, then the 3 must belong in A2, and we can update to {&#8216;A1&#8217;: &#8216;7&#8217;, &#8216;A2&#8217;:&#8216;3&#8217;, &#8230;}. These updates to A2 may in turn cause further updates to its peers, and the peers of those peers, and so on. This process is called constraint propagation.</p>
</dd>
<dt>Search <code class="fold">@</code></dt>
<dd><p>What is the search algorithm? Simple: first make sure we haven&#8217;t already found a solution or a contradiction, and if not, choose one unfilled square and consider all its possible values. One at a time, try assigning the square each value, and searching from the resulting position. In other words, we search for a value d such that we can successfully search for a solution from the result of assigning square s to d. If the search leads to an failed position, go back and consider another value of d. This is a recursive search, and we call it a depth-first search because we (recursively) consider all possibilities under values[s] = d before we consider a different value for s.</p>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="https://github.com/pauek/norvig-sudoku">pauek/norvig-sudoku: Norvig&#8217;s Sudoku solver in C++</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#19968;&#36947;&#38463;&#37324;&#31508;&#35797;&#39064;&#65292;&#24605;&#36335;&#24212;&#35813;&#26159;&#24590;&#26679;&#65311; <code class="fold">@</code></dt>
<dd><p>refs and see also</p>
<ul>
<li><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/02.09.md">The-Art-Of-Programming-By-July/02.09.md at master &#183; julycoding/The-Art-Of-Programming-By-July</a></li>
<li><a href="https://www.zhihu.com/question/50512830">&#19968;&#36947;&#38463;&#37324;&#31508;&#35797;&#39064;&#65292;&#24605;&#36335;&#24212;&#35813;&#26159;&#24590;&#26679;&#65311; - &#30693;&#20046;</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne <code class="fold">@</code></dt>
<dd><blockquote>
<p>essential information that every serious programmer needs to know about algorithms and data structures</p>
</blockquote>
<p>refs and see also</p>
<ul>
<li><a href="http://algs4.cs.princeton.edu/home/">Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne</a></li>
</ul>
</dd>
</dl></li>
<li><p><a href="http://www.cnblogs.com/avril/p/3293449.html">Leetcode: Palindrome Partitioning II - Avril - &#21338;&#23458;&#22253;</a></p></li>
<li><dl>
<dt><a href="http://note.huangz.me/">huangz/note &#8212; huangz/note</a> <code class="fold">@</code></dt>
<dd><dl>
<dt><a href="http://note.huangz.me/algorithm/arithmetic/index.html">&#31639;&#26415; &#8212; huangz/note</a> <code class="fold">@</code></dt>
<dd><dl>
<dt><a href="http://note.huangz.me/algorithm/arithmetic/power-law.html">&#24130;&#27425;&#23450;&#24459; &#8212;&#8212; Power Law &#8212; huangz/note</a> <code class="fold">@</code></dt>
<dd><p>&#22914;&#26524;&#26576;&#20214;&#20107;&#30340;&#21457;&#29983;&#39057;&#29575;&#21644;&#23427;&#30340;&#26576;&#20010;&#23646;&#24615;&#25104;&#24130;&#20851;&#31995;&#65292;&#37027;&#20040;&#36825;&#20010;&#39057;&#29575;&#23601;&#21487;&#20197;&#31216;&#20043;&#20026;&#31526;&#21512;&#24130;&#27425;&#23450;&#24459;&#12290;</p>
<p>&#24130;&#27425;&#23450;&#24459;&#30340;&#34920;&#29616;&#26159;&#65292; &#23569;&#25968;&#20960;&#20010;&#20107;&#20214;&#30340;&#21457;&#29983;&#39057;&#29575;&#21344;&#20102;&#25972;&#20010;&#21457;&#29983;&#39057;&#29575;&#30340;&#22823;&#37096;&#20998;&#65292; &#32780;&#20854;&#20313;&#30340;&#22823;&#22810;&#25968;&#20107;&#20214;&#21482;&#21344;&#25972;&#20010;&#21457;&#29983;&#39057;&#29575;&#30340;&#19968;&#20010;&#23567;&#37096;&#20998;&#65292; &#22914;&#22270;&#65306;</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/Long_tail.svg/450px-Long_tail.svg.png" />

</div>
<p>In statistics, a power law is a functional relationship between two quantities, where a relative change in one quantity results in a proportional relative change in the other quantity, independent of the initial size of those quantities: one quantity varies as a power of another. For instance, considering the area of a square in terms of the length of its side, if the length is doubled, the area is multiplied by a factor of four.</p>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Exponential_backoff">Exponential backoff - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
<dt><a href="http://note.huangz.me/algorithm/arithmetic/exponential-backoff.html">&#25351;&#25968;&#34917;&#20607; &#8212;&#8212; Exponential backoff &#8212; huangz/note</a> <code class="fold">@</code></dt>
<dd><p>&#25351;&#25968;&#34917;&#20607;&#25351;&#30340;&#26159;&#65292;&#22312;&#25191;&#34892;&#20107;&#20214;&#26102;&#65292;&#36890;&#36807;&#21453;&#39304;&#65292;&#36880;&#28176;&#38477;&#20302;&#26576;&#20010;&#36807;&#31243;&#30340;&#36895;&#29575;&#65292;&#20174;&#32780;&#26368;&#32456;&#25214;&#21040;&#19968;&#20010;&#21512;&#36866;&#30340;&#36895;&#29575;&#65288;&#26469;&#22788;&#29702;&#20107;&#20214;&#65289;&#12290;</p>
<p>Exponential backoff is an algorithm that uses feedback to multiplicatively decrease the rate of some process, in order to gradually find an acceptable rate.</p>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Exponential_backoff">Exponential backoff - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
<dt><a href="http://note.huangz.me/algorithm/arithmetic/parse-string-to-number.html">&#23558;&#23383;&#31526;&#20018;&#35299;&#37322;&#20026;&#25968;&#23383; &#8212;&#8212; Parse string to number &#8212; huangz/note</a> <code class="fold">@</code></dt>
<dd><p>&#23601;&#26159; atoi&#12290;</p>
</dd>
</dl>
</dd>
</dl>
<p><a href="http://note.huangz.me/system/csapp/chp1.html">&#31532;&#19968;&#31456;&#65306; &#35745;&#31639;&#31995;&#32479;&#31616;&#20171; &#8212; huangz/note</a> &#9829;&#65039;</p>
<p><a href="http://note.huangz.me/network/unp/chp2.html">&#31532; 2 &#31456;&#65306;&#20256;&#36755;&#23618;&#65306;TCP &#12289; UDP &#21644; SCTP &#8212; huangz/note</a></p>
<p><a href="http://note.huangz.me/os/apue/index.html">&#12298;UNIX &#29615;&#22659;&#39640;&#32423;&#32534;&#31243;&#12299;&#31508;&#35760; &#8212; huangz/note</a></p>
</dd>
</dl></li>
<li><dl>
<dt><a href="https://zhuanlan.zhihu.com/simons">SimonS&#8217;s Algo - &#30693;&#20046;&#19987;&#26639;</a> <code class="fold">@</code></dt>
<dd><p><a href="https://zhuanlan.zhihu.com/p/20038650?refer=simons">&#20998;&#29677;&#38382;&#39064;&#31639;&#27861;&#27714;&#35299;&#8212;&#8212;&#21160;&#24577;&#35268;&#21010; - SimonS&#8217;s Algo - &#30693;&#20046;&#19987;&#26639;</a></p>
<dl>
<dt><a href="https://zhuanlan.zhihu.com/p/20042325?refer=simons">&#20498;&#21047; LeetCode&#8212;&#8212;Valid Number - SimonS&#8217;s Algo - &#30693;&#20046;&#19987;&#26639;</a> <code class="fold">@</code></dt>
<dd><p>&#20351;&#29992;<strong>&#30830;&#23450;&#26377;&#31351;&#29366;&#24577;&#33258;&#21160;&#26426; (DFA)</strong> &#26469;&#35299;&#31572;&#27492;&#39064;&#24517;&#28982;&#26159;&#26368;&#20248;&#38597;&#30340;&#65292;&#26080;&#35770;&#31354;&#38388;&#36824;&#26159;&#26102;&#38388;&#22797;&#26434;&#24230;&#37117;&#26377;&#19981;&#38169;&#30340;&#34920;&#29616;&#12290;&#22914;&#26524;&#19981;&#29087;&#24713; DFA &#30340;&#35805;&#20063;&#27809;&#20851;&#31995;&#65292;&#21487;&#20197;&#25226;&#26412;&#25991;&#24403;&#20316;&#20837;&#38376;&#25945;&#31243;&#26469;&#30475;&#12290;</p>
<p>&#25152;&#35859;&#8220;&#30830;&#23450;&#26377;&#31351;&#29366;&#24577;&#8221;&#65292;&#24517;&#28982;&#38656;&#35201;&#25105;&#20204;&#33258;&#24049;&#21160;&#25163;&#26500;&#36896;&#20986;&#25152;&#26377;&#29366;&#24577;&#26469;&#65292;&#22914;&#19979;&#25152;&#31034;&#65306;</p>
<ul>
<li>0 &#21021;&#22987;&#26080;&#36755;&#20837;&#25110;&#32773;&#21482;&#26377; space &#30340;&#29366;&#24577;</li>
<li>1 &#36755;&#20837;&#20102;&#25968;&#23383;&#20043;&#21518;&#30340;&#29366;&#24577;</li>
<li>2 &#21069;&#38754;&#26080;&#25968;&#23383;&#65292;&#21482;&#36755;&#20837;&#20102; dot &#30340;&#29366;&#24577;</li>
<li>3 &#36755;&#20837;&#20102; +/- &#29366;&#24577;</li>
<li>4 &#21069;&#38754;&#26377;&#25968;&#23383;&#21644;&#26377; dot &#30340;&#29366;&#24577;</li>
<li>5 &#8216;e&#8217; or &#8217;E&#8217;&#36755;&#20837;&#21518;&#30340;&#29366;&#24577;</li>
<li>6 &#36755;&#20837; e &#20043;&#21518;&#36755;&#20837; +/- &#30340;&#29366;&#24577;</li>
<li>7 &#36755;&#20837; e &#21518;&#36755;&#20837;&#25968;&#23383;&#30340;&#29366;&#24577;</li>
<li>8 &#21069;&#38754;&#26377;&#26377;&#25928;&#25968;&#36755;&#20837;&#20043;&#21518;&#65292;&#36755;&#20837; space &#30340;&#29366;&#24577;</li>
</ul>
<div class="figure">
<img src="http://img.hb.aicdn.com/30ee1dcf092b0ff270d715558f7c84ccf79d4897b667-ZCBWYf_fw658" />

</div>
<p>&#22312; 9 &#31181;&#29366;&#24577;&#20013;&#65292;&#25105;&#20204;&#21487;&#20197;&#21457;&#29616;&#21482;&#26377; 1&#12289;4&#12289;7&#12289;8 &#22235;&#31181;&#29366;&#24577;&#26159;&#21512;&#27861;&#30340;&#65292;&#25152;&#20197;&#39064;&#30446;&#36814;&#20995;&#32780;&#35299;&#65292;&#21482;&#35201;&#25384;&#20010;&#36941;&#21382;&#23383;&#31526;&#65292;&#36890;&#36807;&#21028;&#26029;&#36941;&#21382;&#21040;&#26368;&#21518;&#19968;&#20010;&#23383;&#31526;&#26102;&#30340;&#29366;&#24577;&#21363;&#21487;&#30830;&#23450;&#35813;&#23383;&#31526;&#20018;&#26159;&#21542;&#21512;&#27861;&#12290;</p>
<p>&#22312;&#32534;&#31243;&#20013;&#65292;&#25105;&#20204;&#21487;&#20197;&#31616;&#21333;&#22320;&#29992;&#19968;&#20010;&#37051;&#25509;&#30697;&#38453;&#26469;&#23384;&#20648;&#19978;&#22270;&#36716;&#31227;&#20851;&#31995;&#65292;&#19981;&#20102;&#35299;&#30340;&#21516;&#23398;&#35831;&#24694;&#34917;&#22270;&#35770;&#30456;&#20851;&#22522;&#30784;&#30693;&#35782;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Solution:
    <span class="co"># @param {string} s</span>
    <span class="co"># @return {boolean}</span>
    <span class="kw">def</span> isNumber(<span class="va">self</span>, s):
        INVALID<span class="op">=</span><span class="dv">0</span><span class="op">;</span> SPACE<span class="op">=</span><span class="dv">1</span><span class="op">;</span> SIGN<span class="op">=</span><span class="dv">2</span><span class="op">;</span> DIGIT<span class="op">=</span><span class="dv">3</span><span class="op">;</span> DOT<span class="op">=</span><span class="dv">4</span><span class="op">;</span> EXPONENT<span class="op">=</span><span class="dv">5</span><span class="op">;</span>
        <span class="co">#0invalid,1space,2sign,3digit,4dot,5exponent,6num_inputs</span>
        transitionTable<span class="op">=</span>[[<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>],      <span class="co">#0 no input or just spaces</span>
                         [<span class="op">-</span><span class="dv">1</span>, <span class="dv">8</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">5</span>],      <span class="co">#1 input is digits</span>
                         [<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>],   <span class="co">#2 no digits in front just Dot</span>
                         [<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>],    <span class="co">#3 sign</span>
                         [<span class="op">-</span><span class="dv">1</span>, <span class="dv">8</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">5</span>],     <span class="co">#4 digits and dot in front</span>
                         [<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>],    <span class="co">#5 input &#39;e&#39; or &#39;E&#39;</span>
                         [<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">7</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>],   <span class="co">#6 after &#39;e&#39; input sign</span>
                         [<span class="op">-</span><span class="dv">1</span>, <span class="dv">8</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">7</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>],    <span class="co">#7 after &#39;e&#39; input digits</span>
                         [<span class="op">-</span><span class="dv">1</span>, <span class="dv">8</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>]]   <span class="co">#8 after valid input input space</span>
         state <span class="op">=</span> <span class="dv">0</span>
         <span class="cf">for</span> c <span class="op">in</span> s:
            inputtype <span class="op">=</span> INVALID

            <span class="cf">if</span> c <span class="op">==</span> <span class="st">&#39; &#39;</span>: inputtype <span class="op">=</span> SPACE
            <span class="cf">elif</span> c <span class="op">==</span> <span class="st">&#39;-&#39;</span> <span class="op">or</span> c <span class="op">==</span> <span class="st">&#39;+&#39;</span>: inputtype <span class="op">=</span> SIGN
            <span class="cf">elif</span> c.isdigit(): inputtype <span class="op">=</span> DIGIT
            <span class="cf">elif</span> c <span class="op">==</span> <span class="st">&#39;.&#39;</span>: inputtype <span class="op">=</span> DOT
            <span class="cf">elif</span> c.upper() <span class="op">==</span> <span class="st">&#39;E&#39;</span>: inputtype <span class="op">=</span> EXPONENT

            state <span class="op">=</span> transitionTable[state][inputtype]
            <span class="cf">if</span> state <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>: <span class="cf">return</span> <span class="va">False</span>
            <span class="cf">return</span> state <span class="op">==</span> <span class="dv">1</span> <span class="op">or</span> state <span class="op">==</span> <span class="dv">4</span> <span class="op">or</span> state <span class="op">==</span> <span class="dv">7</span> <span class="op">or</span> state <span class="op">==</span> <span class="dv">8</span></code></pre></div>
</dd>
</dl>
<ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/20102352?refer=simons">&#23383;&#31526;&#20018;&#30456;&#20284;&#24230;&#20043;&#32654;&#65288;&#20108;&#65289; - SimonS&#8217;s Algo - &#30693;&#20046;&#19987;&#26639;</a></p></li>
<li><p><a href="https://www.zhihu.com/question/29454855/answer/44437341">&#29492;&#23376;&#25688;&#39321;&#34121;&#19968;&#27425;&#21487;&#20197;&#25688; 1 &#20010;&#25110; 2 &#20010;&#65292;&#24635;&#20849; 50 &#20010;&#65292;&#38382;&#26377;&#22810;&#23569;&#31181;&#25688;&#27861;&#65311; - SimonS &#30340;&#22238;&#31572; - &#30693;&#20046;</a></p></li>
<li><p><a href="https://zhuanlan.zhihu.com/p/20546361?refer=simons">&#12302;&#21860;&#37202;&#19982;&#23615;&#19981;&#28287;&#12303;&#20043;&#20851;&#32852;&#35268;&#21017; - SimonS&#8217;s Algo - &#30693;&#20046;&#19987;&#26639;</a></p></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#31185;&#23398;&#26494;&#40736;&#20250; &#187; &#36951;&#20256;&#31639;&#27861;&#65306;&#20869;&#23384;&#20013;&#30340;&#36827;&#21270; <code class="fold">@</code></dt>
<dd><p>&#31616;&#21333;&#22320;&#35828;&#65292;&#36951;&#20256;&#31639;&#27861;&#26159;&#19968;&#31181;&#35299;&#20915;&#38382;&#39064;&#30340;&#26041;&#27861;&#12290;&#23427;<strong>&#27169;&#25311;&#22823;&#33258;&#28982;&#20013;&#31181;&#32676;&#22312;&#36873;&#25321;&#21387;&#21147;&#19979;&#30340;&#28436;&#21270;&#65292;&#20174;&#32780;&#24471;&#21040;&#38382;&#39064;&#30340;&#19968;&#20010;&#36817;&#20284;&#35299;</strong>&#12290;</p>
<p>&#20854;&#27425;&#65292;&#20026;&#20102;&#20351;&#25159;&#36125;&#30340;&#26679;&#23376;&#21521;Firefox&#22270;&#26631;&#38752;&#36817;&#65292;&#25105;&#20204;&#35201;&#32473;&#23427;&#20204;&#21152;&#19978;&#19968;&#28857;&#36873;&#25321;&#21387;&#21147;&#65292;&#23601;&#26159;&#25991;&#31456;&#24320;&#22836;&#25925;&#20107;&#20013;&#25552;&#21040;&#30340;&#37027;&#20010;&#20154;&#30340;&#34892;&#21160;&#65306;&#22312;&#27599;&#19968;&#20195;&#25226;&#26368;&#19981;&#20687;Firefox&#30340;&#25159;&#36125;&#28120;&#27760;&#20986;&#21435;&#65292;&#21516;&#26102;&#20063;&#32473;&#26032;&#30340;&#20010;&#20307;&#30041;&#19979;&#29983;&#23384;&#30340;&#31354;&#38388;&#12290;&#24590;&#20040;&#35780;&#20215;&#36825;&#20010;&#25159;&#36125;&#20687;&#19981;&#20687;Firefox&#21602;&#65311;&#26368;&#30452;&#25509;&#30340;&#26041;&#27861;&#23601;&#26159;&#19968;&#20010;&#19968;&#20010;&#20687;&#32032;&#27604;&#36739;&#65292;&#39068;&#33394;&#30456;&#24046;&#24471;&#36234;&#22810;&#23601;&#36234;&#19981;&#20687;&#12290;&#36825;&#20010;&#35780;&#20215;&#30340;&#20989;&#25968;&#21483;&#20570;&#8220;&#36866;&#24212;&#20989;&#25968;&#8221;&#65292;&#23427;&#36127;&#36131;&#35780;&#20215;&#19968;&#20010;&#20010;&#20307;&#21040;&#24213;&#26377;&#22810;&#36866;&#24212;&#25105;&#20204;&#30340;&#35201;&#27714;&#12290;</p>
<p>&#22909;&#20102;&#65292;&#29616;&#22312;&#26159;&#19975;&#20107;&#20465;&#22791;&#21482;&#27424;&#19996;&#39118;&#20102;&#12290;&#23450;&#20041;&#22909;&#22522;&#22240;&#65292;&#20889;&#22909;&#32321;&#34893;&#12289;&#21464;&#24322;&#12289;&#35780;&#20215;&#36866;&#24212;&#24615;&#12289;&#28120;&#27760;&#21644;&#32456;&#27490;&#30340;&#20195;&#30721;&#20043;&#21518;&#65292;&#21482;&#38656;&#35201;&#38543;&#26426;&#20135;&#29983;&#19968;&#20010;&#36866;&#24403;&#22823;&#23567;&#30340;&#31181;&#32676;&#65292;&#28982;&#21518;&#35753;&#23427;&#36825;&#26679;&#19968;&#20195;&#20195;&#30340;&#32321;&#34893;&#12289;&#21464;&#24322;&#21644;&#28120;&#27760;&#19979;&#21435;&#65292;&#21040;&#26368;&#21518;&#32456;&#27490;&#25105;&#20204;&#23601;&#20250;&#33719;&#24471;&#19968;&#20010;&#24778;&#21916;&#30340;&#32467;&#26524;&#65306;&#65288;&#36825;&#22238;&#26159;&#23436;&#25972;&#30340;&#20102;&#65292;&#22270;&#29255;&#19979;&#30340;&#25968;&#23383;&#34920;&#31034;&#36825;&#20010;&#25159;&#36125;&#26159;&#31532;&#20960;&#20195;&#20013;&#26368;&#22909;&#30340;&#65289;</p>
<div class="figure">
<img src="http://blufiles.storage.msn.com/y1p96zcjxuwxolgnU-4kYeJil49VAcoYd0ieRPXt9jLGTd7UOR8kUlNdb1ZAzScolGo?PARTNER=WRITER" />

</div>
<p>&#20854;&#23454;&#65292;&#36890;&#36807;&#24494;&#35843;&#21442;&#25968;&#21644;&#32321;&#34893;&#12289;&#21464;&#24322;&#12289;&#28120;&#27760;&#12289;&#32456;&#27490;&#30340;&#20195;&#30721;&#65292;&#25105;&#20204;&#26377;&#21487;&#33021;&#24471;&#21040;&#26356;&#26377;&#25928;&#30340;&#31639;&#27861;&#12290;&#36951;&#20256;&#31639;&#27861;&#21482;&#26159;&#19968;&#20010;&#26694;&#26550;&#65292;&#37324;&#36793;&#20855;&#20307;&#20869;&#23481;&#21487;&#20197;&#26681;&#25454;&#23454;&#38469;&#38382;&#39064;&#36827;&#34892;&#35843;&#25972;&#65292;&#36825;&#20063;&#26159;&#23427;&#33021;&#22312;&#35768;&#22810;&#38382;&#39064;&#19978;&#27966;&#19978;&#29992;&#22330;&#30340;&#19968;&#20010;&#21407;&#22240;&#12290;&#20687;&#36825;&#26679;&#21487;&#20197;&#36866;&#24212;&#24456;&#22810;&#38382;&#39064;&#30340;&#31639;&#27861;&#36824;&#26377;&#27169;&#25311;&#36864;&#28779;&#31639;&#27861;&#12289;&#31890;&#23376;&#32676;&#31639;&#27861;&#12289;&#34433;&#32676;&#31639;&#27861;&#12289;&#31105;&#24524;&#25628;&#32034;&#31561;&#31561;&#65292;&#32479;&#31216;&#20026;&#20803;&#21551;&#21457;&#24335;&#31639;&#27861;&#65288;Meta-heuristic algorithms&#65289;&#12290;</p>
<dl>
<dt>Metaheuristic :TODO: <code class="fold">@</code></dt>
<dd><p>TODO</p>
</dd>
</dl>
<p>&#36951;&#20256;&#31639;&#27861;&#27169;&#25311;&#19968;&#20010;&#20154;&#24037;&#31181;&#32676;&#30340;&#36827;&#21270;&#36807;&#31243;&#65292;&#36890;&#36807;&#36873;&#25321; (Selection)&#12289;&#20132;&#21449; (Crossover) &#20197;&#21450;&#21464;&#24322; (Mutation) &#31561;&#26426;&#21046;&#65292;&#22312;&#27599;&#27425;&#36845;&#20195;&#20013;&#37117;&#20445;&#30041;&#19968;&#32452;&#20505;&#36873;&#20010;&#20307;&#65292;&#37325;&#22797;&#27492;&#36807;&#31243;&#65292;&#31181;&#32676;&#32463;&#36807;&#33509;&#24178;&#20195;&#20197;&#21518;&#65292;&#29702;&#24819;&#24773;&#20917;&#19979;&#20854;&#36866;&#24212;&#24230;&#36798;&#21040;<strong><em>&#36817;&#20284;&#26368;&#20248;</em></strong>&#30340;&#29366;&#24577;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="https://www.zhihu.com/question/23293449">&#22914;&#20309;&#36890;&#20439;&#26131;&#25026;&#22320;&#35299;&#37322;&#36951;&#20256;&#31639;&#27861;&#65311;&#26377;&#20160;&#20040;&#20363;&#23376;&#65311; - &#30693;&#20046;</a></li>
<li><a href="http://songshuhui.net/archives/10462">&#31185;&#23398;&#26494;&#40736;&#20250; &#187; &#36951;&#20256;&#31639;&#27861;&#65306;&#20869;&#23384;&#20013;&#30340;&#36827;&#21270;</a></li>
<li><a href="https://en.wikipedia.org/wiki/Metaheuristic">Metaheuristic - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
</dl></li>
<li><p><a href="https://www.zhihu.com/question/20962240">&#22914;&#20309;&#29992;&#31616;&#21333;&#26131;&#25026;&#30340;&#20363;&#23376;&#35299;&#37322;&#38544;&#39532;&#23572;&#21487;&#22827;&#27169;&#22411;&#65311; - &#30693;&#20046;</a></p></li>
<li><p><a href="https://www.zhihu.com/question/29687860">&#26426;&#22120;&#23398;&#20064;&#19987;&#23478;&#19982;&#32479;&#35745;&#23398;&#23478;&#35266;&#28857;&#19978;&#26377;&#21738;&#20123;&#19981;&#21516;&#65311; - &#30693;&#20046;</a></p></li>
<li><dl>
<dt><a href="https://www.zhihu.com/question/22237507">&#22855;&#24322;&#20540;&#30340;&#29289;&#29702;&#24847;&#20041;&#26159;&#20160;&#20040;&#65311; - &#30693;&#20046;</a> <code class="fold">@</code></dt>
<dd><p><a href="http://blog.sciencenet.cn/blog-696950-699432.html">&#31185;&#23398;&#32593;&#8212;&#22855;&#24322;&#20540;&#20998;&#35299; (SVD) &#8212; &#20960;&#20309;&#24847;&#20041; - &#20313;&#38706;&#30340;&#21338;&#25991;</a></p>
</dd>
</dl></li>
<li><p><a href="http://algorithm.yuanbin.me/zh-hans/basics_data_structure/heap.html">Heap &#183; Data Structure and Algorithm notes</a></p></li>
<li><dl>
<dt>&#12298;DPV &#8211; Algorithm&#12299; &#31639;&#27861;&#20043;&#32654;&#65288;Algorithms&#65289;&#20070;&#35780; <code class="fold">@</code></dt>
<dd><p>&#31639;&#27861;&#20316;&#20026;&#19968;&#38376;&#23398;&#38382;&#65292;&#26377;&#20004;&#26465;&#27491;&#20132;&#30340;&#32447;&#32034;&#12290;&#19968;&#20010;&#26159;&#31639;&#27861;&#22788;&#29702;&#30340;&#23545;&#35937;&#65306;&#25968;&#12289;&#30697;&#38453;&#12289;&#38598;&#21512;&#12289;&#20018; (strings)&#12289;&#25490;&#21015; (permutations)&#12289;&#22270; (graphs)&#12289;&#34920;&#36798;&#24335;(formula)&#12289;&#20998;&#24067;(distributions)&#65292;&#31561;&#31561;&#12290;&#21478;&#19968;&#20010;&#26159;&#31639;&#27861;&#30340;&#35774;&#35745;&#24605;&#24819;&#65306;&#36138;&#23146;&#12289;&#20998;&#27835;&#12289;&#21160;&#24577;&#35268;&#21010;&#12289;&#32447;&#24615;&#35268;&#21010;&#12289;&#23616;&#37096;&#25628;&#32034; (local search)&#65292;&#31561;&#31561;&#12290;&#36825;&#20004;&#26465;&#32447;&#32034;&#20960;&#20046;&#26159;&#30456;&#20114;&#29420;&#31435;&#30340;&#65306;&#21516;&#19968;&#20010;&#31163;&#25955;&#23545;&#35937;&#65292;&#20363;&#22914;&#22270;&#65292;&#31245;&#26377;&#19981;&#21516;&#30340;&#38382;&#39064;&#65292;&#20363;&#22914;single-source shortest path &#21644;all-pair shortest path&#65292;&#23601;&#21487;&#20197;&#29992;&#21040;&#19981;&#21516;&#30340;&#35774;&#35745;&#24605;&#24819;&#65292;&#22914;&#36138;&#23146;&#21644;&#21160;&#24577;&#35268;&#21010;&#65307;&#32780;&#23436;&#20840;&#19981;&#21516;&#30340;&#31163;&#25955;&#23545;&#35937;&#19978;&#30340;&#38382;&#39064;&#65292;&#20363;&#22914;&#25490;&#24207;&#21644;&#25972;&#25968;&#20056;&#27861;&#65292;&#20063;&#35768;&#23601;&#20250;&#29992;&#21040;&#30456;&#21516;&#30340;&#24605;&#24819;&#65292;&#20363;&#22914;&#20998;&#27835;&#12290;</p>
<p>refs and see also</p>
<ul>
<li><a href="https://book.douban.com/review/1325850/">&#31639;&#27861;&#20043;&#32654;&#65288;Algorithms&#65289;&#20070;&#35780;</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#12298;The Algorithm Design Manual&#12299; <code class="fold">@</code></dt>
<dd><p><a href="http://www3.cs.stonybrook.edu/~algorith/video-lectures/">Skiena&#8217;s Audio Lectures</a></p>
<p><a href="https://book.douban.com/review/6250350/">&#19981;&#24871;&#23545;&#8220;&#25163;&#20876;&#8221;&#20043;&#21517;&#65292;&#21363;&#20351;&#36890;&#35835;&#36807; CLRS &#20877;&#35835;&#20063;&#26377;&#25152;&#25910;&#33719;&#65288;&#31639;&#27861;&#35774;&#35745;&#25163;&#20876;&#65289;&#20070;&#35780;</a></p>
</dd>
</dl></li>
<li><dl>
<dt>red-black tree <code class="fold">@</code></dt>
<dd><p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red&#8211;black tree - Wikipedia, the free encyclopedia</a></li>
<li><a href="http://daoluan.net/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2013/09/25/rbtree-is-not-difficult.html">&#32418;&#40657;&#26641;&#24182;&#27809;&#26377;&#25105;&#20204;&#24819;&#35937;&#30340;&#37027;&#20040;&#38590;(&#19978;) - &#25443;&#20081;&#23567;&#23376;</a></li>
<li><a href="http://daoluan.net/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/2013/09/28/rbtree-is-not-difficult-2.html">&#32418;&#40657;&#26641;&#24182;&#27809;&#26377;&#25105;&#20204;&#24819;&#35937;&#30340;&#37027;&#20040;&#38590;(&#19979;) - &#25443;&#20081;&#23567;&#23376;</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>sorting <code class="fold">@</code></dt>
<dd><p>refs and see also</p>
<ul>
<li><a href="http://blog.csdn.net/yang_yulei/article/details/27237641">&#25490;&#24207;&#65288;&#19968;&#65289;&#24402;&#24182;&#12289;&#24555;&#25490;&#12289;&#20248;&#20808;&#38431;&#21015;&#31561;&#65288;&#22270;&#25991;&#35814;&#35299;&#65289; - &#33756;&#40479;&#30340;&#33258;&#30041;&#22320; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
<li><a href="http://blog.csdn.net/yang_yulei/article/details/27237809">&#25490;&#24207;&#65288;&#20108;&#65289;&#38190;&#32034;&#24341;&#12289;&#26742;&#25490;&#24207;&#12289;&#20301;&#31034;&#22270;&#12289;&#36133;&#32773;&#26641;&#31561;&#65288;&#22270;&#25991;&#35814;&#35299;&#8211;&#36133;&#32773;&#26641;&#65289; - &#33756;&#40479;&#30340;&#33258;&#30041;&#22320; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Code Reading <code class="fold">@</code></dt>
<dd><p><a href="https://github.com/4ker/Lua-Source-Internal">4ker/Lua-Source-Internal: Lua source internal</a></p>
<p><a href="http://blog.csdn.net/sparkliang/article/details/4957667">libevent &#28304;&#30721;&#28145;&#24230;&#21078;&#26512;&#19968; - sparkliang &#30340;&#19987;&#26639; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></p>
<p><a href="http://blog.csdn.net/sparkliang/article/details/4957744">libevent &#28304;&#30721;&#28145;&#24230;&#21078;&#26512;&#20108; - sparkliang &#30340;&#19987;&#26639; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></p>
<p><a href="https://github.com/daoluan/decode-memcached">daoluan/decode-memcached: memcached &#28304;&#30721;&#21078;&#26512;&#27880;&#37322;</a></p>
<dl>
<dt><a href="http://redisbook.com/">Redis &#35774;&#35745;&#19982;&#23454;&#29616; &#8212; Redis &#35774;&#35745;&#19982;&#23454;&#29616;</a> &#9829;&#65039; <code class="fold">@</code></dt>
<dd><dl>
<dt>What is Redis <code class="fold">@</code></dt>
<dd><p>Redis &#26159;&#19968;&#20010;&#24320;&#28304;&#30340;&#20351;&#29992; ANSI C &#35821;&#35328;&#32534;&#20889;&#12289;&#25903;&#25345;&#32593;&#32476;&#12289;&#21487;&#22522;&#20110;&#20869;&#23384;&#20134;&#21487;&#25345;&#20037;&#21270;&#30340;&#26085;&#24535;&#22411;&#12289;Key-Value &#25968;&#25454;&#24211;&#65292;&#24182;&#25552;&#20379;&#22810;&#31181;&#35821;&#35328;&#30340; API&#12290;&#20174; 2010 &#24180; 3 &#26376; 15 &#26085;&#36215;&#65292;Redis &#30340;&#24320;&#21457;&#24037;&#20316;&#30001;VMware &#20027;&#25345;&#12290;&#20174; 2013 &#24180; 5 &#26376;&#24320;&#22987;&#65292;Redis &#30340;&#24320;&#21457;&#30001; Pivotal &#36190;&#21161;&#12290;</p>
<p>Redis &#30340;&#20248;&#28857;&#22914;&#19979;&#65306;</p>
<ul>
<li>&#20016;&#23500;&#30340;&#25968;&#25454;&#32467;&#26500;&#21644;&#21629;&#20196;</li>
<li>&#40664;&#35748;&#23601;&#26377;&#25345;&#20037;&#21270;</li>
<li>&#20107;&#21153;</li>
<li>&#20540;&#26377; 512MB&#65288;memcached &#26368;&#22823;&#26159; 1MB&#65289;</li>
</ul>
<p>Memcached &#30340;&#20248;&#28857;&#65306;</p>
<ul>
<li>&#21487;&#20197;&#20570;&#38598;&#32676;</li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="https://www.zhihu.com/question/19829601">Redis &#21644; Memcached &#21508;&#26377;&#20160;&#20040;&#20248;&#32570;&#28857;&#65292;&#20027;&#35201;&#30340;&#24212;&#29992;&#22330;&#26223;&#26159;&#20160;&#20040;&#26679;&#30340;&#65311; - &#30693;&#20046;</a></li>
</ul>
</dd>
<dt>&#31532;&#19968;&#37096;&#20998;&#65306;&#25968;&#25454;&#32467;&#26500;&#19982;&#23545;&#35937; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#31616;&#21333;&#21160;&#24577;&#23383;&#31526;&#20018; <code class="fold">@</code></dt>
<dd><p>Redis &#27809;&#26377;&#30452;&#25509;&#20351;&#29992; C &#35821;&#35328;&#20256;&#32479;&#30340;&#23383;&#31526;&#20018;&#34920;&#31034;&#65288;&#20197;&#31354;&#23383;&#31526;&#32467;&#23614;&#30340;&#23383;&#31526;&#25968;&#32452;&#65292;&#20197;&#19979;&#31616;&#31216; C &#23383;&#31526;&#20018;&#65289;&#65292; &#32780;&#26159;&#33258;&#24049;&#26500;&#24314;&#20102;&#19968;&#31181;&#21517;&#20026;&#31616;&#21333;&#21160;&#24577;&#23383;&#31526;&#20018;&#65288;<strong>simple dynamic string&#65292;SDS</strong>&#65289;&#30340;&#25277;&#35937;&#31867;&#22411;&#65292; &#24182;&#23558; SDS &#29992;&#20316; Redis &#30340;&#40664;&#35748;&#23383;&#31526;&#20018;&#34920;&#31034;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> sdshdr {
    <span class="co">// &#35760;&#24405; buf &#25968;&#32452;&#20013;&#24050;&#20351;&#29992;&#23383;&#33410;&#30340;&#25968;&#37327;</span>
    <span class="co">// &#31561;&#20110; SDS &#25152;&#20445;&#23384;&#23383;&#31526;&#20018;&#30340;&#38271;&#24230;</span>
    <span class="dt">int</span> len;

    <span class="co">// &#35760;&#24405; buf &#25968;&#32452;&#20013;&#26410;&#20351;&#29992;&#23383;&#33410;&#30340;&#25968;&#37327;</span>
    <span class="dt">int</span> free;

    <span class="co">// &#23383;&#33410;&#25968;&#32452;&#65292;&#29992;&#20110;&#20445;&#23384;&#23383;&#31526;&#20018;</span>
    <span class="dt">char</span> buf[];
};</code></pre></div>
<table>
<colgroup>
<col width="53%" />
<col width="46%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">C &#23383;&#31526;&#20018;</th>
<th align="left">SDS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">&#33719;&#21462;&#23383;&#31526;&#20018;&#38271;&#24230;&#30340;&#22797;&#26434;&#24230;&#20026; O(N) &#12290; API &#26159;&#19981;&#23433;&#20840;&#30340;&#65292;&#21487;&#33021;&#20250;&#36896;&#25104;&#32531;&#20914;&#21306;&#28322;&#20986;&#12290;&#20462;&#25913;&#23383;&#31526;&#20018;&#38271;&#24230; N &#27425;&#24517;&#28982;&#38656;&#35201;&#25191;&#34892; N &#27425;&#20869;&#23384;&#37325;&#20998;&#37197;&#12290;&#21482;&#33021;&#20445;&#23384;&#25991;&#26412;&#25968;&#25454;&#12290;&#21487;&#20197;&#20351;&#29992;&#25152;&#26377; <string.h> &#24211;&#20013;&#30340;&#20989;&#25968;&#12290;</td>
<td align="left">&#33719;&#21462;&#23383;&#31526;&#20018;&#38271;&#24230;&#30340;&#22797;&#26434;&#24230;&#20026; O(1) &#12290; API &#26159;&#23433;&#20840;&#30340;&#65292;&#19981;&#20250;&#36896;&#25104;&#32531;&#20914;&#21306;&#28322;&#20986;&#12290;&#20462;&#25913;&#23383;&#31526;&#20018;&#38271;&#24230; N &#27425;&#26368;&#22810;&#38656;&#35201;&#25191;&#34892; N &#27425;&#20869;&#23384;&#37325;&#20998;&#37197;&#12290;&#21487;&#20197;&#20445;&#23384;&#25991;&#26412;&#25110;&#32773;&#20108;&#36827;&#21046;&#25968;&#25454;&#12290;&#21487;&#20197;&#20351;&#29992;&#19968;&#37096;&#20998; <string.h> &#24211;&#20013;&#30340;&#20989;&#25968;&#12290;</td>
</tr>
</tbody>
</table>
<p>Redis &#21482;&#20250;&#20351;&#29992; C &#23383;&#31526;&#20018;&#20316;&#20026;&#23383;&#38754;&#37327;&#65292; &#22312;&#22823;&#22810;&#25968;&#24773;&#20917;&#19979;&#65292; Redis &#20351;&#29992; SDS &#65288;Simple Dynamic String&#65292;&#31616;&#21333;&#21160;&#24577;&#23383;&#31526;&#20018;&#65289;&#20316;&#20026;&#23383;&#31526;&#20018;&#34920;&#31034;&#12290;</p>
<p>&#27604;&#36215; C &#23383;&#31526;&#20018;&#65292; SDS &#20855;&#26377;&#20197;&#19979;&#20248;&#28857;&#65306;</p>
<ul>
<li>&#24120;&#25968;&#22797;&#26434;&#24230;&#33719;&#21462;&#23383;&#31526;&#20018;&#38271;&#24230;&#12290;</li>
<li>&#26460;&#32477;&#32531;&#20914;&#21306;&#28322;&#20986;&#12290;</li>
<li>&#20943;&#23569;&#20462;&#25913;&#23383;&#31526;&#20018;&#38271;&#24230;&#26102;&#25152;&#38656;&#30340;&#20869;&#23384;&#37325;&#20998;&#37197;&#27425;&#25968;&#12290;</li>
<li>&#20108;&#36827;&#21046;&#23433;&#20840;&#12290;</li>
<li>&#20860;&#23481;&#37096;&#20998; C &#23383;&#31526;&#20018;&#20989;&#25968;&#12290;</li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Null-terminated_string">Null-terminated string - Wikipedia, the free encyclopedia</a></li>
</ul>
</dd>
<dt>&#38142;&#34920; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">struct</span> list {
    <span class="co">// &#34920;&#22836;&#33410;&#28857;</span>
    listNode *head;

    <span class="co">// &#34920;&#23614;&#33410;&#28857;</span>
    listNode *tail;

    <span class="co">// &#38142;&#34920;&#25152;&#21253;&#21547;&#30340;&#33410;&#28857;&#25968;&#37327;</span>
    <span class="dt">unsigned</span> <span class="dt">long</span> len;

    <span class="co">// &#33410;&#28857;&#20540;&#22797;&#21046;&#20989;&#25968;</span>
    <span class="dt">void</span> *(*dup)(<span class="dt">void</span> *ptr);

    <span class="co">// &#33410;&#28857;&#20540;&#37322;&#25918;&#20989;&#25968;</span>
    <span class="dt">void</span> (*free)(<span class="dt">void</span> *ptr);

    <span class="co">// &#33410;&#28857;&#20540;&#23545;&#27604;&#20989;&#25968;</span>
    <span class="dt">int</span> (*match)(<span class="dt">void</span> *ptr, <span class="dt">void</span> *key);
} list;</code></pre></div>
<p>Redis &#30340;&#38142;&#34920;&#23454;&#29616;&#30340;&#29305;&#24615;&#21487;&#20197;&#24635;&#32467;&#22914;&#19979;&#65306;</p>
<ul>
<li>&#21452;&#31471;&#65306; &#38142;&#34920;&#33410;&#28857;&#24102;&#26377; prev &#21644; next &#25351;&#38024;&#65292; &#33719;&#21462;&#26576;&#20010;&#33410;&#28857;&#30340;&#21069;&#32622;&#33410;&#28857;&#21644;&#21518;&#32622;&#33410;&#28857;&#30340;&#22797;&#26434;&#24230;&#37117;&#26159; O(1) &#12290;</li>
<li>&#26080;&#29615;&#65306; &#34920;&#22836;&#33410;&#28857;&#30340; prev &#25351;&#38024;&#21644;&#34920;&#23614;&#33410;&#28857;&#30340; next &#25351;&#38024;&#37117;&#25351;&#21521; NULL &#65292; <strong>&#23545;&#38142;&#34920;&#30340;&#35775;&#38382;&#20197; NULL &#20026;&#32456;&#28857;</strong>&#12290;</li>
<li>&#24102;&#34920;&#22836;&#25351;&#38024;&#21644;&#34920;&#23614;&#25351;&#38024;&#65306; &#36890;&#36807; list &#32467;&#26500;&#30340; head &#25351;&#38024;&#21644; tail &#25351;&#38024;&#65292; &#31243;&#24207;&#33719;&#21462;&#38142;&#34920;&#30340;&#34920;&#22836;&#33410;&#28857;&#21644;&#34920;&#23614;&#33410;&#28857;&#30340;&#22797;&#26434;&#24230;&#20026; O(1) &#12290;</li>
<li>&#24102;&#38142;&#34920;&#38271;&#24230;&#35745;&#25968;&#22120;&#65306; &#31243;&#24207;&#20351;&#29992; list &#32467;&#26500;&#30340; len &#23646;&#24615;&#26469;&#23545; list &#25345;&#26377;&#30340;&#38142;&#34920;&#33410;&#28857;&#36827;&#34892;&#35745;&#25968;&#65292; &#31243;&#24207;&#33719;&#21462;&#38142;&#34920;&#20013;&#33410;&#28857;&#25968;&#37327;&#30340;&#22797;&#26434;&#24230;&#20026; O(1) &#12290;</li>
<li>&#22810;&#24577;&#65306; &#38142;&#34920;&#33410;&#28857;&#20351;&#29992; <code>void*</code> &#25351;&#38024;&#26469;&#20445;&#23384;&#33410;&#28857;&#20540;&#65292; &#24182;&#19988;&#21487;&#20197;&#36890;&#36807; list &#32467;&#26500;&#30340; dup &#12289; free &#12289; match &#19977;&#20010;&#23646;&#24615;&#20026;&#33410;&#28857;&#20540;&#35774;&#32622;&#31867;&#22411;&#29305;&#23450;&#20989;&#25968;&#65292; &#25152;&#20197;&#38142;&#34920;&#21487;&#20197;&#29992;&#20110;&#20445;&#23384;&#21508;&#31181;&#19981;&#21516;&#31867;&#22411;&#30340;&#20540;&#12290;</li>
</ul>
<p>&#37325;&#28857;&#22238;&#39038;</p>
<ul>
<li>&#38142;&#34920;&#34987;&#24191;&#27867;&#29992;&#20110;&#23454;&#29616; Redis &#30340;&#21508;&#31181;&#21151;&#33021;&#65292; &#27604;&#22914;&#21015;&#34920;&#38190;&#65292; &#21457;&#24067;&#19982;&#35746;&#38405;&#65292; &#24930;&#26597;&#35810;&#65292; &#30417;&#35270;&#22120;&#65292; &#31561;&#31561;&#12290;</li>
<li>&#27599;&#20010;&#38142;&#34920;&#33410;&#28857;&#30001;&#19968;&#20010; listNode &#32467;&#26500;&#26469;&#34920;&#31034;&#65292; &#27599;&#20010;&#33410;&#28857;&#37117;&#26377;&#19968;&#20010;&#25351;&#21521;&#21069;&#32622;&#33410;&#28857;&#21644;&#21518;&#32622;&#33410;&#28857;&#30340;&#25351;&#38024;&#65292; &#25152;&#20197; Redis &#30340;&#38142;&#34920;&#23454;&#29616;&#26159;&#21452;&#31471;&#38142;&#34920;&#12290;</li>
<li>&#27599;&#20010;&#38142;&#34920;&#20351;&#29992;&#19968;&#20010; list &#32467;&#26500;&#26469;&#34920;&#31034;&#65292; &#36825;&#20010;&#32467;&#26500;&#24102;&#26377;&#34920;&#22836;&#33410;&#28857;&#25351;&#38024;&#12289;&#34920;&#23614;&#33410;&#28857;&#25351;&#38024;&#12289;&#20197;&#21450;&#38142;&#34920;&#38271;&#24230;&#31561;&#20449;&#24687;&#12290;</li>
<li>&#22240;&#20026;&#38142;&#34920;&#34920;&#22836;&#33410;&#28857;&#30340;&#21069;&#32622;&#33410;&#28857;&#21644;&#34920;&#23614;&#33410;&#28857;&#30340;&#21518;&#32622;&#33410;&#28857;&#37117;&#25351;&#21521; NULL &#65292; &#25152;&#20197; Redis &#30340;&#38142;&#34920;&#23454;&#29616;&#26159;&#26080;&#29615;&#38142;&#34920;&#12290;</li>
<li>&#36890;&#36807;&#20026;&#38142;&#34920;&#35774;&#32622;&#19981;&#21516;&#30340;&#31867;&#22411;&#29305;&#23450;&#20989;&#25968;&#65292; Redis &#30340;&#38142;&#34920;&#21487;&#20197;&#29992;&#20110;&#20445;&#23384;&#21508;&#31181;&#19981;&#21516;&#31867;&#22411;&#30340;&#20540;&#12290;</li>
</ul>
</dd>
<dt>&#23383;&#20856; <code class="fold">@</code></dt>
<dd><p>&#23383;&#20856;&#32463;&#24120;&#20316;&#20026;&#19968;&#31181;&#25968;&#25454;&#32467;&#26500;&#20869;&#32622;&#22312;&#24456;&#22810;&#39640;&#32423;&#32534;&#31243;&#35821;&#35328;&#37324;&#38754;&#65292; &#20294; Redis &#25152;&#20351;&#29992;&#30340; C &#35821;&#35328;&#24182;&#27809;&#26377;&#20869;&#32622;&#36825;&#31181;&#25968;&#25454;&#32467;&#26500;&#65292; &#22240;&#27492; Redis &#26500;&#24314;&#20102;&#33258;&#24049;&#30340;&#23383;&#20856;&#23454;&#29616;&#12290;</p>
<p>&#23383;&#20856;&#22312; Redis &#20013;&#30340;&#24212;&#29992;&#30456;&#24403;&#24191;&#27867;&#65292; &#27604;&#22914; Redis &#30340;&#25968;&#25454;&#24211;&#23601;&#26159;&#20351;&#29992;&#23383;&#20856;&#26469;&#20316;&#20026;&#24213;&#23618;&#23454;&#29616;&#30340;&#65292; &#23545;&#25968;&#25454;&#24211;&#30340;&#22686;&#12289;&#21024;&#12289;&#26597;&#12289;&#25913;&#25805;&#20316;&#20063;&#26159;&#26500;&#24314;&#22312;&#23545;&#23383;&#20856;&#30340;&#25805;&#20316;&#20043;&#19978;&#30340;&#12290;</p>
<dl>
<dt>&#23383;&#20856;&#30340;&#23454;&#29616; <code class="fold">@</code></dt>
<dd><p>Redis &#30340;&#23383;&#20856;&#20351;&#29992;&#21704;&#24076;&#34920;&#20316;&#20026;&#24213;&#23618;&#23454;&#29616;&#65292; &#19968;&#20010;&#21704;&#24076;&#34920;&#37324;&#38754;&#21487;&#20197;&#26377;&#22810;&#20010;&#21704;&#24076;&#34920;&#33410;&#28857;&#65292; &#32780;&#27599;&#20010;&#21704;&#24076;&#34920;&#33410;&#28857;&#23601;&#20445;&#23384;&#20102;&#23383;&#20856;&#20013;&#30340;&#19968;&#20010;&#38190;&#20540;&#23545;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// key-value</span>
<span class="kw">typedef</span> <span class="kw">struct</span> dictEntry {

    <span class="co">// &#38190;</span>
    <span class="dt">void</span> *key;

    <span class="co">// &#20540;</span>
    <span class="kw">union</span> {
        <span class="dt">void</span> *val;
        <span class="dt">uint64_t</span> u64;
        <span class="dt">int64_t</span> s64;
    } v;

    <span class="co">// &#25351;&#21521;&#19979;&#20010;&#21704;&#24076;&#34920;&#33410;&#28857;&#65292;&#24418;&#25104;&#38142;&#34920;</span>
    <span class="kw">struct</span> dictEntry *next;

} dictEntry;</code></pre></div>
<p>key &#23646;&#24615;&#20445;&#23384;&#30528;&#38190;&#20540;&#23545;&#20013;&#30340;&#38190;&#65292; &#32780; v &#23646;&#24615;&#21017;&#20445;&#23384;&#30528;&#38190;&#20540;&#23545;&#20013;&#30340;&#20540;&#65292;&#20854;&#20013;&#38190;&#20540;&#23545;&#30340;&#20540;&#21487;&#20197;&#26159;&#19968;&#20010;&#25351;&#38024;&#65292; &#25110;&#32773;&#26159;&#19968;&#20010; uint64_t &#25972;&#25968;&#65292;&#21448;&#25110;&#32773;&#26159;&#19968;&#20010; int64_t &#25972;&#25968;&#12290;</p>
<p>next &#23646;&#24615;&#26159;&#25351;&#21521;&#21478;&#19968;&#20010;&#21704;&#24076;&#34920;&#33410;&#28857;&#30340;&#25351;&#38024;&#65292; &#36825;&#20010;&#25351;&#38024;&#21487;&#20197;&#23558;&#22810;&#20010;&#21704;&#24076;&#20540;&#30456;&#21516;&#30340;&#38190;&#20540;&#23545;&#36830;&#25509;&#22312;&#19968;&#27425;&#65292; &#20197;&#27492;&#26469;&#35299;&#20915;&#38190;&#20914;&#31361;&#65288;collision&#65289;&#30340;&#38382;&#39064;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// dict hash table</span>
<span class="kw">typedef</span> <span class="kw">struct</span> dictht {

    <span class="co">// &#21704;&#24076;&#34920;&#25968;&#32452;</span>
    dictEntry **table;

    <span class="co">// &#21704;&#24076;&#34920;&#22823;&#23567;</span>
    <span class="dt">unsigned</span> <span class="dt">long</span> size;

    <span class="co">// &#21704;&#24076;&#34920;&#22823;&#23567;&#25513;&#30721;&#65292;&#29992;&#20110;&#35745;&#31639;&#32034;&#24341;&#20540;</span>
    <span class="co">// &#24635;&#26159;&#31561;&#20110; size - 1</span>
    <span class="dt">unsigned</span> <span class="dt">long</span> sizemask;

    <span class="co">// &#35813;&#21704;&#24076;&#34920;&#24050;&#26377;&#33410;&#28857;&#30340;&#25968;&#37327;</span>
    <span class="dt">unsigned</span> <span class="dt">long</span> used;

} dictht;

<span class="co">// dict</span>
<span class="kw">typedef</span> <span class="kw">struct</span> dict {

    <span class="co">// &#31867;&#22411;&#29305;&#23450;&#20989;&#25968;</span>
    dictType *type;

    <span class="co">// &#31169;&#26377;&#25968;&#25454;</span>
    <span class="dt">void</span> *privdata;

    <span class="co">// &#21704;&#24076;&#34920;</span>
    dictht ht[<span class="dv">2</span>];

    <span class="co">// rehash &#32034;&#24341;</span>
    <span class="co">// &#24403; rehash &#19981;&#22312;&#36827;&#34892;&#26102;&#65292;&#20540;&#20026; -1</span>
    <span class="dt">int</span> rehashidx; <span class="co">/* rehashing not in progress if rehashidx == -1 */</span>

} dict;</code></pre></div>
<div class="figure">
<img src="http://redisbook.com/_images/graphviz-d2641d962325fd58bf15d9fffb4208f70251a999.png" />

</div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">struct</span> dictType {

    <span class="co">// &#35745;&#31639;&#21704;&#24076;&#20540;&#30340;&#20989;&#25968;</span>
    <span class="dt">unsigned</span> <span class="dt">int</span> (*hashFunction)(<span class="dt">const</span> <span class="dt">void</span> *key);

    <span class="co">// &#22797;&#21046;&#38190;&#30340;&#20989;&#25968;</span>
    <span class="dt">void</span> *(*keyDup)(<span class="dt">void</span> *privdata, <span class="dt">const</span> <span class="dt">void</span> *key);

    <span class="co">// &#22797;&#21046;&#20540;&#30340;&#20989;&#25968;</span>
    <span class="dt">void</span> *(*valDup)(<span class="dt">void</span> *privdata, <span class="dt">const</span> <span class="dt">void</span> *obj);

    <span class="co">// &#23545;&#27604;&#38190;&#30340;&#20989;&#25968;</span>
    <span class="dt">int</span> (*keyCompare)(<span class="dt">void</span> *privdata, <span class="dt">const</span> <span class="dt">void</span> *key1, <span class="dt">const</span> <span class="dt">void</span> *key2);

    <span class="co">// &#38144;&#27585;&#38190;&#30340;&#20989;&#25968;</span>
    <span class="dt">void</span> (*keyDestructor)(<span class="dt">void</span> *privdata, <span class="dt">void</span> *key);

    <span class="co">// &#38144;&#27585;&#20540;&#30340;&#20989;&#25968;</span>
    <span class="dt">void</span> (*valDestructor)(<span class="dt">void</span> *privdata, <span class="dt">void</span> *obj);

} dictType;</code></pre></div>
</dd>
<dt>&#21704;&#24076;&#31639;&#27861; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="er"># &#20351;&#29992;&#23383;&#20856;&#35774;&#32622;&#30340;&#21704;&#24076;&#20989;&#25968;&#65292;&#35745;&#31639;&#38190; key &#30340;&#21704;&#24076;&#20540;</span>
hash = dict-&gt;type-&gt;hashFunction(key);

<span class="er"># &#20351;&#29992;&#21704;&#24076;&#34920;&#30340; sizemask &#23646;&#24615;&#21644;&#21704;&#24076;&#20540;&#65292;&#35745;&#31639;&#20986;&#32034;&#24341;&#20540;</span>
<span class="er"># &#26681;&#25454;&#24773;&#20917;&#19981;&#21516;&#65292; ht[x] &#21487;&#20197;&#26159; ht[0] &#25110;&#32773; ht[1]</span>
index = hash &amp; dict-&gt;ht[x].sizemask;</code></pre></div>
<p>Redis &#20351;&#29992; MurmurHash2 &#31639;&#27861;&#26469;&#35745;&#31639;&#38190;&#30340;&#21704;&#24076;&#20540;&#12290;</p>
<p>MurmurHash &#31639;&#27861;&#26368;&#21021;&#30001; Austin Appleby &#20110; 2008 &#24180;&#21457;&#26126;&#65292; &#36825;&#31181;&#31639;&#27861;&#30340;&#20248;&#28857;&#22312;&#20110;&#65292; &#21363;&#20351;&#36755;&#20837;&#30340;&#38190;&#26159;&#26377;&#35268;&#24459;&#30340;&#65292; &#31639;&#27861;&#20173;&#33021;&#32473;&#20986;&#19968;&#20010;&#24456;&#22909;&#30340;&#38543;&#26426;&#20998;&#24067;&#24615;&#65292; &#24182;&#19988;&#31639;&#27861;&#30340;&#35745;&#31639;&#36895;&#24230;&#20063;&#38750;&#24120;&#24555;&#12290;</p>
</dd>
<dt>&#35299;&#20915;&#38190;&#20914;&#31361; <code class="fold">@</code></dt>
<dd><p>Redis &#30340;&#21704;&#24076;&#34920;&#20351;&#29992;&#38142;&#22320;&#22336;&#27861;&#65288;separate chaining&#65289;&#26469;&#35299;&#20915;&#38190;&#20914;&#31361;&#65306;&#27599;&#20010;&#21704;&#24076;&#34920;&#33410;&#28857;&#37117;&#26377;&#19968;&#20010; next &#25351;&#38024;&#65292; &#22810;&#20010;&#21704;&#24076;&#34920;&#33410;&#28857;&#21487;&#20197;&#29992; next &#25351;&#38024;&#26500;&#25104;&#19968;&#20010;&#21333;&#21521;&#38142;&#34920;&#65292; &#34987;&#20998;&#37197;&#21040;&#21516;&#19968;&#20010;&#32034;&#24341;&#19978;&#30340;&#22810;&#20010;&#33410;&#28857;&#21487;&#20197;&#29992;&#36825;&#20010;&#21333;&#21521;&#38142;&#34920;&#36830;&#25509;&#36215;&#26469;&#65292; &#36825;&#23601;&#35299;&#20915;&#20102;&#38190;&#20914;&#31361;&#30340;&#38382;&#39064;&#12290;</p>
<p><strong>&#22240;&#20026; dictEntry &#33410;&#28857;&#32452;&#25104;&#30340;&#38142;&#34920;&#27809;&#26377;&#25351;&#21521;&#38142;&#34920;&#34920;&#23614;&#30340;&#25351;&#38024;&#65292; &#25152;&#20197;&#20026;&#20102;&#36895;&#24230;&#32771;&#34385;&#65292; &#31243;&#24207;&#24635;&#26159;&#23558;&#26032;&#33410;&#28857;&#28155;&#21152;&#21040;&#38142;&#34920;&#30340;&#34920;&#22836;&#20301;&#32622;&#65288;&#22797;&#26434;&#24230;&#20026; O(1)&#65289;&#65292; &#25490;&#22312;&#20854;&#20182;&#24050;&#26377;&#33410;&#28857;&#30340;&#21069;&#38754;&#12290;</strong></p>
</dd>
<dt>rehash <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://redisbook.com/_images/graphviz-93608325578e8e45848938ef420115bf2227639e.png" alt="before" />
<p class="caption">before</p>
</div>
<div class="figure">
<img src="http://redisbook.com/_images/graphviz-b68acb4d868ec7d79a44935ce08a159746ca58da.png" alt="malloc for ht[1]" />
<p class="caption">&#8220;malloc&#8221; for <code>ht[1]</code></p>
</div>
<div class="figure">
<img src="http://redisbook.com/_images/graphviz-b68acb4d868ec7d79a44935ce08a159746ca58da.png" alt="copy" />
<p class="caption">copy</p>
</div>
<div class="figure">
<img src="http://redisbook.com/_images/graphviz-fa28d986a72f1f48b83c7f959ea217b1f9527d3c.png" alt="after" />
<p class="caption">after</p>
</div>
<p><strong>&#21704;&#24076;&#34920;&#30340;&#25193;&#23637;&#19982;&#25910;&#32553;</strong></p>
<p>&#24403;&#20197;&#19979;&#26465;&#20214;&#20013;&#30340;&#20219;&#24847;&#19968;&#20010;&#34987;&#28385;&#36275;&#26102;&#65292; &#31243;&#24207;&#20250;&#33258;&#21160;&#24320;&#22987;&#23545;&#21704;&#24076;&#34920;&#25191;&#34892;&#25193;&#23637;&#25805;&#20316;&#65306;</p>
<ul>
<li>&#26381;&#21153;&#22120;&#30446;&#21069;&#27809;&#26377;&#22312;&#25191;&#34892; BGSAVE &#21629;&#20196;&#25110;&#32773; BGREWRITEAOF &#21629;&#20196;&#65292;&#24182;&#19988;&#21704;&#24076;&#34920;&#30340;&#36127;&#36733;&#22240;&#23376;&#22823;&#20110;&#31561;&#20110; 1&#65288;&#22240;&#20026;&#26159;&#38142;&#24335;&#65292;&#25152;&#20197; load factor &#21487;&#20197;&#22823;&#20110; 1&#65289;&#65307;</li>
<li>&#26381;&#21153;&#22120;&#30446;&#21069;&#27491;&#22312;&#25191;&#34892; BGSAVE &#21629;&#20196;&#25110;&#32773; BGREWRITEAOF &#21629;&#20196;&#65292;&#24182;&#19988;&#21704;&#24076;&#34920;&#30340;&#36127;&#36733;&#22240;&#23376;&#22823;&#20110;&#31561;&#20110; 5 &#65307;</li>
</ul>
<p>&#20854;&#20013;&#21704;&#24076;&#34920;&#30340;&#36127;&#36733;&#22240;&#23376;&#21487;&#20197;&#36890;&#36807;&#20844;&#24335;&#65306;</p>
<pre><code># &#36127;&#36733;&#22240;&#23376; = &#21704;&#24076;&#34920;&#24050;&#20445;&#23384;&#33410;&#28857;&#25968;&#37327; / &#21704;&#24076;&#34920;&#22823;&#23567;
load_factor = ht[0].used / ht[0].size</code></pre>
</dd>
<dt>&#28176;&#36827;&#24335; rehash <code class="fold">@</code></dt>
<dd><p>&#22240;&#27492;&#65292; &#20026;&#20102;&#36991;&#20813; rehash &#23545;&#26381;&#21153;&#22120;&#24615;&#33021;&#36896;&#25104;&#24433;&#21709;&#65292; &#26381;&#21153;&#22120;&#19981;&#26159;&#19968;&#27425;&#24615;&#23558; <code>ht[0]</code> &#37324;&#38754;&#30340;&#25152;&#26377;&#38190;&#20540;&#23545;&#20840;&#37096; rehash &#21040; <code>ht[1]</code>&#65292; &#32780;&#26159;&#20998;&#22810;&#27425;&#12289;&#28176;&#36827;&#24335;&#22320;&#23558; <code>ht[0]</code> &#37324;&#38754;&#30340;&#38190;&#20540;&#23545;&#24930;&#24930;&#22320; rehash &#21040; <code>ht[1]</code>&#12290;</p>
<p>&#22240;&#20026;&#22312;&#36827;&#34892;&#28176;&#36827;&#24335; rehash &#30340;&#36807;&#31243;&#20013;&#65292; &#23383;&#20856;&#20250;&#21516;&#26102;&#20351;&#29992; ht[0] &#21644; ht[1] &#20004;&#20010;&#21704;&#24076;&#34920;&#65292; &#25152;&#20197;&#22312;&#28176;&#36827;&#24335; rehash &#36827;&#34892;&#26399;&#38388;&#65292; &#23383;&#20856;&#30340;&#21024;&#38500;&#65288;delete&#65289;&#12289;&#26597;&#25214;&#65288;find&#65289;&#12289;&#26356;&#26032;&#65288;update&#65289;&#31561;&#25805;&#20316;&#20250;&#22312;&#20004;&#20010;&#21704;&#24076;&#34920;&#19978;&#36827;&#34892;&#65306; &#27604;&#22914;&#35828;&#65292; &#35201;&#22312;&#23383;&#20856;&#37324;&#38754;&#26597;&#25214;&#19968;&#20010;&#38190;&#30340;&#35805;&#65292; &#31243;&#24207;&#20250;&#20808;&#22312; ht[0] &#37324;&#38754;&#36827;&#34892;&#26597;&#25214;&#65292; &#22914;&#26524;&#27809;&#25214;&#21040;&#30340;&#35805;&#65292; &#23601;&#20250;&#32487;&#32493;&#21040; ht[1] &#37324;&#38754;&#36827;&#34892;&#26597;&#25214;&#65292; &#35832;&#22914;&#27492;&#31867;&#12290;</p>
<p>&#21478;&#22806;&#65292; &#22312;&#28176;&#36827;&#24335; rehash &#25191;&#34892;&#26399;&#38388;&#65292; &#26032;&#28155;&#21152;&#21040;&#23383;&#20856;&#30340;&#38190;&#20540;&#23545;&#19968;&#24459;&#20250;&#34987;&#20445;&#23384;&#21040; ht[1] &#37324;&#38754;&#65292; &#32780; ht[0] &#21017;&#19981;&#20877;&#36827;&#34892;&#20219;&#20309;&#28155;&#21152;&#25805;&#20316;&#65306;&#36825;&#19968;&#25514;&#26045;&#20445;&#35777;&#20102; ht[0] &#21253;&#21547;&#30340;&#38190;&#20540;&#23545;&#25968;&#37327;&#20250;&#21482;&#20943;&#19981;&#22686;&#65292; &#24182;&#38543;&#30528; rehash &#25805;&#20316;&#30340;&#25191;&#34892;&#32780;&#26368;&#32456;&#21464;&#25104;&#31354;&#34920;&#12290;</p>
</dd>
<dt>&#37325;&#28857;&#22238;&#39038; <code class="fold">@</code></dt>
<dd><ul>
<li>&#23383;&#20856;&#34987;&#24191;&#27867;&#29992;&#20110;&#23454;&#29616; Redis &#30340;&#21508;&#31181;&#21151;&#33021;&#65292; &#20854;&#20013;&#21253;&#25324;&#25968;&#25454;&#24211;&#21644;&#21704;&#24076;&#38190;&#12290;</li>
<li>Redis &#20013;&#30340;&#23383;&#20856;&#20351;&#29992;&#21704;&#24076;&#34920;&#20316;&#20026;&#24213;&#23618;&#23454;&#29616;&#65292; &#27599;&#20010;&#23383;&#20856;&#24102;&#26377;&#20004;&#20010;&#21704;&#24076;&#34920;&#65292; &#19968;&#20010;&#29992;&#20110;&#24179;&#26102;&#20351;&#29992;&#65292; &#21478;&#19968;&#20010;&#20165;&#22312;&#36827;&#34892; rehash &#26102;&#20351;&#29992;&#12290;</li>
<li>&#24403;&#23383;&#20856;&#34987;&#29992;&#20316;&#25968;&#25454;&#24211;&#30340;&#24213;&#23618;&#23454;&#29616;&#65292; &#25110;&#32773;&#21704;&#24076;&#38190;&#30340;&#24213;&#23618;&#23454;&#29616;&#26102;&#65292; Redis &#20351;&#29992; MurmurHash2 &#31639;&#27861;&#26469;&#35745;&#31639;&#38190;&#30340;&#21704;&#24076;&#20540;&#12290;</li>
<li>&#21704;&#24076;&#34920;&#20351;&#29992;&#38142;&#22320;&#22336;&#27861;&#26469;&#35299;&#20915;&#38190;&#20914;&#31361;&#65292; &#34987;&#20998;&#37197;&#21040;&#21516;&#19968;&#20010;&#32034;&#24341;&#19978;&#30340;&#22810;&#20010;&#38190;&#20540;&#23545;&#20250;&#36830;&#25509;&#25104;&#19968;&#20010;&#21333;&#21521;&#38142;&#34920;&#12290;</li>
<li>&#22312;&#23545;&#21704;&#24076;&#34920;&#36827;&#34892;&#25193;&#23637;&#25110;&#32773;&#25910;&#32553;&#25805;&#20316;&#26102;&#65292; &#31243;&#24207;&#38656;&#35201;&#23558;&#29616;&#26377;&#21704;&#24076;&#34920;&#21253;&#21547;&#30340;&#25152;&#26377;&#38190;&#20540;&#23545; rehash &#21040;&#26032;&#21704;&#24076;&#34920;&#37324;&#38754;&#65292; &#24182;&#19988;&#36825;&#20010; rehash &#36807;&#31243;&#24182;&#19981;&#26159;&#19968;&#27425;&#24615;&#22320;&#23436;&#25104;&#30340;&#65292; &#32780;&#26159;&#28176;&#36827;&#24335;&#22320;&#23436;&#25104;&#30340;&#12290;</li>
</ul>
</dd>
</dl>
</dd>
<dt>&#36339;&#36291;&#34920; <code class="fold">@</code></dt>
<dd><p>&#36339;&#36291;&#34920;&#65288;skiplist&#65289;&#26159;&#19968;&#31181;&#26377;&#24207;&#25968;&#25454;&#32467;&#26500;&#65292; &#23427;&#36890;&#36807;&#22312;&#27599;&#20010;&#33410;&#28857;&#20013;&#32500;&#25345;&#22810;&#20010;&#25351;&#21521;&#20854;&#20182;&#33410;&#28857;&#30340;&#25351;&#38024;&#65292; &#20174;&#32780;&#36798;&#21040;&#24555;&#36895;&#35775;&#38382;&#33410;&#28857;&#30340;&#30446;&#30340;&#12290;</p>
<p>&#36339;&#36291;&#34920;&#25903;&#25345;&#24179;&#22343; O(log N) &#26368;&#22351; O(N) &#22797;&#26434;&#24230;&#30340;&#33410;&#28857;&#26597;&#25214;&#65292; &#36824;&#21487;&#20197;&#36890;&#36807;&#39034;&#24207;&#24615;&#25805;&#20316;&#26469;&#25209;&#37327;&#22788;&#29702;&#33410;&#28857;&#12290;</p>
<p>&#22312;&#22823;&#37096;&#20998;&#24773;&#20917;&#19979;&#65292; &#36339;&#36291;&#34920;&#30340;&#25928;&#29575;&#21487;&#20197;&#21644;&#24179;&#34913;&#26641;&#30456;&#23218;&#32654;&#65292; &#24182;&#19988;&#22240;&#20026;&#36339;&#36291;&#34920;&#30340;&#23454;&#29616;&#27604;&#24179;&#34913;&#26641;&#35201;&#26469;&#24471;&#26356;&#20026;&#31616;&#21333;&#65292; &#25152;&#20197;&#26377;&#19981;&#23569;&#31243;&#24207;&#37117;&#20351;&#29992;&#36339;&#36291;&#34920;&#26469;&#20195;&#26367;&#24179;&#34913;&#26641;&#12290;</p>
<p>Redis &#20351;&#29992;&#36339;&#36291;&#34920;&#20316;&#20026;&#26377;&#24207;&#38598;&#21512;&#38190;&#30340;&#24213;&#23618;&#23454;&#29616;&#20043;&#19968;&#65306; &#22914;&#26524;&#19968;&#20010;&#26377;&#24207;&#38598;&#21512;&#21253;&#21547;&#30340;&#20803;&#32032;&#25968;&#37327;&#27604;&#36739;&#22810;&#65292; &#21448;&#25110;&#32773;&#26377;&#24207;&#38598;&#21512;&#20013;&#20803;&#32032;&#30340;&#25104;&#21592;&#65288;member&#65289;&#26159;&#27604;&#36739;&#38271;&#30340;&#23383;&#31526;&#20018;&#26102;&#65292; Redis &#23601;&#20250;&#20351;&#29992;&#36339;&#36291;&#34920;&#26469;&#20316;&#20026;&#26377;&#24207;&#38598;&#21512;&#38190;&#30340;&#24213;&#23618;&#23454;&#29616;&#12290;</p>
<p>&#21644;&#38142;&#34920;&#12289;&#23383;&#20856;&#31561;&#25968;&#25454;&#32467;&#26500;&#34987;&#24191;&#27867;&#22320;&#24212;&#29992;&#22312; Redis &#20869;&#37096;&#19981;&#21516;&#65292; Redis &#21482;&#22312;&#20004;&#20010;&#22320;&#26041;&#29992;&#21040;&#20102;&#36339;&#36291;&#34920;&#65292; &#19968;&#20010;&#26159;&#23454;&#29616;&#26377;&#24207;&#38598;&#21512;&#38190;&#65292; &#21478;&#19968;&#20010;&#26159;&#22312;&#38598;&#32676;&#33410;&#28857;&#20013;&#29992;&#20316;&#20869;&#37096;&#25968;&#25454;&#32467;&#26500;&#65292; &#38500;&#27492;&#20043;&#22806;&#65292; &#36339;&#36291;&#34920;&#22312; Redis &#37324;&#38754;&#27809;&#26377;&#20854;&#20182;&#29992;&#36884;&#12290;</p>
<dl>
<dt>&#37325;&#28857;&#22238;&#39038; <code class="fold">@</code></dt>
<dd><ul>
<li>&#36339;&#36291;&#34920;&#26159;&#26377;&#24207;&#38598;&#21512;&#30340;&#24213;&#23618;&#23454;&#29616;&#20043;&#19968;&#65292; &#38500;&#27492;&#20043;&#22806;&#23427;&#22312; Redis &#20013;&#27809;&#26377;&#20854;&#20182;&#24212;&#29992;&#12290;</li>
<li>Redis &#30340;&#36339;&#36291;&#34920;&#23454;&#29616;&#30001; zskiplist &#21644; zskiplistNode &#20004;&#20010;&#32467;&#26500;&#32452;&#25104;&#65292; &#20854;&#20013; zskiplist &#29992;&#20110;&#20445;&#23384;&#36339;&#36291;&#34920;&#20449;&#24687;&#65288;&#27604;&#22914;&#34920;&#22836;&#33410;&#28857;&#12289;&#34920;&#23614;&#33410;&#28857;&#12289;&#38271;&#24230;&#65289;&#65292; &#32780; zskiplistNode &#21017;&#29992;&#20110;&#34920;&#31034;&#36339;&#36291;&#34920;&#33410;&#28857;&#12290;</li>
<li>&#27599;&#20010;&#36339;&#36291;&#34920;&#33410;&#28857;&#30340;&#23618;&#39640;&#37117;&#26159; 1 &#33267; 32 &#20043;&#38388;&#30340;&#38543;&#26426;&#25968;&#12290;</li>
<li>&#22312;&#21516;&#19968;&#20010;&#36339;&#36291;&#34920;&#20013;&#65292; &#22810;&#20010;&#33410;&#28857;&#21487;&#20197;&#21253;&#21547;&#30456;&#21516;&#30340;&#20998;&#20540;&#65292; &#20294;&#27599;&#20010;&#33410;&#28857;&#30340;&#25104;&#21592;&#23545;&#35937;&#24517;&#39035;&#26159;&#21807;&#19968;&#30340;&#12290;</li>
<li>&#36339;&#36291;&#34920;&#20013;&#30340;&#33410;&#28857;&#25353;&#29031;&#20998;&#20540;&#22823;&#23567;&#36827;&#34892;&#25490;&#24207;&#65292; &#24403;&#20998;&#20540;&#30456;&#21516;&#26102;&#65292;&#33410;&#28857;&#25353;&#29031;&#25104;&#21592;&#23545;&#35937;&#30340;&#22823;&#23567;&#36827;&#34892;&#25490;&#24207;&#12290;</li>
</ul>
</dd>
</dl>
</dd>
<dt>&#25972;&#25968;&#38598;&#21512; <code class="fold">@</code></dt>
<dd><p>&#25972;&#25968;&#38598;&#21512;&#65288;intset&#65289;&#26159;&#38598;&#21512;&#38190;&#30340;&#24213;&#23618;&#23454;&#29616;&#20043;&#19968;&#65306; &#24403;&#19968;&#20010;&#38598;&#21512;&#21482;&#21253;&#21547;&#25972;&#25968;&#20540;&#20803;&#32032;&#65292; &#24182;&#19988;&#36825;&#20010;&#38598;&#21512;&#30340;&#20803;&#32032;&#25968;&#37327;&#19981;&#22810;&#26102;&#65292; Redis &#23601;&#20250;&#20351;&#29992;&#25972;&#25968;&#38598;&#21512;&#20316;&#20026;&#38598;&#21512;&#38190;&#30340;&#24213;&#23618;&#23454;&#29616;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">struct</span> intset {

    <span class="co">// &#32534;&#30721;&#26041;&#24335;</span>
    <span class="dt">uint32_t</span> encoding;

    <span class="co">// &#38598;&#21512;&#21253;&#21547;&#30340;&#20803;&#32032;&#25968;&#37327;</span>
    <span class="dt">uint32_t</span> length;

    <span class="co">// &#20445;&#23384;&#20803;&#32032;&#30340;&#25968;&#32452;</span>
    <span class="dt">int8_t</span> contents[];

} intset;</code></pre></div>
<p>&#27599;&#24403;&#25105;&#20204;&#35201;&#23558;&#19968;&#20010;&#26032;&#20803;&#32032;&#28155;&#21152;&#21040;&#25972;&#25968;&#38598;&#21512;&#37324;&#38754;&#65292; &#24182;&#19988;&#26032;&#20803;&#32032;&#30340;&#31867;&#22411;&#27604;&#25972;&#25968;&#38598;&#21512;&#29616;&#26377;&#25152;&#26377;&#20803;&#32032;&#30340;&#31867;&#22411;&#37117;&#35201;&#38271;&#26102;&#65292; &#25972;&#25968;&#38598;&#21512;&#38656;&#35201;&#20808;&#36827;&#34892;&#21319;&#32423;&#65288;upgrade&#65289;&#65292; &#28982;&#21518;&#25165;&#33021;&#23558;&#26032;&#20803;&#32032;&#28155;&#21152;&#21040;&#25972;&#25968;&#38598;&#21512;&#37324;&#38754;&#12290;</p>
<p>&#21319;&#32423;&#25972;&#25968;&#38598;&#21512;&#24182;&#28155;&#21152;&#26032;&#20803;&#32032;&#20849;&#20998;&#20026;&#19977;&#27493;&#36827;&#34892;&#65306;</p>
<ul>
<li>&#26681;&#25454;&#26032;&#20803;&#32032;&#30340;&#31867;&#22411;&#65292; &#25193;&#23637;&#25972;&#25968;&#38598;&#21512;&#24213;&#23618;&#25968;&#32452;&#30340;&#31354;&#38388;&#22823;&#23567;&#65292; &#24182;&#20026;&#26032;&#20803;&#32032;&#20998;&#37197;&#31354;&#38388;&#12290;</li>
<li>&#23558;&#24213;&#23618;&#25968;&#32452;&#29616;&#26377;&#30340;&#25152;&#26377;&#20803;&#32032;&#37117;&#36716;&#25442;&#25104;&#19982;&#26032;&#20803;&#32032;&#30456;&#21516;&#30340;&#31867;&#22411;&#65292; &#24182;&#23558;&#31867;&#22411;&#36716;&#25442;&#21518;&#30340;&#20803;&#32032;&#25918;&#32622;&#21040;&#27491;&#30830;&#30340;&#20301;&#19978;&#65292; &#32780;&#19988;&#22312;&#25918;&#32622;&#20803;&#32032;&#30340;&#36807;&#31243;&#20013;&#65292; &#38656;&#35201;&#32487;&#32493;&#32500;&#25345;&#24213;&#23618;&#25968;&#32452;&#30340;&#26377;&#24207;&#24615;&#36136;&#19981;&#21464;&#12290;</li>
<li>&#23558;&#26032;&#20803;&#32032;&#28155;&#21152;&#21040;&#24213;&#23618;&#25968;&#32452;&#37324;&#38754;&#12290;</li>
</ul>
<p>&#27604;&#22914;&#35828;&#65292; &#22914;&#26524;&#25105;&#20204;&#19968;&#30452;&#21482;&#21521;&#25972;&#25968;&#38598;&#21512;&#28155;&#21152; int16_t &#31867;&#22411;&#30340;&#20540;&#65292; &#37027;&#20040;&#25972;&#25968;&#38598;&#21512;&#30340;&#24213;&#23618;&#23454;&#29616;&#23601;&#20250;&#19968;&#30452;&#26159; int16_t &#31867;&#22411;&#30340;&#25968;&#32452;&#65292; &#21482;&#26377;&#22312;&#25105;&#20204;&#35201;&#23558; int32_t &#31867;&#22411;&#25110;&#32773; int64_t &#31867;&#22411;&#30340;&#20540;&#28155;&#21152;&#21040;&#38598;&#21512;&#26102;&#65292; &#31243;&#24207;&#25165;&#20250;&#23545;&#25968;&#32452;&#36827;&#34892;&#21319;&#32423;&#12290;</p>
<p>&#25972;&#25968;&#38598;&#21512;&#19981;&#25903;&#25345;&#38477;&#32423;&#25805;&#20316;&#65292; &#19968;&#26086;&#23545;&#25968;&#32452;&#36827;&#34892;&#20102;&#21319;&#32423;&#65292; &#32534;&#30721;&#23601;&#20250;&#19968;&#30452;&#20445;&#25345;&#21319;&#32423;&#21518;&#30340;&#29366;&#24577;&#12290;</p>
<p>&#20030;&#20010;&#20363;&#23376;&#65292; &#23545;&#20110;&#22270; 6-11 &#25152;&#31034;&#30340;&#25972;&#25968;&#38598;&#21512;&#26469;&#35828;&#65292; &#21363;&#20351;&#25105;&#20204;&#23558;&#38598;&#21512;&#37324;&#21807;&#19968;&#19968;&#20010;&#30495;&#27491;&#38656;&#35201;&#20351;&#29992; int64_t &#31867;&#22411;&#26469;&#20445;&#23384;&#30340;&#20803;&#32032; 4294967295 &#21024;&#38500;&#20102;&#65292; &#25972;&#25968;&#38598;&#21512;&#30340;&#32534;&#30721;&#20173;&#28982;&#20250;&#32500;&#25345; INTSET_ENC_INT64 &#65292; &#24213;&#23618;&#25968;&#32452;&#20063;&#20173;&#28982;&#20250;&#26159; int64_t &#31867;&#22411;&#30340;&#65292;</p>
<pre><code>intsetNew           &#21019;&#24314;&#19968;&#20010;&#26032;&#30340;&#25972;&#25968;&#38598;&#21512;&#12290;  O(1)
intsetAdd           &#23558;&#32473;&#23450;&#20803;&#32032;&#28155;&#21152;&#21040;&#25972;&#25968;&#38598;&#21512;&#37324;&#38754;&#12290;  O(N)
intsetRemove        &#20174;&#25972;&#25968;&#38598;&#21512;&#20013;&#31227;&#38500;&#32473;&#23450;&#20803;&#32032;&#12290;  O(N)
intsetFind          &#26816;&#26597;&#32473;&#23450;&#20540;&#26159;&#21542;&#23384;&#22312;&#20110;&#38598;&#21512;&#12290;  &#22240;&#20026;&#24213;&#23618;&#25968;&#32452;&#26377;&#24207;&#65292;&#26597;&#25214;&#21487;&#20197;&#36890;&#36807;&#20108;&#20998;&#26597;&#25214;&#27861;&#26469;&#36827;&#34892;&#65292; &#25152;&#20197;&#22797;&#26434;&#24230;&#20026; O(log N) &#12290;
intsetRandom        &#20174;&#25972;&#25968;&#38598;&#21512;&#20013;&#38543;&#26426;&#36820;&#22238;&#19968;&#20010;&#20803;&#32032;&#12290;  O(1)
intsetGet           &#21462;&#20986;&#24213;&#23618;&#25968;&#32452;&#22312;&#32473;&#23450;&#32034;&#24341;&#19978;&#30340;&#20803;&#32032;&#12290;    O(1)
intsetLen           &#36820;&#22238;&#25972;&#25968;&#38598;&#21512;&#21253;&#21547;&#30340;&#20803;&#32032;&#20010;&#25968;&#12290;    O(1)
intsetBlobLen       &#36820;&#22238;&#25972;&#25968;&#38598;&#21512;&#21344;&#29992;&#30340;&#20869;&#23384;&#23383;&#33410;&#25968;&#12290;  O(1)</code></pre>
<p>&#37325;&#28857;&#22238;&#39038;</p>
<ul>
<li>&#25972;&#25968;&#38598;&#21512;&#26159;&#38598;&#21512;&#38190;&#30340;&#24213;&#23618;&#23454;&#29616;&#20043;&#19968;&#12290;</li>
<li>&#25972;&#25968;&#38598;&#21512;&#30340;&#24213;&#23618;&#23454;&#29616;&#20026;&#25968;&#32452;&#65292; &#36825;&#20010;&#25968;&#32452;&#20197;&#26377;&#24207;&#12289;&#26080;&#37325;&#22797;&#30340;&#26041;&#24335;&#20445;&#23384;&#38598;&#21512;&#20803;&#32032;&#65292; &#22312;&#26377;&#38656;&#35201;&#26102;&#65292; &#31243;&#24207;&#20250;&#26681;&#25454;&#26032;&#28155;&#21152;&#20803;&#32032;&#30340;&#31867;&#22411;&#65292; &#25913;&#21464;&#36825;&#20010;&#25968;&#32452;&#30340;&#31867;&#22411;&#12290;</li>
<li>&#21319;&#32423;&#25805;&#20316;&#20026;&#25972;&#25968;&#38598;&#21512;&#24102;&#26469;&#20102;&#25805;&#20316;&#19978;&#30340;&#28789;&#27963;&#24615;&#65292; &#24182;&#19988;&#23613;&#21487;&#33021;&#22320;&#33410;&#32422;&#20102;&#20869;&#23384;&#12290;</li>
<li>&#25972;&#25968;&#38598;&#21512;&#21482;&#25903;&#25345;&#21319;&#32423;&#25805;&#20316;&#65292; &#19981;&#25903;&#25345;&#38477;&#32423;&#25805;&#20316;&#12290;</li>
</ul>
</dd>
<dt>&#21387;&#32553;&#21015;&#34920; <code class="fold">@</code></dt>
<dd><p>&#21387;&#32553;&#21015;&#34920;&#65288;ziplist&#65289;&#26159;&#21015;&#34920;&#38190;&#21644;&#21704;&#24076;&#38190;&#30340;&#24213;&#23618;&#23454;&#29616;&#20043;&#19968;&#12290;</p>
<p>&#24403;&#19968;&#20010;&#21015;&#34920;&#38190;&#21482;&#21253;&#21547;&#23569;&#37327;&#21015;&#34920;&#39033;&#65292; &#24182;&#19988;&#27599;&#20010;&#21015;&#34920;&#39033;&#35201;&#20040;&#23601;&#26159;&#23567;&#25972;&#25968;&#20540;&#65292; &#35201;&#20040;&#23601;&#26159;&#38271;&#24230;&#27604;&#36739;&#30701;&#30340;&#23383;&#31526;&#20018;&#65292; &#37027;&#20040; Redis &#23601;&#20250;&#20351;&#29992;&#21387;&#32553;&#21015;&#34920;&#26469;&#20570;&#21015;&#34920;&#38190;&#30340;&#24213;&#23618;&#23454;&#29616;&#12290;</p>
<dl>
<dt>&#21387;&#32553;&#21015;&#34920;&#30340;&#26500;&#25104; <code class="fold">@</code></dt>
<dd><p>&#21387;&#32553;&#21015;&#34920;&#26159; Redis &#20026;&#20102;&#33410;&#32422;&#20869;&#23384;&#32780;&#24320;&#21457;&#30340;&#65292; &#30001;&#19968;&#31995;&#21015;&#29305;&#27530;&#32534;&#30721;&#30340;&#36830;&#32493;&#20869;&#23384;&#22359;&#32452;&#25104;&#30340;&#39034;&#24207;&#22411;&#65288;sequential&#65289;&#25968;&#25454;&#32467;&#26500;&#12290;</p>
<p>&#19968;&#20010;&#21387;&#32553;&#21015;&#34920;&#21487;&#20197;&#21253;&#21547;&#20219;&#24847;&#22810;&#20010;&#33410;&#28857;&#65288;entry&#65289;&#65292; &#27599;&#20010;&#33410;&#28857;&#21487;&#20197;&#20445;&#23384;&#19968;&#20010;&#23383;&#33410;&#25968;&#32452;&#25110;&#32773;&#19968;&#20010;&#25972;&#25968;&#20540;&#12290;</p>
<p>&#22270; 7-1 &#23637;&#31034;&#20102;&#21387;&#32553;&#21015;&#34920;&#30340;&#21508;&#20010;&#32452;&#25104;&#37096;&#20998;&#65292; &#34920; 7-1 &#21017;&#35760;&#24405;&#20102;&#21508;&#20010;&#32452;&#25104;&#37096;&#20998;&#30340;&#31867;&#22411;&#12289;&#38271;&#24230;&#12289;&#20197;&#21450;&#29992;&#36884;&#12290;</p>
<div class="figure">
<img src="http://redisbook.com/_images/graphviz-fe42f343a3f32f477efb5e895da547d476a7c97d.png" />

</div>
<div class="figure">
<img src="http://redisbook.com/_images/graphviz-071fe5086440a360087904af9a5f78e8e02c2d8d.png" />

</div>
<p>&#27599;&#20010;&#21387;&#32553;&#21015;&#34920;&#33410;&#28857;&#37117;&#30001; previous_entry_length &#12289; encoding &#12289; content &#19977;&#20010;&#37096;&#20998;&#32452;&#25104;&#65292; &#22914;&#22270; 7-4 &#25152;&#31034;&#12290;</p>
<div class="figure">
<img src="http://redisbook.com/_images/graphviz-49750cc228ee403c4ef64ad1d2911154765bf3d3.png" />

</div>
<p>&#21387;&#32553;&#21015;&#34920;&#30340;&#20174;&#34920;&#23614;&#21521;&#34920;&#22836;&#36941;&#21382;&#25805;&#20316;&#23601;&#26159;&#20351;&#29992;&#36825;&#19968;&#21407;&#29702;&#23454;&#29616;&#30340;&#65306;&#21482;&#35201;&#25105;&#20204;&#25317;&#26377;&#20102;&#19968;&#20010;&#25351;&#21521;&#26576;&#20010;&#33410;&#28857;&#36215;&#22987;&#22320;&#22336;&#30340;&#25351;&#38024;&#65292; &#37027;&#20040;&#36890;&#36807;&#36825;&#20010;&#25351;&#38024;&#20197;&#21450;&#36825;&#20010;&#33410;&#28857;&#30340; previous_entry_length &#23646;&#24615;&#65292; &#31243;&#24207;&#23601;&#21487;&#20197;&#19968;&#30452;&#21521;&#21069;&#19968;&#20010;&#33410;&#28857;&#22238;&#28335;&#65292; &#26368;&#32456;&#21040;&#36798;&#21387;&#32553;&#21015;&#34920;&#30340;&#34920;&#22836;&#33410;&#28857;&#12290;</p>
<div class="figure">
<img src="http://redisbook.com/_images/graphviz-cfb376f8015f3af9f59acd30dc71a35e90c6d763.png" />

</div>
</dd>
<dt>&#36830;&#38145;&#26356;&#26032; <code class="fold">@</code></dt>
<dd><p>&#22240;&#20026;&#36830;&#38145;&#26356;&#26032;&#22312;&#26368;&#22351;&#24773;&#20917;&#19979;&#38656;&#35201;&#23545;&#21387;&#32553;&#21015;&#34920;&#25191;&#34892; N &#27425;&#31354;&#38388;&#37325;&#20998;&#37197;&#25805;&#20316;&#65292; &#32780;&#27599;&#27425;&#31354;&#38388;&#37325;&#20998;&#37197;&#30340;&#26368;&#22351;&#22797;&#26434;&#24230;&#20026; O(N) &#65292; &#25152;&#20197;&#36830;&#38145;&#26356;&#26032;&#30340;&#26368;&#22351;&#22797;&#26434;&#24230;&#20026; O(N^2) &#12290;</p>
<p>&#35201;&#27880;&#24847;&#30340;&#26159;&#65292; &#23613;&#31649;&#36830;&#38145;&#26356;&#26032;&#30340;&#22797;&#26434;&#24230;&#36739;&#39640;&#65292; &#20294;&#23427;&#30495;&#27491;&#36896;&#25104;&#24615;&#33021;&#38382;&#39064;&#30340;&#20960;&#29575;&#26159;&#24456;&#20302;&#30340;&#65306;</p>
<ul>
<li>&#39318;&#20808;&#65292; &#21387;&#32553;&#21015;&#34920;&#37324;&#35201;&#24688;&#22909;&#26377;&#22810;&#20010;&#36830;&#32493;&#30340;&#12289;&#38271;&#24230;&#20171;&#20110; 250 &#23383;&#33410;&#33267; 253 &#23383;&#33410;&#20043;&#38388;&#30340;&#33410;&#28857;&#65292; &#36830;&#38145;&#26356;&#26032;&#25165;&#26377;&#21487;&#33021;&#34987;&#24341;&#21457;&#65292; &#22312;&#23454;&#38469;&#20013;&#65292; &#36825;&#31181;&#24773;&#20917;&#24182;&#19981;&#22810;&#35265;&#65307;</li>
<li>&#20854;&#27425;&#65292; &#21363;&#20351;&#20986;&#29616;&#36830;&#38145;&#26356;&#26032;&#65292; &#20294;&#21482;&#35201;&#34987;&#26356;&#26032;&#30340;&#33410;&#28857;&#25968;&#37327;&#19981;&#22810;&#65292; &#23601;&#19981;&#20250;&#23545;&#24615;&#33021;&#36896;&#25104;&#20219;&#20309;&#24433;&#21709;&#65306; &#27604;&#22914;&#35828;&#65292; &#23545;&#19977;&#20116;&#20010;&#33410;&#28857;&#36827;&#34892;&#36830;&#38145;&#26356;&#26032;&#26159;&#32477;&#23545;&#19981;&#20250;&#24433;&#21709;&#24615;&#33021;&#30340;&#65307;</li>
</ul>
<p>&#22240;&#20026;&#20197;&#19978;&#21407;&#22240;&#65292; ziplistPush &#31561;&#21629;&#20196;&#30340;&#24179;&#22343;&#22797;&#26434;&#24230;&#20165;&#20026; O(N) &#65292; &#22312;&#23454;&#38469;&#20013;&#65292; &#25105;&#20204;&#21487;&#20197;&#25918;&#24515;&#22320;&#20351;&#29992;&#36825;&#20123;&#20989;&#25968;&#65292; &#32780;&#19981;&#24517;&#25285;&#24515;&#36830;&#38145;&#26356;&#26032;&#20250;&#24433;&#21709;&#21387;&#32553;&#21015;&#34920;&#30340;&#24615;&#33021;&#12290;</p>
</dd>
<dt>&#37325;&#28857;&#22238;&#39038; <code class="fold">@</code></dt>
<dd><ul>
<li>&#21387;&#32553;&#21015;&#34920;&#26159;&#19968;&#31181;&#20026;&#33410;&#32422;&#20869;&#23384;&#32780;&#24320;&#21457;&#30340;&#39034;&#24207;&#22411;&#25968;&#25454;&#32467;&#26500;&#12290;</li>
<li>&#21387;&#32553;&#21015;&#34920;&#34987;&#29992;&#20316;&#21015;&#34920;&#38190;&#21644;&#21704;&#24076;&#38190;&#30340;&#24213;&#23618;&#23454;&#29616;&#20043;&#19968;&#12290;</li>
<li>&#21387;&#32553;&#21015;&#34920;&#21487;&#20197;&#21253;&#21547;&#22810;&#20010;&#33410;&#28857;&#65292;&#27599;&#20010;&#33410;&#28857;&#21487;&#20197;&#20445;&#23384;&#19968;&#20010;&#23383;&#33410;&#25968;&#32452;&#25110;&#32773;&#25972;&#25968;&#20540;&#12290;</li>
<li>&#28155;&#21152;&#26032;&#33410;&#28857;&#21040;&#21387;&#32553;&#21015;&#34920;&#65292; &#25110;&#32773;&#20174;&#21387;&#32553;&#21015;&#34920;&#20013;&#21024;&#38500;&#33410;&#28857;&#65292; &#21487;&#33021;&#20250;&#24341;&#21457;&#36830;&#38145;&#26356;&#26032;&#25805;&#20316;&#65292; &#20294;&#36825;&#31181;&#25805;&#20316;&#20986;&#29616;&#30340;&#20960;&#29575;&#24182;&#19981;&#39640;&#12290;</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>&#23545;&#35937;</p>
</dd>
<dt>&#31532;&#20108;&#37096;&#20998;&#65306;&#21333;&#26426;&#25968;&#25454;&#24211;&#30340;&#23454;&#29616; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#25968;&#25454;&#24211; <code class="fold">@</code></dt>
<dd><p>&#26381;&#21153;&#22120;&#20013;&#30340;&#25968;&#25454;&#24211;&#20999;&#25442;&#25968;&#25454;&#24211;&#25968;&#25454;&#24211;&#38190;&#31354;&#38388;&#35774;&#32622;&#38190;&#30340;&#29983;&#23384;&#26102;&#38388;&#25110;&#36807;&#26399;&#26102;&#38388;&#36807;&#26399;&#38190;&#21024;&#38500;&#31574;&#30053; Redis &#30340;&#36807;&#26399;&#38190;&#21024;&#38500;&#31574;&#30053; AOF &#12289;RDB &#21644;&#22797;&#21046;&#21151;&#33021;&#23545;&#36807;&#26399;&#38190;&#30340;&#22788;&#29702;&#25968;&#25454;&#24211;&#36890;&#30693;&#37325;&#28857;&#22238;&#39038;</p>
</dd>
<dt>RDB &#25345;&#20037;&#21270; <code class="fold">@</code></dt>
<dd><p>RDB &#25991;&#20214;&#30340;&#21019;&#24314;&#19982;&#36733;&#20837;&#33258;&#21160;&#38388;&#38548;&#24615;&#20445;&#23384; RDB &#25991;&#20214;&#32467;&#26500;&#20998;&#26512; RDB &#25991;&#20214;&#37325;&#28857;&#22238;&#39038;</p>
</dd>
<dt>AOF &#25345;&#20037;&#21270; <code class="fold">@</code></dt>
<dd><p>AOF &#25345;&#20037;&#21270;&#30340;&#23454;&#29616; AOF &#25991;&#20214;&#30340;&#36733;&#20837;&#19982;&#25968;&#25454;&#36824;&#21407; AOF &#37325;&#20889;&#37325;&#28857;&#22238;&#39038;</p>
</dd>
<dt>&#20107;&#20214; <code class="fold">@</code></dt>
<dd><p>&#25991;&#20214;&#20107;&#20214;&#26102;&#38388;&#20107;&#20214;&#20107;&#20214;&#30340;&#35843;&#24230;&#19982;&#25191;&#34892;&#37325;&#28857;&#22238;&#39038;&#21442;&#32771;&#36164;&#26009;</p>
</dd>
<dt>&#23458;&#25143;&#31471; <code class="fold">@</code></dt>
<dd><p>&#23458;&#25143;&#31471;&#23646;&#24615;&#23458;&#25143;&#31471;&#30340;&#21019;&#24314;&#19982;&#20851;&#38381;&#37325;&#28857;&#22238;&#39038;</p>
</dd>
<dt>&#26381;&#21153;&#22120; <code class="fold">@</code></dt>
<dd><p>&#21629;&#20196;&#35831;&#27714;&#30340;&#25191;&#34892;&#36807;&#31243; serverCron &#20989;&#25968;&#21021;&#22987;&#21270;&#26381;&#21153;&#22120;&#37325;&#28857;&#22238;&#39038;</p>
</dd>
</dl>
</dd>
<dt>&#31532;&#19977;&#37096;&#20998;&#65306;&#22810;&#26426;&#25968;&#25454;&#24211;&#30340;&#23454;&#29616; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#22797;&#21046; <code class="fold">@</code></dt>
<dd><p>&#26087;&#29256;&#22797;&#21046;&#21151;&#33021;&#30340;&#23454;&#29616;&#26087;&#29256;&#22797;&#21046;&#21151;&#33021;&#30340;&#32570;&#38519;&#26032;&#29256;&#22797;&#21046;&#21151;&#33021;&#30340;&#23454;&#29616;&#37096;&#20998;&#37325;&#21516;&#27493;&#30340;&#23454;&#29616; PSYNC &#21629;&#20196;&#30340;&#23454;&#29616;&#22797;&#21046;&#30340;&#23454;&#29616;&#24515;&#36339;&#26816;&#27979;&#37325;&#28857;&#22238;&#39038;</p>
</dd>
<dt>Sentinel <code class="fold">@</code></dt>
<dd><p>&#21551;&#21160;&#24182;&#21021;&#22987;&#21270; Sentinel &#33719;&#21462;&#20027;&#26381;&#21153;&#22120;&#20449;&#24687;&#33719;&#21462;&#20174;&#26381;&#21153;&#22120;&#20449;&#24687;&#21521;&#20027;&#26381;&#21153;&#22120;&#21644;&#20174;&#26381;&#21153;&#22120;&#21457;&#36865;&#20449;&#24687;&#25509;&#25910;&#26469;&#33258;&#20027;&#26381;&#21153;&#22120;&#21644;&#20174;&#26381;&#21153;&#22120;&#30340;&#39057;&#36947;&#20449;&#24687;&#26816;&#27979;&#20027;&#35266;&#19979;&#32447;&#29366;&#24577;&#26816;&#26597;&#23458;&#35266;&#19979;&#32447;&#29366;&#24577;&#36873;&#20030;&#39046;&#22836; Sentinel &#25925;&#38556;&#36716;&#31227;&#37325;&#28857;&#22238;&#39038;&#21442;&#32771;&#36164;&#26009;</p>
</dd>
<dt>&#38598;&#32676; <code class="fold">@</code></dt>
<dd><p>&#33410;&#28857;&#27133;&#25351;&#27966;&#22312;&#38598;&#32676;&#20013;&#25191;&#34892;&#21629;&#20196;&#37325;&#26032;&#20998;&#29255; ASK &#38169;&#35823;&#22797;&#21046;&#19982;&#25925;&#38556;&#36716;&#31227;&#28040;&#24687;&#37325;&#28857;&#22238;&#39038;</p>
</dd>
</dl>
</dd>
<dt>&#31532;&#22235;&#37096;&#20998;&#65306;&#29420;&#31435;&#21151;&#33021;&#30340;&#23454;&#29616; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#21457;&#24067;&#19982;&#35746;&#38405; <code class="fold">@</code></dt>
<dd><p>&#39057;&#36947;&#30340;&#35746;&#38405;&#19982;&#36864;&#35746;&#27169;&#24335;&#30340;&#35746;&#38405;&#19982;&#36864;&#35746;&#21457;&#36865;&#28040;&#24687;&#26597;&#30475;&#35746;&#38405;&#20449;&#24687;&#37325;&#28857;&#22238;&#39038;&#21442;&#32771;&#36164;&#26009;</p>
</dd>
<dt>&#20107;&#21153; <code class="fold">@</code></dt>
<dd><p>&#20107;&#21153;&#30340;&#23454;&#29616; WATCH &#21629;&#20196;&#30340;&#23454;&#29616;&#20107;&#21153;&#30340; ACID &#24615;&#36136;&#37325;&#28857;&#22238;&#39038;&#21442;&#32771;&#36164;&#26009;</p>
</dd>
<dt>Lua &#33050;&#26412; <code class="fold">@</code></dt>
<dd><p>&#21019;&#24314;&#24182;&#20462;&#25913; Lua &#29615;&#22659; Lua &#29615;&#22659;&#21327;&#20316;&#32452;&#20214; EVAL &#21629;&#20196;&#30340;&#23454;&#29616; EVALSHA &#21629;&#20196;&#30340;&#23454;&#29616;&#33050;&#26412;&#31649;&#29702;&#21629;&#20196;&#30340;&#23454;&#29616;&#33050;&#26412;&#22797;&#21046;&#37325;&#28857;&#22238;&#39038;&#21442;&#32771;&#36164;&#26009;</p>
</dd>
<dt>&#25490;&#24207; <code class="fold">@</code></dt>
<dd><p>SORT <key> &#21629;&#20196;&#30340;&#23454;&#29616; ALPHA &#36873;&#39033;&#30340;&#23454;&#29616; ASC &#36873;&#39033;&#21644; DESC &#36873;&#39033;&#30340;&#23454;&#29616; BY &#36873;&#39033;&#30340;&#23454;&#29616;&#24102;&#26377; ALPHA &#36873;&#39033;&#30340; BY &#36873;&#39033;&#30340;&#23454;&#29616; LIMIT &#36873;&#39033;&#30340;&#23454;&#29616; GET &#36873;&#39033;&#30340;&#23454;&#29616; STORE &#36873;&#39033;&#30340;&#23454;&#29616;&#22810;&#20010;&#36873;&#39033;&#30340;&#25191;&#34892;&#39034;&#24207;&#37325;&#28857;&#22238;&#39038;</p>
</dd>
<dt>&#20108;&#36827;&#21046;&#20301;&#25968;&#32452; <code class="fold">@</code></dt>
<dd><p>&#20301;&#25968;&#32452;&#30340;&#34920;&#31034; GETBIT &#21629;&#20196;&#30340;&#23454;&#29616; SETBIT &#21629;&#20196;&#30340;&#23454;&#29616; BITCOUNT &#21629;&#20196;&#30340;&#23454;&#29616; BITOP &#21629;&#20196;&#30340;&#23454;&#29616;&#37325;&#28857;&#22238;&#39038;&#21442;&#32771;&#36164;&#26009;</p>
</dd>
<dt>&#24930;&#26597;&#35810;&#26085;&#24535; <code class="fold">@</code></dt>
<dd><p>&#24930;&#26597;&#35810;&#35760;&#24405;&#30340;&#20445;&#23384;&#24930;&#26597;&#35810;&#26085;&#24535;&#30340;&#38405;&#35272;&#21644;&#21024;&#38500;&#28155;&#21152;&#26032;&#26085;&#24535;&#37325;&#28857;&#22238;&#39038;</p>
</dd>
<dt>&#30417;&#35270;&#22120; <code class="fold">@</code></dt>
<dd><p>&#25104;&#20026;&#30417;&#35270;&#22120;&#21521;&#30417;&#35270;&#22120;&#21457;&#36865;&#21629;&#20196;&#20449;&#24687;&#37325;&#28857;&#22238;&#39038;</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>LeetCode &#39064;&#30446;&#24635;&#32467;/&#20998;&#31867; <code class="fold">@</code></dt>
<dd><p>&#27880;&#65306;&#27492;&#20998;&#31867;&#20165;&#20379;&#22823;&#27010;&#21442;&#32771;&#65292;&#27809;&#26377;&#31934;&#38613;&#32454;&#29730;&#12290;&#26377;&#19981;&#21516;&#24847;&#35265;&#27426;&#36814;&#35780;&#35770;~ &#27426;&#36814;&#21442;&#32771;&#25105;&#30340;leetcode&#20195;&#30721;</p>
<p>&#21033;&#29992;&#22534;&#26632;&#65306;</p>
<ul>
<li>http://oj.leetcode.com/problems/evaluate-reverse-polish-notation/</li>
<li>http://oj.leetcode.com/problems/longest-valid-parentheses/ &#65288;&#20063;&#21487;&#20197;&#29992;&#19968;&#32500;&#25968;&#32452;&#65292;&#36138;&#24515;&#65289;</li>
<li>http://oj.leetcode.com/problems/valid-parentheses/</li>
<li>http://oj.leetcode.com/problems/largest-rectangle-in-histogram/</li>
<li>&#29305;&#21035;&#27880;&#24847;&#32454;&#33410;&#65306;http://oj.leetcode.com/problems/trapping-rain-water/</li>
</ul>
<p>&#22810;&#31181;&#25968;&#25454;&#32467;&#26500;&#65306;</p>
<ul>
<li>http://oj.leetcode.com/problems/lru-cache/</li>
<li>http://oj.leetcode.com/problems/substring-with-concatenation-of-all-words/ (&#27880;&#24847;&#36941;&#21382;&#26041;&#27861;&#65289;</li>
<li>HASH&#65306;http://oj.leetcode.com/problems/longest-consecutive-sequence/</li>
</ul>
<p>&#31616;&#21333;&#32534;&#31243;&#65306;</p>
<ul>
<li>http://oj.leetcode.com/problems/longest-common-prefix/</li>
<li>http://oj.leetcode.com/problems/string-to-integer-atoi/ (&#20998;&#26512;&#65292;&#25511;&#21046;&#35821;&#21477;&#65289;</li>
</ul>
<p>&#25490;&#24207; &amp; &#26597;&#25214;&#65306;</p>
<ul>
<li>&#20108;&#20998;&#26597;&#25214;&#65306;http://oj.leetcode.com/problems/search-a-2d-matrix/</li>
<li>&#20108;&#20998;&#26597;&#25214;&#36827;&#38454;&#65306;http://oj.leetcode.com/problems/search-for-a-range/</li>
<li>&#20108;&#20998;&#26597;&#25214;&#24212;&#29992;&#65306;http://oj.leetcode.com/problems/sqrtx/</li>
<li>&#20108;&#20998;&#26597;&#25214;&#24212;&#29992;&#65306;http://oj.leetcode.com/problems/search-insert-position/</li>
<li>&#20108;&#20998;&#26597;&#25214;&#21464;&#31181;&#65306;http://oj.leetcode.com/problems/search-in-rotated-sorted-array/</li>
<li>&#20108;&#20998;&#26597;&#25214;&#21464;&#31181;&#65306;http://oj.leetcode.com/problems/search-in-rotated-sorted-array-ii/</li>
</ul>
<p>&#31616;&#21333;&#25968;&#23398;&#65306;</p>
<ul>
<li>http://oj.leetcode.com/problems/pascals-triangle/</li>
<li>http://oj.leetcode.com/problems/pascals-triangle-ii/</li>
<li>http://oj.leetcode.com/problems/powx-n/</li>
<li>http://oj.leetcode.com/problems/reverse-integer/</li>
<li>http://oj.leetcode.com/problems/plus-one/</li>
<li>http://oj.leetcode.com/problems/unique-paths/</li>
<li>http://oj.leetcode.com/problems/palindrome-number/</li>
<li>http://oj.leetcode.com/problems/permutation-sequence/</li>
<li>http://oj.leetcode.com/problems/merge-intervals/</li>
<li>http://oj.leetcode.com/problems/valid-number/</li>
<li>http://oj.leetcode.com/problems/climbing-stairs/</li>
<li>http://oj.leetcode.com/problems/roman-to-integer/</li>
<li>http://oj.leetcode.com/problems/integer-to-roman/</li>
<li>http://oj.leetcode.com/problems/divide-two-integers/</li>
<li>&#21306;&#38388;&#65306;http://oj.leetcode.com/problems/insert-interval/</li>
</ul>
<p>&#22823;&#25968;&#30340;&#25968;&#23398;&#36816;&#31639;&#65306;</p>
<ul>
<li>http://oj.leetcode.com/problems/add-binary/</li>
<li>http://oj.leetcode.com/problems/add-two-numbers/</li>
</ul>
<p>&#25968;&#32452;&#65306;</p>
<ul>
<li>http://oj.leetcode.com/problems/remove-element/</li>
<li>http://oj.leetcode.com/problems/merge-sorted-array/</li>
<li>http://oj.leetcode.com/problems/first-missing-positive/</li>
<li>http://oj.leetcode.com/problems/spiral-matrix/</li>
<li>http://oj.leetcode.com/problems/spiral-matrix-ii/</li>
<li>http://oj.leetcode.com/problems/rotate-image/</li>
<li>&#36941;&#21382;&#25216;&#24039;&#65306;http://oj.leetcode.com/problems/container-with-most-water/</li>
<li>http://oj.leetcode.com/problems/two-sum/</li>
<li>http://oj.leetcode.com/problems/3sum/</li>
<li>http://oj.leetcode.com/problems/3sum-closest/</li>
<li>http://oj.leetcode.com/problems/4sum/</li>
<li>http://oj.leetcode.com/problems/set-matrix-zeroes/</li>
<li>&#29992;&#22909;&#26631;&#35760;&#25968;&#32452;&#65306;http://oj.leetcode.com/problems/valid-sudoku/</li>
<li>http://oj.leetcode.com/problems/next-permutation/</li>
<li>http://oj.leetcode.com/problems/word-search/</li>
<li>http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/</li>
<li>http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array-ii/</li>
<li>http://oj.leetcode.com/problems/sort-colors/</li>
</ul>
<p>&#26292;&#21147;&#26041;&#27861;/&#32454;&#33410;&#23454;&#29616;&#65306;</p>
<ul>
<li>http://oj.leetcode.com/problems/max-points-on-a-line/</li>
</ul>
<p>&#38142;&#34920;&#65306;</p>
<ul>
<li>&#24402;&#24182;&#25490;&#24207;&#65306;http://oj.leetcode.com/problems/sort-list/</li>
<li>&#25554;&#20837;&#25490;&#24207;&#65306;http://oj.leetcode.com/problems/insertion-sort-list/</li>
<li>&#21453;&#36716;&#12289;&#25554;&#20837;&#65306;http://oj.leetcode.com/problems/reorder-list/</li>
<li>&#26816;&#27979;&#26159;&#21542;&#26377;&#29615;&#65306;http://oj.leetcode.com/problems/linked-list-cycle/</li>
<li>&#30830;&#23450;&#38142;&#34920;&#29615;&#30340;&#36215;&#28857;&#65306;http://oj.leetcode.com/problems/linked-list-cycle-ii/</li>
<li>Deep Copy &#24102;&#26377;&#38543;&#26426;&#25351;&#38024;&#30340;&#38142;&#34920;&#65306;http://oj.leetcode.com/problems/copy-list-with-random-pointer/</li>
<li>&#38142;&#34920;&#32454;&#33410;&#65306;http://oj.leetcode.com/problems/rotate-list/</li>
<li>http://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/</li>
<li>&#21024;&#38500;&#32454;&#33410;&#65306;http://oj.leetcode.com/problems/remove-duplicates-from-sorted-list-ii/</li>
<li>http://oj.leetcode.com/problems/partition-list/</li>
<li>http://oj.leetcode.com/problems/swap-nodes-in-pairs/</li>
<li>Merge &#20004;&#20010;&#38142;&#34920;&#65306;http://oj.leetcode.com/problems/merge-two-sorted-lists/</li>
<li>Merge &#22810;&#38142;&#34920;&#65306;http://oj.leetcode.com/problems/merge-k-sorted-lists/</li>
<li>&#32454;&#33410;&#65306;http://oj.leetcode.com/problems/reverse-nodes-in-k-group/</li>
<li>http://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/</li>
<li>http://oj.leetcode.com/problems/reverse-linked-list-ii/</li>
</ul>
<p>&#20108;&#21449;&#26641;&#36941;&#21382;&#65306;&#36882;&#24402; &amp; &#38750;&#36882;&#24402;</p>
<ul>
<li>http://oj.leetcode.com/problems/same-tree/</li>
<li>&#21069;&#24207;&#65306;http://oj.leetcode.com/problems/binary-tree-preorder-traversal/</li>
<li>&#20013;&#24207;&#65306;http://oj.leetcode.com/problems/binary-tree-inorder-traversal/</li>
<li>&#21518;&#24207;&#65306;http://oj.leetcode.com/problems/binary-tree-postorder-traversal/</li>
<li>&#36941;&#21382;&#21464;&#31181;&#65306;http://oj.leetcode.com/problems/sum-root-to-leaf-numbers/</li>
<li>&#36941;&#21382;&#21464;&#31181;&#65306;http://oj.leetcode.com/problems/path-sum/</li>
<li>&#36941;&#21382;&#21464;&#31181;&#65306;http://oj.leetcode.com/problems/path-sum-ii/</li>
<li>&#36941;&#21382;&#21464;&#31181;&#65306;http://oj.leetcode.com/problems/maximum-depth-of-binary-tree/</li>
<li>&#36941;&#21382;&#21464;&#31181;&#65306;http://oj.leetcode.com/problems/minimum-depth-of-binary-tree/</li>
<li>&#37325;&#24314;&#20108;&#21449;&#26641;&#65306;http://oj.leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</li>
<li>&#37325;&#24314;&#20108;&#21449;&#26641;&#65306;http://oj.leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</li>
<li>&#23618;&#27425;&#36941;&#21382;&#21464;&#31181;&#65306;http://oj.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/</li>
<li>&#36941;&#21382;&#21464;&#31181;&#65306;http://oj.leetcode.com/problems/symmetric-tree/</li>
<li>&#36941;&#21382;&#24212;&#29992;&#65306;http://oj.leetcode.com/problems/binary-tree-maximum-path-sum/</li>
<li>&#36941;&#21382;&#24212;&#29992;&#65306;http://oj.leetcode.com/problems/balanced-binary-tree/</li>
<li>&#36941;&#21382;&#24212;&#29992;&#65306;http://oj.leetcode.com/problems/recover-binary-search-tree/</li>
<li>&#36941;&#21382;&#24212;&#29992;&#65306;http://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/</li>
<li>level&#36941;&#21382;&#65306;http://oj.leetcode.com/problems/binary-tree-level-order-traversal/</li>
<li>level &#36941;&#21382;&#65306;http://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/</li>
<li>level &#36941;&#21382;&#21464;&#31181;&#65306;http://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node/</li>
<li>level &#36941;&#21382;&#21464;&#31181;&#65306;http://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/</li>
</ul>
<p>&#38382;&#39064;&#20998;&#26512;/&#26234;&#21830;/&#32454;&#33410;&#65306;</p>
<ul>
<li>http://oj.leetcode.com/problems/single-number/</li>
<li>http://oj.leetcode.com/problems/single-number-ii/</li>
<li>http://oj.leetcode.com/problems/candy/ &#65311;</li>
<li>http://oj.leetcode.com/problems/gas-station/</li>
</ul>
<p>&#21160;&#24577;&#35268;&#21010;&#65306;</p>
<ul>
<li>http://oj.leetcode.com/problems/triangle/ &#65288;&#26368;&#30701;&#36335;&#24452;&#65289;</li>
<li>http://oj.leetcode.com/problems/subsets/ &#65288;&#21478;&#19968;&#31181;&#24418;&#24335;&#65289;</li>
<li>http://oj.leetcode.com/problems/subsets-ii/</li>
<li>http://oj.leetcode.com/problems/edit-distance/ &#65288;&#32463;&#20856;&#65289;</li>
<li>http://oj.leetcode.com/problems/word-break/</li>
<li>http://oj.leetcode.com/problems/word-break-ii/</li>
<li>http://oj.leetcode.com/problems/unique-binary-search-trees/ &#65288;&#21160;&#24577;&#35268;&#21010;&#36991;&#20813;&#36882;&#24402;&#65289;</li>
<li>http://oj.leetcode.com/problems/unique-paths-ii/</li>
<li>http://oj.leetcode.com/problems/scramble-string/</li>
<li>http://oj.leetcode.com/problems/palindrome-partitioning/</li>
<li>http://oj.leetcode.com/problems/palindrome-partitioning-ii/</li>
<li>http://oj.leetcode.com/problems/interleaving-string/</li>
<li>http://oj.leetcode.com/problems/distinct-subsequences/</li>
<li>http://oj.leetcode.com/problems/decode-ways/</li>
<li>http://oj.leetcode.com/problems/gray-code/</li>
<li>http://oj.leetcode.com/problems/minimum-path-sum/</li>
</ul>
<p>&#22238;&#28335;&#65306;</p>
<ul>
<li>http://oj.leetcode.com/problems/combinations/</li>
<li>http://oj.leetcode.com/problems/generate-parentheses/</li>
<li>http://oj.leetcode.com/problems/combination-sum/</li>
<li>http://oj.leetcode.com/problems/combination-sum-ii/</li>
<li>http://oj.leetcode.com/problems/sudoku-solver/</li>
<li>&#32463;&#20856;N&#30343;&#21518;&#65306;http://oj.leetcode.com/problems/n-queens/</li>
<li>http://oj.leetcode.com/problems/n-queens-ii/</li>
<li>http://oj.leetcode.com/problems/letter-combinations-of-a-phone-number/</li>
</ul>
<p>&#36138;&#24515;&#65306;</p>
<ul>
<li>http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/</li>
<li>http://oj.leetcode.com/problems/jump-game/</li>
<li>http://oj.leetcode.com/problems/jump-game-ii/</li>
<li>http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/</li>
<li>http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/</li>
<li>http://oj.leetcode.com/problems/maximum-subarray/</li>
<li>http://oj.leetcode.com/problems/minimum-window-substring/</li>
<li>http://oj.leetcode.com/problems/maximal-rectangle/</li>
<li>http://oj.leetcode.com/problems/longest-substring-without-repeating-characters/</li>
</ul>
<p>&#20998;&#27835; &amp; &#36882;&#24402;&#65306;</p>
<ul>
<li>http://oj.leetcode.com/problems/unique-binary-search-trees-ii/</li>
<li>http://oj.leetcode.com/problems/restore-ip-addresses/ &#65288;&#26102;&#38388;&#22797;&#26434;&#24230;&#26377;&#38480;&#65292;&#36882;&#24402;&#28385;&#36275;&#65289;</li>
<li>http://oj.leetcode.com/problems/permutations/</li>
<li>http://oj.leetcode.com/problems/permutations-ii/</li>
<li>http://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</li>
<li>http://oj.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/</li>
<li>http://oj.leetcode.com/problems/median-of-two-sorted-arrays/</li>
<li>http://oj.leetcode.com/problems/validate-binary-search-tree/</li>
</ul>
<p>&#23383;&#31526;&#20018;&#65306;</p>
<ul>
<li>http://oj.leetcode.com/problems/count-and-say/</li>
<li>http://oj.leetcode.com/problems/implement-strstr/ &#65288;&#23376;&#20018;&#26597;&#25214;&#65289;</li>
<li>http://oj.leetcode.com/problems/anagrams/</li>
<li>http://oj.leetcode.com/problems/text-justification/ (&#32454;&#33410;&#65289;</li>
<li>http://oj.leetcode.com/problems/simplify-path/ &#65288;&#22522;&#30784;&#25511;&#21046;&#35821;&#21477; if-else-for&#65289;</li>
<li>http://oj.leetcode.com/problems/multiply-strings/</li>
<li>http://oj.leetcode.com/problems/regular-expression-matching/</li>
<li>http://oj.leetcode.com/problems/wildcard-matching/</li>
<li>http://oj.leetcode.com/problems/longest-palindromic-substring/</li>
<li>http://oj.leetcode.com/problems/zigzag-conversion/</li>
<li>http://oj.leetcode.com/problems/length-of-last-word/</li>
<li>http://oj.leetcode.com/problems/valid-palindrome/</li>
</ul>
<p>&#22270;&#65306;</p>
<ul>
<li>&#28145;&#25628;/&#24191;&#25628;&#65306;http://oj.leetcode.com/problems/clone-graph/</li>
</ul>
<p>&#25628;&#32034; &amp; &#36941;&#21382;&#65306;</p>
<ul>
<li>http://oj.leetcode.com/problems/word-ladder/</li>
<li>http://oj.leetcode.com/problems/word-ladder-ii/</li>
<li>&#24191;&#25628;&#65306;http://oj.leetcode.com/problems/surrounded-regions/</li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="https://www.douban.com/note/330562764/">LeetCode &#39064;&#30446;&#24635;&#32467;/&#20998;&#31867;</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#21033;&#29992; Trie &#26641;&#27714;&#22810;&#20010;&#23383;&#31526;&#20018;&#30340;&#26368;&#23567;&#32534;&#36753;&#36317;&#31163; <code class="fold">@</code></dt>
<dd><dl>
<dt>&#32534;&#36753;&#36317;&#31163; <code class="fold">@</code></dt>
<dd><p>1965 &#24180;&#65292;&#20420;&#22269;&#31185;&#23398;&#23478; Vladimir Levenshtein &#32473;&#23383;&#31526;&#20018;&#30456;&#20284;&#24230;&#20570;&#20986;&#20102;&#19968;&#20010;&#26126;&#30830;&#30340;&#23450;&#20041;&#21483;&#20570; Levenshtein &#36317;&#31163;&#65292;&#25105;&#20204;&#36890;&#24120;&#21483;&#23427;&#8220;&#32534;&#36753;&#36317;&#31163;&#8221;&#12290;&#23383;&#31526;&#20018; A &#21040; B &#30340;&#32534;&#36753;&#36317;&#31163;&#26159;&#25351;&#65292;&#21482;&#29992;&#25554;&#20837;&#12289;&#21024;&#38500;&#21644;&#26367;&#25442;&#19977;&#31181;&#25805;&#20316;&#65292;&#26368;&#23569;&#38656;&#35201;&#22810;&#23569;&#27493;&#21487;&#20197;&#25226; A &#21464;&#25104; B&#12290;&#20363;&#22914;&#65292;&#20174; FAME &#21040; GATE &#38656;&#35201;&#20004;&#27493;&#65288;&#20004;&#27425;&#26367;&#25442;&#65289;&#65292;&#20174; GAME &#21040; ACM &#21017;&#38656;&#35201;&#19977;&#27493;&#65288;&#21024;&#38500; G &#21644; E &#20877;&#28155;&#21152; C&#65289;&#12290;Levenshtein &#32473;&#20986;&#20102;&#32534;&#36753;&#36317;&#31163;&#30340;&#19968;&#33324;&#27714;&#27861;&#65292;&#23601;&#26159;&#22823;&#23478;&#37117;&#38750;&#24120;&#29087;&#24713;&#30340;&#32463;&#20856;<strong>&#21160;&#24577;&#35268;&#21010;</strong>&#38382;&#39064;&#12290;</p>
<p>Levenshtein &#30340;&#23450;&#20041;&#21487;&#20197;&#26159;&#21333;&#35789;&#20219;&#24847;&#20301;&#32622;&#19978;&#30340;&#25805;&#20316;&#65292;&#20284;&#20046;&#19981;&#36941;&#21382;&#23383;&#20856;&#26159;&#19981;&#21487;&#33021;&#23436;&#25104;&#30340;&#12290;&#29616;&#22312;&#24456;&#22810;&#36719;&#20214;&#37117;&#26377;&#25340;&#20889;&#26816;&#26597;&#30340;&#21151;&#33021;&#65292;&#25552;&#20986;&#26356;&#27491;&#24314;&#35758;&#30340;&#36895;&#24230;&#26159;&#24456;&#24555;&#30340;&#12290;&#23427;&#20204;&#21040;&#24213;&#26159;&#24590;&#20040;&#20570;&#30340;&#21602;&#65311;1973 &#24180;&#65292;Burkhard &#21644; Keller &#25552;&#20986;&#30340; BK &#26641;&#26377;&#25928;&#22320;&#35299;&#20915;&#20102;&#36825;&#20010;&#38382;&#39064;&#12290;&#36825;&#20010;&#25968;&#25454;&#32467;&#26500;&#24378;&#23601;&#24378;&#22312;&#65292;&#23427;&#21021;&#27493;&#35299;&#20915;&#20102;&#19968;&#20010;&#30475;&#20284;&#19981;&#21487;&#33021;&#30340;&#38382;&#39064;&#65292;&#32780;&#20854;&#21407;&#29702;&#38750;&#24120;&#31616;&#21333;&#12290;</p>
<p>&#39318;&#20808;&#65292;&#25105;&#20204;&#35266;&#23519; Levenshtein &#36317;&#31163;&#30340;&#24615;&#36136;&#12290;&#20196; d(x,y) &#34920;&#31034;&#23383;&#31526;&#20018; x &#21040; y &#30340; Levenshtein &#36317;&#31163;&#65292;&#37027;&#20040;&#26174;&#28982;&#65306;</p>
<ol style="list-style-type: decimal">
<li>d(x,y) = 0 &#24403;&#19988;&#20165;&#24403; x=y &#65288;Levenshtein &#36317;&#31163;&#20026; 0 &lt;==&gt; &#23383;&#31526;&#20018;&#30456;&#31561;&#65289;</li>
<li>d(x,y) = d(y,x) &#65288;&#20174; x &#21464;&#21040; y &#30340;&#26368;&#23569;&#27493;&#25968;&#23601;&#26159;&#20174; y &#21464;&#21040; x &#30340;&#26368;&#23569;&#27493;&#25968;&#65289;</li>
<li>d(x,y) + d(y,z) &gt;= d(x,z) &#65288;&#20174; x &#21464;&#21040; z &#25152;&#38656;&#30340;&#27493;&#25968;&#19981;&#20250;&#36229;&#36807; x &#20808;&#21464;&#25104; y &#20877;&#21464;&#25104; z &#30340;&#27493;&#25968;&#65289;</li>
</ol>
<p>&#26368;&#21518;&#36825;&#19968;&#20010;&#24615;&#36136;&#21483;&#20570;&#19977;&#35282;&#24418;&#19981;&#31561;&#24335;&#12290;&#23601;&#22909;&#20687;&#19968;&#20010;&#19977;&#35282;&#24418;&#19968;&#26679;&#65292;&#20004;&#36793;&#20043;&#21644;&#24517;&#28982;&#22823;&#20110;&#31532;&#19977;&#36793;&#12290;&#32473;&#26576;&#20010;&#38598;&#21512;&#20869;&#30340;&#20803;&#32032;&#23450;&#20041;&#19968;&#20010;&#20108;&#20803;&#30340;&#8220;&#36317;&#31163;&#20989;&#25968;&#8221;&#65292;&#22914;&#26524;&#36825;&#20010;&#36317;&#31163;&#20989;&#25968;&#21516;&#26102;&#28385;&#36275;&#19978;&#38754;&#35828;&#30340;&#19977;&#20010;&#24615;&#36136;&#65292;&#25105;&#20204;&#23601;&#31216;&#23427;&#20026;&#8220;&#24230;&#37327;&#31354;&#38388;&#8221;&#12290;&#25105;&#20204;&#30340;&#19977;&#32500;&#31354;&#38388;&#23601;&#26159;&#19968;&#20010;&#20856;&#22411;&#30340;&#24230;&#37327;&#31354;&#38388;&#65292;&#23427;&#30340;&#36317;&#31163;&#20989;&#25968;&#23601;&#26159;&#28857;&#23545;&#30340;&#30452;&#32447;&#36317;&#31163;&#12290;&#24230;&#37327;&#31354;&#38388;&#36824;&#26377;&#24456;&#22810;&#65292;&#27604;&#22914; Manhattan &#36317;&#31163;&#65292;&#22270;&#35770;&#20013;&#30340;&#26368;&#30701;&#36335;&#65292;&#24403;&#28982;&#36824;&#26377;&#36825;&#37324;&#25552;&#21040;&#30340; Levenshtein &#36317;&#31163;&#12290;&#23601;&#22909;&#20687;&#24182;&#26597;&#38598;&#23545;&#25152;&#26377;&#31561;&#20215;&#20851;&#31995;&#37117;&#36866;&#29992;&#19968;&#26679;&#65292;BK &#26641;&#21487;&#20197;&#29992;&#20110;&#20219;&#20309;&#19968;&#20010;&#24230;&#37327;&#31354;&#38388;&#12290;</p>
<p>&#26597;&#35810;&#25805;&#20316;&#24322;&#24120;&#26041;&#20415;&#12290;&#22914;&#26524;&#25105;&#20204;&#38656;&#35201;&#36820;&#22238;&#19982;&#38169;&#35823;&#21333;&#35789;&#36317;&#31163;&#19981;&#36229;&#36807; n &#30340;&#21333;&#35789;&#65292;&#36825;&#20010;&#38169;&#35823;&#21333;&#35789;&#19982;&#26641;&#26681;&#25152;&#23545;&#24212;&#30340;&#21333;&#35789;&#36317;&#31163;&#20026; d&#65292;&#37027;&#20040;&#25509;&#19979;&#26469;&#25105;&#20204;&#21482;&#38656;&#35201;&#36882;&#24402;&#22320;&#32771;&#34385;&#32534;&#21495;&#22312; d-n &#21040; d+n &#33539;&#22260;&#20869;&#30340;&#36793;&#25152;&#36830;&#25509;&#30340;&#23376;&#26641;&#12290;&#30001;&#20110; n &#36890;&#24120;&#24456;&#23567;&#65292;&#22240;&#27492;&#27599;&#27425;&#19982;&#26576;&#20010;&#33410;&#28857;&#36827;&#34892;&#27604;&#36739;&#26102;&#37117;&#21487;&#20197;&#25490;&#38500;&#24456;&#22810;&#23376;&#26641;&#12290;</p>
<p>&#20030;&#20010;&#20363;&#23376;&#65292;&#20551;&#22914;&#25105;&#20204;&#36755;&#20837;&#19968;&#20010; GAIE&#65292;&#31243;&#24207;&#21457;&#29616;&#23427;&#19981;&#22312;&#23383;&#20856;&#20013;&#12290;&#29616;&#22312;&#65292;&#25105;&#20204;&#24819;&#36820;&#22238;&#23383;&#20856;&#20013;&#25152;&#26377;&#19982; GAIE &#36317;&#31163;&#20026; 1 &#30340;&#21333;&#35789;&#12290;&#25105;&#20204;&#39318;&#20808;&#23558; GAIE &#19982;&#26641;&#26681;&#36827;&#34892;&#27604;&#36739;&#65292;&#24471;&#21040;&#30340;&#36317;&#31163; d=1&#12290;&#30001;&#20110; Levenshtein &#36317;&#31163;&#28385;&#36275;&#19977;&#35282;&#24418;&#19981;&#31561;&#24335;&#65292;&#22240;&#27492;&#29616;&#22312;&#25152;&#26377;&#31163; GAME &#36317;&#31163;&#36229;&#36807; 2 &#30340;&#21333;&#35789;&#20840;&#37096;&#21487;&#20197;&#25490;&#38500;&#20102;&#12290;&#27604;&#22914;&#65292;&#20197; AIM &#20026;&#26681;&#30340;&#23376;&#26641;&#21040; GAME &#30340;&#36317;&#31163;&#37117;&#26159; 3&#65292;&#32780; GAME &#21644; GAIE &#20043;&#38388;&#30340;&#36317;&#31163;&#26159; 1&#65292;&#37027;&#20040; AIM &#21450;&#20854;&#23376;&#26641;&#21040; GAIE &#30340;&#36317;&#31163;&#33267;&#23569;&#37117;&#26159; 2&#12290;&#20110;&#26159;&#65292;&#29616;&#22312;&#31243;&#24207;&#21482;&#38656;&#35201;&#27839;&#30528;&#26631;&#21495;&#33539;&#22260;&#22312; 1-1 &#21040; 1+1 &#37324;&#30340;&#36793;&#32487;&#32493;&#36208;&#19979;&#21435;&#12290;&#25105;&#20204;&#32487;&#32493;&#35745;&#31639; GAIE &#21644; FAME &#30340;&#36317;&#31163;&#65292;&#21457;&#29616;&#23427;&#20026; 2&#65292;&#20110;&#26159;&#32487;&#32493;&#27839;&#26631;&#21495;&#22312; 1 &#21644; 3 &#20043;&#38388;&#30340;&#36793;&#21069;&#36827;&#12290;&#36941;&#21382;&#32467;&#26463;&#21518;&#22238;&#21040; GAME &#30340;&#31532;&#20108;&#20010;&#33410;&#28857;&#65292;&#21457;&#29616; GAIE &#21644; GAIN &#36317;&#31163;&#20026; 1&#65292;&#36755;&#20986; GAIN &#24182;&#32487;&#32493;&#27839;&#32534;&#21495;&#20026; 1 &#25110; 2 &#30340;&#36793;&#36882;&#24402;&#19979;&#21435;&#65288;&#37027;&#26465;&#32534;&#21495;&#20026; 4 &#30340;&#36793;&#36830;&#25509;&#30340;&#23376;&#26641;&#21448;&#34987;&#25490;&#38500;&#25481;&#20102;&#65289;&#8230;&#8230;</p>
<div class="figure">
<img src="http://www.matrix67.com/blogimage/200710223.gif" />

</div>
<p>&#23454;&#36341;&#34920;&#26126;&#65292;&#19968;&#27425;&#26597;&#35810;&#25152;&#36941;&#21382;&#30340;&#33410;&#28857;&#19981;&#20250;&#36229;&#36807;&#25152;&#26377;&#33410;&#28857;&#30340; 5% &#21040; 8%&#65292;&#20004;&#27425;&#26597;&#35810;&#21017;&#19968;&#33324;&#19981;&#20250; 17-25%&#65292;&#25928;&#29575;&#36828;&#36828;&#36229;&#36807;&#26292;&#21147;&#26522;&#20030;&#12290;&#36866;&#24403;&#36827;&#34892;&#32531;&#23384;&#65292;&#20943;&#23567; Levenshtein &#36317;&#31163;&#24120;&#25968; n &#21487;&#20197;&#20351;&#31639;&#27861;&#25928;&#29575;&#26356;&#39640;&#12290;</p>
<p>&#36825;&#31687;&#25991;&#31456;&#30495;&#26159;&#22815;&#20102;&#65292;&#21644; Matrix67 &#30340;&#20960;&#20046;&#19968;&#27169;&#19968;&#26679;&#65306;<a href="https://zhuanlan.zhihu.com/p/20101194?refer=simons">&#23383;&#31526;&#20018;&#30456;&#20284;&#24230;&#20043;&#32654;&#65288;&#19968;&#65289;- SimonS&#8217;s Algo - &#30693;&#20046;&#19987;&#26639;</a>&#12290;</p>
</dd>
<dt>Trie &#26641;&#30340;&#23454;&#29616; <code class="fold">@</code></dt>
<dd><p>&#30001;&#20110;&#22810;&#21449;&#26641;&#19981;&#22815;&#28789;&#27963;&#65292;&#21516;&#26102;&#23545;&#31354;&#38388;&#23384;&#22312;&#21363;&#22823;&#30340;&#28010;&#36153;&#65292;&#22240;&#27492;&#26412;&#25991;&#21033;&#29992;&#20108;&#21449;&#26641;&#23454;&#29616;&#19968;&#26869; Trie &#26641;&#12290;</p>
<p>&#20108;&#21449;&#26641;&#26159;&#36825;&#26679;&#30340;&#32467;&#26500;&#65306;&#33410;&#28857;&#30340;&#24038;&#23401;&#23376;&#20195;&#34920;&#23427;&#30340;&#31532;&#19968;&#20010;&#23401;&#23376;&#65292;&#33410;&#28857;&#30340;&#21491;&#23401;&#23376;&#20195;&#34920;&#23427;&#30340;&#20804;&#24351;&#33410;&#28857;&#12290;</p>
<p>&#24635;&#20307;&#30340;&#24605;&#36335;&#26159;&#65306;</p>
<ul>
<li>&#24314;&#31435; 10 &#19975;&#27425;&#30340;&#35789;&#20856;&#65292;&#21333;&#35789;&#38271;&#24230; 5-30</li>
<li>&#20026;&#36825;&#20123;&#21333;&#35789;&#24314;&#31435; Trie &#26641;&#65292;&#32473;&#23450;&#20219;&#24847;&#23383;&#31526;&#20018;&#65292;&#27714;&#25152;&#26377;&#19982;&#35813;&#23383;&#31526;&#20018;&#30340;&#32534;&#36753;&#36317;&#31163;&#20026; 1 &#25110;&#32773; 2 &#30340;&#21333;&#35789;</li>
<li>&#21516;&#26102;&#29992;&#26292;&#21147;&#21305;&#37197;&#30340;&#26041;&#27861;&#27714;&#24471;&#31526;&#21512;&#35201;&#27714;&#30340;&#23383;&#31526;&#20018;&#65292;&#28982;&#21518;&#36827;&#34892;&#26102;&#38388;&#30340;&#27604;&#36739;&#12290;</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;fstream&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;ctime&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;sys/time.h&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> X = <span class="dv">30</span>;
<span class="dt">const</span> <span class="dt">int</span> Y = <span class="dv">30</span>;
<span class="dt">const</span> <span class="dt">int</span> MAX = <span class="dv">30</span>;

<span class="dt">int</span> edit_length(string &amp;x, string &amp;y);

<span class="co">// Trie&#26641;&#30340;&#33410;&#28857;&#23450;&#20041;</span>
<span class="kw">struct</span> Node {
    <span class="dt">int</span> length;
    string word;
    Node *left, *right;
    Node() : length(<span class="dv">0</span>), word(<span class="st">&quot;&quot;</span>), left(<span class="dv">0</span>), right(<span class="dv">0</span>) { }
};

<span class="co">// Trie &#26641;&#30340;&#25805;&#20316;&#23450;&#20041;</span>
<span class="kw">class</span> Trie {
    <span class="kw">private</span>:
        Node* pRoot;
    <span class="kw">private</span>:
        <span class="co">// &#38144;&#27585; Trie &#26641;</span>
        <span class="dt">void</span> destory(Node* r) {
            <span class="kw">if</span>(!r) { <span class="kw">return</span>; }
            destory(r -&gt; left);
            destory(r -&gt; right);
            <span class="kw">delete</span> r;
            r = NULL;
        }
        <span class="dt">void</span> find( Node *pRoot, string &amp;str, <span class="dt">int</span> limit_num, vector&lt;string&gt; &amp;word_set );
    <span class="kw">public</span>:
        Trie() {}
        ~Trie() { destroy(pRoot); }
        <span class="dt">void</span> insert(string str);
        <span class="dt">void</span> search(string &amp;str, <span class="dt">int</span> limit_num, vector&lt;string&gt; &amp;word_set);
};

<span class="co">// &#25554;&#20837;&#21333;&#35789;&#65292;&#24314;&#31435; Trie &#26641;</span>
<span class="dt">void</span> Trie::insert(string str){
    <span class="kw">if</span>(pRoot != NULL){
        <span class="co">//&#22914;&#26524;trie&#26641;&#24050;&#32463;&#23384;&#22312;</span>
        Node *pPre = pRoot;
        Node *pCur = pRoot -&gt; left;
        <span class="kw">while</span>(<span class="dv">1</span>) {
            <span class="co">//&#35745;&#31639;&#35813;&#21333;&#35789;&#19982;&#24403;&#21069;&#33410;&#28857;&#30340;&#32534;&#36753;&#36317;&#31163;</span>
            string word = pPre -&gt; word;
            <span class="dt">int</span> distance = edit_length(word, str);
            <span class="co">//&#33509;&#35813;&#21333;&#35789;&#24050;&#23384;&#22312;</span>
            <span class="kw">if</span>(distance == <span class="dv">0</span>) {
                <span class="kw">break</span>;
            }
            <span class="co">//&#33509;&#35813;&#21333;&#35789;&#19981;&#23384;&#22312;</span>
            <span class="kw">if</span>(pCur == NULL) {
                <span class="co">//&#33509;&#39318;&#33410;&#28857;&#19981;&#23384;&#22312;&#65292;&#21017;&#21019;&#24314;&#39318;&#33410;&#28857;</span>
                pCur = <span class="kw">new</span> Node();
                pCur -&gt; length = distance;
                pCur -&gt; word = str;
                pCur -&gt; left = NULL;
                pCur -&gt; right = NULL;

                pPre -&gt; left = pCur;

                <span class="kw">break</span>;

            } <span class="kw">else</span> <span class="kw">if</span> (pCur != NULL &amp;&amp; pCur -&gt; length &gt; distance) {
                <span class="co">//&#33509;&#39318;&#33410;&#28857;&#23384;&#22312;&#65292;&#24182;&#19988;&#39318;&#33410;&#28857;&#22823;&#20110;&#30446;&#26631;&#32534;&#36753;&#36317;&#31163;&#65292;&#37325;&#24314;&#39318;&#33410;&#28857;</span>
                Node *p = <span class="kw">new</span> Node();
                p -&gt; length = distance;
                p -&gt; word = str;
                p -&gt; left = NULL;
                p -&gt; right = pCur;

                pPre -&gt; left = p;
                <span class="kw">break</span>;

            } <span class="kw">else</span> {
                <span class="co">//&#39318;&#33410;&#28857;&#23384;&#22312;&#65292;&#19988;&#39318;&#33410;&#28857;&#23567;&#20110;&#31561;&#20110;&#30446;&#26631;&#32534;&#36753;&#36317;&#31163;</span>
                <span class="kw">while</span>(pCur != NULL &amp;&amp; pCur -&gt; length &lt; distance){
                    pPre = pCur;
                    pCur = pCur -&gt; right;
                }
                <span class="kw">if</span>(pCur != NULL &amp;&amp; pCur -&gt; length == distance){
                    <span class="co">//&#25214;&#21040;&#20102;&#30446;&#26631;&#33410;&#28857;</span>
                    pPre = pCur;
                    pCur = pCur -&gt; left;
                } <span class="kw">else</span> {
                    <span class="co">//&#21019;&#24314;&#30446;&#26631;&#33410;&#28857;</span>
                    Node *p = <span class="kw">new</span> Node();
                    p -&gt; length = distance;
                    p -&gt; word = str;
                    p -&gt; left = NULL;
                    p -&gt; right = pCur;

                    pPre -&gt; right = p;
                    <span class="kw">break</span>;
                }
            }
        }
    } <span class="kw">else</span> {
        <span class="co">//&#22914;&#26524;Trie&#26641;&#36824;&#19981;&#23384;&#22312;&#65292;&#20197;&#35813;&#21333;&#35789;&#21019;&#24314;&#26681;&#33410;&#28857;</span>
        pRoot = <span class="kw">new</span> Node();
        pRoot -&gt; length = <span class="dv">0</span>;
        pRoot -&gt; word = str;
    }
}

<span class="co">// &#25628;&#32034;&#19982;&#32473;&#23450;&#23383;&#31526;&#20018;&#30340;&#32534;&#36753;&#36317;&#31163;&#23567;&#20110;&#32473;&#23450;&#20540;&#30340;&#25152;&#26377;&#23383;&#31526;&#20018;&#65288;&#20869;&#37096;&#35843;&#29992;&#65289;</span>
<span class="dt">void</span> Trie::find(Node* pRoot, string &amp;str, <span class="dt">int</span> limit_num, vector&lt;string&gt; &amp;word_set) {

    <span class="kw">if</span>(pRoot == NULL){
        cout &lt;&lt; <span class="st">&quot;kong&quot;</span> &lt;&lt; endl;
        <span class="kw">return</span>;
    }
    string word = pRoot -&gt; word;
    <span class="dt">int</span> distance = edit_length(word, str);
    <span class="kw">if</span>(distance &lt; limit_num) {
        word_set.push_back(word);
    }

    <span class="co">//&#22914;&#26524;&#24403;&#21069;&#33410;&#28857;&#26377;&#23401;&#23376;&#30340;&#35805;</span>
    Node *pCur = pRoot -&gt; left;
    <span class="kw">while</span>(pCur != NULL){
        <span class="kw">if</span>(pCur -&gt; length &lt; distance + limit_num &amp;&amp;
                pCur -&gt; length &gt; distance - limit_num &amp;&amp;
                pCur -&gt; length &gt; limit_num - distance){
            find(pCur, str, limit_num, word_set);
        }
        pCur = pCur -&gt; right;
    }
}


<span class="co">// &#21253;&#35013;&#20989;&#25968;&#65292;&#25628;&#32034;&#19982;&#32473;&#23450;&#23383;&#31526;&#20018;&#30340;&#32534;&#36753;&#36317;&#31163;&#23567;&#20110;&#32473;&#23450;&#20540;&#30340;&#25152;&#26377;&#23383;&#31526;&#20018;&#65288;&#22806;&#37096;&#35843;&#29992;&#65289;</span>
<span class="dt">void</span> Trie::search(string &amp;str, <span class="dt">int</span> limit_num, vector&lt;string&gt; &amp;word_set){
    find(pRoot, str, limit_num, word_set);
}

<span class="co">// ---------------------------&#24037;&#20855;&#20989;&#25968;------------------------------</span>
<span class="co">// &#27714;&#20004;&#20010;&#23383;&#31526;&#20018;&#30340;&#26368;&#26029;&#32534;&#36753;&#36317;&#31163;</span>
<span class="dt">int</span> edit_length(string &amp;x, string &amp;y){
    <span class="dt">int</span> xlen = x.length();
    <span class="dt">int</span> ylen = y.length();
    <span class="dt">int</span> edit[<span class="dv">3</span>][Y<span class="dv">+1</span>];
    memset(edit, <span class="dv">0</span>, <span class="kw">sizeof</span>(edit));

    <span class="dt">int</span> i = <span class="dv">0</span>;
    <span class="dt">int</span> j = <span class="dv">0</span>;
    <span class="kw">for</span>(j = <span class="dv">0</span>; j &lt;= ylen; j++){
        edit[<span class="dv">0</span>][j] = j;
    }
    <span class="kw">for</span>(i = <span class="dv">1</span>; i &lt;= xlen; i++){
        edit[i%<span class="dv">3</span>][<span class="dv">0</span>] = edit[(i<span class="dv">-1</span>)%<span class="dv">3</span>][<span class="dv">0</span>] + <span class="dv">1</span>;
        <span class="kw">for</span>(j = <span class="dv">1</span>; j &lt;= ylen; j++){
            <span class="kw">if</span> (x[i<span class="dv">-1</span>] == y[j<span class="dv">-1</span>]) {
                edit[i%<span class="dv">3</span>][j] = min(min(edit[i%<span class="dv">3</span>][j<span class="dv">-1</span>] + <span class="dv">1</span>, edit[(i<span class="dv">-1</span>)%<span class="dv">3</span>][j] + <span class="dv">1</span>),
                        edit[(i<span class="dv">-1</span>)%<span class="dv">3</span>][j<span class="dv">-1</span>]);
            } <span class="kw">else</span> {
                <span class="kw">if</span>(i &gt;= <span class="dv">2</span> &amp;&amp; j &gt;= <span class="dv">2</span> &amp;&amp; x[i<span class="dv">-2</span>] == y[j<span class="dv">-1</span>] &amp;&amp; x[i<span class="dv">-1</span>] == y[j<span class="dv">-2</span>]){
                    edit[i%<span class="dv">3</span>][j] = min(min(edit[i%<span class="dv">3</span>][j<span class="dv">-1</span>] + <span class="dv">1</span>, edit[(i<span class="dv">-1</span>)%<span class="dv">3</span>][j] + <span class="dv">1</span>),
                            min(edit[(i<span class="dv">-1</span>)%<span class="dv">3</span>][j<span class="dv">-1</span>] + <span class="dv">1</span>, edit[(i<span class="dv">-2</span>)%<span class="dv">3</span>][j<span class="dv">-2</span>] + <span class="dv">1</span>));
                } <span class="kw">else</span> {
                    edit[i%<span class="dv">3</span>][j] = min(min(edit[i%<span class="dv">3</span>][j<span class="dv">-1</span>] + <span class="dv">1</span>, edit[(i<span class="dv">-1</span>)%<span class="dv">3</span>][j] + <span class="dv">1</span>),
                            edit[(i<span class="dv">-1</span>)%<span class="dv">3</span>][j<span class="dv">-1</span>] + <span class="dv">1</span>);
                }
            }
        }
    }
    <span class="kw">return</span> edit[(i<span class="dv">-1</span>)%<span class="dv">3</span>][j<span class="dv">-1</span>];
}

<span class="co">//&#29983;&#25104;&#38543;&#26426;&#23383;&#31526;&#20018;</span>
string rand_string(<span class="dt">int</span> len){
    srand(time(NULL));
    <span class="dt">char</span> a[MAX<span class="dv">+1</span>];
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len; i++){
        a[i] = rand()%<span class="dv">26</span> + <span class="st">&#39;a&#39;</span>;
    }
    a[len] = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>;
    string str(a);
    <span class="kw">return</span> str;
}

<span class="co">// &#33719;&#21462;&#24403;&#21069;&#26102;&#38388; (ms)</span>
<span class="dt">long</span> getCurrentTime(){
    <span class="kw">struct</span> timeval tv;
    gettimeofday(&amp;tv, NULL);
    <span class="kw">return</span> tv.tv_sec*<span class="dv">1000</span> + tv.tv_usec/<span class="dv">1000</span>;
}

<span class="co">//-----------------------------&#27979;&#35797;&#20989;&#25968;------------------------</span>
<span class="co">//&#27979;&#35797;&#26368;&#30701;&#32534;&#36753;&#36317;&#31163;&#20989;&#25968;</span>
<span class="dt">void</span> Test_1(){
    string a = <span class="st">&quot;abcdef&quot;</span>;
    string b = <span class="st">&quot;abcdef&quot;</span>;
    <span class="dt">int</span> max_len = edit_length(a, b);
    cout &lt;&lt; max_len &lt;&lt; endl;
}

<span class="co">// &#39564;&#35777; Trie &#26641;&#26159;&#21542;&#23436;&#25972;</span>
<span class="dt">void</span> Test_2(){

    <span class="co">//1.&#21019;&#24314;&#23545;&#35937;&#65292;&#25171;&#24320;&#25991;&#20214;</span>
    Trie trie;
    string str;
    ifstream fin;
    fin.open(<span class="st">&quot;dict.txt&quot;</span>);
    <span class="kw">if</span>(!fin){
        cout &lt;&lt; <span class="st">&quot;&#25171;&#24320;&#25991;&#20214;&#22833;&#36133;&#65281;&quot;</span> &lt;&lt; endl;
    }

    <span class="co">//2.&#24314;&#31435;Trie&#26641;</span>
    <span class="kw">while</span>(getline(fin, str, <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>)){
        trie.insert(str);
    }
    fin.close();

    <span class="co">//3.&#39564;&#35777;Trie&#26641;&#30340;&#27491;&#30830;&#24615;</span>
    fin.open(<span class="st">&quot;dict.txt&quot;</span>);
    <span class="kw">if</span>(!fin){
        cout &lt;&lt; <span class="st">&quot;&#25171;&#24320;&#25991;&#20214;&#22833;&#36133;&#65281;&quot;</span> &lt;&lt; endl;
    }
    <span class="kw">while</span>(getline(fin, str, <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>)){
        <span class="dt">int</span> count = <span class="dv">0</span>;
        vector&lt;string&gt; word_set;
        trie.search(str, <span class="dv">1</span>, word_set);
        cout &lt;&lt; word_set.size() &lt;&lt; <span class="st">&quot;  &quot;</span> &lt;&lt; str &lt;&lt; endl;
    }

}


<span class="co">//&#27979;&#35797;&#23545;&#20110;&#38543;&#26426;&#23383;&#31526;&#20018;&#25628;&#32034;&#32467;&#26524;&#30340;&#27491;&#30830;&#24615;</span>
<span class="dt">void</span> Test_3(){

    <span class="co">//1.&#21019;&#24314;&#23545;&#35937;&#65292;&#25171;&#24320;&#25991;&#20214;</span>
    Trie trie;
    string str;
    ifstream fin;
    fin.open(<span class="st">&quot;dict.txt&quot;</span>);
    <span class="kw">if</span>(!fin){
        cout &lt;&lt; <span class="st">&quot;&#25171;&#24320;&#25991;&#20214;&#22833;&#36133;&#65281;&quot;</span> &lt;&lt; endl;
    }

    <span class="co">//2.&#24314;&#31435;Trie&#26641;</span>
    <span class="dt">long</span> time_1 = getCurrentTime();
    <span class="kw">while</span>(getline(fin, str, <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>)){
        trie.insert(str);
    }
    <span class="dt">long</span> time_2 = getCurrentTime();
    fin.close();

    <span class="co">//3.&#20135;&#29983;&#38543;&#26426;&#23383;&#31526;&#20018;</span>
    string rand_str = rand_string(<span class="dv">6</span>);
    <span class="co">//rand_str = &quot;wdeuojyucsalslpd&quot;;</span>
    cout &lt;&lt; <span class="st">&quot;&#38543;&#26426;&#23383;&#31526;&#20018;&#20026;&#65306;&quot;</span> &lt;&lt; rand_str &lt;&lt; endl;

    <span class="co">//4.&#21033;&#29992;Trie&#26641;&#35745;&#31639;&#32467;&#26524;</span>
    vector&lt;string&gt; word_set_1;
    <span class="dt">long</span> time_3 = getCurrentTime();
    trie.search(rand_str, <span class="dv">3</span>, word_set_1);
    <span class="dt">long</span> time_4 = getCurrentTime();

    <span class="co">//5.&#21033;&#29992;&#26292;&#21147;&#21305;&#37197;&#35745;&#31639;&#32467;&#26524;</span>
    vector&lt;string&gt; word_set_2;
    vector&lt;string&gt; word_dict;
    fin.open(<span class="st">&quot;dict.txt&quot;</span>);
    <span class="kw">if</span>(!fin){
        cout &lt;&lt; <span class="st">&quot;&#25171;&#24320;&#25991;&#20214;&#22833;&#36133;&#65281;&quot;</span> &lt;&lt; endl;
    }
    <span class="kw">while</span>(getline(fin, str, <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>)){
        word_dict.push_back(str);
    }
    <span class="dt">int</span> size = word_dict.size();
    <span class="dt">long</span> time_5 = getCurrentTime();
    <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; size; j++){
        <span class="kw">if</span>(edit_length(word_dict[j], rand_str) &lt; <span class="dv">3</span>){
            word_set_2.push_back(word_dict[j]);
        }
    }
    <span class="dt">long</span> time_6 = getCurrentTime();
    fin.close();

    <span class="co">//6.&#32467;&#26524;&#27604;&#36739;</span>
    sort(word_set_1.begin(), word_set_1.end());
    sort(word_set_2.begin(), word_set_2.end());

    cout &lt;&lt; <span class="st">&quot;word_set_1&#30340;&#22823;&#23567;&#65306;&quot;</span> &lt;&lt; word_set_1.size() &lt;&lt; endl;
    cout &lt;&lt; <span class="st">&quot;&#32467;&#26524;&#20026;&#65306;&quot;</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; word_set_1.size(); i++){
        cout &lt;&lt; <span class="st">&quot;  &quot;</span> &lt;&lt; word_set_1[i];
    }
    cout &lt;&lt; endl;

    cout &lt;&lt; <span class="st">&quot;word_set_2&#30340;&#22823;&#23567;&#65306;&quot;</span> &lt;&lt; word_set_2.size() &lt;&lt; endl;
    cout &lt;&lt; <span class="st">&quot;&#32467;&#26524;&#20026;&#65306;&quot;</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; word_set_2.size(); i++){
        cout &lt;&lt; <span class="st">&quot;  &quot;</span> &lt;&lt; word_set_2[i];
    }
    cout &lt;&lt; endl;

    <span class="kw">if</span>(word_set_1 == word_set_2){
        cout &lt;&lt; <span class="st">&quot;&#39564;&#35777;&#27491;&#30830;&quot;</span> &lt;&lt; endl;
    } <span class="kw">else</span> {
        cout &lt;&lt; <span class="st">&quot;&#39564;&#35777;&#38169;&#35823;&quot;</span> &lt;&lt; endl;
    }

    <span class="co">//7.&#26102;&#38388;&#27604;&#36739;</span>
    cout &lt;&lt; <span class="st">&quot;&#24314;&#31435;Trie&#26641;&#29992;&#26102;&#65288;ms&#65289;&#65306;&quot;</span> &lt;&lt; time_2 - time_1 &lt;&lt; endl;
    cout &lt;&lt; <span class="st">&quot;Trie&#26641;&#25628;&#32034;&#29992;&#26102;&#65288;ms&#65289;&#65306;&quot;</span> &lt;&lt; time_4 - time_3 &lt;&lt; endl;
    cout &lt;&lt; <span class="st">&quot;&#26292;&#21147;&#25628;&#32034;&#29992;&#26102;&#65288;ms&#65289;&#65306;&quot;</span>   &lt;&lt; time_6 - time_5 &lt;&lt; endl;
    cout &lt;&lt; <span class="st">&quot;&#30334;&#20998;&#27604;&#65306;&quot;</span> &lt;&lt; <span class="dt">double</span>(time_4 -time_3)/(time_6 - time_5) &lt;&lt; endl;
}
<span class="dt">int</span> main(){

    <span class="co">//Test_1();</span>
    <span class="co">//Test_2();</span>
    Test_3();
}</code></pre></div>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://www.matrix67.com/blog/archives/333">&#32534;&#36753;&#36317;&#31163;&#12289;&#25340;&#20889;&#26816;&#26597;&#19982;&#24230;&#37327;&#31354;&#38388;&#65306;&#19968;&#20010;&#26377;&#36259;&#30340;&#25968;&#25454;&#32467;&#26500; | Matrix67: The Aha Moments</a></li>
<li><a href="http://blog.csdn.net/u010189459/article/details/34114465">&#21033;&#29992; Trie &#26641;&#27714;&#22810;&#20010;&#23383;&#31526;&#20018;&#30340;&#26368;&#23567;&#32534;&#36753;&#36317;&#31163; - &#26102;&#31354;&#38713;&#38643;&#30340;&#19987;&#26639; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>&#22914;&#20309;&#20174;&#38646;&#20889;&#19968;&#20010;&#27491;&#21017;&#34920;&#36798;&#24335;&#24341;&#25806;&#65311; <code class="fold">@</code></dt>
<dd><p>&#25512;&#33616;&#20195;&#30721;: Henry Spencer&#8217;s regexp engine <a href="https://github.com/garyhouston/regexp.old/blob/master/regexp.c">regexp.old/regexp.c at master &#183; garyhouston/regexp.old</a> &#26159;&#24456;&#22810;&#29616;&#20195;&#27969;&#34892;&#30340;&#27491;&#21017;&#24341;&#25806;&#30340;&#22987;&#31062;, &#35299;&#37322;&#22120;&#23454;&#29616;, &#24456;&#22810;&#26032; feature &#33021;&#25193;&#23637;&#24471;&#24471;&#36827;&#21435;, &#20063;&#26377;&#28151;&#21512; DFA &#30340;&#20248;&#21270;</p>
<dl>
<dt><a href="http://whudoc.qiniudn.com/2016/regex.zip" class="uri">http://whudoc.qiniudn.com/2016/regex.zip</a> <code class="fold">@</code></dt>
<dd><p>&#20889;&#20102;&#20010; 80 &#34892;&#30340; C++ &#27169;&#26495;&#29256;&#12290;&#27880;&#24847;&#21834;&#65292;regex &#30340;&#23450;&#20041;&#21253;&#25324;&#20102; concatenation&#65292; alternation&#65288;&#8220;|&#8221;&#65289;&#65292;Kleene closure&#65288;&#8220;*&#8221;&#65289;&#65292;&#36824;&#24471;&#26377;&#19968;&#20010;&#949;&#23383;&#31526;&#65288;&#21487;&#36817;&#20284;&#35748;&#20026; &#8220;?&#8221;&#65289;&#65292;expression &#36824;&#35201;&#33021;&#23884;&#22871;&#65288;&#8220;(&#8221;&#8220;)&#8221;&#65289;&#12290;&#26377;&#20123;&#20363;&#23376;&#37324;&#32570;&#20102; alternation &#21644;&#23884;&#22871;&#37027;&#23601;&#19981;&#35813;&#21483; regex &#20102;&#12290;</p>
<p>&#20043;&#25152;&#20197;&#36825;&#20040;&#30701;&#26159;&#22240;&#20026;&#21387;&#26681;&#27809;&#26377; parsing&#65292;parsing &#22810;&#26080;&#32842;&#21834;&#12290;&#30452;&#25509;&#26500;&#36896; regex &#30340; AST&#65292;&#26681;&#26412;&#19981;&#21435;&#25171; NFA &#30340;&#20027;&#24847;&#12290;&#24819;&#21152;&#20160;&#20040;&#21151;&#33021;&#23601;&#30452;&#25509;&#21152; type &#23601;&#34892;&#20102;&#12290;</p>
<p>&#36825;&#20010;&#26159; compile time regex&#65292;&#25152;&#20197;&#36305;&#36215;&#26469;&#26159; raw speed&#65292;&#24456;&#24555;&#12290;&#20320;&#35201;&#26159;&#35201;&#36816;&#34892;&#26102;&#30340;regex&#65292;&#25226;&#37027;&#20960;&#20010;&#27169;&#26495;&#29305;&#21270;&#25913;&#20026;&#19968;&#20010;&#26641;&#29366; variant &#32467;&#26500;&#65292;&#22312;&#26641;&#19978;&#36208;&#23601;&#34892;&#20102;&#65292;&#31639;&#27861;&#65288;&#21253;&#25324;&#37027;&#20010; continuation &#30340; trick&#65289;&#37117;&#26159;&#19968;&#26679;&#30340;&#12290;</p>
<p>&#24314; NFA &#37027;&#22871;&#20570;&#27861;&#26159; Ken Thompson &#25512;&#20986;&#26469;&#30340;&#8220;&#26631;&#20934;&#8221;&#31639;&#27861;&#65292;&#20294;&#26159;&#23601;&#29609;&#29609;&#32780;&#24050;&#24212;&#35813;&#20174;&#26356;&#31616;&#21333;&#30340;&#23398;&#36215;&#12290;&#23398;&#19968;&#19979; CPS &#21464;&#25442;&#21448;&#19981;&#20250;&#27515;&#12290;</p>
<p>&#21478;&#22806;&#25226;&#31243;&#24207;&#20889;&#30701;&#23567;&#32039;&#20945;&#30340;&#35776;&#31373;&#23601;&#26159;&#20889;&#25104; FP style&#12290;&#25105;&#30340; 80 &#34892;&#20013;&#25152;&#26377;&#20989;&#25968;&#37117;&#21482;&#26377;&#19968;&#20010; return &#35821;&#21477;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> Left, <span class="kw">typename</span> Right&gt;
<span class="kw">struct</span> ConcatExpr;

<span class="kw">template</span> &lt;<span class="kw">typename</span> Left, <span class="kw">typename</span> Right&gt;
<span class="kw">struct</span> AltExpr;

<span class="kw">template</span> &lt;<span class="kw">typename</span> SubExpr&gt;
<span class="kw">struct</span> RepeatExpr;

<span class="kw">template</span> &lt;<span class="dt">char</span> ch&gt;
<span class="kw">struct</span> MatchExpr;

<span class="kw">template</span> &lt;<span class="kw">typename</span> RegExpr&gt;
<span class="kw">struct</span> MatchImpl;

<span class="kw">struct</span> EpsilonExpr;

<span class="kw">template</span> &lt;<span class="kw">typename</span> SubExpr&gt;
<span class="kw">using</span> OptionalExpr = AltExpr&lt;SubExpr, EpsilonExpr&gt;;

<span class="kw">template</span> &lt;<span class="kw">typename</span> Left, <span class="kw">typename</span> Right&gt;
<span class="kw">struct</span> MatchImpl&lt;ConcatExpr&lt;Left, Right&gt;&gt; {
  <span class="kw">template</span> &lt;<span class="kw">typename</span> Continuation&gt;
  <span class="dt">static</span> <span class="dt">bool</span> Apply(<span class="dt">const</span> <span class="dt">char</span>* target, Continuation cont) {
    <span class="kw">return</span> MatchImpl&lt;Left&gt;::Apply(target, [cont](<span class="dt">const</span> <span class="dt">char</span>* rest) -&gt; <span class="dt">bool</span> {
      <span class="kw">return</span> MatchImpl&lt;Right&gt;::Apply(rest, cont);
    });
  }
};

<span class="kw">template</span> &lt;<span class="kw">typename</span> Left, <span class="kw">typename</span> Right&gt;
<span class="kw">struct</span> MatchImpl&lt;AltExpr&lt;Left, Right&gt;&gt; {
  <span class="kw">template</span> &lt;<span class="kw">typename</span> Continuation&gt;
  <span class="dt">static</span> <span class="dt">bool</span> Apply(<span class="dt">const</span> <span class="dt">char</span>* target, Continuation cont) {
    <span class="kw">return</span> MatchImpl&lt;Left&gt;::Apply(target, cont) ||
           MatchImpl&lt;Right&gt;::Apply(target, cont);
  }
};

<span class="kw">template</span> &lt;<span class="kw">typename</span> SubExpr&gt;
<span class="kw">struct</span> MatchImpl&lt;RepeatExpr&lt;SubExpr&gt;&gt; {
  <span class="kw">template</span> &lt;<span class="kw">typename</span> Continuation&gt;
  <span class="dt">static</span> <span class="dt">bool</span> Apply(<span class="dt">const</span> <span class="dt">char</span>* target, Continuation cont) {
    <span class="kw">return</span> MatchImpl&lt;SubExpr&gt;::Apply(
               target,
               [target, cont](<span class="dt">const</span> <span class="dt">char</span>* rest) -&gt; <span class="dt">bool</span> {
                 <span class="kw">return</span> target &lt; rest &amp;&amp;
                     MatchImpl&lt;RepeatExpr&lt;SubExpr&gt;&gt;::Apply(rest, cont);
               }) ||
           cont(target);
  }
};

<span class="kw">template</span> &lt;<span class="dt">char</span> ch&gt;
<span class="kw">struct</span> MatchImpl&lt;MatchExpr&lt;ch&gt;&gt; {
  <span class="kw">template</span> &lt;<span class="kw">typename</span> Continuation&gt;
  <span class="dt">static</span> <span class="dt">bool</span> Apply(<span class="dt">const</span> <span class="dt">char</span>* target, Continuation cont) {
    <span class="kw">return</span> *target &amp;&amp; *target == ch &amp;&amp; cont(target + <span class="dv">1</span>);
  }
};

<span class="kw">template</span> &lt;&gt;
<span class="kw">struct</span> MatchImpl&lt;EpsilonExpr&gt; {
  <span class="kw">template</span> &lt;<span class="kw">typename</span> Continuation&gt;
  <span class="dt">static</span> <span class="dt">bool</span> Apply(<span class="dt">const</span> <span class="dt">char</span>* target, Continuation cont) {
    <span class="kw">return</span> cont(target);
  }
};

<span class="kw">template</span> &lt;<span class="kw">typename</span> RegExpr&gt;
<span class="dt">bool</span> RegexMatch(<span class="dt">const</span> <span class="dt">char</span>* target) {
  <span class="kw">return</span> MatchImpl&lt;RegExpr&gt;::Apply(
      target, [](<span class="dt">const</span> <span class="dt">char</span>* rest) -&gt; <span class="dt">bool</span> { <span class="kw">return</span> *rest == <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>; });
}

<span class="kw">template</span> &lt;<span class="kw">typename</span> RegExpr&gt;
<span class="dt">bool</span> RegexSearch(<span class="dt">const</span> <span class="dt">char</span>* target) {
  <span class="kw">return</span> MatchImpl&lt;RegExpr&gt;::Apply(
             target, [](<span class="dt">const</span> <span class="dt">char</span>* rest) -&gt; <span class="dt">bool</span> { <span class="kw">return</span> <span class="kw">true</span>; }) ||
         (*target &amp;&amp; RegexSearch&lt;RegExpr&gt;(target + <span class="dv">1</span>));
}

<span class="ot">#include &lt;cassert&gt;</span>

<span class="dt">int</span> main() {
  assert((RegexMatch&lt;ConcatExpr&lt;MatchExpr&lt;<span class="st">&#39;a&#39;</span>&gt;, MatchExpr&lt;<span class="st">&#39;b&#39;</span>&gt;&gt;&gt;(<span class="st">&quot;ab&quot;</span>)));
  assert((RegexMatch&lt;AltExpr&lt;MatchExpr&lt;<span class="st">&#39;a&#39;</span>&gt;, MatchExpr&lt;<span class="st">&#39;b&#39;</span>&gt;&gt;&gt;(<span class="st">&quot;a&quot;</span>)));
  assert((RegexMatch&lt;AltExpr&lt;MatchExpr&lt;<span class="st">&#39;a&#39;</span>&gt;, MatchExpr&lt;<span class="st">&#39;b&#39;</span>&gt;&gt;&gt;(<span class="st">&quot;b&quot;</span>)));
  assert((RegexMatch&lt;RepeatExpr&lt;MatchExpr&lt;<span class="st">&#39;a&#39;</span>&gt;&gt;&gt;(<span class="st">&quot;aaaaa&quot;</span>)));
  assert((RegexMatch&lt;ConcatExpr&lt;RepeatExpr&lt;MatchExpr&lt;<span class="st">&#39;a&#39;</span>&gt;&gt;, MatchExpr&lt;<span class="st">&#39;b&#39;</span>&gt;&gt;&gt;(
      <span class="st">&quot;aaaaab&quot;</span>)));
  assert((
      RegexMatch&lt;ConcatExpr&lt;RepeatExpr&lt;MatchExpr&lt;<span class="st">&#39;a&#39;</span>&gt;&gt;, MatchExpr&lt;<span class="st">&#39;b&#39;</span>&gt;&gt;&gt;(<span class="st">&quot;b&quot;</span>)));
  assert((RegexSearch&lt;ConcatExpr&lt;RepeatExpr&lt;MatchExpr&lt;<span class="st">&#39;a&#39;</span>&gt;&gt;, MatchExpr&lt;<span class="st">&#39;b&#39;</span>&gt;&gt;&gt;(
      <span class="st">&quot;aaaaabb&quot;</span>)));
  assert((RegexMatch&lt;OptionalExpr&lt;MatchExpr&lt;<span class="st">&#39;a&#39;</span>&gt;&gt;&gt;(<span class="st">&quot;a&quot;</span>)));
  assert((RegexMatch&lt;OptionalExpr&lt;MatchExpr&lt;<span class="st">&#39;a&#39;</span>&gt;&gt;&gt;(<span class="st">&quot;&quot;</span>)));
  assert((RegexMatch&lt;OptionalExpr&lt;ConcatExpr&lt;MatchExpr&lt;<span class="st">&#39;a&#39;</span>&gt;, MatchExpr&lt;<span class="st">&#39;b&#39;</span>&gt;&gt;&gt;&gt;(
      <span class="st">&quot;ab&quot;</span>)));
  assert((RegexMatch&lt;OptionalExpr&lt;ConcatExpr&lt;MatchExpr&lt;<span class="st">&#39;a&#39;</span>&gt;, MatchExpr&lt;<span class="st">&#39;b&#39;</span>&gt;&gt;&gt;&gt;(
      <span class="st">&quot;&quot;</span>)));
  assert((!RegexMatch&lt;RepeatExpr&lt;MatchExpr&lt;<span class="st">&#39;a&#39;</span>&gt;&gt;&gt;(<span class="st">&quot;aaaaab&quot;</span>)));
  assert((RegexMatch&lt;RepeatExpr&lt;OptionalExpr&lt;MatchExpr&lt;<span class="st">&#39;a&#39;</span>&gt;&gt;&gt;&gt;(<span class="st">&quot;&quot;</span>)));

  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</dd>
<dt>Milo Yip &#30340;&#27491;&#21017;&#20195;&#30721; <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">todo</code></pre></div>
<p><a href="https://github.com/miloyip/rapidjson/blob/regex/include/rapidjson/internal/regex.h">rapidjson/regex.h at regex &#183; miloyip/rapidjson</a></p>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="https://www.zhihu.com/question/27434493">&#22914;&#20309;&#20174;&#38646;&#20889;&#19968;&#20010;&#27491;&#21017;&#34920;&#36798;&#24335;&#24341;&#25806;&#65311; - &#30693;&#20046;</a></li>
</ul>
</dd>
</dl></li>
<li><p><a href="http://blog.csdn.net/kuhuaishuxia/article/details/52254209">ACM &#39064;&#38598;&#20197;&#21450;&#21508;&#31181;&#24635;&#32467;&#22823;&#20840;&#65281; - &#26543;&#27088;&#26641;&#19979;&#20056;&#20937; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></p></li>
<li><p><a href="http://www.hankcs.com/tag/%e3%80%8a%e6%8c%91%e6%88%98%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e7%ab%9e%e8%b5%9b%e7%ac%ac2%e7%89%88%e3%80%8b/">&#12298;&#25361;&#25112;&#31243;&#24207;&#35774;&#35745;&#31454;&#36187;(&#31532;2&#29256;)&#12299;-&#30721;&#20892;&#22330;</a></p></li>
<li><p><a href="http://www.csie.ntnu.edu.tw/~u91029/">&#28436;&#31639;&#27861;&#31558;&#35352;</a></p></li>
<li><p><a href="https://www.byvoid.com/blog/tag/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8">&#32178;&#35468; - BYVoid</a></p></li>
<li><p><a href="http://hihocoder.com/discuss/question/3663">hiho &#19968;&#19979;&#31532; 114 &#21608;&#12298;Image Encryption&#12299;&#39064;&#30446;&#20998;&#26512; - hihoCoder</a></p></li>
<li><p><a href="http://dsa.cs.tsinghua.edu.cn/%7Edeng/ds/dsacpp/index.htm">DSACPP, &#25968;&#25454;&#32467;&#26500;&#65288;C++&#35821;&#35328;&#29256;&#65289;</a></p></li>
<li><p><a href="http://blog.csdn.net/v_july_v/article/details/19131887">&#31243;&#24207;&#21592;&#22914;&#20309;&#24555;&#36895;&#20934;&#22791;&#38754;&#35797;&#20013;&#30340;&#31639;&#27861; - &#32467;&#26500;&#20043;&#27861; &#31639;&#27861;&#20043;&#36947; - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></p></li>
<li><p><a href="http://blog.csdn.net/loveyou426/article/details/7927297">&#26816;&#27979;&#21333;&#38142;&#34920;&#20013;&#26159;&#21542;&#26377;&#29615;&#8211;&#24555;&#24930;&#25351;&#38024;&#27861; - Linloves - &#21338;&#23458;&#39057;&#36947; - CSDN.NET</a></p></li>
<li><dl>
<dt>Adoo&#8217;s blog - Introduction to Algorithm -third edition <code class="fold">@</code></dt>
<dd><p><a href="http://www.roading.org//algorithm/introductiontoalgorithm/%e7%ae%97%e6%b3%95%e5%af%bc%e8%ae%ba%e5%b9%b3%e6%91%8a%e5%88%86%e6%9e%90.html">&#31639;&#27861;&#23548;&#35770;&#8212;&#8212;&#24179;&#25674;&#20998;&#26512;</a></p>
<dl>
<dt><a href="http://www.roading.org//algorithm/introductiontoalgorithm/%e7%ae%97%e6%b3%95%e5%af%bc%e8%ae%ba%e8%b5%ab%e5%a4%ab%e6%9b%bc%e7%bc%96%e7%a0%81.html">&#36203;&#22827;&#26364;&#32534;&#30721;</a> <code class="fold">@</code></dt>
<dd><div class="figure">
<img src="http://www.roading.org/images/2012-03/image_thumb22.png" />

</div>
<p>&#36203;&#22827;&#26364;&#32534;&#30721;&#30340;&#27491;&#30830;&#24615;</p>
<p>&#35777;&#26126;&#36203;&#22827;&#26364;&#32534;&#30721;&#30340;&#27491;&#30830;&#24615;&#38656;&#35777;&#26126;&#36138;&#24515;&#31639;&#27861;&#30340;&#20004;&#35201;&#32032;&#65306;</p>
<ul>
<li>&#20855;&#26377;&#26368;&#20248;&#23376;&#32467;&#26500;</li>
<li>&#36138;&#24515;&#36873;&#25321;&#24615;&#36136;</li>
</ul>
</dd>
<dt><a href="http://www.roading.org//algorithm/introductiontoalgorithm/%e7%ae%97%e6%b3%95%e5%af%bc%e8%ae%ba%e7%b4%a2%e5%bc%95%e8%a1%a8.html">&#12298;&#31639;&#27861;&#23548;&#35770;&#12299;&#31508;&#35760;&#27719;&#24635;</a> <code class="fold">@</code></dt>
<dd><p><a href="http://www.roading.org//algorithm/introductiontoalgorithm/%e4%bb%bfstl-%e7%9a%84%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84c%e5%ae%9e%e7%8e%b0.html">&#20223;STL &#30340;&#20108;&#21449;&#25628;&#32034;&#26641;&#30340;C++&#23454;&#29616;</a></p>
<p><a href="http://www.roading.org//algorithm/introductiontoalgorithm/%e6%89%a9%e5%b1%95%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84.html">&#25193;&#23637;&#25968;&#25454;&#32467;&#26500;</a></p>
<p><a href="http://www.roading.org//algorithm/introductiontoalgorithm/c%e5%ae%9e%e7%8e%b0%e7%ba%a2%e9%bb%91%e6%a0%91%ef%bc%8c%e4%bb%bfstl%e5%b0%81%e8%a3%85.html">C++&#23454;&#29616;&#32418;&#40657;&#26641;&#65292;&#20223;STL&#23553;&#35013;</a></p>
<p><a href="http://www.roading.org//algorithm/introductiontoalgorithm/chapter-13-red-black-trees-%e7%ba%a2%e9%bb%91%e6%a0%91.html">Chapter 13 Red-Black trees (&#32418;&#40657;&#26641;)</a></p>
<p><a href="http://www.roading.org//algorithm/introductiontoalgorithm/radix-tree-%e5%9f%ba%e6%95%b0%e6%a0%91.html">Radix Tree &#22522;&#25968;&#26641;</a></p>
<p><a href="http://www.roading.org//algorithm/introductiontoalgorithm/%e7%ae%97%e6%b3%95%e5%af%bc%e8%ae%ba6-3-young-tableaus.html">&#31639;&#27861;&#23548;&#35770;6-3 young tableaus</a></p>
<p><a href="http://www.roading.org//algorithm/introductiontoalgorithm/%e5%93%88%e5%b8%8c%e8%a1%a8%ef%bc%881%ef%bc%89.html">&#21704;&#24076;&#34920;&#65288;1&#65289;</a></p>
<p><a href="http://www.roading.org//algorithm/introductiontoalgorithm/%e7%ac%ac%e4%b8%83%e7%ab%a0%ef%bc%881%ef%bc%89-%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f.html">&#24555;&#36895;&#25490;&#24207;&#21450;C++&#23454;&#29616;</a></p>
<p><a href="http://www.roading.org//algorithm/introductiontoalgorithm/%e5%88%a9%e7%94%a8%e5%a0%86%e6%9d%a5%e5%bb%ba%e7%ab%8b%e4%bc%98%e5%85%88%e7%ba%a7%e9%98%9f%e5%88%97.html">&#21033;&#29992;&#22534;&#26469;&#24314;&#31435;&#20248;&#20808;&#32423;&#38431;&#21015;</a></p>
<p><a href="http://www.roading.org//algorithm/introductiontoalgorithm/%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f-insertionsort-c%e5%ae%9e%e7%8e%b0.html">&#25490;&#24207;&#20043;&#25554;&#20837;&#25490;&#24207;&#19982;&#21512;&#24182;&#25490;&#24207;-C++&#23454;&#29616;</a></p>
</dd>
</dl>
<p>refs and see also</p>
<ul>
<li><a href="http://www.roading.org/category/introduction-to-algorithm-third-edition.html">Adoo&#8217;s blog - Introduction to Algorithm -third edition</a> <code class="fold">@</code></li>
</ul>
</dd>
</dl></li>
</ul>
</dd>
</dl>
</div>
<script src="../lazyload.min.js"></script>
<script src="../jquery-3.0.0.min.js"></script>
<script src="../jquery.idTabs.min.js"></script>
<script src="../egg.min.js"></script>
<script src="../clipboard.min.js"></script>
<script src="../notes.js"></script>
</body>
</html>
