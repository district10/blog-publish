<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="author" content="district10" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Learning Ruby</title>
    <link rel="stylesheet" href="../github-markdown.css" type="text/css" />
    <link rel="stylesheet" href="../highlight.css" type="text/css" />
    <link rel="stylesheet" href="../notes.css" type="text/css" />
</head>
<body class="markdown-body">
<div id="navigator">
    <a id="gotoindex" href="index.html" title="&#12304;&#22238;&#21040;&#31508;&#35760;&#32034;&#24341; | Back to Index&#12305;">&#9763;</a></div>
<div id="main-body">
<dl>
<dt><a href="https://www.zhihu.com/question/32204010/answer/55189845">&#26377;&#21738;&#20123;&#20540;&#24471;&#25512;&#33616;&#30340; Ruby &#23398;&#20064;&#27969;&#31243;&#65311; - &#30693;&#20046;</a></dt>
<dd><p>&#24456;&#22810;&#20154;&#26159;: &#20808;&#23398; Rails &#20570;&#39033;&#30446;, &#28982;&#21518;&#20877;&#26469;&#23398; Ruby&#8230;</p>
<p>&#20687; <span class="citation">[@RednaxelaFX]</span>(//www.zhihu.com/people/a06cfb38e37dac1658e6457df4d7f032) &#30340;&#23398;&#20064;&#27969;&#31243;&#23601;&#19981;&#19968;&#26679;, &#20182;&#26159;&#20808;&#30475; Ruby &#30340; parse.y &#26469;&#36895;&#25104;&#35821;&#27861;, &#28982;&#21518;&#20877;&#29992;&#26469;&#29228;&#23567;&#40644;&#22270;&#25110;&#32773;&#27721;&#21270;&#26085;&#25991;&#28216;&#25103;, &#21516;&#26102;&#30475;&#30475;&#21508;&#31181; VM &#30340;&#23454;&#29616;&#20363;&#22914; JRuby &#21862;, Rubinius &#21862;, MRuby &#21862;, IronRuby &#21862;&#8230;</p>
<p>&#27491;&#32479;&#28857;&#30340;&#23398;&#20064;&#27861;&#26159;&#25214;&#19968;&#26412;&#20070;&#30475;, &#20363;&#22914; Programming Ruby 1.9 &amp; 2.0 , &#20294;&#26159;&#21487;&#33021;&#20250;&#24930;&#19968;&#28857;&#20294;&#36866;&#21512;&#27809;&#20160;&#20040;&#32534;&#31243;&#22522;&#30784;&#30340;. &#23454;&#36341;&#27966;&#21487;&#33021;&#20250;&#21916;&#27426;&#30475; <a href="//link.zhihu.com/?target=http%3A//rubykoans.com/">Learn Ruby with the Neo Ruby Koans</a></p>
<p>&#23545;&#26377;&#21069;&#36884;&#30340;&#23567;&#22993;&#23064;&#23567;&#20249;&#25105;&#20250;&#25512;&#33616;&#30475;&#19978;&#21476;&#37034;&#20070; <a href="//link.zhihu.com/?target=http%3A//mislav.uniqpath.com/poignant-guide/">Why&#8217;s (Poignant) Guide to Ruby</a></p>
<p>&#26377;&#28857;&#32534;&#31243;&#32463;&#39564;&#30340;, &#30452;&#25509;&#30475;&#19968;&#24352;&#32593;&#39029; <a href="//link.zhihu.com/?target=http%3A//ruby.on-page.net/">Ruby.on-page.net</a> &#25110;&#32773;&#27604;&#30528; code roseta &#20570;&#23601;&#21487;&#20197;&#20102;</p>
<p><a href="//link.zhihu.com/?target=http%3A//rubyquiz.com/">Ruby Quiz</a> &#27599;&#21608;&#19968;&#39064;&#20840;&#30475;&#19968;&#36941;&#20320;&#20250;&#21463;&#30410;&#33391;&#22810;, &#22312;&#23398;&#20064;&#20102;&#22522;&#30784;&#35821;&#27861;&#21518;&#21487;&#20197;&#24320;&#22987;&#30475;</p>
<p>&#26049;&#38376;&#24038;&#36947;&#30340;&#20363;&#22914;&#25105;, &#22312;&#21508;&#38382;&#31572;&#32593;&#31449;&#21644;&#31038;&#21306;&#19978;&#25214; Code Golf &#38382;&#39064;&#29992; Ruby &#22238;&#31572;, &#25110;&#32773;&#20851;&#27880;&#30693;&#20046;&#30340; Ruby &#35805;&#39064;&#12290;</p>
</dd>
</dl>
<p>tzx|&#26368;&#21518;&#65306;</p>
<ul>
<li><a href="../misc/ruby-style-guide.html">Ruby Style Guide</a>&#65292;&#25105;&#30340;&#31508;&#35760;</li>
<li><a href="http://poignant.guide/">Why&#8217;s (Poignant) Guide to Ruby</a>&#65292;&#20070;</li>
<li><a href="http://rubykoans.com/">Learn Ruby with the Edgecase Ruby Koans</a></li>
</ul>
<hr />
<div class="figure">
<img src="https://img3.doubanio.com/lpic/s12295310.jpg" />

</div>
<ul>
<li><a href="http://shop.oreilly.com/product/9780596516178.do">The Ruby Programming Language&#160;-&#160;O&#8217;Reilly Media</a></li>
<li><a href="https://book.douban.com/subject/2337297/">The Ruby Programming Language (&#35910;&#29923;)</a></li>
</ul>
<pre><code>By David Flanagan, Yukihiro Matsumoto
Publisher: O&#39;Reilly Media
Final Release Date: January 2008
Pages: 448</code></pre>
<h2 id="chapter-1-introduction">Chapter 1 Introduction</h2>
<h3 id="a-tour-of-ruby">A Tour of Ruby</h3>
<ul>
<li><dl>
<dt>ruby is (fully) object-oriented <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dv">1</span>.class         <span class="co"># =&gt; Fixnum: the number 1 is a Fixnum</span>
<span class="fl">0.0</span>.class       <span class="co"># =&gt; Float: floating-point numbers have class Float</span>
<span class="dv">true</span>.class      <span class="co"># =&gt; TrueClass: true is a the singleton instance of TrueClass</span>
<span class="dv">false</span>.class     <span class="co"># =&gt; FalseClass</span>
<span class="dv">nil</span>.class       <span class="co"># =&gt; NilClass</span></code></pre></div>
<p>parentheses is optional</p>
</dd>
</dl></li>
<li><dl>
<dt>Blocks and Iterators <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dv">3</span>.times { print <span class="st">&quot;Ruby! &quot;</span> }      <span class="co"># Prints &quot;Ruby! Ruby! Ruby! &quot;</span>
<span class="dv">1</span>.upto(<span class="dv">9</span>) {|x| print x }        <span class="co"># Prints &quot;123456789&quot;, upto, downto</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">a = [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>]       <span class="co"># This is an array literal</span>
a[<span class="dv">3</span>] = a[<span class="dv">2</span>] - <span class="dv">1</span>
a.each <span class="kw">do</span> |elt|
    print elt<span class="dv">+1</span>
<span class="kw">end</span>                 <span class="co"># This block was delimited with do/end instead of {}</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">a = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]
b = a.map {|x| x*x }
c = a.select {|x| x%<span class="dv">2</span>==<span class="dv">0</span> }
a.inject <span class="kw">do</span> |sum,x|
    sum + x
<span class="kw">end</span></code></pre></div>
<p>hashes</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">h = {
    <span class="st">:one</span> =&gt; <span class="dv">1</span>,
    <span class="st">:two</span> =&gt; <span class="dv">2</span>
}
h[<span class="st">:one</span>]
h[<span class="st">:three</span>] = <span class="dv">3</span>
h.each <span class="kw">do</span> |key,value|
    print <span class="st">&quot;</span><span class="ot">#{</span>value<span class="ot">}</span><span class="st">:</span><span class="ot">#{</span>key<span class="ot">}</span><span class="st">; &quot;</span>
<span class="kw">end</span>

<span class="co"># &#24403;&#28982;&#20063;&#25903;&#25345; JS &#37027;&#26679;&#30340;</span>
h = { <span class="st">one: </span><span class="dv">1</span>, <span class="st">two: </span><span class="dv">2</span> }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">File</span>.open(<span class="st">&quot;data.txt&quot;</span>) <span class="kw">do</span> |f|    <span class="co"># Open named file and pass stream to block</span>
    line = f.readline           <span class="co"># Use the stream to read from the file</span>
<span class="kw">end</span>                             <span class="co"># Stream automatically closed at block end</span>

t = <span class="dt">Thread</span>.new <span class="kw">do</span>               <span class="co"># Run this block in a new thread</span>
    <span class="dt">File</span>.read(<span class="st">&quot;data.txt&quot;</span>)       <span class="co"># Read a file in the background</span>
<span class="kw">end</span>                             <span class="co"># File contents available as thread value</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">interpolated = <span class="st">&quot;interpolated&quot;</span>
print <span class="st">&quot;can be </span><span class="ot">#{</span>interpolated<span class="ot">}</span><span class="st">&quot;</span>

<span class="co"># to_s: to string</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Expressions and Operators in Ruby <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="st">&quot;str&quot;</span> * <span class="dv">3</span>                   <span class="co"># rep</span>
<span class="st">&quot;%d %s&quot;</span> % [<span class="dv">2</span>, <span class="st">&quot;two&quot;</span>]        <span class="co"># format</span>
<span class="dv">2</span>**<span class="dv">1024</span>                     <span class="co"># to the power of 1024</span></code></pre></div>
</dd>
</dl></li>
<li><p>Operator overides: <code>[]</code> (Array &amp; Hash)&#65292;&#22312; ruby &#37324;&#22826;&#28789;&#27963;&#20102;&#22826;&#24120;&#35265;&#20102;&#8230;&#8230;</p></li>
<li><dl>
<dt>Methods <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> square(x)
    x*x
<span class="kw">end</span></code></pre></div>
<p>Live update Math module (core Ruby lib)</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> <span class="dt">Math</span>.square(x)  <span class="co"># Define a class method of the Math module</span>
    x*x             <span class="co"># The last expression is the return value</span>
<span class="kw">end</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Assignment <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">=
+=, -=, *=, <span class="ot">/=</span>
<span class="ot">x,y = 1,2</span>
<span class="ot">a,b = b,a               # swap</span>
<span class="ot">x,y,z = [1,2,3]         # unpack, splat</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">o.x=(<span class="dv">1</span>)             <span class="co"># &quot;x=&quot; &#26159;&#19968;&#20010; method&#8230;&#8230;&#25152;&#20197;&#26159;&#22312;&#35843;&#29992;&#23376;&#20989;&#25968;</span>

<span class="co"># &#36825;&#26679;&#30340; method &#21644;&#19968;&#33324;&#30340; method &#27809;&#21861;&#19981;&#21516;&#65292;&#38500;&#20102;&#23427;&#36824;&#21487;&#20197;&#36825;&#26679;&#35843;&#29992;&#65306;</span>
o.x = <span class="dv">1</span>             <span class="co"># &#31561;&#20215;&#20110; o.x=(1)</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Punctuation Suffixes and Prefixes <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">empty?              <span class="co"># &#36825;&#26159;&#19968;&#20010; method</span>
sort                <span class="co">#</span>
sort!               <span class="co"># mutator method, in-place</span>
<span class="dt">$global_varible</span>
<span class="ot">@instance_varible</span>
<span class="ot">@@class_varible</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Regexp and Range <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="ot">/[Rr]uby/</span>
<span class="ot">/\d{5}/</span>
<span class="dv">1</span>..<span class="dv">3</span>            <span class="co"># 1&lt;= x &lt;= 3</span>
<span class="dv">1</span>...<span class="dv">3</span>            <span class="co"># 1&lt;= x &lt; 3</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">generation = <span class="kw">case</span> birthyear
    <span class="kw">when</span> <span class="dv">1946</span>..<span class="dv">1963</span>: <span class="st">&quot;Baby Boomer&quot;</span>
    <span class="kw">when</span> <span class="dv">1964</span>..<span class="dv">1976</span>: <span class="st">&quot;Generation X&quot;</span>
    <span class="kw">when</span> <span class="dv">1978</span>..<span class="dv">2000</span>: <span class="st">&quot;Generation Y&quot;</span>
    <span class="co"># when cond1, cond2</span>
    <span class="kw">else</span> <span class="dv">nil</span>
<span class="kw">end</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Classes and Modules <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">class</span> <span class="dt">Sequence</span>
    include <span class="dt">Enumerable</span>
    <span class="kw">def</span> initialize(from, to, by)    <span class="co"># Sequence.new(from,to,by)</span>
        ...
    <span class="kw">end</span>
    <span class="kw">def</span> [](index)
        ...
    <span class="kw">end</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">Sequence</span>
    <span class="kw">def</span> <span class="dv">self</span>.fromtoby(from, to, by)
        x = from
        <span class="kw">while</span> x &lt;= to
            <span class="kw">yield</span> x
            x += by
        <span class="kw">end</span>
    <span class="kw">end</span>
<span class="kw">end</span>
<span class="co"># Sequences.fromtoby(1, 10, 2) {|x| print x }</span>
<span class="co"># Prints &quot;13579&quot;</span></code></pre></div>
<p>The core Ruby API is a rich one, and it is worth taking the time to study the platform (see Chapter 9) so you don&#8217;t end up spending time writing methods that have already been implemented for you!</p>
</dd>
</dl></li>
<li><dl>
<dt>Ruby Surprises <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># ruby: mutable string</span>
[]=             <span class="co"># method, insert, delete, update, etc</span>
&lt;&lt;              <span class="co"># append</span>
freeze          <span class="co"># make immutable</span></code></pre></div>
<p>nil -&gt; false, otherwise -&gt; true</p>
</dd>
</dl></li>
</ul>
<h3 id="try-ruby">Try Ruby</h3>
<ul>
<li><code class="sourceCode bash"><span class="kw">ruby</span> -e <span class="st">&#39;puts &quot;Hello World&quot;&#39;</span></code>, <code>e</code> for evaluate</li>
<li><code class="sourceCode bash"><span class="kw">irb</span> --simple-prompt</code></li>
<li><code>ri Array.sort</code>, read doc</li>
<li><dl>
<dt>Ruby Package Management with gem <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># gem install rails</span>
gem list                    <span class="co"># List installed gems</span>
gem enviroment              <span class="co"># Display RubyGems configuration information</span>
gem update rails            <span class="co"># Update a named gem</span>
gem update                  <span class="co"># Update all installed gems</span>
gem update --system         <span class="co"># Update RubyGems itself</span>
gem uninstall rails         <span class="co"># Remove an installed gem</span></code></pre></div>
</dd>
</dl></li>
</ul>
<h3 id="about-this-book">About This Book</h3>
<p>This chapter concludes with a heavily commented extended example demonstrating a nontrivial Ruby program.</p>
<dl>
<dt>The chapters that follow cover Ruby from the bottom up: <code class="fold">@</code></dt>
<dd><ul>
<li>Chapter 2 covers the lexical and syntactic structure of Ruby, including basic issues like character set, case sensitivity, and reserved words.</li>
<li>Chapter 3 explains the kinds of data&#8212;numbers, strings, ranges, arrays, and so on &#8212; that Ruby programs can manipulate, and it covers the basic features of all Ruby objects.</li>
<li>Chapter 4 covers primary expressions in Ruby&#8212;literals, variable references, method invocations, and assignments&#8212;and it explains the operators used to combine primary expressions into compound expressions.</li>
<li>Chapter 5 explains conditionals, loops (including blocks and iterator methods), exceptions, and the other Ruby expressions that would be called statements or control structures in other languages.</li>
<li>Chapter 6 formally documents Ruby&#8217;s method definition and invocation syntax, and it also covers the invocable objects known as procs and lambdas. This chapter includes an explanation of closures and an exploration of functional programming techniques in Ruby.</li>
<li>Chapter 7 explains how to define classes and modules in Ruby. Classes are fundamental to object-oriented programming, and this chapter also covers topics such as inheritance, method visibility, mixin modules, and the method name resolution algorithm.</li>
<li>Chapter 8 covers Ruby&#8217;s APIs that allow a program to inspect and manipulate itself, and then demonstrates metaprogramming techniques that use those APIs to make programming easier. The chapter includes an example of domain-specific language.</li>
<li>Chapter 9 demonstrates the most important classes and methods of the core Ruby platform with simple code fragments. This is not a reference but a detailed overview of the core classes. Topics include text processing, numeric computation, collections (such as arrays and hashes), input/output, networking, and threads. After reading this chapter, you&#8217;ll understand the breadth of the Ruby platform, and you&#8217;ll be able to use the ri tool or an online reference to explore the platform in depth.</li>
<li>Chapter 10 covers the top-level Ruby programming environment, including global variables and global functions, command-line arguments supported by the Ruby interpreter, and Ruby&#8217;s security mechanism.</li>
</ul>
</dd>
</dl>
<h3 id="a-sudoku-solver-in-ruby">A Sudoku Solver in Ruby</h3>
<dl>
<dt>code <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">class</span> <span class="dt">Puzzle</span>
    <span class="dt">ASCII</span> = <span class="st">&quot;.123456789&quot;</span>                                    <span class="co"># external rep</span>
    <span class="dt">BIN</span> = <span class="st">&quot;\000\001\002\003\004\005\006\007\010\011&quot;</span>        <span class="co"># internal rep</span>
    <span class="kw">def</span> initialize(lines)
        <span class="kw">if</span> (lines.responds_to? <span class="st">:join</span>)
            s = lines.join
        <span class="kw">else</span>
            s = lines.dup
        <span class="kw">end</span>
        s.gsub!(<span class="ot">/\s/</span>, <span class="st">&quot;&quot;</span>)                                   <span class="co"># strip all whitespaces</span>

        raise <span class="dt">Invalid</span>, <span class="st">&quot;Grid is the wrong size&quot;</span> <span class="kw">unless</span> s.size == <span class="dv">81</span>
        <span class="kw">if</span> i = s.index(<span class="ot">/[^123456789\.]/</span>)
            raise <span class="dt">Invalid</span>, <span class="st">&quot;Illegal character </span><span class="ot">#{</span>s[i,<span class="dv">1</span>]<span class="ot">}</span><span class="st"> in puzzle&quot;</span>
        <span class="kw">end</span>
        s.tr!(<span class="dt">ASCII</span>, <span class="dt">BIN</span>)                                   <span class="co"># external rep -&gt; internal rep</span>
        <span class="ot">@grid</span> = s.unpack(<span class="st">&#39;c*&#39;</span>)                              <span class="co"># unpack bytes to array of nums</span>
        raise <span class="dt">Invalid</span>, <span class="st">&quot;Initial puzzle has duplicates&quot;</span> <span class="kw">if</span> has_duplicates?
    <span class="kw">end</span>

    <span class="kw">def</span> dup
        copy = <span class="dv">super</span>
        <span class="ot">@grid</span> = <span class="ot">@grid</span>.dup
        copy                                                <span class="co"># return the copied</span>
    <span class="kw">end</span>

    <span class="kw">def</span> [](row,col)
        <span class="ot">@grid</span>[row*<span class="dv">9</span>+col]
    <span class="kw">end</span>

    <span class="kw">def</span> []=(row, col, newvalue)
        <span class="kw">unless</span> (<span class="dv">0</span>..<span class="dv">9</span>).include? newvalue
            raise ...
        <span class="kw">end</span>
        <span class="ot">@grid</span>[row*<span class="dv">9</span>+col] = newvalue
    <span class="kw">end</span>

    <span class="dt">BoxOfIndex</span> = [
        <span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,
        <span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,
        <span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,
        <span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>,
        <span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>,
        <span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>,
        <span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>,
        <span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>,
        <span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>
    ].freeze

    <span class="kw">def</span> each_unknown
        <span class="dv">0</span>.upto <span class="dv">8</span> <span class="kw">do</span> |row|
            <span class="dv">0</span>.upto <span class="dv">8</span> <span class="kw">do</span> |col|
                index = row*<span class="dv">9</span>+col
                <span class="kw">next</span> <span class="kw">if</span> <span class="ot">@grid</span>[index] != <span class="dv">0</span> <span class="co"># Move on if we know the cell&#39;s value</span>
                box = <span class="dt">BoxOfIndex</span>[index]
                <span class="kw">yield</span> row, col, box
            <span class="kw">end</span>
        <span class="kw">end</span>
    <span class="kw">end</span>

    <span class="kw">def</span> has_duplicates?
        <span class="co"># uniq! returns nil (false) if all the elements in an array are unique.</span>
        <span class="co"># So if uniq! returns something then the board has duplicates.</span>
        <span class="dv">0</span>.upto(<span class="dv">8</span>) {|row| <span class="kw">return</span> <span class="dv">true</span> <span class="kw">if</span> rowdigits(row).uniq! }
        <span class="dv">0</span>.upto(<span class="dv">8</span>) {|col| <span class="kw">return</span> <span class="dv">true</span> <span class="kw">if</span> coldigits(col).uniq! }
        <span class="dv">0</span>.upto(<span class="dv">8</span>) {|box| <span class="kw">return</span> <span class="dv">true</span> <span class="kw">if</span> boxdigits(box).uniq! }
        <span class="dv">false</span>
    <span class="kw">end</span>

    <span class="dt">AllDigits</span> = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>].freeze
    <span class="kw">def</span> possible(row, col, box)
        <span class="co"># +: array concat, -: set diff</span>
        <span class="dt">AllDigits</span> - (rowdigits(row) + coldigits(col) + boxdigits(box))
    <span class="kw">end</span>

    <span class="kw">private</span> <span class="co"># these below methods are private</span>

    <span class="co"># all digits in the row-th row</span>
    <span class="kw">def</span> rowdigits(row)
        <span class="co"># Array subtraction is set difference, with duplicate removal.</span>
        <span class="ot">@grid</span>[row*<span class="dv">9</span>,<span class="dv">9</span>] - [<span class="dv">0</span>]
    <span class="kw">end</span>

    <span class="co"># &#21487;&#20197;&#30475;&#21040;&#65292;&#8220;+&#8221; &#26159; array concat&#65292;&#8220;-&#8221; &#26159; set diffrence (no dup)</span>
    <span class="kw">def</span> coldigits(col)
        result = []
        <span class="co"># Start with an empty array</span>
        col.step(<span class="dv">80</span>, <span class="dv">9</span>) {|i|
            v = <span class="ot">@grid</span>[i]
            <span class="co"># Get value of cell at that index</span>
            result &lt;&lt; v <span class="kw">if</span> (v != <span class="dv">0</span>) <span class="co"># Add it to the array if non-zero</span>
        }
        result              <span class="co"># &#36825;&#26159;&#19981;&#26159;&#26377; dup &#21834;&#8230;&#8230;</span>
    <span class="kw">end</span>

    <span class="co"># &#27599;&#20010; box &#24038;&#19978;&#35282;&#30340; index</span>
    <span class="dt">BoxToIndex</span> = [<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">27</span>, <span class="dv">30</span>, <span class="dv">33</span>, <span class="dv">54</span>, <span class="dv">57</span>, <span class="dv">60</span>].freeze

    <span class="kw">def</span> boxdigits(b)
        <span class="co"># Convert box number to index of upper-left corner of the box.</span>
        i = <span class="dt">BoxToIndex</span>[b]
        <span class="co"># Return an array of values, with 0 elements removed.</span>
        [
            <span class="ot">@grid</span>[i], <span class="ot">@grid</span>[i<span class="dv">+1</span>], <span class="ot">@grid</span>[i<span class="dv">+2</span>],
            <span class="ot">@grid</span>[i<span class="dv">+9</span>], <span class="ot">@grid</span>[i<span class="dv">+10</span>], <span class="ot">@grid</span>[i<span class="dv">+11</span>],
            <span class="ot">@grid</span>[i<span class="dv">+18</span>], <span class="ot">@grid</span>[i<span class="dv">+19</span>], <span class="ot">@grid</span>[i<span class="dv">+20</span>]
        ] - [<span class="dv">0</span>]
    <span class="kw">end</span>
<span class="kw">end</span> <span class="co"># This is the end of the Puzzle class</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># An exception of this class indicates invalid input,</span>
<span class="kw">class</span> <span class="dt">Invalid</span> &lt; <span class="dt">StandardError</span>
<span class="kw">end</span>

<span class="kw">class</span> <span class="dt">Impossible</span> &lt; <span class="dt">StandardError</span>
<span class="kw">end</span>

<span class="kw">def</span> <span class="dt">Sudoku</span>.scan(puzzle)
    unchanged = <span class="dv">false</span>
    <span class="kw">until</span> unchanged
        unchanged = <span class="dv">true</span>            <span class="co"># Assume no cells will be changed this time</span>
        rmin,cmin,pmin = <span class="dv">nil</span>        <span class="co"># Track cell with minimal possible set</span>
        min = <span class="dv">10</span>                    <span class="co"># More than the maximal number of possibilities</span>
        puzzle.each_unknown <span class="kw">do</span> |row, col, box|
            p = puzzle.possible(row, col, box)
            <span class="kw">case</span> p.size
            <span class="kw">when</span> <span class="dv">0</span>
                raise <span class="dt">Impossible</span>
            <span class="kw">when</span> <span class="dv">1</span>
                puzzle[row,col] = p[<span class="dv">0</span>]  <span class="co"># set to the only possibility</span>
                unchanged = <span class="dv">false</span>       <span class="co"># note that we&#39;ve made a change</span>
            <span class="kw">else</span>    <span class="co"># &gt;1</span>
                <span class="kw">if</span> unchanged &amp;&amp; p.size &lt; min
                    min = p.size
                    rmin, cmin, pmin = row, col, p
                <span class="kw">end</span>
            <span class="kw">end</span>
        <span class="kw">end</span>
        <span class="kw">return</span> rmin, cmin, pmin         <span class="co"># &#25214;&#21040;&#20102; puzzle &#26368;&#23481;&#26131;&#31361;&#30772;&#30340;&#28857;&#65306;&#36825;&#37324;&#21487;&#33021;&#24615;&#26368;&#23569;</span>
    <span class="kw">end</span>

    <span class="kw">def</span> <span class="dt">Sudoku</span>.solve(puzzle)
        puzzle = puzzle.dup
        r,c,p = scan(puzzle)
        <span class="kw">return</span> puzzle <span class="kw">if</span> r == <span class="dv">nil</span>
        p.each <span class="kw">do</span> |guess|
            puzzle[r,c] = guess
            <span class="kw">begin</span>
                <span class="kw">return</span> solve(puzzle)
            <span class="kw">rescue</span> <span class="dt">Impossible</span>
                <span class="kw">next</span>
            <span class="kw">end</span>
        <span class="kw">end</span>
        raise <span class="dt">Impossible</span>
    <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
</dd>
</dl>
<h2 id="chapter-2-the-structure-and-execution-of-ruby-programs">Chapter 2 The Structure and Execution of Ruby Programs</h2>
<h3 id="lexical-structure">Lexical Structure</h3>
<p>seq of tokens:</p>
<ul>
<li><dl>
<dt>comments <code class="fold">@</code></dt>
<dd><ul>
<li><code># comments</code></li>
<li><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co">=begin</span>
<span class="co">    embedded document</span>
<span class="co">    you can comment out code here</span>
<span class="co">=end</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co">=begin rdoc</span>
<span class="co">    this uses a special markup language</span>
<span class="co">    * list</span>
<span class="co">    *   *bold* &lt;b&gt;....&lt;/b&gt;</span>
<span class="co">    *   *italic* &lt;i&gt;....&lt;/i&gt;</span>
<span class="co">=end</span></code></pre></div></li>
</ul>
</dd>
</dl></li>
<li>Literals</li>
<li>Punctuation</li>
<li>Unicode &#20989;&#25968;&#21487;&#20197;&#29992; unicode &#34920;&#31034;</li>
<li><dl>
<dt>Punctuation in identifiers <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">$files</span>                      <span class="co"># A global variable</span>
<span class="ot">@data</span>                       <span class="co"># An instance variable</span>
<span class="ot">@@counter</span>                   <span class="co"># A class variable</span>
empty?                      <span class="co"># A Boolean-valued method or predicate</span>
sort!                       <span class="co"># An in-place alternative to the regular sort method</span>
timeout=                    <span class="co"># A method invoked by assignment</span></code></pre></div>
<p>the token <code>__END__</code> marks the end of the program (and the beginning of a data section) if it appears on a line by itself with no leading or trailing whitespace.</p>
</dd>
</dl></li>
<li><dl>
<dt>Whitespace <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># fluent API, not work in Ruby 1.8</span>
animals = <span class="dt">Array</span>.new
    .push(<span class="st">&quot;dog&quot;</span>)
    .push(<span class="st">&quot;cow&quot;</span>)
    .push(<span class="st">&quot;cat&quot;</span>)
    .sort
<span class="co"># &#26377;&#8220;.&#8221;&#24320;&#22836;&#30340;&#34892;&#65292;&#26080;&#38656;&#8220;\&#8221;&#26469;&#32493;&#34892;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">f(<span class="dv">3+2</span>)+<span class="dv">1</span>
f (<span class="dv">3+2</span>)+<span class="dv">1</span>           <span class="co"># &#25226; (3+1)+1 &#20256;&#20837;&#20102;&#20989;&#25968; f</span></code></pre></div>
</dd>
</dl></li>
</ul>
<h3 id="syntactic-structure">Syntactic Structure</h3>
<ul>
<li><dl>
<dt>Literials <code class="fold">@</code></dt>
<dd><ul>
<li><code>[1,2,3]</code>, <strong>Array</strong></li>
<li><code>{1=&gt;&quot;one&quot;, 2=&gt;&quot;two&quot;}</code>&#65292;<strong>Hash</strong></li>
<li><code>1..3</code>&#65292;<strong>Range</strong></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Block Structure in Ruby <code class="fold">@</code></dt>
<dd><ul>
<li><code>{  |var| ... }</code>&#65292;&#19968;&#34892;&#21487;&#20197;&#20889;&#23436;&#30340;&#35805;&#26368;&#22909;&#29992;&#36825;&#20010;</li>
<li><code>do |var| ... end</code>&#65292;&#24456;&#22810;&#34892;&#30340;&#35805;</li>
</ul>
</dd>
</dl></li>
</ul>
<h3 id="file-structure">File Structure</h3>
<dl>
<dt><code>__END__</code> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">#!/usr/bin/ruby -w              # shebang comment</span>
<span class="co"># -*- coding: utf-8 -*-         # coding comment, for Emacs. (Vim? use &quot;# vi: set fileencoding=utf-8&quot;)</span>
require <span class="st">&#39;socket&#39;</span>                <span class="co"># load libs</span>

    ...                         <span class="co"># program code goes here</span>

<span class="dt">__END__</span>                         <span class="co"># mark end of code</span>
    ...                         <span class="co"># program data goes here</span></code></pre></div>
</dd>
</dl>
<h3 id="program-encoding">Program Encoding</h3>
<p>Better utf-8</p>
<h3 id="program-execution">Program Execution</h3>
<dl>
<dt>utf-8 <code class="fold">@</code></dt>
<dd><ul>
<li><code>ruby -Ku</code>, utf-8</li>
<li><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># coding: utf-8</span></code></pre></div></li>
<li><p>&#36825;&#20010;&#23436;&#20840;&#26159; shell &#30340;&#20107;&#24773;&#8230;&#8230;</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ruby</span> -E utf-8                   <span class="co"># Encoding name follows -E</span>
<span class="kw">ruby</span> -Eutf-8                    <span class="co"># The space is optional</span>
<span class="kw">ruby</span> --encoding utf-8           <span class="co"># Encoding following --encoding with a space</span>
<span class="kw">ruby</span> --encoding=utf-8           <span class="co"># Or use an equals sign with --encoding</span></code></pre></div>
<p>ruby &#36824;&#21487;&#20197; register <code>at_exit</code> &#20989;&#25968;&#65288;&#21644; C &#19968;&#26679;&#65289;</p></li>
</ul>
</dd>
</dl>
<h2 id="chapter-3-datatypes-and-objects">Chapter 3 Datatypes and Objects</h2>
<h3 id="numbers">Numbers</h3>
<ul>
<li><dl>
<dt>Numberic (immutable) <code class="fold">@</code></dt>
<dd><ul>
<li>Integer
<ul>
<li>Fixnum (31 bits)</li>
<li>Bignum</li>
</ul></li>
<li>Float</li>
<li>Complext (std. lib.)</li>
<li>BigDecimal (std. lib.)</li>
<li>Rational (std. lib.) &#20998;&#25968;</li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt><code>_</code> &#26469;&#20998;&#38548;&#65292;<code>0x...</code>&#12289;<code>0...</code> <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dv">1_000_000_000</span>
0x
<span class="bn">0b1111_0000</span>
x = <span class="dv">5</span> % <span class="dv">2</span>
x = <span class="fl">1.5</span> % <span class="fl">0.4</span>
<span class="dv">4</span>**<span class="dv">3</span>**<span class="dv">2</span> <span class="co"># 4**9</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>integer division &amp; modulo <code class="fold">@</code></dt>
<dd><p>An important corollary of Ruby&#8217;s definition of integer division is that, in Ruby, -a/b equals a/-b but may not equal -(a/b) .</p>
<pre><code>corollary

&#33521; [k&#601;&#39;r&#594;l&#601;r&#618;] &#32654; [&#39;k&#596;r&#601;l&#603;ri]

    n. &#25512;&#35770;&#65307;&#24517;&#28982;&#30340;&#32467;&#26524;</code></pre>
<p>Ruby&#8217;s definition of the modulo operation also differs from that of C and Java. In Ruby, &#8211;7%3 is 2 . In C and Java, the result is -1 instead. The magnitude of the result differs, of course, because the value of the quotient differs. But the sign of the result differs, too. In Ruby, the sign of the result is always the same as the sign of the second operand. In C and Java, the sign of the result is always the same as the sign of the first operand. (Ruby also provides a remainder method that behaves, in sign and magnitude, like the C modulo operator.)</p>
</dd>
</dl></li>
</ul>
<h3 id="text">Text</h3>
<ul>
<li><code>'a\b' == 'a\\b'</code>&#21487;&#20197;&#65292;&#20294;&#26159;&#27809;&#24517;&#35201; escape&#12290;</li>
<li><code>&quot;#{interp}&quot;</code>, escape interp: <code>&quot;\#{none_interp}&quot;</code></li>
<li><code>''</code> &#19981;&#21487;&#20197;&#29992;&#8220;&#8221;&#32493;&#34892;&#65292;<code>&quot;&quot;</code> &#21487;&#20197;&#12290;</li>
<li><code>\u00D7</code> &#8220;x&#8221;&#65292;leading 0 &#19981;&#33021;&#30465;&#30053;</li>
<li><code>\u20ac&quot;</code> &#8220;&#8364;&#8221;&#65292;&#22823;&#23567;&#20889;&#19968;&#26679;</li>
<li><dl>
<dt><code>%q</code>, single quote, <code>%Q</code> double quote <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="ot">%q(</span><span class="st">..........</span><span class="ot">)</span>
<span class="ot">%q-</span><span class="st">..........</span><span class="ot">-</span>
<span class="ot">%q{</span><span class="st">..........</span><span class="ot">}</span>
<span class="ot">%q|</span><span class="st">..........|</span></code></pre></div>
<p>&#21644; Perl &#31867;&#20284;</p>
<p><code>%Q</code>, double quote <code class="fold">@</code></p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="ot">%Q(</span><span class="st">..........</span><span class="ot">)</span>
<span class="ot">%Q-</span><span class="st">..........</span><span class="ot">-</span>
<span class="ot">%Q{</span><span class="st">..........</span><span class="ot">}</span>
<span class="ot">%</span>_<span class="ot">..</span>........_ <span class="co"># Q &#30465;&#30053;&#20102;</span></code></pre></div>
<p><code>()</code> &#36825;&#26679;&#30340;&#21644; <code>||</code> &#26377;&#28857;&#19981;&#19968;&#26679;&#12290;&#21069;&#32773;&#26159; paired&#65292;&#21518;&#32773;&#27809;&#26377;&#12290;&#21069;&#32773;&#21487;&#20197; nest &#32780;&#19981;&#38656;&#35201; escape&#12290;</p>
<dl>
<dt>&#21040;&#24213;&#29992;&#22312;&#21738;&#20799;&#21602;&#65311;</dt>
<dd><p>They&#8217;re extraordinarily useful for escaping HTML with JavaScript in it where you&#8217;ve already &#8220;run out&#8221; of quoting methods:</p>
<p><code class="sourceCode ruby">link =<span class="ot"> %q[</span><span class="st">&lt;a href=&quot;javascript:method(&#39;call&#39;)&quot;&gt;link&lt;/a&gt;</span><span class="ot">]</span></code></p>
<p>I&#8217;ve also found them to be very useful when working with multi-line SQL statements:</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">execute(<span class="ot">%Q[</span>
<span class="st">  INSERT INTO table_a (column_a)</span>
<span class="st">    SELECT value</span>
<span class="st">      FROM table_b</span>
<span class="st">      WHERE key=&#39;value&#39;</span>
<span class="ot">]</span>)</code></pre></div>
<p>The advantage there is you don&#8217;t need to pay attention to the type of quoting used within your query. It will work with either single, double, or both. They&#8217;re also a lot less fuss than the HEREDOC style method.</p>
<p>Ruby provides other convenience methods like this such as %r which can construct regular expressions. That avoids slash-itis when trying to write one that handles stuff like http:// that would otherwise have to be escaped.</p>
<p>Solutions of Delimiter collision</p>
<ul>
<li>ASCII delimited text</li>
<li>Escape character</li>
<li>Escape sequence</li>
<li>Dual quoting delimiters: &#8216;he says &#8220;good&#8221;&#8217;</li>
<li>Padding quoting delimiters</li>
<li>Configurable alternate quoting delimiters</li>
<li>Content boundary</li>
<li>Whitespace or indentation</li>
</ul>
<p>refs and see also</p>
<ul>
<li><a href="https://stackoverflow.com/questions/10144543/what-is-the-use-case-for-rubys-q-q-quoting-methods">string - What is the use case for Ruby&#8217;s %q / %Q quoting methods? - Stack Overflow</a></li>
<li><a href="https://en.wikipedia.org/wiki/Delimiter#Delimiter_collision">Delimiter - Wikipedia</a></li>
</ul>
</dd>
</dl>
</dd>
</dl></li>
<li><dl>
<dt>here doc <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">document = &lt;&lt;<span class="kw">EOF</span>
<span class="ot">    ...</span>
<span class="ot">    ...</span>
<span class="ot">    ...</span>
<span class="kw">EOF</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>backtick command execution &amp; <code>%x[cmd]</code> <code class="fold">@</code></dt>
<dd><p><code>ls</code>, <code>%x[ls]</code></p>
</dd>
</dl></li>
<li><dl>
<dt>string literal <code class="fold">@</code></dt>
<dd><ul>
<li><code>?\t</code> tab?</li>
<li><code>?\C-x</code> Ctrl-X?</li>
<li><p>float to string: 2.3.to_s&#65292;&#22312; string interp &#30340;&#26102;&#20505;&#19981;&#38656;&#35201;&#26174;&#24335;&#36755;&#20837; to_s</p></li>
<li><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">s = <span class="st">&quot;...&quot;</span>
s[<span class="dv">0</span>], s[-s.length]              <span class="co"># first char</span>
s[s.length<span class="dv">-1</span>], s[-<span class="dv">1</span>]            <span class="co"># last char</span>
s[<span class="dv">0</span>] =<span class="dv"> ?H</span>                       <span class="co"># replace with &#39;H&#39;</span>
s[-<span class="dv">1</span>] = <span class="st">&quot;&quot;</span>                      <span class="co"># delete last char</span>
s[start,len]
s[s.length,<span class="dv">0</span>] = <span class="st">&quot;good&quot;</span>          <span class="co"># append</span>
s[<span class="dv">2</span>..<span class="dv">3</span>]
s[-<span class="dv">3</span>..-<span class="dv">1</span>]
s[<span class="dv">0</span>..<span class="dv">0</span>]                         <span class="co"># first char</span>
s[<span class="dv">0</span>...<span class="dv">0</span>]                        <span class="co"># no char</span>

s = <span class="st">&quot;hello&quot;</span>                     <span class="co"># Start with the word &quot;hello&quot;</span>
<span class="kw">while</span>(s[<span class="st">&quot;l&quot;</span>])                   <span class="co"># While the string contains the substring &quot;l&quot;</span>
    s[<span class="st">&quot;l&quot;</span>] = <span class="st">&quot;L&quot;</span>;               <span class="co"># Replace first occurrence of &quot;l&quot; with &quot;L&quot;</span>
<span class="kw">end</span>                             <span class="co"># Now we have &quot;heLLo&quot;</span>

s[<span class="ot">/[aeiou]/</span>] = <span class="st">&#39;*&#39;</span>              <span class="co"># Replace first vowel with an asterisk</span></code></pre></div>
<p><code>s[start,len=1]</code> &#21644; <code>s[start]</code> &#20960;&#20046;&#19968;&#26679;&#65292;&#38500;&#20102;&#21518;&#32773;&#22312; start = s.length &#26102;&#26159;&#8220;&#8221; &#32780;&#19981;&#26159; nil&#12290;&#36825;&#26679;&#26041;&#20415;&#20102; append&#12290;</p></li>
<li><p>Iterating Strings</p>
<ul>
<li>s.length</li>
<li>s.bytesize</li>
<li><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">text = stream.readline.force_encoding(<span class="st">&quot;utf-8&quot;</span>)
bytes = text.dup.force_encoding(<span class="dv">nil</span>)                <span class="co"># nil encoding means binary</span>

s = <span class="st">&quot;\xa4&quot;</span>.force_encoding(<span class="st">&quot;utf-8&quot;</span>)                  <span class="co"># This is not a valid UTF-8 string</span>
s.valid_encoding?                                   <span class="co"># =&gt; false</span></code></pre></div></li>
</ul></li>
</ul>
</dd>
</dl></li>
</ul>
<h3 id="arrays">Arrays</h3>
<ul>
<li><code>%q</code>, <code>%Q</code> for string literal</li>
<li><code>%w</code>, <code>%W</code> for array literal</li>
<li><dl>
<dt>code examlpes <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">[-<span class="dv">10</span>...<span class="dv">0</span>, <span class="dv">0</span>..<span class="dv">10</span>,] <span class="co"># An array of two ranges; trailing commas are allowed</span>
[[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">5</span>]] <span class="co"># An array of nested arrays</span>

words =<span class="ot"> %w[</span><span class="st">this is a test</span><span class="ot">]</span>      <span class="co"># Same as: [&#39;this&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test&#39;]</span>
open =<span class="ot"> %w| </span>( [ { &lt; |            <span class="co"># Same as: [&#39;(&#39;, &#39;[&#39;, &#39;{&#39;, &#39;&lt;&#39;]</span>
white =<span class="ot"> %W(</span><span class="st">\s \t \r \n</span><span class="ot">)</span>         <span class="co"># Same as: [&quot;\s&quot;, &quot;\t&quot;, &quot;\r&quot;, &quot;\n&quot;]</span>

a[<span class="dv">0</span>], a[-a.length]
a[-<span class="dv">1</span>], a[a.length<span class="dv">-1</span>]

a = (<span class="st">&#39;a&#39;</span>..<span class="st">&#39;e&#39;</span>).to_a
a &lt;&lt; <span class="dv">1</span> &lt;&lt; <span class="dv">2</span>
a &lt;&lt; [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]
a = [<span class="dv">0</span>] * <span class="dv">8</span>

a | b                           <span class="co"># merge, no dup</span>
b | a                           <span class="co"># merge, no dup</span>
a &amp; b                           <span class="co"># union, no dup</span>
b &amp; a                           <span class="co"># union, no dup</span></code></pre></div>
</dd>
</dl></li>
</ul>
<h3 id="hashes">Hashes</h3>
<ul>
<li><dl>
<dt>What is Hash? <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">numbers = <span class="dt">Hash</span>.new
numbers[<span class="st">&quot;one&quot;</span>] = <span class="dv">1</span>
numbers[<span class="st">&quot;two&quot;</span>] = <span class="dv">2</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Hash Literals <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">numbers = { <span class="st">&quot;one&quot;</span> =&gt; <span class="dv">1</span>, <span class="st">&quot;two&quot;</span> =&gt; <span class="dv">2</span>, <span class="st">&quot;three&quot;</span> =&gt; <span class="dv">3</span> }
numbers = { <span class="st">:one</span> =&gt; <span class="dv">1</span>, <span class="st">:two</span> =&gt; <span class="dv">2</span>, <span class="st">:three</span> =&gt; <span class="dv">3</span> }</code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Hash Codes, Equality, and Mutable Keys <code class="fold">@</code></dt>
<dd><p>rehash</p>
</dd>
</dl></li>
</ul>
<h3 id="ranges">Ranges</h3>
<ul>
<li><dl>
<dt>what is range? <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dv">1</span>..<span class="dv">10</span>
<span class="fl">1.0</span>...<span class="fl">10.0</span>

cold_war = <span class="dv">1945</span>..<span class="dv">1989</span>
cold_war.include? birthdate.year
(<span class="dv">1945</span>..<span class="dv">1989</span>).include? birthdate.year

r.each { ... }
r.step(<span class="dv">2</span>) { ... }
r.to_a              <span class="co"># enumerable defines to_a</span>

r.member?           <span class="co"># both continuous membership test</span>
r.include?</code></pre></div>
<p>&#36825;&#37324;&#35201;&#27880;&#24847;&#12290;</p>
<p>Note that ranges with integer endpoints are discrete, but floating-point numbers as endpoints are continuous.</p>
<p>&#22312; case when &#37324;&#38754;&#29992;&#24471;&#25402;&#22810;&#12290;</p>
</dd>
</dl></li>
</ul>
<h3 id="symbols">Symbols</h3>
<ul>
<li><code>%s[&quot;]</code></li>
<li><dl>
<dt>Symbols are often used to refer to method names in reflective code. <code class="fold">@</code></dt>
<dd><p>For example, suppose we want to know if some object has an each method: &#9829;&#65039;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">o.respond_to? <span class="st">:each</span></code></pre></div>
</dd>
</dl></li>
</ul>
<h3 id="true-false-and-nil">True, False, and Nil</h3>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">o == <span class="dv">nil</span>
o.nil?</code></pre></div>
<h3 id="objects">Objects</h3>
<ul>
<li>all are objects</li>
<li>gc</li>
<li>def Class.initialize -&gt; Class.new</li>
<li><code>object_id</code>, <code>__id__</code></li>
<li><dl>
<dt>object class and object type <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># ruby 1.8</span>
o = <span class="st">&quot;str&quot;</span>
o.class                     <span class="co"># String</span>
o.class.class               <span class="co"># Object</span>
o.class.class.class         <span class="co"># nil</span>

<span class="co"># Ruby 1.9 only</span>
<span class="dt">Object</span>.superclass           <span class="co"># BasicObject: Object has a superclass in 1.9</span>
<span class="dt">BasicObject</span>.superclass      <span class="co"># nil: BasicObject has no superclass</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">x.instance_of? <span class="dt">Fixnum</span>       <span class="co"># &#31867;&#22411;</span>
x.is_a? <span class="dt">Fixnum</span>              <span class="co"># maybe &#23376;&#31867;&#25104;&#21592;&#65292;&#21644; kind_of &#19968;&#26679;</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>object equality <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">a.equals?(b)
a.object_id == b.object_id  <span class="co"># Works like a.equal?(b)</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">a.eql?(b)
a.equal?(b)
a == b

<span class="dv">1</span> == <span class="fl">1.0</span>            <span class="co"># true: Fixnum and Float objects can be ==</span>
<span class="dv">1</span>.eql?(<span class="fl">1.0</span>)         <span class="co"># false: but they are never eql!</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>The <code>===</code> operator, case when range&#8230; <code class="fold">@</code></dt>
<dd><p>&#22810;&#29992;&#22312; case &#37324;&#38754;&#21028;&#26029; when &#30340;&#26102;&#20505;&#65292;&#27604;&#22914; (1..10) === 5 &#23601;&#26159; true&#12290;</p>
</dd>
</dl></li>
<li><dl>
<dt>The <code>=~</code> operator <code class="fold">@</code></dt>
<dd><p>regex match</p>
<p>todo: p78</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dv">1</span> &lt;=&gt; <span class="dv">5</span>             <span class="co"># order</span>

nan == nan          <span class="co"># false</span>
nan.equal?(nan)     <span class="co"># true</span></code></pre></div>
</dd>
</dl></li>
<li><dl>
<dt>Object conversion <code class="fold">@</code></dt>
<dd><pre><code>to_s                # string
to_i                # int
to_f                # float
to_a                # array</code></pre>
</dd>
</dl></li>
<li><p>Copying Objects: <code>clone</code>, <code>dup</code></p></li>
<li><dl>
<dt>Marshaling Objects</dt>
<dd><ul>
<li><code>marshal.dump</code></li>
<li><code>marshal.load</code></li>
</ul>
</dd>
</dl></li>
<li><dl>
<dt>Freezing Objects <code class="fold">@</code></dt>
<dd><pre><code>.freeze
.frozen?</code></pre>
</dd>
</dl></li>
<li><dl>
<dt>Taining Objects <code class="fold">@</code></dt>
<dd><p>taint&#65292;&#34987;&#27745;&#26579;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">s = <span class="st">&quot;str&quot;</span>           <span class="co"># not tainted</span>
s.taint             <span class="co"># mark as tainted</span>
s.tainted?          <span class="co"># true</span>
s.upcase.tainted?   <span class="co"># still</span>
s[<span class="dv">0</span>,<span class="dv">2</span>].tainted?     <span class="co"># still</span></code></pre></div>
<p>user input are tainted.</p>
<p><code>$SAFE</code></p>
</dd>
</dl></li>
</ul>
<h2 id="chapter-4-expressions-and-operators">Chapter 4 Expressions and Operators</h2>
<h3 id="literals-and-keyword-literals">Literals and Keyword Literals</h3>
<h3 id="variable-references">Variable References</h3>
<h3 id="constant-references">Constant References</h3>
<h3 id="method-invocations">Method Invocations</h3>
<ul>
<li><dl>
<dt>Method Invocations <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">.
::
<span class="co"># if omitted, the method is invoked on self</span>

puts <span class="st">&quot;hello&quot;</span>                <span class="co"># Kernel.puts</span></code></pre></div>
<p>Assignment to arrays is also done via method invocation. If the object o defines a method named <code>[]=</code> , then the expression <code>o[x]=y</code> becomes <code>o.[]=(x,y)</code>, and the expression <code>o[x,y]=z</code> becomes <code>o.[]=(x,y,z)</code>.</p>
<p>We&#8217;ll see later in this chapter that many of Ruby&#8217;s operators are defined as methods, and expressions like x+y are evaluated as <code>x.+(y)</code>, where the method name is <code>+</code>. The fact that many of Ruby&#8217;s operators are defined as methods means that you can redefine these operators in your own classes.</p>
</dd>
</dl></li>
</ul>
<h3 id="assignments">Assignments</h3>
<ul>
<li><dl>
<dt>Assigning to Variables <code class="fold">@</code></dt>
<dd><div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">class</span> <span class="dt">Ambiguous</span>
    <span class="kw">def</span> x; <span class="dv">1</span>; <span class="kw">end</span>               <span class="co"># A method named &quot;x&quot;. Always returns 1</span>
    <span class="kw">def</span> test
        puts x                  <span class="co"># No variable has been seen; refers to method above: prints 1</span>
        x = <span class="dv">0</span> <span class="kw">if</span> <span class="dv">false</span>          <span class="co"># The line below is never evaluated, because of the &quot;if false&quot; clause. But</span>
                                <span class="co"># the parser sees it and treats x as a variable for the rest of the method.</span>
        puts x
        x = <span class="dv">2</span>
        puts x
    <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<pre><code>o.[]=(x,y),             o[x]   = y
o.[]=(x,y,z),           o[x,y] = z</code></pre>
</dd>
</dl></li>
<li><dl>
<dt>Abbreviated Assignment <code class="fold">@</code></dt>
<dd><pre><code>+, -, *, /
%,
**,
&amp;&amp;, ||, &amp;, |, ^
&lt;&lt;, &gt;&gt;</code></pre>
<p>The <code>||=</code> Idiom</p>
<pre><code>results ||= []
results = results || []</code></pre>
</dd>
</dl></li>
<li><dl>
<dt>Parallel Assignment <code class="fold">@</code></dt>
<dd><ul>
<li>Same number of lvalues and rvalues: <code>x,y,z = 1,2,3</code></li>
<li><p>One lvalue, multiple rvalues:</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">x  = <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>          <span class="co"># x = [1,2,3]</span>
x, = <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>          <span class="co"># x =  1</span></code></pre></div></li>
<li><p>Multiple lvalues, single array rvalue</p>
<pre><code>x,y,z = [1,2,3]     # x,y,z = 1,2,3
x     = [1,2,3]
x,    = [1,2,3]</code></pre></li>
<li><p>Different numbers of lvalues and rvalues</p>
<p>nil</p></li>
<li><p>The splat operator</p>
<p>splat&#65292;&#21457;&#20986;&#28293;&#27900;&#22768;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">x,y,z = <span class="dv">1</span>, *[<span class="dv">2</span>,<span class="dv">3</span>]</code></pre></div>
<p>&#19981;&#33021; double splat&#12290;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">x, *y = <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>           <span class="co"># x=1, y=[2,3]</span>
x, *y = <span class="dv">1</span>,<span class="dv">2</span>             <span class="co"># x=1, y=[2]</span>
x, *y = <span class="dv">1</span>               <span class="co"># x=1, y=[]</span>

<span class="co"># Ruby 1.9 only</span>
*x,y = <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>          <span class="co"># x=[1,2]; y=3</span>
*x,y = <span class="dv">1</span>, <span class="dv">2</span>             <span class="co"># x=[1]; y=2</span>
*x,y = <span class="dv">1</span>                <span class="co"># x=[]; y=1</span>

<span class="co"># &#20004;&#38754;&#21516;&#26102; splat</span>
x, y, *z = <span class="dv">1</span>, *[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>] <span class="co"># x=1; y=2; z=[3,4]</span></code></pre></div></li>
<li><p>Parentheses in parallel assignment &#9829;&#65039; &#25324;&#24359;&#21644;&#26041;&#25324;&#21495;&#19968;&#36215;&#23601;&#33021;&#26641;&#29366;&#36171;&#20540;/&#21021;&#22987;&#21270;</p>
<p>&#8220;unpack&#8221;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">x,y,z = <span class="dv">1</span>,[<span class="dv">2</span>,<span class="dv">3</span>]                 <span class="co"># No parens: x=1;y=[2,3];z=nil</span>
x,(y,z) = <span class="dv">1</span>,[<span class="dv">2</span>,<span class="dv">3</span>]               <span class="co"># Parens: x=1;y=2;z=3</span>
a,b,c,d = [<span class="dv">1</span>,[<span class="dv">2</span>,[<span class="dv">3</span>,<span class="dv">4</span>]]]         <span class="co"># No parens: a=1;b=[2,[3,4]];c=d=nil</span>
a,(b,(c,d)) = [<span class="dv">1</span>,[<span class="dv">2</span>,[<span class="dv">3</span>,<span class="dv">4</span>]]]     <span class="co"># Parens: a=1;b=2;c=3;d=4</span></code></pre></div></li>
<li><p>The value of parallel assignment</p>
<p>The return value of a parallel assignment expression is the array of rvalues (after being augmented by any splat operators).</p>
<p>&#36820;&#22238;&#20540;&#23601;&#26159;&#21491;&#36793;&#30340;&#20540;&#65292;&#34987; splat &#20043;&#21518;&#30340;&#20869;&#23481;&#65288;&#36825;&#26679;&#30340;&#22909;&#22788;&#26159;&#21487;&#20197;&#36830;&#32493;&#36171;&#20540;&#65289;</p></li>
</ul>
</dd>
</dl></li>
</ul>
<h3 id="operators">Operators</h3>
<p>Ruby operators, by precedence (high to low), with arity (N), associativity (A), and definability (M)</p>
<ul>
<li>Unary + and &#8211;</li>
<li>Exponentiation: <code>**</code></li>
<li>Arithmetic: +, &#8211;, *, /, and %</li>
<li>Shift and Append: &lt;&lt; and &gt;&gt;</li>
<li><p>Complement, Union, Intersection: ~, &amp;, |, and ^</p>
<pre><code>(0b1010 &amp; 0b1100).to_s(2)       # =&gt; &quot;1000&quot;</code></pre></li>
<li><p>Comparison: &lt;, &lt;=, &gt;, &gt;=, and &lt;=&gt;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># Declare class A as a subclass of B</span>
<span class="kw">class</span> A &lt; B
<span class="kw">end</span></code></pre></div></li>
<li><p>Equality: ==, !=, =~, !~, and ===</p>
<pre><code>!= inverse of ==
!~ inverse of =~
=== case-equality operator</code></pre></li>
<li><p>Boolean Operators: &amp;&amp;, ||, !, and, or, not</p></li>
<li><p>Ranges and Flip-Flops: .. and &#8230;</p>
<p>Boolean flip-flops</p>
<p><code>..</code> creates an awk-style flip-flop, and <code>...</code> creates a sed-style flip-flop.</p>
<pre><code>(1..10).each {|x| print x if x==3..x==5 }</code></pre>
<p>In the code example, the flip-flop is evaluated repeatedly, for values of x from 1 to 10. It starts off in the false state, and evaluates to false when x is 1 and 2 . When x==3 , the flip-flop flips to true and returns true . It continues to return true when x is 4 and 5 . When x==5 , however, the flip-flop flops back to false , and returns false for the remaining values of x . The result is that this code prints 345.</p>
<pre><code>ARGF.each do |line|
    # For each line of standard in or of named files
    print line if line=~/TODO/..line=~/^$/ # Print lines when flip-flop is true
end</code></pre></li>
<li><p>Conditional: ?:</p>
<pre><code>a ? b : c ? d : e           # This expression...
a ? b : (c ? d : e)         # is evaluated like this..
(a ? b : c) ? d : e         # NOT like this</code></pre>
<p>&#26368;&#21518;&#19968;&#31181;&#22909;&#25630;&#24618;&#8230;&#8230;</p></li>
<li><p>Assignment Operators</p>
<p>right-associative</p></li>
<li><p>The defined? Operator</p>
<pre><code># Compute f(x), but only if f and x are both defined
y = f(x) if defined? f(x)</code></pre>
<p>Return values of the defined? operator</p>
<pre><code>defined? a and defined? b               # This works
defined? a &amp;&amp; defined? b                # Evaluated as: defined?((a &amp;&amp; defined? b))</code></pre></li>
<li><p>Statement Modifiers</p>
<pre><code>print x if x</code></pre></li>
<li><p>Nonoperators:</p>
<pre><code>()                  # method definition &amp; invocation
[]
{}                  # alternative to do/end, also used in hash literals
.   ::              # qualified names
;   ,   =&gt;          # sep
:                   # symbol prefix
*   &amp;   &lt;           # *:unpack, &amp;, &lt;: subclass</code></pre></li>
</ul>
<h2 id="chapter-5-statements-and-control-structures">Chapter 5 Statements and Control Structures</h2>
<ul>
<li>Conditionals</li>
<li>Loops</li>
<li>Iterators and blocks</li>
<li>Flow-altering statements like return and break</li>
<li>Exceptions</li>
<li>The special-case BEGIN and END statements</li>
<li>The esoteric control structures known as fibers and continuations</li>
</ul>
<pre><code>esoteric

    &#33521; [,es&#601;&#39;ter&#618;k; ,i&#720;s&#601;-] &#32654; [,&#603;s&#601;&#39;t&#603;r&#618;k]

    adj. &#31192;&#20256;&#30340;&#65307;&#38480;&#20110;&#22280;&#20869;&#20154;&#30340;&#65307;&#38590;&#25026;&#30340;</code></pre>
<h3 id="conditionals">Conditionals</h3>
<ul>
<li><p>if</p>
<ul>
<li>if cond &#8230; end,</li>
<li>if cond &#8230; else &#8230; end</li>
<li>if conf &#8230; elsif conf &#8230; end</li>
</ul>
<p>In most languages, the if conditional is a statement. In Ruby, however, <strong>everything is an expression</strong>, even the control structures that are commonly called statements. The return value of an if &#8220;statement&#8221; (i.e., the value that results from evaluating an if expression) is the value of the last expression in the code that was executed, or nil if no block of code was executed.</p>
<p>&#20063;&#23601;&#26159;&#35828; if else &#20063;&#26159;&#26377;&#36820;&#22238;&#20540;&#30340;&#12290;</p></li>
<li><p>if As a <strong>Modifier</strong></p>
<p><code class="sourceCode ruby">... <span class="kw">if</span> cond</code> &#65288;&#19981;&#33021;&#25442;&#34892;&#65289;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">y = x.invert <span class="kw">if</span> x.respond_to? <span class="st">:invert</span>           <span class="co"># &#21487;&#33021;&#19981; evaluate</span>
y = (x.invert <span class="kw">if</span> x.respond_to? <span class="st">:invert</span>)         <span class="co"># &#24635;&#26159; evaluate&#65292;&#21487;&#33021; nil</span></code></pre></div>
<p>&#27880;&#24847;&#19979;&#38754; if&#65292;unless &#21508;&#31181;&#37117;&#26377; conditionals &#21644; modifiers &#20960;&#31181;&#21487;&#20197;&#20889;&#65292;&#20294;&#26159;&#26377;&#20123;&#26159;&#19981;&#22909;&#30340;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">if</span> cond             <span class="kw">begin</span>               (
    ...                 ...                 ...
    ...                 ...                 ...
<span class="kw">end</span>                 <span class="kw">end</span> <span class="kw">if</span> cond         ) <span class="kw">end</span> <span class="kw">if</span> cond</code></pre></div></li>
<li><p>unless</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">unless</span> cond
    ...
<span class="kw">end</span>

<span class="kw">unless</span> cond
    ...
<span class="kw">else</span>
    ...
<span class="kw">end</span>

... <span class="kw">unless</span> cond</code></pre></div></li>
<li><p>case</p>
<pre><code>case var
when cond then ...
when cond then ...
else
    ...
end</code></pre></li>
<li><p>The <code>?:</code> Operator&#65292;Ternary &#25805;&#20316;&#31526;&#12290;&#27809;&#25340;&#38169;&#30340;&#35805;&#12290;<code>['t&#605;n&#601;ri]</code></p></li>
</ul>
<h3 id="loops">Loops</h3>
<ul>
<li><p>while and until</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">while cond <span class="kw">do</span>
    ...
<span class="kw">end</span>

<span class="kw">until</span> cond <span class="kw">do</span>
    ...
<span class="kw">end</span>

<span class="kw">begin</span>
    ...
<span class="kw">end</span> <span class="kw">until</span> cond

(
    ...
) <span class="kw">until</span> cond</code></pre></div></li>
<li><p>while and until As Modifiers</p></li>
<li><p>the for/in Loop</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">for</span> var <span class="kw">in</span> collection [<span class="kw">do</span>]
    ...
<span class="kw">end</span>

<span class="kw">for</span> key,value <span class="kw">in</span> hash
    ...
<span class="kw">end</span></code></pre></div></li>
</ul>
<h3 id="iterators-and-enumerable-objects">Iterators and Enumerable Objects</h3>
<ul>
<li><p>tap</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">chars = <span class="st">&quot;hello world&quot;</span>   .tap    { |x| puts <span class="st">&quot;original object: </span><span class="ot">#{</span>x.inspect<span class="ot">}</span><span class="st">&quot;</span> }
    .each_char          .tap    { |x| puts <span class="st">&quot;each_char returns: </span><span class="ot">#{</span>x.inspect<span class="ot">}</span><span class="st">&quot;</span> }
    .to_a               .tap    { |x| puts <span class="st">&quot;to_a returns: </span><span class="ot">#{</span>x.inspect<span class="ot">}</span><span class="st">&quot;</span> }
    .map {|c| c.succ }  .tap    { |x| puts <span class="st">&quot;map returns: </span><span class="ot">#{</span>x.inspect<span class="ot">}</span><span class="st">&quot;</span>  }
    .sort               .tap    { |x| puts <span class="st">&quot;sort returns: </span><span class="ot">#{</span>x.inspect<span class="ot">}</span><span class="st">&quot;</span> }</code></pre></div>
<p>tap &#26377;&#28857;&#20687; shell &#37324;&#38754;&#30340; tee&#12290;&#36825;&#37324; tap &#30340;&#24847;&#24605;&#21644; tap a phone &#19968;&#26679;&#65292;&#23601;&#26159;&#20599;&#21548;&#65292;&#19981;&#24178;&#25200;&#22320;&#20599;&#21548;&#12290;</p></li>
<li><p>Enumerable Objects</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">File</span>.open(filename) <span class="kw">do</span> |f|
    f.each_with_index <span class="kw">do</span> |line,number|
        print <span class="st">&quot;</span><span class="ot">#{</span>number<span class="ot">}</span><span class="st">: </span><span class="ot">#{</span>line<span class="ot">}</span><span class="st">&quot;</span>
    <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<p>&#23601;&#26159;&#21487;&#20197;&#29992; each &#30340;&#65311;</p>
<ul>
<li>collect (map)</li>
<li>select (&#31867;&#20284;&#8220;filter&#8221;&#30340;&#27010;&#24565;)</li>
<li>reject (&#21644; select &#30456;&#21453;)</li>
<li><p>inject (&#26377;&#28857;&#20687; c++ &#30340; partial_sum)</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">data = [<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">4</span>]
sum = data.inject {|sum, x| sum + x }               <span class="co"># =&gt; 14 (2+5+3+4)</span>
floatprod = data.inject(<span class="fl">1.0</span>) {|p,x| p*x }           <span class="co"># =&gt; 120.0 (1.0*2*5*3*4)</span>
max = data.inject {|m,x| m&gt;x ? m : x }              <span class="co"># =&gt; 5 (largest element)</span></code></pre></div></li>
</ul></li>
<li><p>Writing Custom Iterators</p>
<p>iterators &#37324;&#38754;&#30340;&#19996;&#35199;&#26159; yield &#20986;&#26469;&#30340;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> sequence(n, m, c)
    i = <span class="dv">0</span>
    <span class="kw">while</span>(i &lt; n)
        <span class="kw">yield</span> m*i + c
        i += <span class="dv">1</span>
    <span class="kw">end</span>
<span class="kw">end</span>

sequence(<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">1</span>) {|y| puts y }</code></pre></div>
<dl>
<dt>Nomenclature: yield and Iterators <code class="fold">@</code></dt>
<dd><pre><code>nomenclature

    &#33521; [n&#601;(&#650;)&#39;me&#331;kl&#601;t&#643;&#601;; &#39;n&#601;&#650;m&#601;n,kle&#618;t&#643;&#601;] &#32654; [&#712;nom&#601;n&#716;klet&#643;&#602;]

    n. &#21629;&#21517;&#27861;&#65307;&#26415;&#35821;</code></pre>
<p>A method such as sequence that expects a block and invokes it multiple times is called an iterator because it looks and behaves like a loop. This may be confusing if you are used to languages like Java in which iterators are objects. In Java, the client code that uses the iterator is in control and &#8220;pulls&#8221; values from the iterator when it needs them. In Ruby, the iterator method is in control and &#8220;pushes&#8221; values to the block that wants them.</p>
<p>This nomenclature issue is related to the distinction between &#8220;internal iterators&#8221; and &#8220;external iterators,&#8221; which is discussed later in this section.</p>
</dd>
</dl>
<p>If a method is invoked without a block, it is an error for that method to yield, because there is nothing to yield to. yield &#30340;&#19996;&#35199;&#26159;&#34987; push &#21040;&#21518;&#38754;&#30340; block &#37324;&#38754;&#30340;&#12290;</p>
<p>Sometimes you want to write a method that yields to a block if one is provided but takes some default action (other than raising an error) if invoked with no block. To do this, use <code>block_given?</code> to determine whether there is a block associated with the invocation. <code>block_given?</code>, and its synonym <code>iterator?</code>, are Kernel methods, so they act like global functions. Here is an example:</p>
<p>&#19979;&#38754;&#36825;&#26679;&#30340;&#35805;&#65292;&#23601;&#26159;&#26377; block &#30340;&#26102;&#20505;&#65292;&#25165; yield&#12290;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> sequence(n, m, c)
    i, s = <span class="dv">0</span>, []
    <span class="kw">while</span>(i &lt; n)
        y = m*i + c
        <span class="kw">yield</span> y <span class="kw">if</span> block_given?
        s &lt;&lt; y
        i += <span class="dv">1</span>
    <span class="kw">end</span>
    s
<span class="kw">end</span></code></pre></div></li>
<li><p>Enumerators</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">to_enum
enum_for

<span class="co"># Call this method with an Enumerator instead of a mutable array.</span>
<span class="co"># This is a useful defensive strategy to avoid bugs.</span>
process(data.to_enum) <span class="co"># Instead of just process(data)</span>

<span class="co"># iterator methods: :each_char, :each_byte, :each_line</span>
s = <span class="st">&quot;hello&quot;</span>
s.enum_for(<span class="st">:each_char</span>).map {|c| c.succ }    <span class="co"># =&gt; [&quot;i&quot;, &quot;f&quot;, &quot;m&quot;, &quot;m&quot;, &quot;p&quot;]</span>
s.chars.map { ... }

<span class="kw">for</span> line, number <span class="kw">in</span> text.each_line.with_index
    print <span class="st">&quot;</span><span class="ot">#{</span>number<span class="dv">+1</span><span class="ot">}</span><span class="st">: </span><span class="ot">#{</span>line<span class="ot">}</span><span class="st">&quot;</span>
<span class="kw">end</span></code></pre></div></li>
<li><p>External Iterators</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">iterator = <span class="dv">9</span>.downto(<span class="dv">1</span>)                      <span class="co"># An enumerator as external iterator</span>
<span class="kw">begin</span>                                       <span class="co"># So we can use rescue below</span>
    print iterator.next <span class="kw">while</span> <span class="dv">true</span>          <span class="co"># Call the next method repeatedly</span>
<span class="kw">rescue</span> <span class="dt">StopIteration</span>                        <span class="co"># When there are no more values</span>
    puts <span class="st">&quot;...blastoff!&quot;</span>                     <span class="co"># An expected, nonexceptional condition</span>
<span class="kw">end</span></code></pre></div></li>
<li><p>Internal versus External Iterators</p>
<p>The &#8220;gang of four&#8221; define and contrast <strong>internal and external iterators</strong> quite clearly in their design patterns book:</p>
<blockquote>
<p>A fundamental issue is deciding <strong>which party controls the iteration</strong>, the iterator or the client that uses the iterator. When the client controls the iteration, the iterator is called an external iterator, and when the iterator controls it, the iterator is an internal iterator. Clients that use an external iterator must advance the traversal and request the next element explicitly from the iterator. In contrast, the client hands an internal iterator an operation to perform, and the iterator applies that operation to every element&#8230;.</p>
<p>&#31616;&#35328;&#20043;&#65292;external &#36824;&#26159; internal &#21462;&#20915;&#20110;&#35841;&#22312;&#25511;&#21046; iteration&#65292;&#22914;&#26524;&#33258;&#24049;&#22312;&#25511;&#21046;&#65292;&#37027;&#23601;&#26159; internal&#65292;&#22914;&#26524;&#29992;&#25143;&#65288;client&#65289;&#22312;&#25511;&#21046;&#65292;&#23601;&#26159; external&#12290;</p>
<p>External iterators are more flexible than internal iterators. It&#8217;s easy to compare two collections for equality with an external iterator, for example, but it&#8217;s practically impossible with internal iterators&#8230;. But on the other hand, internal iterators are easier to use, because they define the iteration logic for you.</p>
<p>internal &#22909;&#29992;&#65292;&#22240;&#20026;&#24490;&#29615;&#30340;&#36923;&#36753;&#24050;&#32463;&#26377;&#20102;&#65292;external &#21487;&#20197;&#26356;&#28789;&#27963;&#65292;&#27604;&#22914;&#19968;&#27425; iterate &#20004;&#20010; collection&#65292;&#24182;&#20570;&#27604;&#36739;&#21861;&#30340;&#12290;</p>
</blockquote>
<p>In Ruby, iterator methods like each are internal iterators; they control the iteration and &#8220;push&#8221; values to the block of code associated with the method invocation. Enumerators have an each method for internal iteration, but in Ruby 1.9 and later, they also work as external iterators&#8212;client code can sequentially &#8220;pull&#8221; values from an enumerator with next.</p></li>
</ul>
<h3 id="blocks">Blocks</h3>
<ul>
<li><code>{}</code>, <code>begin ... end</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># The block takes two words and &quot;returns&quot; their relative order</span>
words.sort! {|x,y| y &lt;=&gt; x }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">array.collect <span class="kw">do</span> |x|
    <span class="kw">next</span> <span class="dv">0</span> <span class="kw">if</span> x == <span class="dv">nil</span>          <span class="co"># return x</span>
    <span class="kw">next</span> x, x*x                 <span class="co"># return two values&#65292;&#20294;&#36825;&#20004;&#20010; value &#20854;&#23454;&#26159;&#19968;&#20010; []&#65292;&#26159;&#19968;&#20010;&#20803;&#32032;</span>
<span class="kw">end</span>

<span class="co"># &#25152;&#20197;&#19978;&#38754;&#30340;&#25805;&#20316;&#36807;&#21518;&#65292;list &#30340;&#20803;&#32032;&#20010;&#25968;&#19981;&#21464;&#12290;</span>

<span class="co"># or without next</span>
array.collect <span class="kw">do</span> |x|
    <span class="kw">if</span> x == <span class="dv">nil</span>
        <span class="dv">0</span>
    <span class="kw">else</span>
        [x, x*x]
    <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<ul>
<li><p>Blocks and Variable Scope: <code>hash.each {|key,value; i,j,k| ... }</code></p></li>
<li><p>Passing Arguments to a Block:</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">hash.each_pair {|k,v| ... }         <span class="co"># k,v = key, value</span>
hash.each {|k,v| ... }              <span class="co"># k,v = [key, value]</span>

<span class="kw">def</span> two; <span class="kw">yield</span> <span class="dv">1</span>,<span class="dv">2</span>; <span class="kw">end</span> <span class="co"># An iterator that yields two values</span>
two {|x| p x }          <span class="co"># Ruby 1.8: warns and prints [1,2],</span>
two {|x| p x }          <span class="co"># Ruby 1.9: prints 1, no warning</span>
two {|*x| p x }         <span class="co"># Either version: prints [1,2]; no warning</span>
two {|x,| p x }         <span class="co"># Either version: prints 1; no warning</span>

[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>].each {|x,y=<span class="dv">10</span>| print x*y }
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>].each &amp;-&gt;(x,y=<span class="dv">10</span>) { print x*y }      <span class="co"># Prints &quot;102030&quot;</span></code></pre></div></li>
</ul>
<h3 id="altering-control-flow">Altering Control Flow</h3>
<ul>
<li><p>return,</p>
<p>&#20027;&#35201;&#29992;&#20110; return permaturely&#65288;&#25552;&#21069; return&#65289;</p></li>
<li><p>break, <code class="sourceCode ruby"><span class="kw">break</span> <span class="kw">if</span> cond</code></p>
<p>&#20063;&#21487;&#20197; break with a value</p>
<p>Recall that <strong>all syntactic constructs in Ruby are expressions</strong>, and all can have a value. The break statement can specify a value for the loop or iterator it is breaking out of. The break keyword may be followed by an expression or a comma-separated list of expressions. If break is used with no expression, then the value of the loop expression, or the return value of the iterator method, is nil. If break is used with a single expression, then the value of that expression becomes the value of the loop expression or the return value of the iterator. And if break is used with multiple expressions, then the values of those expressions are placed into an array, and that array becomes the value of the loop expression or the return value of the iterator.</p>
<p>By contrast, a while loop that terminates normally with no break always has a value of nil. &#21861;&#37117;&#26377;&#36820;&#22238;&#20540;&#30340;&#65292;&#21253;&#25324;&#27969;&#31243;&#25511;&#21046;&#35821;&#21477;&#65292;&#22914;&#26524;&#20320;&#19981;&#36820;&#22238;&#65292;&#23601;&#36820;&#22238; nil&#12290;&#65288;&#20854;&#23454;&#36825;&#20010;&#22312; while &#37324;&#38754;&#26159;&#19981;&#21512;&#24120;&#35268;&#30340;&#65292;&#22240;&#20026;&#19981;&#26159;&#36820;&#22238;&#30340;&#26368;&#21518;&#19968;&#20010;&#35821;&#21477;&#12290;&#65289; The return value of an iterator that terminates normally is defined by the iterator method. Many iterators, such as times and each , simply return the object on which they were invoked.</p></li>
<li><p>next</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">while</span>(line = gets.chop)
    <span class="kw">next</span> <span class="kw">if</span> line[<span class="dv">0</span>,<span class="dv">1</span>] == <span class="st">&quot;#&quot;</span>
    puts eval(line)
    <span class="co"># Control goes here when the next statement is executed</span>
<span class="kw">end</span></code></pre></div></li>
<li><p>redo,</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">while</span>(i &lt; <span class="dv">3</span>)
    <span class="co"># Control returns here when redo is executed</span>
    print i
    i += <span class="dv">1</span>
    <span class="kw">redo</span> <span class="kw">if</span> i == <span class="dv">3</span>
<span class="kw">end</span></code></pre></div></li>
<li><p>retry,</p>
<p>retry &#20250;&#37325;&#21551;&#25972;&#20010; iteration</p></li>
<li><p>throw/catch,</p></li>
</ul>
<h3 id="exceptions-and-exception-handling">Exceptions and Exception Handling</h3>
<p>The Ruby Exception Class Hierarchy</p>
<p>define new exception classes</p>
<p>class MyError &lt; StandardError; end</p>
<pre><code>raise &quot;msg&quot;
raise RuntimeError, &quot;msg&quot;
raise RuntimeError.new(&quot;msg&quot;)
raise RuntimeError.exception(&quot;msg&quot;)
raise RuntimeError</code></pre>
<p>Handling Exceptions with rescue</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">begin</span>
    ...
<span class="kw">rescue</span>
    ...
<span class="kw">end</span>

<span class="kw">begin</span>                                       <span class="co"># Handle exceptions in this block</span>
    x = factorial(-<span class="dv">1</span>)                       <span class="co"># Note illegal argument</span>
<span class="kw">rescue</span> =&gt; ex                                <span class="co"># Store exception in variable ex</span>
    puts <span class="st">&quot;</span><span class="ot">#{</span>ex.class<span class="ot">}</span><span class="st">: </span><span class="ot">#{</span>ex.message<span class="ot">}</span><span class="st">&quot;</span>       <span class="co"># Handle exception by printing message</span>
<span class="kw">end</span>                                         <span class="co"># End the begin/rescue block</span></code></pre></div>
<p>Handling exceptions by type</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">rescue</span> <span class="dt">Exception</span>
<span class="kw">rescue</span> <span class="dt">ArgumentError</span> =&gt; e
<span class="co"># &#21487;&#20197; rescue &#20960;&#36941;</span></code></pre></div>
<ul>
<li>Propagation of exceptions &#21644; event &#19968;&#26679;&#65292;&#36825;&#26159;&#20998;&#23618;&#32423;&#30340;&#65292;&#24403;&#28982;&#35201; propagate&#12290;</li>
<li>The else Clause</li>
<li>The ensure Clause (&#31867;&#20284;&#20110; Java &#30340; finally&#65289;</li>
</ul>
<h3 id="begin-and-end">BEGIN and END</h3>
<p>&#21644; awk &#19968;&#26679;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">BEGIN</span> {
    ...
}

<span class="kw">END</span> {
    ...
}

<span class="dv">10</span>.times {<span class="kw">BEGIN</span> { puts <span class="st">&quot;loop&quot;</span> }}    <span class="co"># Only printed once</span>

<span class="kw">if</span> (<span class="dv">true</span>)
    ...<span class="kw">begin</span>...                     <span class="co"># &#25191;&#34892; (&#19968;&#27425;)</span>
    ...<span class="kw">end</span>...                       <span class="co"># &#25191;&#34892;</span>
<span class="kw">else</span>
    ...<span class="kw">begin</span>...                     <span class="co"># &#25191;&#34892;</span>
    ...<span class="kw">end</span>...                       <span class="co"># &#19981;&#25191;&#34892;</span>
<span class="kw">end</span></code></pre></div>
<p>The Kernel method <code>at_exit</code> provides an alternative to the END statement; it registers a block of code to be executed just before the interpreter exits.</p>
<h3 id="threads-fibers-and-continuations">Threads, Fibers, and Continuations</h3>
<ul>
<li><p>Threads for Concurrency</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">threads = filenames.map <span class="kw">do</span> |f|
    <span class="dt">Thread</span>.new { <span class="dt">File</span>.read(f) }
<span class="kw">end</span>

threads.map { |t| t.value }</code></pre></div></li>
<li><p>Fibers for Coroutines</p>
<p><strong>fiber &#23601;&#26159; lightweight thread&#65292;&#25110;&#32773;&#21483; coroutines &#65288;more accurately&#65292;semi-coroutines&#65289;</strong></p>
<p>The most common use for coroutines is to <strong>implement generators</strong>: objects that can compute a partial result, yield the result back to the caller, and save the state of the computation so that the caller can resume that computation to obtain the next result. In Ruby, the Fiber class is used to enable the automatic conversion of internal iterators, such as the each method, into enumerators or external iterators.</p>
<p>Note that fibers are an advanced and relatively obscure control structure; the majority of Ruby programmers will never need to use the Fiber class directly. If you have never programed with coroutines or generators before, you may find them difficult to understand at first. If so, study the examples carefully and try out some examples of your own.</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">f = <span class="dt">Fiber</span>.new {                     <span class="co"># Line 1:     Create a new fiber</span>
    puts <span class="st">&quot;Fiber says Hello&quot;</span>         <span class="co"># Line 2:</span>
    <span class="dt">Fiber</span>.yield                     <span class="co"># Line 3:     goto line 9</span>
    puts <span class="st">&quot;Fiber says Goodbye&quot;</span>       <span class="co"># Line 4:</span>
}                                   <span class="co"># Line 5:     goto line 11</span>
                                    <span class="co"># Line 6:</span>
puts <span class="st">&quot;Caller says Hello&quot;</span>            <span class="co"># Line 7:</span>
f.resume                            <span class="co"># Line 8:     goto line 2</span>
puts <span class="st">&quot;Caller says Goodbye&quot;</span>          <span class="co"># Line 9:</span>
f.resume                            <span class="co"># Line 10:    goto line 4</span>
                                    <span class="co"># Line 11:</span></code></pre></div>
<p>It is worth noting here that the &#8220;yielding&#8221; performed by Fiber.yield is completely different than the yielding performed by the yield statement. Fiber.yield yields control from the current fiber back to the caller that invoked it. The yield statement, on the other hand, yields control from an iterator method to the block associated with the method.</p>
<p>todo, p168</p>
<ul>
<li>Fiber arguments and return values</li>
<li>Implementing generators with fibers</li>
<li><p>Advanced fiber features</p>
<pre><code>require &#39;fiber&#39;</code></pre></li>
</ul></li>
<li><p>Continuations</p></li>
</ul>
<h2 id="chapter-6-methods-procs-lambdas-and-closures">Chapter 6 Methods, Procs, Lambdas, and Closures</h2>
<ul>
<li>method</li>
<li>invocation</li>
</ul>
<h3 id="defining-simple-methods">Defining Simple Methods</h3>
<ul>
<li><p>singleton</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">o = <span class="st">&quot;message&quot;</span>
<span class="kw">def</span> o.printme           <span class="co"># Define a singleton method for this object</span>
    puts <span class="dv">self</span>
<span class="kw">end</span>
o.printme               <span class="co"># Invoke the singleton</span></code></pre></div></li>
<li><p><code>undef</code></p></li>
</ul>
<h3 id="method-names">Method Names</h3>
<ul>
<li><p>Method Name Resolution</p></li>
<li><p>Method Aliases</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">alias</span> aka also_known_as</code></pre></div>
<p>&#20854;&#23454;&#20687;&#26159;&#19968;&#20010; variable &#25351;&#21521;&#19968;&#20010; reference</p></li>
</ul>
<h3 id="methods-and-parentheses">Methods and Parentheses</h3>
<p>Optional parentheses</p>
<p>Define method &#30340;&#26102;&#20505;&#65292;&#21487;&#20197; omit paren &#65288;&#36890;&#24120;&#22823;&#23478;&#37117;&#36825;&#26679;&#12290;&#65289;</p>
<p>Required Parentheses</p>
<h3 id="method-arguments">Method Arguments</h3>
<ul>
<li><p>Parameter Defaults</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> prefix(s, len=<span class="dv">1</span>)
    s[<span class="dv">0</span>,len]
<span class="kw">end</span>

<span class="kw">def</span> suffix(s, index=s.size<span class="dv">-1</span>)
    s[index, s.size-index]
<span class="kw">end</span>

<span class="kw">def</span> append(x,a=[])
    a &lt;&lt; x
<span class="kw">end</span></code></pre></div></li>
<li><p>Variable-Length Argument Lists and Arrays</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> max(first, *rest)
    rest.each { ... }
<span class="kw">end</span></code></pre></div>
<p>&#36825;&#20010;&#22909;&#26377; lisp &#39118;&#26684;&#21834;&#8230;&#8230;car&#65292;lst &#21861;&#30340;&#8230;&#8230;</p></li>
<li>Mapping Arguments to Parameters</li>
<li>Hashes for Named Arguments</li>
<li><p>Block Arguments: <code>{ |x| ... }</code></p>
<ul>
<li>One of the features of blocks is their anonymity <code>&#230;n&#601;'n&#618;m&#618;t&#618;</code> &#21311;&#21517;&#24615;</li>
<li><p>add a final argument to your method, and prefix the argument name with an ampersand (<code>&amp;</code>)</p>
<p>&#32473; block &#21069;&#38754;&#21152;&#19978;&#19968;&#20010; <code>&amp;</code> &#23601;&#26159;&#19968;&#20010; proc&#65288;am<strong>P</strong>ersand&#65289;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> sequence3(n, m, c, &amp;b)  <span class="co"># Explicit argument to get block as a Proc</span>
    i = <span class="dv">0</span>
    <span class="kw">while</span>(i &lt; n)
        b.call(i*m + c)     <span class="co"># Invoke the Proc with its call method</span>
        i += <span class="dv">1</span>
    <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<p>&#19968;&#20010; proc &#23601;&#21487;&#20197;&#36890;&#36807;&#8220;.call&#8221;&#26469; invoke&#12290;</p></li>
</ul></li>
<li><p>Procs and Lambdas</p></li>
</ul>
<p>todo, p189</p>
<h3 id="procs-and-lambdas">Procs and Lambdas</h3>
<p>block &#19981;&#26159; obj&#65292;&#25152;&#20197;&#19981;&#33021;&#20462;&#25913;&#12290;&#19968;&#20010; object&#65292;&#20687;&#19968;&#20010; block&#65292;&#31216;&#20043;&#20026; proc &#25110;&#32773; lambda&#12290;</p>
<ul>
<li>proc: block-like behavior</li>
<li>lambda: method-like behavior</li>
<li>proc &#21644; lambda &#37117;&#26159; Proc &#31867;&#30340; instance</li>
</ul>
<dl>
<dt>The subsections that follow explain <code class="fold">@</code></dt>
<dd><ul>
<li>How to create Proc objects in both proc and lambda forms</li>
<li>How to invoke Proc objects</li>
<li>How to determine how many arguments a Proc expects</li>
<li>How to determine if two Proc objects are the same</li>
<li>How procs and lambdas differ from each other</li>
</ul>
</dd>
</dl>
<ul>
<li><p>Creating Procs</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> makeproc(&amp;p)    <span class="co"># conv block to proc</span>
    p
<span class="kw">end</span>

adder = makeproc {|x,y| x+y }

sum = adder.call(<span class="dv">2</span>,<span class="dv">2</span>)</code></pre></div>
<p>&#36825;&#37324;&#20256;&#20837;&#30340;&#8220;&amp;p&#8221;&#26159; block&#65292;&#8220;p&#8221;&#26159; proc&#65292;&#20063;&#23601;&#26159; <code>{}</code> &#26159; block&#65292;&#20256;&#20837;&#20043;&#21518;&#65292;&#23601;&#21464;&#25104;&#20102; proc&#12290;&#20256;&#22238;&#12290;</p>
<ul>
<li><p>Proc.new&#65292;&#36825;&#20010;&#23454;&#29616;&#20272;&#35745;&#20063;&#24046;&#19981;&#22810;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">p = <span class="dt">Proc</span>.new {|x,y| x+y }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> invoke(&amp;b)                  <span class="kw">def</span> invoke
    b.call                          <span class="dt">Proc</span>.new.call
<span class="kw">end</span>                             <span class="kw">end</span></code></pre></div></li>
<li><p>Kernel.lambda</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">is_positive = lambda {|x| x&gt;<span class="dv">0</span> }</code></pre></div>
<p>block &#21069;&#38754;&#21152;&#19978; lambda&#65292;&#23601;&#26159; lambda &#20102;&#12290;</p></li>
<li><p>Lambda Literals</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">succ = lambda {|x| x<span class="dv">+1</span> }
<span class="co"># &gt;= ruby 1.9</span>
succ = -&gt;(x){ x<span class="dv">+1</span> }

succ.call(<span class="dv">2</span>)

<span class="co"># This lambda takes 2 args and declares 3 local vars</span>
f = -&gt;(x,y; i,j,k) { ... }

<span class="co"># with defaults</span>
zoom = -&gt;(x,y,factor=<span class="dv">2</span>){ [x*factor, y*factor] }

<span class="co"># omit paren</span>
succ = -&gt;x { x<span class="dv">+1</span> }
f = -&gt; x,y; i,j,k { ... }
zoom = -&gt;x,y,factor=<span class="dv">2</span> { [...] }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> compose(f,g)
    -&gt;(x) { f.call(g.call(x)) }
<span class="kw">end</span>

succOfSquare = compose(-&gt;x{x<span class="dv">+1</span>}, -&gt;x{x*x})
succOfSquare.call(<span class="dv">4</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">data.sort {|a,b| b-a }              <span class="co"># the block version</span>
data.sort &amp;-&gt;(a,b){ b-a }           <span class="co"># the lambda version</span></code></pre></div></li>
</ul></li>
<li><p>Invoking Procs and Lambdas</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># f = Proc.new {|x,y| 1.0/(1.0/x+1.0/y) }</span>
z = f.call(x,y)
z = f[x,y]
z = f.(x,y)             <span class="co"># ruby &gt;= 1.9</span></code></pre></div></li>
<li><p>The Arity of a Proc</p>
<p>Arity: n. &#21442;&#25968;&#25968;&#37327;</p>
<p>The arity of a proc or lambda is the number of arguments it expects. (The word is derived from the &#8220;ary&#8221; suffix of unary, binary, ternary, etc.)</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">lambda{||}.arity                <span class="co"># 0</span>
lambda{|x| x}.arity             <span class="co"># 1</span>
lambda{|x,y| x+y}.arity         <span class="co"># 2</span>

lambda {|*args|}.arity          <span class="co"># -1</span>
lambda {|first, *rest|}.arity   <span class="co"># -2</span></code></pre></div></li>
<li><p>Proc Equality</p>
<p>always false unless <code>q = p.dup</code> (p == q: true, but <code>p.__id__ == q.__id__</code>: false)</p></li>
<li><p>How Lambdas Differ from Procs</p>
<p><code>.lambda?</code></p>
<ul>
<li><p>return</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> test
    puts <span class="st">&quot;entering method&quot;</span>
    <span class="dv">1</span>.times { puts <span class="st">&quot;entering block&quot;</span>; <span class="kw">return</span> }   <span class="co"># Makes test method return</span>
    puts <span class="st">&quot;exiting method&quot;</span>                       <span class="co"># This line is never executed</span>
<span class="kw">end</span>
test</code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> test
    puts <span class="st">&quot;entering method&quot;</span>
    p = <span class="dt">Proc</span>.new { puts <span class="st">&quot;entering proc&quot;</span>; <span class="kw">return</span> }
    p.call                  <span class="co"># Invoking the proc makes method return</span>
    puts <span class="st">&quot;exiting method&quot;</span>   <span class="co"># This line is never executed</span>
<span class="kw">end</span>
test</code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> procBuilder(message)                <span class="co"># Create and return a proc</span>
    <span class="dt">Proc</span>.new { puts message; <span class="kw">return</span> }   <span class="co"># return returns from procBuilder</span>
    <span class="co"># but procBuilder has already returned here!</span>
    <span class="kw">end</span>
<span class="kw">def</span> test
    puts <span class="st">&quot;entering method&quot;</span>
    p = procBuilder(<span class="st">&quot;entering proc&quot;</span>)
    p.call                  <span class="co"># Prints &quot;entering proc&quot; and raises LocalJumpError!</span>
    puts <span class="st">&quot;exiting method&quot;</span>   <span class="co"># This line is never executed</span>
<span class="kw">end</span>
test</code></pre></div>
<p>lambda &#19981;&#22826;&#19968;&#26679;&#65306;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> test
    puts <span class="st">&quot;entering method&quot;</span>
    p = lambda { puts <span class="st">&quot;entering lambda&quot;</span>; <span class="kw">return</span> }
    p.call                  <span class="co"># Invoking the lambda does not make the method return</span>
    puts <span class="st">&quot;exiting method&quot;</span>   <span class="co"># This line *is* executed now</span>
<span class="kw">end</span>
test</code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> lambdaBuilder(message)          <span class="co"># Create and return a lambda</span>
    lambda { puts message; <span class="kw">return</span> } <span class="co"># return returns from the lambda</span>
<span class="kw">end</span>
<span class="kw">def</span> test
    puts <span class="st">&quot;entering method&quot;</span>
    l = lambdaBuilder(<span class="st">&quot;entering lambda&quot;</span>)
    l.call                  <span class="co"># Prints &quot;entering lambda&quot;</span>
    puts <span class="st">&quot;exiting method&quot;</span>   <span class="co"># This line is executed</span>
<span class="kw">end</span>
test</code></pre></div></li>
<li><p>breaks</p></li>
<li><p>Other control-flow statements</p></li>
<li><p>Argument passing to procs and lambdas</p>
<ul>
<li>proc: use nil</li>
<li>lambda: wrong!</li>
</ul></li>
</ul></li>
</ul>
<h3 id="closures">Closures</h3>
<p>closures: closes over</p>
<p>In Ruby, procs and lambdas are closures. The term &#8220;closure&#8221; comes from the early days of computer science; it refers to an object that is both an invocable function and a variable binding for that function. When you create a proc or a lambda, the resulting Proc object holds not just the executable block but also bindings for all the variables used by the block.</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> multiplier(n)
    lambda {|data| data.collect{|x| x*n } }     <span class="co"># &#21644; JS &#37324;&#38754;&#19968;&#26679;&#65292;&#36820;&#22238;&#19968;&#20010;&#20989;&#25968;</span>
<span class="kw">end</span>
doubler = multiplier(<span class="dv">2</span>)
puts doubler.call([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]) <span class="co"># Prints 2,4,6</span></code></pre></div>
<ul>
<li><p>Closures and Shared Variables</p>
<p>&#20854;&#23454;&#23601;&#26159;&#36820;&#22238;&#20004;&#20010;&#20989;&#25968;&#21679;&#12290;&#20854;&#23454;&#25105;&#35273;&#24471;&#36825;&#37324;&#36824;&#19981;&#22914;&#36820;&#22238;&#19968;&#20010; hash &#21602;&#65292;&#24178;&#22043;&#25630;&#24471;&#24456;&#20998;&#35010;&#8230;&#8230;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> accessor_pair(initialValue=<span class="dv">nil</span>)
    value = initialValue
    getter = lambda { value }
    setter = lambda {|x| value = x }
    <span class="kw">return</span> getter,setter
<span class="kw">end</span>

getX, setX = accessor_pair(<span class="dv">0</span>)
puts getX[]
setX[<span class="dv">10</span>]
puts getX[]</code></pre></div></li>
<li><p>Closures and Bindings</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> multipliers(*args)
    args.map {|x| lambda {|y| x*y }}
<span class="kw">end</span>
double,triple = multipliers(<span class="dv">2</span>,<span class="dv">3</span>)
puts double.call(<span class="dv">2</span>)</code></pre></div>
<p>&#36825;&#20010;&#22043;&#65292;&#20854;&#23454; map &#20986;&#26469;&#26159;&#19968;&#22534;&#20989;&#25968;&#65288;proc&#65289;&#12290;</p></li>
<li><p>Closures and Bindings</p>
<p>A Binding object</p>
<ul>
<li>providing no interesting methods of its own</li>
<li>providing a context in which to evaluate a string of Ruby code</li>
</ul>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> multiplier(n)
    lambda {|data| data.collect{|x| x*n } }
<span class="kw">end</span>
doubler = multiplier(<span class="dv">2</span>)
puts doubler.call([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])      <span class="co"># 2,4,6</span></code></pre></div>
<p>bind!:</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">eval(<span class="st">&quot;n=3&quot;</span>, doubler.binding)            <span class="co"># &#22914;&#26524; doubler &#26159; proc &#30340;&#35805;&#65292;&#29992; eval(&quot;n=3&quot;, doubler.binding)</span>
<span class="co"># ruby &gt;= 1.9</span>
doubler.binding.eval(<span class="st">&quot;n=3&quot;</span>)</code></pre></div>
<p>&#23621;&#28982;&#21487;&#20197;&#30452;&#25509;&#20462;&#25913; closure &#37324;&#38754;&#30340;&#8220;&#37197;&#32622;&#8221;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">puts doubler.call([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])  <span class="co"># 3,6,9</span></code></pre></div></li>
</ul>
<h3 id="method-objects">Method Objects</h3>
<p>Ruby has powerful metaprogramming (or reflection) capabilities, and methods can actually be represented as instances of the Method class.</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">m = <span class="dv">0</span>.method(<span class="st">:succ</span>)             <span class="co"># A Method representing the succ method of Fixnum 0</span></code></pre></div>
<ul>
<li><p><strong>Unbound Method Objects</strong></p>
<p>&#23601;&#26159;&#27809;&#26377; bound &#30340; method&#65292;&#21487;&#20197;&#20174;&#38543;&#24847;&#19968;&#20010; obj &#33719;&#24471;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">unbound_plus = <span class="dt">Fixnum</span>.instance_method(<span class="st">&quot;+&quot;</span>)  <span class="co"># or `public_instance_method`</span>

<span class="co"># bind &amp; call</span>
plus_2 = unbound_plus.bind(<span class="dv">2</span>)
sum = plus_2.call(<span class="dv">2</span>)                        <span class="co"># =&gt; 4</span></code></pre></div></li>
</ul>
<h3 id="functional-programming">Functional Programming</h3>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">mean = a.inject {|x,y| x+y } / a.size
sumOfSquares = a.map{|x| (x-mean)**<span class="dv">2</span> }.inject{ |x,y| x+y }
standDevision = <span class="dt">Math</span>.sqrt(sumOfSquares/(a.size<span class="dv">-1</span>))</code></pre></div>
<ul>
<li><p>Applying a Function to an Enumerable</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">Functional</span>
    <span class="kw">def</span> apply(enum)
        enum.map &amp;<span class="dv">self</span>
    <span class="kw">end</span>
    <span class="kw">alias</span> | apply

    <span class="kw">def</span> reduce(enum)
        enum.inject &amp;<span class="dv">self</span>
    <span class="kw">end</span>
    <span class="kw">alias</span> &lt;= reduce
<span class="kw">end</span>

<span class="co"># &#36825;&#29305;&#20040;&#23601;&#32473; Proc &#21644; Method &#21152;&#19978;&#20102;&#36825;&#20004;&#20010;&#21151;&#33021;&#65306;apply&#65292;reduce</span>
<span class="kw">class</span> <span class="dt">Proc</span>; include <span class="dt">Functional</span>; <span class="kw">end</span>
<span class="kw">class</span> <span class="dt">Method</span>; include <span class="dt">Functional</span>; <span class="kw">end</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">sum= lamdba {|x,y| x+y }
mean = (sum&lt;=a)/a.size
deviation = lambda{|x| x-mean }
square = lambda{|x| x*x }
standDeviation = <span class="dt">Math</span>.sqrt( (sum&lt;=square|(deviation|a))/(a.size<span class="dv">-1</span>) )</code></pre></div></li>
<li><p>Composing Functions</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">Functional</span>
    <span class="kw">def</span> compose(f)
        <span class="kw">if</span> <span class="dv">self</span>.respond_to?(<span class="st">:arity</span>) &amp;&amp; <span class="dv">self</span>.arity == <span class="dv">1</span>      <span class="co"># &#21482;&#33021;&#22788;&#29702;&#19968;&#20010;&#21442;&#25968;</span>
            lambda {|*args| <span class="dv">self</span>[f[*args]] }
        <span class="kw">else</span>
            lambda {|*args| <span class="dv">self</span>[*f[*args]] }               <span class="co"># splash</span>
        <span class="kw">end</span>
    <span class="kw">end</span>
    <span class="kw">alias</span> * compose
<span class="kw">end</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co">#   &lt;=  reduce</span>
<span class="co">#   *   compose</span>
<span class="co">#   |   apply</span>
standardDeviation = <span class="dt">Math</span>.sqrt((sum&lt;=square*deviation|a)/(a.size<span class="dv">-1</span>))

<span class="co"># &#36825;&#37324;&#20854;&#23454;&#36824;&#20381;&#36182;&#20102; mean&#65292;&#19981;&#22909;</span></code></pre></div></li>
<li><p>Partially Applying Functions</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">Functional</span>
    <span class="kw">def</span> apply_head(*first)
        lambda {|*rest| <span class="dv">self</span>[*first.concat(rest)]}
    <span class="kw">end</span>
    <span class="kw">alias</span> &gt;&gt; apply_head         <span class="co"># g = f &gt;&gt; 2 -- set first arg to 2</span>
    <span class="kw">def</span> apply_tail(*last)
        lambda {|*rest| <span class="dv">self</span>[*rest.concat(last)]}
    <span class="kw">end</span>
    <span class="kw">alias</span> &lt;&lt; apply_tail         <span class="co"># g = f &lt;&lt; 2 -- set last arg to 2</span>
<span class="kw">end</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">difference = lambda {|x,y| x-y }
deviation  = difference&lt;&lt;<span class="kw">mean</span></code></pre></div></li>
<li><p>Memoizing Functions</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">Functional</span>
    <span class="kw">def</span> memoize
        cache = {}
        lambda {|*args|
            <span class="kw">unless</span> cache.has_key?(args)
                cache[args] = <span class="dv">self</span>[*args]   <span class="co"># compute and cache, and return</span>
            <span class="kw">end</span>
            cache[args]                     <span class="co"># retrieve from cache</span>
        }                                   <span class="co"># return the lambda function</span>
    <span class="kw">end</span>
    <span class="kw">alias</span> +@ memoize                        <span class="co"># cached_f = +f</span>
<span class="kw">end</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">factorial = lambda {|x| <span class="kw">return</span> <span class="dv">1</span> <span class="kw">if</span> x==<span class="dv">0</span>; x*factorial[x<span class="dv">-1</span>]; }.memoize
factorial = +lambda {|x| <span class="kw">return</span> <span class="dv">1</span> <span class="kw">if</span> x==<span class="dv">0</span>; x*factorial[x<span class="dv">-1</span>]; }</code></pre></div></li>
<li><p>Symbols, Methods, and Procs</p>
<p>Ruby 1.9 adds a useful to_proc method to the Symbol class. This method allows a symbol to be prefixed with <code>&amp;</code> and passed as a block to an iterator.</p>
<p>&#36825;&#20010;&#24456;&#26377;&#29992;&#12290;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>].map(&amp;<span class="st">:succ</span>)             <span class="co"># =&gt; [2,3,4]</span>
<span class="co"># &#31561;&#20215;&#20110;&#65306;</span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>].map {|n| n.succ }</code></pre></div>
<p><code>:succ</code> &#26159;&#19968;&#20010; symbol&#65292;<code>&amp;:succ</code> &#26159;&#19968;&#20010; symbol prefixed with &amp;&#65292;&#25152;&#20197;&#25972;&#20307;&#23601;&#26159;&#19968;&#20010; block</p>
<p>Symbol.to_proc &#30340; implementation&#65306;</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">class</span> <span class="dt">Symbol</span>
    <span class="kw">def</span> to_proc
        lambda {|receiver, *args| receiver.send(<span class="dv">self</span>, *args)}
        <span class="co"># or</span>
        <span class="co"># lambda {|receiver, *args| receiver.method(self)[*args]}</span>
    <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">class</span> <span class="dt">Module</span>
    <span class="kw">alias</span> [] instance_method
<span class="kw">end</span>

<span class="dt">String</span>[<span class="st">:reverse</span>].bind(<span class="st">&quot;hello&quot;</span>).call         <span class="co"># =&gt; &quot;olleh&quot;</span>

<span class="kw">class</span> <span class="dt">UnboundMethod</span>
    <span class="kw">alias</span> [] bind
<span class="kw">end</span>

<span class="dt">String</span>[<span class="st">:reverse</span>][<span class="st">&quot;hello&quot;</span>][]                 <span class="co"># =&gt; &quot;olleh&quot;</span></code></pre></div>
<p>todo, p210</p></li>
</ul>
<h2 id="chapter-7-classes-and-modules">Chapter 7 Classes and Modules</h2>
<h3 id="defining-a-simple-class">Defining a Simple Class</h3>
<h3 id="method-visibility-public-protected-private">Method Visibility: Public, Protected, Private</h3>
<h3 id="subclassing-and-inheritance">Subclassing and Inheritance</h3>
<h3 id="object-creation-and-initialization">Object Creation and Initialization</h3>
<h3 id="modules">Modules</h3>
<h3 id="loading-and-requiring-modules">Loading and Requiring Modules</h3>
<h3 id="singleton-methods-and-the-eigenclass">Singleton Methods and the Eigenclass</h3>
<h3 id="method-lookup">Method Lookup</h3>
<h3 id="constant-lookup">Constant Lookup</h3>
<h2 id="chapter-8-reflection-and-metaprogramming">Chapter 8 Reflection and Metaprogramming</h2>
<h3 id="types-classes-and-modules">Types, Classes, and Modules</h3>
<h3 id="evaluating-strings-and-blocks">Evaluating Strings and Blocks</h3>
<h3 id="variables-and-constants">Variables and Constants</h3>
<h3 id="methods">Methods</h3>
<h3 id="hooks">Hooks</h3>
<h3 id="tracing">Tracing</h3>
<h3 id="objectspace-and-gc">ObjectSpace and GC</h3>
<h3 id="custom-control-structures">Custom Control Structures</h3>
<h3 id="missing-methods-and-missing-constants">Missing Methods and Missing Constants</h3>
<h3 id="dynamically-creating-methods">Dynamically Creating Methods</h3>
<h3 id="alias-chaining">Alias Chaining</h3>
<h3 id="domain-specific-languages">Domain-Specific Languages</h3>
<h2 id="chapter-9-the-ruby-platform">Chapter 9 The Ruby Platform</h2>
<h3 id="strings">Strings</h3>
<h3 id="regular-expressions">Regular Expressions</h3>
<h3 id="numbers-and-math">Numbers and Math</h3>
<h3 id="dates-and-times">Dates and Times</h3>
<h3 id="collections">Collections</h3>
<h3 id="files-and-directories">Files and Directories</h3>
<h3 id="inputoutput">Input/Output</h3>
<h3 id="networking">Networking</h3>
<h3 id="threads-and-concurrency">Threads and Concurrency</h3>
<h2 id="chapter-10-the-ruby-environment">Chapter 10 The Ruby Environment</h2>
<h3 id="invoking-the-ruby-interpreter">Invoking the Ruby Interpreter</h3>
<h3 id="the-top-level-environment">The Top-Level Environment</h3>
<h3 id="practical-extraction-and-reporting-shortcuts">Practical Extraction and Reporting Shortcuts</h3>
<h3 id="calling-the-os">Calling the OS</h3>
<h3 id="security">Security</h3>
<h2 id="colophon">Colophon</h2>
<hr />
<ul>
<li><a href="https://github.com/4ker/ruby-style-guide">4ker/ruby-style-guide: A community-driven Ruby coding style guide</a></li>
</ul>
</div>
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="blur-svg">
    <defs>
        <filter id="blur-filter">
            <feGaussianBlur stdDeviation="3"></feGaussianBlur>
        </filter>
    </defs>
</svg>
<script src="../lazyload.min.js"></script>
<script src="../jquery-3.0.0.min.js"></script>
<script src="../jquery.idTabs.min.js"></script>
<script src="../egg.min.js"></script>
<script src="../clipboard.min.js"></script>
<script src="../notes.js"></script>
</body>
</html>
