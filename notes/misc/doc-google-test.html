<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="author" content="district10" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Google Test</title>
    <link rel="stylesheet" href="../github-markdown.css" type="text/css" />
    <link rel="stylesheet" href="../highlight.css" type="text/css" />
    <link rel="stylesheet" href="../notes.css" type="text/css" />
</head>
<body class="markdown-body">
<div id="navigator">
    <a id="gotoindex" href="index.html" title="&#12304;&#22238;&#21040;&#31508;&#35760;&#32034;&#24341; | Back to Index&#12305;">&#9763;</a></div>
<div id="main-body">
<h1 id="google-test">Google Test</h1>
<pre class="tzx-plain"><code>// Copyright 2005, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</code></pre>
<h2 id="primer">Primer</h2>
<h3 id="introduction-why-google-c-testing-framework">Introduction: Why Google C++ Testing Framework?</h3>
<p><em>Google C++ Testing Framework</em> helps you write better C++ tests.</p>
<p>No matter whether you work on Linux, Windows, or a Mac, if you write C++ code, Google Test can help you.</p>
<p>So what makes a good test, and how does Google C++ Testing Framework fit in? We believe:</p>
<ul>
<li>Tests should be <strong><em>independent</em></strong> and <strong><em>repeatable</em></strong>. It&#8217;s a pain to debug a test that succeeds or fails as a result of other tests. Google C++ Testing Framework isolates the tests by running each of them on a different object. When a test fails, Google C++ Testing Framework allows you to run it in isolation for quick debugging.</li>
<li>Tests should be well <strong><em>organized</em></strong> and reflect the structure of the tested code. Google C++ Testing Framework groups related tests into test cases that can share data and subroutines. This common pattern is easy to recognize and makes tests easy to maintain. Such consistency is especially helpful when people switch projects and start to work on a new code base.</li>
<li>Tests should be <strong><em>portable</em></strong> and <strong><em>reusable</em></strong>. The open-source community has a lot of code that is platform-neutral, its tests should also be platform-neutral. Google C++ Testing Framework works on different OSes, with different compilers (gcc, MSVC, and others), with or without exceptions, so Google C++ Testing Framework tests can easily work with a variety of configurations. (Note that the current release only contains build scripts for Linux - we are actively working on scripts for other platforms.)</li>
<li>When tests fail, they should provide as much <strong><em>information</em></strong> about the problem as possible. Google C++ Testing Framework doesn&#8217;t stop at the first test failure. Instead, it only stops the current test and continues with the next. You can also set up tests that report non-fatal failures after which the current test continues. Thus, you can <strong>detect and fix multiple bugs in a single run-edit-compile cycle</strong>.</li>
<li>The testing framework should liberate test writers from housekeeping chores and let them <strong>focus on the test <em>content</em></strong>. Google C++ Testing Framework automatically keeps track of all tests defined, and doesn&#8217;t require the user to enumerate them in order to run them.</li>
<li>Tests should be <strong><em>fast</em></strong>. With Google C++ Testing Framework, you can reuse shared resources across tests and pay for the set-up/tear-down only once, without making tests depend on each other.</li>
</ul>
<p>Since Google C++ Testing Framework is based on the popular xUnit architecture, you&#8217;ll feel right at home if you&#8217;ve used JUnit or PyUnit before. If not, it will take you about 10 minutes to learn the basics and get started. So let&#8217;s go!</p>
<p><em>Note:</em> We sometimes refer to Google C++ Testing Framework informally as <em>Google Test</em>.</p>
<h3 id="setting-up-a-new-test-project">Setting up a New Test Project</h3>
<p>To write a test program using Google Test, you need to compile Google Test into a library and link your test with it. We provide build files for some popular build systems: <code>msvc/</code> for Visual Studio, <code>xcode/</code> for Mac Xcode, <code>make/</code> for GNU make, <code>codegear/</code> for Borland C++ Builder, and the autotools script (deprecated) and <code>CMakeLists.txt</code> for CMake (recommended) in the Google Test root directory. If your build system is not on this list, you can take a look at <code>make/Makefile</code> to learn how Google Test should be compiled (basically you want to <strong>compile <code>src/gtest-all.cc</code> with <code>GTEST_ROOT</code> and <code>GTEST_ROOT/include</code> in the header search path</strong>, where <code>GTEST_ROOT</code> is the Google Test root directory).</p>
<p>Once you are able to compile the Google Test library, you should create a project or build target for your test program. Make sure you have <code>GTEST_ROOT/include</code> in the header search path so that the compiler can find <code>&quot;gtest/gtest.h&quot;</code> when compiling your test. Set up your test project to link with the Google Test library (for example, in Visual Studio, this is done by adding a dependency on <code>gtest.vcproj</code>).</p>
<p>If you still have questions, take a look at how Google Test&#8217;s own tests are built and use them as examples.</p>
<h3 id="basic-concepts">Basic Concepts</h3>
<p>When using Google Test, you start by writing <strong><em>assertions</em></strong>, which are statements that check whether a condition is true. An assertion&#8217;s result can be <em>success</em>, <em>nonfatal failure</em>, or <em>fatal failure</em>. If a fatal failure occurs, it aborts the current function; otherwise the program continues normally.</p>
<p><em>Tests</em> use assertions to verify the tested code&#8217;s behavior. If a test crashes or has a failed assertion, then it <em>fails</em>; otherwise it <em>succeeds</em>.</p>
<p>A <em>test case</em> contains one or many tests. You should group your tests into test cases that reflect the structure of the tested code. When multiple tests in a test case need to share common objects and subroutines, you can put them into a <strong><em>test fixture</em></strong> class.</p>
<p><strong>A <em>test program</em> can contain multiple test cases.</strong></p>
<p>We&#8217;ll now explain how to write a test program, starting at the individual assertion level and building up to tests and test cases.</p>
<h3 id="assertions">Assertions</h3>
<p>Google Test assertions are macros that resemble function calls. You test a class or function by making assertions about its behavior. When an assertion fails, Google Test prints the assertion&#8217;s source file and line number location, along with a failure message. You may also supply a custom failure message which will be appended to Google Test&#8217;s message.</p>
<p>The assertions come in pairs that test the same thing but have different effects on the current function. <strong><code>ASSERT_*</code></strong> versions generate fatal failures when they fail, and <strong>abort the current function</strong>. <strong><code>EXPECT_*</code></strong> versions generate nonfatal failures, which don&#8217;t abort the current function. Usually <code>EXPECT_*</code> are preferred, as they allow more than one failures to be reported in a test. However, you should use <code>ASSERT_*</code> if it doesn&#8217;t make sense to continue when the assertion in question fails.</p>
<p>Since a failed <code>ASSERT_*</code> returns from the current function immediately, possibly skipping clean-up code that comes after it, it may cause a space leak. Depending on the nature of the leak, it may or may not be worth fixing - so keep this in mind if you get <strong>a heap checker error</strong> in addition to assertion errors.</p>
<p>To provide <strong>a custom failure message</strong>, simply stream it into the macro using the <code>&lt;&lt;</code> operator, or a sequence of such operators. An example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">ASSERT_EQ(x.size(), y.size()) &lt;&lt; <span class="st">&quot;Vectors x and y are of unequal length&quot;</span>;

<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; x.size(); ++i) {
  EXPECT_EQ(x[i], y[i]) &lt;&lt; <span class="st">&quot;Vectors x and y differ at index &quot;</span> &lt;&lt; i;
}</code></pre></div>
<p><strong>Anything that can be streamed to an <code>ostream</code> can be streamed to an assertion macro&#8211;in particular, C strings and <code>string</code> objects.</strong> If a wide string (<code>wchar_t*</code>, <code>TCHAR*</code> in <code>UNICODE</code> mode on Windows, or <code>std::wstring</code>) is streamed to an assertion, it will be translated to UTF-8 when printed.</p>
<h4 id="basic-assertions">Basic Assertions</h4>
<p>These assertions do basic true/false condition testing.</p>
<table>
<thead>
<tr class="header">
<th align="left"><strong>Fatal assertion</strong></th>
<th align="left"><strong>Nonfatal assertion</strong></th>
<th align="left"><strong>Verifies</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ASSERT_TRUE(</code><em>condition</em><code>)</code>;</td>
<td align="left"><code>EXPECT_TRUE(</code><em>condition</em><code>)</code>;</td>
<td align="left"><em>condition</em> is true</td>
</tr>
<tr class="even">
<td align="left"><code>ASSERT_FALSE(</code><em>condition</em><code>)</code>;</td>
<td align="left"><code>EXPECT_FALSE(</code><em>condition</em><code>)</code>;</td>
<td align="left"><em>condition</em> is false</td>
</tr>
</tbody>
</table>
<p>Remember, when they fail, <code>ASSERT_*</code> yields a fatal failure and returns from the current function, while <code>EXPECT_*</code> yields a nonfatal failure, allowing the function to continue running. In either case, an assertion failure means its containing test fails.</p>
<p><em>Availability</em>: Linux, Windows, Mac.</p>
<h4 id="binary-comparison">Binary Comparison</h4>
<p>This section describes assertions that compare two values.</p>
<table>
<thead>
<tr class="header">
<th align="left"><strong>Fatal assertion</strong></th>
<th align="left"><strong>Nonfatal assertion</strong></th>
<th align="left"><strong>Verifies</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ASSERT_EQ(</code><em>expected</em><code>,</code><em>actual</em><code>);</code></td>
<td align="left"><code>EXPECT_EQ(</code><em>expected</em><code>,</code><em>actual</em><code>);</code></td>
<td align="left"><em>expected</em> <code>==</code> <em>actual</em></td>
</tr>
<tr class="even">
<td align="left"><code>ASSERT_NE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td align="left"><code>EXPECT_NE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td align="left"><em>val1</em> <code>!=</code> <em>val2</em></td>
</tr>
<tr class="odd">
<td align="left"><code>ASSERT_LT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td align="left"><code>EXPECT_LT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td align="left"><em>val1</em> <code>&lt;</code> <em>val2</em></td>
</tr>
<tr class="even">
<td align="left"><code>ASSERT_LE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td align="left"><code>EXPECT_LE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td align="left"><em>val1</em> <code>&lt;=</code> <em>val2</em></td>
</tr>
<tr class="odd">
<td align="left"><code>ASSERT_GT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td align="left"><code>EXPECT_GT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td align="left"><em>val1</em> <code>&gt;</code> <em>val2</em></td>
</tr>
<tr class="even">
<td align="left"><code>ASSERT_GE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td align="left"><code>EXPECT_GE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td>
<td align="left"><em>val1</em> <code>&gt;=</code> <em>val2</em></td>
</tr>
</tbody>
</table>
<p>In the event of a failure, Google Test prints both <em>val1</em> and <em>val2</em> . In <code>ASSERT_EQ*</code> and <code>EXPECT_EQ*</code> (and all other equality assertions we&#8217;ll introduce later), you should put the expression you want to test in the position of <em>actual</em>, and put its expected value in <em>expected</em>, as Google Test&#8217;s failure messages are optimized for this convention.</p>
<p>Value arguments must be comparable by the assertion&#8217;s comparison operator or you&#8217;ll get a compiler error. We used to require the arguments to support the <code>&lt;&lt;</code> operator for streaming to an <code>ostream</code>, but it&#8217;s no longer necessary since v1.6.0 (if <code>&lt;&lt;</code> is supported, it will be called to print the arguments when the assertion fails; otherwise Google Test will attempt to print them in the best way it can. For more details and how to customize the printing of the arguments, see this Google Mock <a href="https://github.com/google/googletest/blob/ff07a5de0e81580547f1685e101194ed1a4fcd56/googletest/docs/Primer.md">recipe</a>.).</p>
<p>These assertions can work with a user-defined type, but only if you define the corresponding comparison operator (e.g. <code>==</code>, <code>&lt;</code>, etc). If the corresponding operator is defined, prefer using the <code>ASSERT_*()</code> macros because they will print out not only the result of the comparison, but the two operands as well.</p>
<p>Arguments are always evaluated exactly once. Therefore, it&#8217;s OK for the arguments to have side effects. However, as with any ordinary C/C++ function, the arguments&#8217; evaluation order is undefined (i.e.&#160;the compiler is free to choose any order) and your code should not depend on any particular argument evaluation order.</p>
<p><strong><code>ASSERT_EQ()</code> does pointer equality on pointers.</strong> If used on two C strings, it tests if they are in the same memory location, not if they have the same value. Therefore, if you want to <strong>compare C strings (e.g. <code>const char*</code>)</strong> by value, use <strong><code>ASSERT_STREQ()</code></strong> , which will be described later on. In particular, to assert that a C string is <code>NULL</code>, use <strong><code>ASSERT_STREQ(NULL, c_string)</code></strong> . However, to compare two <code>string</code> objects, you should use <code>ASSERT_EQ</code>.</p>
<p>Macros in this section work with both narrow and wide string objects (<code>string</code> and <code>wstring</code>).</p>
<p><em>Availability</em>: Linux, Windows, Mac.</p>
<h4 id="string-comparison">String Comparison</h4>
<p>The assertions in this group compare two <strong>C strings</strong>. If you want to compare two <code>string</code> objects, use <code>EXPECT_EQ</code>, <code>EXPECT_NE</code>, and etc instead.</p>
<table style="width:86%;">
<colgroup>
<col width="30%" />
<col width="34%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><strong>Fatal assertion</strong></th>
<th align="left"><strong>Nonfatal assertion</strong></th>
<th align="left"><strong>Verifies</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ASSERT_STREQ(</code><em>expected_str</em><code>,</code><em>actual_str</em><code>);</code></td>
<td align="left"><code>EXPECT_STREQ(</code><em>expected_str</em><code>,</code><em>actual_str</em><code>);</code></td>
<td align="left">the two C strings have the same content</td>
</tr>
<tr class="even">
<td align="left"><code>ASSERT_STRNE(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td align="left"><code>EXPECT_STRNE(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td align="left">the two C strings have different content</td>
</tr>
<tr class="odd">
<td align="left"><code>ASSERT_STRCASEEQ(</code><em>expected_str</em><code>,</code><em>actual_str</em><code>);</code></td>
<td align="left"><code>EXPECT_STRCASEEQ(</code><em>expected_str</em><code>,</code><em>actual_str</em><code>);</code></td>
<td align="left">the two C strings have the same content, ignoring case</td>
</tr>
<tr class="even">
<td align="left"><code>ASSERT_STRCASENE(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td align="left"><code>EXPECT_STRCASENE(</code><em>str1</em><code>,</code><em>str2</em><code>);</code></td>
<td align="left">the two C strings have different content, ignoring case</td>
</tr>
</tbody>
</table>
<p>Note that &#8220;CASE&#8221; in an assertion name means that case is ignored.</p>
<p><code>*STREQ*</code> and <code>*STRNE*</code> also accept wide C strings (<code>wchar_t*</code>). If a comparison of two wide strings fails, their values will be printed as UTF-8 narrow strings.</p>
<p>A <code>NULL</code> pointer and an empty string are considered <em>different</em>.</p>
<p><em>Availability</em>: Linux, Windows, Mac.</p>
<p>See also: For more string comparison tricks (substring, prefix, suffix, and regular expression matching, for example), see the <a href="#advanced-guide">Advanced Google Test Guide</a>.</p>
<h3 id="simple-tests">Simple Tests</h3>
<p>To create a test:</p>
<ol>
<li>Use the <code>TEST()</code> macro to define and name a test function, These are ordinary C++ functions that don&#8217;t return a value.</li>
<li>In this function, along with any valid C++ statements you want to include, use the various Google Test assertions to check values.</li>
<li>The test&#8217;s result is determined by the assertions; if any assertion in the test fails (either fatally or non-fatally), or if the test crashes, the entire test fails. Otherwise, it succeeds.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">TEST(test_case_name, test_name) {
 ... test body ...
}</code></pre></div>
<p><code>TEST()</code> arguments go from general to specific. The <em>first</em> argument is the name of the test case, and the <em>second</em> argument is the test&#8217;s name within the test case. Both names must be valid C++ identifiers, and they <strong>should not contain underscore (<code>_</code>)</strong>. A test&#8217;s <em>full name</em> consists of its containing test case and its individual name. Tests from different test cases can have the same individual name.</p>
<p>For example, let&#8217;s take a simple integer function:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> Factorial(<span class="dt">int</span> n); <span class="co">// Returns the factorial of n</span></code></pre></div>
<p>A test case for this function might look like:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Tests factorial of 0.</span>
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(<span class="dv">1</span>, Factorial(<span class="dv">0</span>));
}

<span class="co">// Tests factorial of positive numbers.</span>
TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(<span class="dv">1</span>, Factorial(<span class="dv">1</span>));
  EXPECT_EQ(<span class="dv">2</span>, Factorial(<span class="dv">2</span>));
  EXPECT_EQ(<span class="dv">6</span>, Factorial(<span class="dv">3</span>));
  EXPECT_EQ(<span class="dv">40320</span>, Factorial(<span class="dv">8</span>));
}</code></pre></div>
<p>Google Test groups the test results by test cases, so logically-related tests should be in the same test case; in other words, the first argument to their <code>TEST()</code> should be the same. In the above example, we have two tests, <code>HandlesZeroInput</code> and <code>HandlesPositiveInput</code>, that belong to the same test case <code>FactorialTest</code>.</p>
<p><em>Availability</em>: Linux, Windows, Mac.</p>
<h3 id="test-fixtures-using-the-same-data-configuration-for-multiple-tests">Test Fixtures: Using the Same Data Configuration for Multiple Tests</h3>
<p>If you find yourself writing two or more tests that operate on similar data, you can use a <em>test fixture</em>. It allows you to reuse the same configuration of objects for several different tests.</p>
<p>To create a fixture, just: 1. Derive a class from <code>::testing::Test</code> . Start its body with <code>protected:</code> or <code>public:</code> as we&#8217;ll want to access fixture members from sub-classes. 1. Inside the class, declare any objects you plan to use. 1. If necessary, write a default constructor or <code>SetUp()</code> function to prepare the objects for each test. A common mistake is to spell <code>SetUp()</code> as <code>Setup()</code> with a small <code>u</code> - don&#8217;t let that happen to you. 1. If necessary, write a destructor or <code>TearDown()</code> function to release any resources you allocated in <code>SetUp()</code> . To learn when you should use the constructor/destructor and when you should use <code>SetUp()/TearDown()</code>, read this <a href="V1_6_FAQ.md#should-i-use-the-constructordestructor-of-the-test-fixture-or-the-set-uptear-down-function">FAQ entry</a>. 1. If needed, define subroutines for your tests to share.</p>
<p>When using a fixture, use <code>TEST_F()</code> instead of <code>TEST()</code> as it allows you to access objects and subroutines in the test fixture:</p>
<pre><code>TEST_F(test_case_name, test_name) {
 ... test body ...
}</code></pre>
<p>Like <code>TEST()</code>, the first argument is the test case name, but for <code>TEST_F()</code> this must be the name of the test fixture class. You&#8217;ve probably guessed: <code>_F</code> is for fixture.</p>
<p>Unfortunately, the C++ macro system does not allow us to create a single macro that can handle both types of tests. Using the wrong macro causes a compiler error.</p>
<p>Also, you must first define a test fixture class before using it in a <code>TEST_F()</code>, or you&#8217;ll get the compiler error &#8220;<code>virtual outside class declaration</code>&#8221;.</p>
<p>For each test defined with <code>TEST_F()</code>, Google Test will: 1. Create a <em>fresh</em> test fixture at runtime 1. Immediately initialize it via <code>SetUp()</code> , 1. Run the test 1. Clean up by calling <code>TearDown()</code> 1. Delete the test fixture. Note that different tests in the same test case have different test fixture objects, and Google Test always deletes a test fixture before it creates the next one. Google Test does not reuse the same test fixture for multiple tests. Any changes one test makes to the fixture do not affect other tests.</p>
<p>As an example, let&#8217;s write tests for a FIFO queue class named <code>Queue</code>, which has the following interface:</p>
<pre><code>template &lt;typename E&gt; // E is the element type.
class Queue {
 public:
  Queue();
  void Enqueue(const E&amp; element);
  E* Dequeue(); // Returns NULL if the queue is empty.
  size_t size() const;
  ...
};</code></pre>
<p>First, define a fixture class. By convention, you should give it the name <code>FooTest</code> where <code>Foo</code> is the class being tested.</p>
<pre><code>class QueueTest : public ::testing::Test {
 protected:
  virtual void SetUp() {
    q1_.Enqueue(1);
    q2_.Enqueue(2);
    q2_.Enqueue(3);
  }

  // virtual void TearDown() {}

  Queue&lt;int&gt; q0_;
  Queue&lt;int&gt; q1_;
  Queue&lt;int&gt; q2_;
};</code></pre>
<p>In this case, <code>TearDown()</code> is not needed since we don&#8217;t have to clean up after each test, other than what&#8217;s already done by the destructor.</p>
<p>Now we&#8217;ll write tests using <code>TEST_F()</code> and this fixture.</p>
<pre><code>TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(0, q0_.size());
}

TEST_F(QueueTest, DequeueWorks) {
  int* n = q0_.Dequeue();
  EXPECT_EQ(NULL, n);

  n = q1_.Dequeue();
  ASSERT_TRUE(n != NULL);
  EXPECT_EQ(1, *n);
  EXPECT_EQ(0, q1_.size());
  delete n;

  n = q2_.Dequeue();
  ASSERT_TRUE(n != NULL);
  EXPECT_EQ(2, *n);
  EXPECT_EQ(1, q2_.size());
  delete n;
}</code></pre>
<p>The above uses both <code>ASSERT_*</code> and <code>EXPECT_*</code> assertions. The rule of thumb is to use <code>EXPECT_*</code> when you want the test to continue to reveal more errors after the assertion failure, and use <code>ASSERT_*</code> when continuing after failure doesn&#8217;t make sense. For example, the second assertion in the <code>Dequeue</code> test is <code>ASSERT_TRUE(n != NULL)</code>, as we need to dereference the pointer <code>n</code> later, which would lead to a segfault when <code>n</code> is <code>NULL</code>.</p>
<p>When these tests run, the following happens: 1. Google Test constructs a <code>QueueTest</code> object (let&#8217;s call it <code>t1</code> ). 1. <code>t1.SetUp()</code> initializes <code>t1</code> . 1. The first test ( <code>IsEmptyInitially</code> ) runs on <code>t1</code> . 1. <code>t1.TearDown()</code> cleans up after the test finishes. 1. <code>t1</code> is destructed. 1. The above steps are repeated on another <code>QueueTest</code> object, this time running the <code>DequeueWorks</code> test.</p>
<p><em>Availability</em>: Linux, Windows, Mac.</p>
<p><em>Note</em>: Google Test automatically saves all <em>Google Test</em> flags when a test object is constructed, and restores them when it is destructed.</p>
<h3 id="invoking-the-tests">Invoking the Tests</h3>
<p><code>TEST()</code> and <code>TEST_F()</code> implicitly register their tests with Google Test. So, unlike with many other C++ testing frameworks, you don&#8217;t have to re-list all your defined tests in order to run them.</p>
<p>After defining your tests, you can run them with <code>RUN_ALL_TESTS()</code> , which returns <code>0</code> if all the tests are successful, or <code>1</code> otherwise. Note that <code>RUN_ALL_TESTS()</code> runs <em>all tests</em> in your link unit &#8211; they can be from different test cases, or even different source files.</p>
<p>When invoked, the <code>RUN_ALL_TESTS()</code> macro: 1. Saves the state of all Google Test flags. 1. Creates a test fixture object for the first test. 1. Initializes it via <code>SetUp()</code>. 1. Runs the test on the fixture object. 1. Cleans up the fixture via <code>TearDown()</code>. 1. Deletes the fixture. 1. Restores the state of all Google Test flags. 1. Repeats the above steps for the next test, until all tests have run.</p>
<p>In addition, if the text fixture&#8217;s constructor generates a fatal failure in step 2, there is no point for step 3 - 5 and they are thus skipped. Similarly, if step 3 generates a fatal failure, step 4 will be skipped.</p>
<p><em>Important</em>: You must not ignore the return value of <code>RUN_ALL_TESTS()</code>, or <code>gcc</code> will give you a compiler error. The rationale for this design is that the automated testing service determines whether a test has passed based on its exit code, not on its stdout/stderr output; thus your <code>main()</code> function must return the value of <code>RUN_ALL_TESTS()</code>.</p>
<p>Also, you should call <code>RUN_ALL_TESTS()</code> only <strong>once</strong>. Calling it more than once conflicts with some advanced Google Test features (e.g.&#160;thread-safe death tests) and thus is not supported.</p>
<p><em>Availability</em>: Linux, Windows, Mac.</p>
<h3 id="writing-the-main-function">Writing the main() Function</h3>
<p>You can start from this boilerplate:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;this/package/foo.h&quot;</span>
<span class="ot">#include &quot;gtest/gtest.h&quot;</span>

<span class="kw">namespace</span> {

<span class="co">// The fixture for testing class Foo.</span>
<span class="kw">class</span> FooTest : <span class="kw">public</span> ::testing::Test {
 <span class="kw">protected</span>:
  <span class="co">// You can remove any or all of the following functions if its body</span>
  <span class="co">// is empty.</span>

  FooTest() {
    <span class="co">// You can do set-up work for each test here.</span>
  }

  <span class="kw">virtual</span> ~FooTest() {
    <span class="co">// You can do clean-up work that doesn&#39;t throw exceptions here.</span>
  }

  <span class="co">// If the constructor and destructor are not enough for setting up</span>
  <span class="co">// and cleaning up each test, you can define the following methods:</span>

  <span class="kw">virtual</span> <span class="dt">void</span> SetUp() {
    <span class="co">// Code here will be called immediately after the constructor (right</span>
    <span class="co">// before each test).</span>
  }

  <span class="kw">virtual</span> <span class="dt">void</span> TearDown() {
    <span class="co">// Code here will be called immediately after each test (right</span>
    <span class="co">// before the destructor).</span>
  }

  <span class="co">// Objects declared here can be used by all tests in the test case for Foo.</span>
};

<span class="co">// Tests that the Foo::Bar() method does Abc.</span>
TEST_F(FooTest, MethodBarDoesAbc) {
  <span class="dt">const</span> string input_filepath = <span class="st">&quot;this/package/testdata/myinputfile.dat&quot;</span>;
  <span class="dt">const</span> string output_filepath = <span class="st">&quot;this/package/testdata/myoutputfile.dat&quot;</span>;
  Foo f;
  EXPECT_EQ(<span class="dv">0</span>, f.Bar(input_filepath, output_filepath));
}

<span class="co">// Tests that Foo does Xyz.</span>
TEST_F(FooTest, DoesXyz) {
  <span class="co">// Exercises the Xyz feature of Foo.</span>
}

}  <span class="co">// namespace</span>

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {
  ::testing::InitGoogleTest(&amp;argc, argv);
  <span class="kw">return</span> RUN_ALL_TESTS();
}</code></pre></div>
<p>The <code>::testing::InitGoogleTest()</code> function parses the command line for Google Test flags, and removes all recognized flags. This allows the user to control a test program&#8217;s behavior via various flags, which we&#8217;ll cover in <a href="V1_6_AdvancedGuide.md">AdvancedGuide</a>. You must call this function before calling <code>RUN_ALL_TESTS()</code>, or the flags won&#8217;t be properly initialized.</p>
<p>On Windows, <code>InitGoogleTest()</code> also works with wide strings, so it can be used in programs compiled in <code>UNICODE</code> mode as well.</p>
<p>But maybe you think that writing all those main() functions is too much work? We agree with you completely and that&#8217;s why Google Test provides a basic implementation of main(). If it fits your needs, then just link your test with gtest_main library and you are good to go.</p>
<h4 id="important-note-for-visual-c-users">Important note for Visual C++ users</h4>
<p>If you put your tests into a library and your <code>main()</code> function is in a different library or in your .exe file, those tests will not run. The reason is a <a href="https://connect.microsoft.com/feedback/viewfeedback.aspx?FeedbackID=244410&amp;siteid=210">bug</a> in Visual C++. When you define your tests, Google Test creates certain static objects to register them. These objects are not referenced from elsewhere but their constructors are still supposed to run. When Visual C++ linker sees that nothing in the library is referenced from other places it throws the library out. You have to reference your library with tests from your main program to keep the linker from discarding it. Here is how to do it. Somewhere in your library code declare a function:</p>
<pre><code>__declspec(dllexport) int PullInMyLibrary() { return 0; }</code></pre>
<p>If you put your tests in a static library (not DLL) then <code>__declspec(dllexport)</code> is not required. Now, in your main program, write a code that invokes that function:</p>
<pre><code>int PullInMyLibrary();
static int dummy = PullInMyLibrary();</code></pre>
<p>This will keep your tests referenced and will make them register themselves at startup.</p>
<p>In addition, if you define your tests in a static library, add <code>/OPT:NOREF</code> to your main program linker options. If you use MSVC++ IDE, go to your .exe project properties/Configuration Properties/Linker/Optimization and set References setting to <code>Keep Unreferenced Data (/OPT:NOREF)</code>. This will keep Visual C++ linker from discarding individual symbols generated by your tests from the final executable.</p>
<p>There is one more pitfall, though. If you use Google Test as a static library (that&#8217;s how it is defined in gtest.vcproj) your tests must also reside in a static library. If you have to have them in a DLL, you <em>must</em> change Google Test to build into a DLL as well. Otherwise your tests will not run correctly or will not run at all. The general conclusion here is: make your life easier - do not write your tests in libraries!</p>
<h3 id="where-to-go-from-here">Where to Go from Here</h3>
<p>Congratulations! You&#8217;ve learned the Google Test basics. You can start writing and running Google Test tests, read some <a href="V1_6_Samples.md">samples</a>, or continue with <a href="V1_6_AdvancedGuide.md">AdvancedGuide</a>, which describes many more useful Google Test features.</p>
<h3 id="known-limitations">Known Limitations</h3>
<p>Google Test is designed to be thread-safe. The implementation is thread-safe on systems where the <code>pthreads</code> library is available. It is currently <em>unsafe</em> to use Google Test assertions from two threads concurrently on other systems (e.g.&#160;Windows). In most tests this is not an issue as usually the assertions are done in the main thread. If you want to help, you can volunteer to implement the necessary synchronization primitives in <code>gtest-port.h</code> for your platform.</p>
<hr />
<h2 id="samples">Samples</h2>
<p><a href="https://github.com/google/googletest/blob/ff07a5de0e81580547f1685e101194ed1a4fcd56/googletest/docs/V1_6_Samples.md">googletest/V1_6_Samples.md at ff07a5de0e81580547f1685e101194ed1a4fcd56 &#183; google/googletest</a></p>
<hr />
<h2 id="advanced-guide">Advanced Guide</h2>
<p>Now that you have read <a href="#primer">Primer</a> and learned how to write tests using Google Test, it&#8217;s time to learn some new tricks. This document will show you more assertions as well as how to construct complex failure messages, propagate fatal failures, reuse and speed up your test fixtures, and use various flags with your tests.</p>
<h4 id="more-assertions">More Assertions</h4>
<p>This section covers some less frequently used, but still significant, assertions.</p>
<h5 id="explicit-success-and-failure">Explicit Success and Failure</h5>
<p>These three assertions do not actually test a value or expression. Instead, they generate a success or failure directly. Like the macros that actually perform a test, you may stream a custom failure message into the them.</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>SUCCEED();</code></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>Generates a success. This does NOT make the overall test succeed. A test is considered successful only if none of its assertions fail during its execution.</p>
<p>Note: <code>SUCCEED()</code> is purely documentary and currently doesn&#8217;t generate any user-visible output. However, we may add <code>SUCCEED()</code> messages to Google Test&#8217;s output in the future.</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>FAIL();</code></th>
<th align="left"><code>ADD_FAILURE();</code></th>
<th align="left"><code>ADD_FAILURE_AT(&quot;</code><em>file_path</em><code>&quot;,</code><em>line_number</em><code>);</code></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p><code>FAIL()</code> generates a fatal failure, while <code>ADD_FAILURE()</code> and <code>ADD_FAILURE_AT()</code> generate a nonfatal failure. These are useful when control flow, rather than a Boolean expression, deteremines the test&#8217;s success or failure. For example, you might want to write something like:</p>
<pre><code>switch(expression) {
  case 1: ... some checks ...
  case 2: ... some other checks
  ...
  default: FAIL() &lt;&lt; &quot;We shouldn&#39;t get here.&quot;;
}</code></pre>
<p><em>Availability</em>: Linux, Windows, Mac.</p>
<h5 id="exception-assertions">Exception Assertions</h5>
<p>These are for verifying that a piece of code throws (or does not throw) an exception of the given type:</p>
<table style="width:86%;">
<colgroup>
<col width="30%" />
<col width="34%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><strong>Fatal assertion</strong></th>
<th align="left"><strong>Nonfatal assertion</strong></th>
<th align="left"><strong>Verifies</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ASSERT_THROW(</code><em>statement</em>, <em>exception_type</em><code>);</code></td>
<td align="left"><code>EXPECT_THROW(</code><em>statement</em>, <em>exception_type</em><code>);</code></td>
<td align="left"><em>statement</em> throws an exception of the given type</td>
</tr>
<tr class="even">
<td align="left"><code>ASSERT_ANY_THROW(</code><em>statement</em><code>);</code></td>
<td align="left"><code>EXPECT_ANY_THROW(</code><em>statement</em><code>);</code></td>
<td align="left"><em>statement</em> throws an exception of any type</td>
</tr>
<tr class="odd">
<td align="left"><code>ASSERT_NO_THROW(</code><em>statement</em><code>);</code></td>
<td align="left"><code>EXPECT_NO_THROW(</code><em>statement</em><code>);</code></td>
<td align="left"><em>statement</em> doesn&#8217;t throw any exception</td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<pre><code>ASSERT_THROW(Foo(5), bar_exception);

EXPECT_NO_THROW({
  int n = 5;
  Bar(&amp;n);
});</code></pre>
<p><em>Availability</em>: Linux, Windows, Mac; since version 1.1.0.</p>
<h5 id="predicate-assertions-for-better-error-messages">Predicate Assertions for Better Error Messages</h5>
<p>Even though Google Test has a rich set of assertions, they can never be complete, as it&#8217;s impossible (nor a good idea) to anticipate all the scenarios a user might run into. Therefore, sometimes a user has to use <code>EXPECT_TRUE()</code> to check a complex expression, for lack of a better macro. This has the problem of not showing you the values of the parts of the expression, making it hard to understand what went wrong. As a workaround, some users choose to construct the failure message by themselves, streaming it into <code>EXPECT_TRUE()</code>. However, this is awkward especially when the expression has side-effects or is expensive to evaluate.</p>
<p>Google Test gives you three different options to solve this problem:</p>
<h6 id="using-an-existing-boolean-function">Using an Existing Boolean Function</h6>
<p>If you already have a function or a functor that returns <code>bool</code> (or a type that can be implicitly converted to <code>bool</code>), you can use it in a <em>predicate assertion</em> to get the function arguments printed for free:</p>
<table style="width:86%;">
<colgroup>
<col width="30%" />
<col width="34%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><strong>Fatal assertion</strong></th>
<th align="left"><strong>Nonfatal assertion</strong></th>
<th align="left"><strong>Verifies</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ASSERT_PRED1(</code><em>pred1, val1</em><code>);</code></td>
<td align="left"><code>EXPECT_PRED1(</code><em>pred1, val1</em><code>);</code></td>
<td align="left"><em>pred1(val1)</em> returns true</td>
</tr>
<tr class="even">
<td align="left"><code>ASSERT_PRED2(</code><em>pred2, val1, val2</em><code>);</code></td>
<td align="left"><code>EXPECT_PRED2(</code><em>pred2, val1, val2</em><code>);</code></td>
<td align="left"><em>pred2(val1, val2)</em> returns true</td>
</tr>
<tr class="odd">
<td align="left">&#8230;</td>
<td align="left">&#8230;</td>
<td align="left">&#8230;</td>
</tr>
</tbody>
</table>
<p>In the above, <em>predn</em> is an <em>n</em>-ary predicate function or functor, where <em>val1</em>, <em>val2</em>, &#8230;, and <em>valn</em> are its arguments. The assertion succeeds if the predicate returns <code>true</code> when applied to the given arguments, and fails otherwise. When the assertion fails, it prints the value of each argument. In either case, the arguments are evaluated exactly once.</p>
<p>Here&#8217;s an example. Given</p>
<pre><code>// Returns true iff m and n have no common divisors except 1.
bool MutuallyPrime(int m, int n) { ... }
const int a = 3;
const int b = 4;
const int c = 10;</code></pre>
<p>the assertion <code>EXPECT_PRED2(MutuallyPrime, a, b);</code> will succeed, while the assertion <code>EXPECT_PRED2(MutuallyPrime, b, c);</code> will fail with the message</p>
<pre>!MutuallyPrime(b, c) is false, where<br>b is 4<br>c is 10<br></pre>
<p><strong>Notes:</strong></p>
<ol style="list-style-type: decimal">
<li>If you see a compiler error &#8220;no matching function to call&#8221; when using <code>ASSERT_PRED*</code> or <code>EXPECT_PRED*</code>, please see <a href="v1_6_FAQ.md#ithe-compiler-complains-about-undefined-references-to-some-static-const-member-variables-but-i-did-define-them-in-the-class-body-whats-wrong">this</a> for how to resolve it.</li>
<li>Currently we only provide predicate assertions of arity &lt;= 5. If you need a higher-arity assertion, let us know.</li>
</ol>
<p><em>Availability</em>: Linux, Windows, Mac</p>
<h6 id="using-a-function-that-returns-an-assertionresult">Using a Function That Returns an AssertionResult</h6>
<p>While <code>EXPECT_PRED*()</code> and friends are handy for a quick job, the syntax is not satisfactory: you have to use different macros for different arities, and it feels more like Lisp than C++. The <code>::testing::AssertionResult</code> class solves this problem.</p>
<p>An <code>AssertionResult</code> object represents the result of an assertion (whether it&#8217;s a success or a failure, and an associated message). You can create an <code>AssertionResult</code> using one of these factory functions:</p>
<pre><code>namespace testing {

// Returns an AssertionResult object to indicate that an assertion has
// succeeded.
AssertionResult AssertionSuccess();

// Returns an AssertionResult object to indicate that an assertion has
// failed.
AssertionResult AssertionFailure();

}</code></pre>
<p>You can then use the <code>&lt;&lt;</code> operator to stream messages to the <code>AssertionResult</code> object.</p>
<p>To provide more readable messages in Boolean assertions (e.g. <code>EXPECT_TRUE()</code>), write a predicate function that returns <code>AssertionResult</code> instead of <code>bool</code>. For example, if you define <code>IsEven()</code> as:</p>
<pre><code>::testing::AssertionResult IsEven(int n) {
  if ((n % 2) == 0)
    return ::testing::AssertionSuccess();
  else
    return ::testing::AssertionFailure() &lt;&lt; n &lt;&lt; &quot; is odd&quot;;
}</code></pre>
<p>instead of:</p>
<pre><code>bool IsEven(int n) {
  return (n % 2) == 0;
}</code></pre>
<p>the failed assertion <code>EXPECT_TRUE(IsEven(Fib(4)))</code> will print:</p>
<pre>Value of: !IsEven(Fib(4))<br>Actual: false (*3 is odd*)<br>Expected: true<br></pre>
<p>instead of a more opaque</p>
<pre>Value of: !IsEven(Fib(4))<br>Actual: false<br>Expected: true<br></pre>
<p>If you want informative messages in <code>EXPECT_FALSE</code> and <code>ASSERT_FALSE</code> as well, and are fine with making the predicate slower in the success case, you can supply a success message:</p>
<pre><code>::testing::AssertionResult IsEven(int n) {
  if ((n % 2) == 0)
    return ::testing::AssertionSuccess() &lt;&lt; n &lt;&lt; &quot; is even&quot;;
  else
    return ::testing::AssertionFailure() &lt;&lt; n &lt;&lt; &quot; is odd&quot;;
}</code></pre>
<p>Then the statement <code>EXPECT_FALSE(IsEven(Fib(6)))</code> will print</p>
<pre>Value of: !IsEven(Fib(6))<br>Actual: true (8 is even)<br>Expected: false<br></pre>
<p><em>Availability</em>: Linux, Windows, Mac; since version 1.4.1.</p>
<h6 id="using-a-predicate-formatter">Using a Predicate-Formatter</h6>
<p>If you find the default message generated by <code>(ASSERT|EXPECT)_PRED*</code> and <code>(ASSERT|EXPECT)_(TRUE|FALSE)</code> unsatisfactory, or some arguments to your predicate do not support streaming to <code>ostream</code>, you can instead use the following <em>predicate-formatter assertions</em> to <em>fully</em> customize how the message is formatted:</p>
<table style="width:86%;">
<colgroup>
<col width="30%" />
<col width="34%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><strong>Fatal assertion</strong></th>
<th align="left"><strong>Nonfatal assertion</strong></th>
<th align="left"><strong>Verifies</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ASSERT_PRED_FORMAT1(</code><em>pred_format1, val1</em><code>);</code></td>
<td align="left"><code>EXPECT_PRED_FORMAT1(</code><em>pred_format1, val1</em><code>); | _pred\_format1(val1)_ is successful | |</code>ASSERT_PRED_FORMAT2(<code>_pred\_format2, val1, val2_</code>);<code>|</code>EXPECT_PRED_FORMAT2(<code>_pred\_format2, val1, val2_</code>);<code>| _pred\_format2(val1, val2)_ is successful | |</code>&#8230;<code>|</code>&#8230;<code>|</code>&#8230;`</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>The difference between this and the previous two groups of macros is that instead of a predicate, <code>(ASSERT|EXPECT)_PRED_FORMAT*</code> take a <em>predicate-formatter</em> (<em>pred_formatn</em>), which is a function or functor with the signature:</p>
<p><code>::testing::AssertionResult PredicateFormattern(const char*</code><em>expr1</em><code>, const char*</code><em>expr2</em><code>, ... const char*</code><em>exprn</em><code>, T1</code><em>val1</em><code>, T2</code><em>val2</em><code>, ... Tn</code><em>valn</em><code>);</code></p>
<p>where <em>val1</em>, <em>val2</em>, &#8230;, and <em>valn</em> are the values of the predicate arguments, and <em>expr1</em>, <em>expr2</em>, &#8230;, and <em>exprn</em> are the corresponding expressions as they appear in the source code. The types <code>T1</code>, <code>T2</code>, &#8230;, and <code>Tn</code> can be either value types or reference types. For example, if an argument has type <code>Foo</code>, you can declare it as either <code>Foo</code> or <code>const Foo&amp;</code>, whichever is appropriate.</p>
<p>A predicate-formatter returns a <code>::testing::AssertionResult</code> object to indicate whether the assertion has succeeded or not. The only way to create such an object is to call one of these factory functions:</p>
<p>As an example, let&#8217;s improve the failure message in the previous example, which uses <code>EXPECT_PRED2()</code>:</p>
<pre><code>// Returns the smallest prime common divisor of m and n,
// or 1 when m and n are mutually prime.
int SmallestPrimeCommonDivisor(int m, int n) { ... }

// A predicate-formatter for asserting that two integers are mutually prime.
::testing::AssertionResult AssertMutuallyPrime(const char* m_expr,
                                               const char* n_expr,
                                               int m,
                                               int n) {
  if (MutuallyPrime(m, n))
    return ::testing::AssertionSuccess();

  return ::testing::AssertionFailure()
      &lt;&lt; m_expr &lt;&lt; &quot; and &quot; &lt;&lt; n_expr &lt;&lt; &quot; (&quot; &lt;&lt; m &lt;&lt; &quot; and &quot; &lt;&lt; n
      &lt;&lt; &quot;) are not mutually prime, &quot; &lt;&lt; &quot;as they have a common divisor &quot;
      &lt;&lt; SmallestPrimeCommonDivisor(m, n);
}</code></pre>
<p>With this predicate-formatter, we can use</p>
<pre><code>EXPECT_PRED_FORMAT2(AssertMutuallyPrime, b, c);</code></pre>
<p>to generate the message</p>
<pre>b and c (4 and 10) are not mutually prime, as they have a common divisor 2.<br></pre>
<p>As you may have realized, many of the assertions we introduced earlier are special cases of <code>(EXPECT|ASSERT)_PRED_FORMAT*</code>. In fact, most of them are indeed defined using <code>(EXPECT|ASSERT)_PRED_FORMAT*</code>.</p>
<p><em>Availability</em>: Linux, Windows, Mac.</p>
<h5 id="floating-point-comparison">Floating-Point Comparison</h5>
<p>Comparing floating-point numbers is tricky. Due to round-off errors, it is very unlikely that two floating-points will match exactly. Therefore, <code>ASSERT_EQ</code> &#8217;s naive comparison usually doesn&#8217;t work. And since floating-points can have a wide value range, no single fixed error bound works. It&#8217;s better to compare by a fixed relative error bound, except for values close to 0 due to the loss of precision there.</p>
<p>In general, for floating-point comparison to make sense, the user needs to carefully choose the error bound. If they don&#8217;t want or care to, comparing in terms of Units in the Last Place (ULPs) is a good default, and Google Test provides assertions to do this. Full details about ULPs are quite long; if you want to learn more, see <a href="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm">this article on float comparison</a>.</p>
<h6 id="floating-point-macros">Floating-Point Macros</h6>
<table style="width:86%;">
<colgroup>
<col width="30%" />
<col width="34%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><strong>Fatal assertion</strong></th>
<th align="left"><strong>Nonfatal assertion</strong></th>
<th align="left"><strong>Verifies</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ASSERT_FLOAT_EQ(</code><em>expected, actual</em><code>);</code></td>
<td align="left"><code>EXPECT_FLOAT_EQ(</code><em>expected, actual</em><code>);</code></td>
<td align="left">the two <code>float</code> values are almost equal</td>
</tr>
<tr class="even">
<td align="left"><code>ASSERT_DOUBLE_EQ(</code><em>expected, actual</em><code>);</code></td>
<td align="left"><code>EXPECT_DOUBLE_EQ(</code><em>expected, actual</em><code>);</code></td>
<td align="left">the two <code>double</code> values are almost equal</td>
</tr>
</tbody>
</table>
<p>By &#8220;almost equal&#8221;, we mean the two values are within 4 ULP&#8217;s from each other.</p>
<p>The following assertions allow you to choose the acceptable error bound:</p>
<table style="width:86%;">
<colgroup>
<col width="30%" />
<col width="34%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><strong>Fatal assertion</strong></th>
<th align="left"><strong>Nonfatal assertion</strong></th>
<th align="left"><strong>Verifies</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ASSERT_NEAR(</code><em>val1, val2, abs_error</em><code>);</code></td>
<td align="left"><code>EXPECT_NEAR</code><em>(val1, val2, abs_error</em><code>);</code></td>
<td align="left">the difference between <em>val1</em> and <em>val2</em> doesn&#8217;t exceed the given absolute error</td>
</tr>
</tbody>
</table>
<p><em>Availability</em>: Linux, Windows, Mac.</p>
<h5 id="floating-point-predicate-format-functions">Floating-Point Predicate-Format Functions</h5>
<p>Some floating-point operations are useful, but not that often used. In order to avoid an explosion of new macros, we provide them as predicate-format functions that can be used in predicate assertion macros (e.g. <code>EXPECT_PRED_FORMAT2</code>, etc).</p>
<pre><code>EXPECT_PRED_FORMAT2(::testing::FloatLE, val1, val2);
EXPECT_PRED_FORMAT2(::testing::DoubleLE, val1, val2);</code></pre>
<p>Verifies that <em>val1</em> is less than, or almost equal to, <em>val2</em>. You can replace <code>EXPECT_PRED_FORMAT2</code> in the above table with <code>ASSERT_PRED_FORMAT2</code>.</p>
<p><em>Availability</em>: Linux, Windows, Mac.</p>
<h4 id="windows-hresult-assertions">Windows HRESULT assertions</h4>
<p>These assertions test for <code>HRESULT</code> success or failure.</p>
<table style="width:86%;">
<colgroup>
<col width="30%" />
<col width="34%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><strong>Fatal assertion</strong></th>
<th align="left"><strong>Nonfatal assertion</strong></th>
<th align="left"><strong>Verifies</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ASSERT_HRESULT_SUCCEEDED(</code><em>expression</em><code>);</code></td>
<td align="left"><code>EXPECT_HRESULT_SUCCEEDED(</code><em>expression</em><code>);</code></td>
<td align="left">_expression_ is a success <code>HRESULT</code></td>
</tr>
<tr class="even">
<td align="left"><code>ASSERT_HRESULT_FAILED(</code><em>expression</em><code>);</code></td>
<td align="left"><code>EXPECT_HRESULT_FAILED(</code><em>expression</em><code>);</code></td>
<td align="left"><em>expression</em> is a failure <code>HRESULT</code></td>
</tr>
</tbody>
</table>
<p>The generated output contains the human-readable error message associated with the <code>HRESULT</code> code returned by <em>expression</em>.</p>
<p>You might use them like this:</p>
<pre><code>CComPtr shell;
ASSERT_HRESULT_SUCCEEDED(shell.CoCreateInstance(L&quot;Shell.Application&quot;));
CComVariant empty;
ASSERT_HRESULT_SUCCEEDED(shell-&gt;ShellExecute(CComBSTR(url), empty, empty, empty, empty));</code></pre>
<p><em>Availability</em>: Windows.</p>
<h4 id="type-assertions">Type Assertions</h4>
<p>You can call the function</p>
<pre><code>::testing::StaticAssertTypeEq&lt;T1, T2&gt;();</code></pre>
<p>to assert that types <code>T1</code> and <code>T2</code> are the same. The function does nothing if the assertion is satisfied. If the types are different, the function call will fail to compile, and the compiler error message will likely (depending on the compiler) show you the actual values of <code>T1</code> and <code>T2</code>. This is mainly useful inside template code.</p>
<p><em>Caveat:</em> When used inside a member function of a class template or a function template, <code>StaticAssertTypeEq&lt;T1, T2&gt;()</code> is effective <em>only if</em> the function is instantiated. For example, given:</p>
<pre><code>template &lt;typename T&gt; class Foo {
 public:
  void Bar() { ::testing::StaticAssertTypeEq&lt;int, T&gt;(); }
};</code></pre>
<p>the code:</p>
<pre><code>void Test1() { Foo&lt;bool&gt; foo; }</code></pre>
<p>will <em>not</em> generate a compiler error, as <code>Foo&lt;bool&gt;::Bar()</code> is never actually instantiated. Instead, you need:</p>
<pre><code>void Test2() { Foo&lt;bool&gt; foo; foo.Bar(); }</code></pre>
<p>to cause a compiler error.</p>
<p><em>Availability:</em> Linux, Windows, Mac; since version 1.3.0.</p>
<h4 id="assertion-placement">Assertion Placement</h4>
<p>You can use assertions in any C++ function. In particular, it doesn&#8217;t have to be a method of the test fixture class. The one constraint is that assertions that generate a fatal failure (<code>FAIL*</code> and <code>ASSERT_*</code>) can only be used in void-returning functions. This is a consequence of Google Test not using exceptions. By placing it in a non-void function you&#8217;ll get a confusing compile error like <code>&quot;error: void value not ignored as it ought to be&quot;</code>.</p>
<p>If you need to use assertions in a function that returns non-void, one option is to make the function return the value in an out parameter instead. For example, you can rewrite <code>T2 Foo(T1 x)</code> to <code>void Foo(T1 x, T2* result)</code>. You need to make sure that <code>*result</code> contains some sensible value even when the function returns prematurely. As the function now returns <code>void</code>, you can use any assertion inside of it.</p>
<p>If changing the function&#8217;s type is not an option, you should just use assertions that generate non-fatal failures, such as <code>ADD_FAILURE*</code> and <code>EXPECT_*</code>.</p>
<p><em>Note</em>: Constructors and destructors are not considered void-returning functions, according to the C++ language specification, and so you may not use fatal assertions in them. You&#8217;ll get a compilation error if you try. A simple workaround is to transfer the entire body of the constructor or destructor to a private void-returning method. However, you should be aware that a fatal assertion failure in a constructor does not terminate the current test, as your intuition might suggest; it merely returns from the constructor early, possibly leaving your object in a partially-constructed state. Likewise, a fatal assertion failure in a destructor may leave your object in a partially-destructed state. Use assertions carefully in these situations!</p>
<h3 id="teaching-google-test-how-to-print-your-values">Teaching Google Test How to Print Your Values</h3>
<p>When a test assertion such as <code>EXPECT_EQ</code> fails, Google Test prints the argument values to help you debug. It does this using a user-extensible value printer.</p>
<p>This printer knows how to print built-in C++ types, native arrays, STL containers, and any type that supports the <code>&lt;&lt;</code> operator. For other types, it prints the raw bytes in the value and hopes that you the user can figure it out.</p>
<p>As mentioned earlier, the printer is <em>extensible</em>. That means you can teach it to do a better job at printing your particular type than to dump the bytes. To do that, define <code>&lt;&lt;</code> for your type:</p>
<pre><code>#include &lt;iostream&gt;

namespace foo {

class Bar { ... };  // We want Google Test to be able to print instances of this.

// It&#39;s important that the &lt;&lt; operator is defined in the SAME
// namespace that defines Bar.  C++&#39;s look-up rules rely on that.
::std::ostream&amp; operator&lt;&lt;(::std::ostream&amp; os, const Bar&amp; bar) {
  return os &lt;&lt; bar.DebugString();  // whatever needed to print bar to os
}

}  // namespace foo</code></pre>
<p>Sometimes, this might not be an option: your team may consider it bad style to have a <code>&lt;&lt;</code> operator for <code>Bar</code>, or <code>Bar</code> may already have a <code>&lt;&lt;</code> operator that doesn&#8217;t do what you want (and you cannot change it). If so, you can instead define a <code>PrintTo()</code> function like this:</p>
<pre><code>#include &lt;iostream&gt;

namespace foo {

class Bar { ... };

// It&#39;s important that PrintTo() is defined in the SAME
// namespace that defines Bar.  C++&#39;s look-up rules rely on that.
void PrintTo(const Bar&amp; bar, ::std::ostream* os) {
  *os &lt;&lt; bar.DebugString();  // whatever needed to print bar to os
}

}  // namespace foo</code></pre>
<p>If you have defined both <code>&lt;&lt;</code> and <code>PrintTo()</code>, the latter will be used when Google Test is concerned. This allows you to customize how the value appears in Google Test&#8217;s output without affecting code that relies on the behavior of its <code>&lt;&lt;</code> operator.</p>
<p>If you want to print a value <code>x</code> using Google Test&#8217;s value printer yourself, just call <code>::testing::PrintToString(</code><em>x</em><code>)</code>, which returns an <code>std::string</code>:</p>
<pre><code>vector&lt;pair&lt;Bar, int&gt; &gt; bar_ints = GetBarIntVector();

EXPECT_TRUE(IsCorrectBarIntVector(bar_ints))
    &lt;&lt; &quot;bar_ints = &quot; &lt;&lt; ::testing::PrintToString(bar_ints);</code></pre>
<h3 id="death-tests">Death Tests</h3>
<p>In many applications, there are assertions that can cause application failure if a condition is not met. These sanity checks, which ensure that the program is in a known good state, are there to fail at the earliest possible time after some program state is corrupted. If the assertion checks the wrong condition, then the program may proceed in an erroneous state, which could lead to memory corruption, security holes, or worse. Hence it is vitally important to test that such assertion statements work as expected.</p>
<p>Since these precondition checks cause the processes to die, we call such tests <em>death tests</em>. More generally, any test that checks that a program terminates (except by throwing an exception) in an expected fashion is also a death test.</p>
<p>Note that if a piece of code throws an exception, we don&#8217;t consider it &#8220;death&#8221; for the purpose of death tests, as the caller of the code could catch the exception and avoid the crash. If you want to verify exceptions thrown by your code, see <a href="#exception-assertions">Exception Assertions</a>.</p>
<p>If you want to test <code>EXPECT_*()/ASSERT_*()</code> failures in your test code, see <a href="#catching-failures">Catching Failures</a>.</p>
<h4 id="how-to-write-a-death-test">How to Write a Death Test</h4>
<p>Google Test has the following macros to support death tests:</p>
<table style="width:86%;">
<colgroup>
<col width="30%" />
<col width="34%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><strong>Fatal assertion</strong></th>
<th align="left"><strong>Nonfatal assertion</strong></th>
<th align="left"><strong>Verifies</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ASSERT_DEATH(</code><em>statement, regex</em><code>); |</code>EXPECT_DEATH(<code>_statement, regex_</code>);</td>
<td align="left"><em>statement</em> crashes with the given error</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>ASSERT_DEATH_IF_SUPPORTED(</code><em>statement, regex</em><code>); |</code>EXPECT_DEATH_IF_SUPPORTED(<code>_statement, regex_</code>);</td>
<td align="left">if death tests are supported, verifies that <em>statement</em> crashes with the given error; otherwise verifies nothing</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>ASSERT_EXIT(</code><em>statement, predicate, regex</em><code>); |</code>EXPECT_EXIT(<code>_statement, predicate, regex_</code>);</td>
<td align="left"><em>statement</em> exits with the given error and its exit code matches <em>predicate</em></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>where <em>statement</em> is a statement that is expected to cause the process to die, <em>predicate</em> is a function or function object that evaluates an integer exit status, and <em>regex</em> is a regular expression that the stderr output of <em>statement</em> is expected to match. Note that <em>statement</em> can be <em>any valid statement</em> (including <em>compound statement</em>) and doesn&#8217;t have to be an expression.</p>
<p>As usual, the <code>ASSERT</code> variants abort the current test function, while the <code>EXPECT</code> variants do not.</p>
<p><strong>Note:</strong> We use the word &#8220;crash&#8221; here to mean that the process terminates with a <em>non-zero</em> exit status code. There are two possibilities: either the process has called <code>exit()</code> or <code>_exit()</code> with a non-zero value, or it may be killed by a signal.</p>
<p>This means that if <em>statement</em> terminates the process with a 0 exit code, it is <em>not</em> considered a crash by <code>EXPECT_DEATH</code>. Use <code>EXPECT_EXIT</code> instead if this is the case, or if you want to restrict the exit code more precisely.</p>
<p>A predicate here must accept an <code>int</code> and return a <code>bool</code>. The death test succeeds only if the predicate returns <code>true</code>. Google Test defines a few predicates that handle the most common cases:</p>
<pre><code>::testing::ExitedWithCode(exit_code)</code></pre>
<p>This expression is <code>true</code> if the program exited normally with the given exit code.</p>
<pre><code>::testing::KilledBySignal(signal_number)  // Not available on Windows.</code></pre>
<p>This expression is <code>true</code> if the program was killed by the given signal.</p>
<p>The <code>*_DEATH</code> macros are convenient wrappers for <code>*_EXIT</code> that use a predicate that verifies the process&#8217; exit code is non-zero.</p>
<p>Note that a death test only cares about three things:</p>
<ol style="list-style-type: decimal">
<li>does <em>statement</em> abort or exit the process?</li>
<li>(in the case of <code>ASSERT_EXIT</code> and <code>EXPECT_EXIT</code>) does the exit status satisfy <em>predicate</em>? Or (in the case of <code>ASSERT_DEATH</code> and <code>EXPECT_DEATH</code>) is the exit status non-zero? And</li>
<li>does the stderr output match <em>regex</em>?</li>
</ol>
<p>In particular, if <em>statement</em> generates an <code>ASSERT_*</code> or <code>EXPECT_*</code> failure, it will <strong>not</strong> cause the death test to fail, as Google Test assertions don&#8217;t abort the process.</p>
<p>To write a death test, simply use one of the above macros inside your test function. For example,</p>
<pre><code>TEST(My*DeathTest*, Foo) {
  // This death test uses a compound statement.
  ASSERT_DEATH({ int n = 5; Foo(&amp;n); }, &quot;Error on line .* of Foo()&quot;);
}
TEST(MyDeathTest, NormalExit) {
  EXPECT_EXIT(NormalExit(), ::testing::ExitedWithCode(0), &quot;Success&quot;);
}
TEST(MyDeathTest, KillMyself) {
  EXPECT_EXIT(KillMyself(), ::testing::KilledBySignal(SIGKILL), &quot;Sending myself unblockable signal&quot;);
}</code></pre>
<p>verifies that:</p>
<ul>
<li>calling <code>Foo(5)</code> causes the process to die with the given error message,</li>
<li>calling <code>NormalExit()</code> causes the process to print <code>&quot;Success&quot;</code> to stderr and exit with exit code 0, and</li>
<li>calling <code>KillMyself()</code> kills the process with signal <code>SIGKILL</code>.</li>
</ul>
<p>The test function body may contain other assertions and statements as well, if necessary.</p>
<p><em>Important:</em> We strongly recommend you to follow the convention of naming your test case (not test) <code>*DeathTest</code> when it contains a death test, as demonstrated in the above example. The <code>Death Tests And Threads</code> section below explains why.</p>
<p>If a test fixture class is shared by normal tests and death tests, you can use typedef to introduce an alias for the fixture class and avoid duplicating its code:</p>
<pre><code>class FooTest : public ::testing::Test { ... };

typedef FooTest FooDeathTest;

TEST_F(FooTest, DoesThis) {
  // normal test
}

TEST_F(FooDeathTest, DoesThat) {
  // death test
}</code></pre>
<p><em>Availability:</em> Linux, Windows (requires MSVC 8.0 or above), Cygwin, and Mac (the latter three are supported since v1.3.0). <code>(ASSERT|EXPECT)_DEATH_IF_SUPPORTED</code> are new in v1.4.0.</p>
<h4 id="regular-expression-syntax">Regular Expression Syntax</h4>
<p>On POSIX systems (e.g.&#160;Linux, Cygwin, and Mac), Google Test uses the <a href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html#tag_09_04">POSIX extended regular expression</a> syntax in death tests. To learn about this syntax, you may want to read this <a href="http://en.wikipedia.org/wiki/Regular_expression#POSIX_Extended_Regular_Expressions">Wikipedia entry</a>.</p>
<p>On Windows, Google Test uses its own simple regular expression implementation. It lacks many features you can find in POSIX extended regular expressions. For example, we don&#8217;t support union (<code>&quot;x|y&quot;</code>), grouping (<code>&quot;(xy)&quot;</code>), brackets (<code>&quot;[xy]&quot;</code>), and repetition count (<code>&quot;x{5,7}&quot;</code>), among others. Below is what we do support (<code>A</code> denotes a literal character, period (<code>.</code>), or a single <code>\\</code> escape sequence; <code>x</code> and <code>y</code> denote regular expressions.):</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>c</code></th>
<th align="left">matches any literal character <code>c</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>\\d</code></td>
<td align="left">matches any decimal digit</td>
</tr>
<tr class="even">
<td align="left"><code>\\D</code></td>
<td align="left">matches any character that&#8217;s not a decimal digit</td>
</tr>
<tr class="odd">
<td align="left"><code>\\f</code></td>
<td align="left">matches <code>\f</code></td>
</tr>
<tr class="even">
<td align="left"><code>\\n</code></td>
<td align="left">matches <code>\n</code></td>
</tr>
<tr class="odd">
<td align="left"><code>\\r</code></td>
<td align="left">matches <code>\r</code></td>
</tr>
<tr class="even">
<td align="left"><code>\\s</code></td>
<td align="left">matches any ASCII whitespace, including <code>\n</code></td>
</tr>
<tr class="odd">
<td align="left"><code>\\S</code></td>
<td align="left">matches any character that&#8217;s not a whitespace</td>
</tr>
<tr class="even">
<td align="left"><code>\\t</code></td>
<td align="left">matches <code>\t</code></td>
</tr>
<tr class="odd">
<td align="left"><code>\\v</code></td>
<td align="left">matches <code>\v</code></td>
</tr>
<tr class="even">
<td align="left"><code>\\w</code></td>
<td align="left">matches any letter, <code>_</code>, or decimal digit</td>
</tr>
<tr class="odd">
<td align="left"><code>\\W</code></td>
<td align="left">matches any character that <code>\\w</code> doesn&#8217;t match</td>
</tr>
<tr class="even">
<td align="left"><code>\\c</code></td>
<td align="left">matches any literal character <code>c</code>, which must be a punctuation</td>
</tr>
<tr class="odd">
<td align="left"><code>.</code></td>
<td align="left">matches any single character except <code>\n</code></td>
</tr>
<tr class="even">
<td align="left"><code>A?</code></td>
<td align="left">matches 0 or 1 occurrences of <code>A</code></td>
</tr>
<tr class="odd">
<td align="left"><code>A*</code></td>
<td align="left">matches 0 or many occurrences of <code>A</code></td>
</tr>
<tr class="even">
<td align="left"><code>A+</code></td>
<td align="left">matches 1 or many occurrences of <code>A</code></td>
</tr>
<tr class="odd">
<td align="left"><code>^</code></td>
<td align="left">matches the beginning of a string (not that of each line)</td>
</tr>
<tr class="even">
<td align="left"><code>$</code></td>
<td align="left">matches the end of a string (not that of each line)</td>
</tr>
<tr class="odd">
<td align="left"><code>xy</code></td>
<td align="left">matches <code>x</code> followed by <code>y</code></td>
</tr>
</tbody>
</table>
<p>To help you determine which capability is available on your system, Google Test defines macro <code>GTEST_USES_POSIX_RE=1</code> when it uses POSIX extended regular expressions, or <code>GTEST_USES_SIMPLE_RE=1</code> when it uses the simple version. If you want your death tests to work in both cases, you can either <code>#if</code> on these macros or use the more limited syntax only.</p>
<h4 id="how-it-works">How It Works</h4>
<p>Under the hood, <code>ASSERT_EXIT()</code> spawns a new process and executes the death test statement in that process. The details of of how precisely that happens depend on the platform and the variable <code>::testing::GTEST_FLAG(death_test_style)</code> (which is initialized from the command-line flag <code>--gtest_death_test_style</code>).</p>
<ul>
<li>On POSIX systems, <code>fork()</code> (or <code>clone()</code> on Linux) is used to spawn the child, after which:
<ul>
<li>If the variable&#8217;s value is <code>&quot;fast&quot;</code>, the death test statement is immediately executed.</li>
<li>If the variable&#8217;s value is <code>&quot;threadsafe&quot;</code>, the child process re-executes the unit test binary just as it was originally invoked, but with some extra flags to cause just the single death test under consideration to be run.</li>
</ul></li>
<li>On Windows, the child is spawned using the <code>CreateProcess()</code> API, and re-executes the binary to cause just the single death test under consideration to be run - much like the <code>threadsafe</code> mode on POSIX.</li>
</ul>
<p>Other values for the variable are illegal and will cause the death test to fail. Currently, the flag&#8217;s default value is <code>&quot;fast&quot;</code>. However, we reserve the right to change it in the future. Therefore, your tests should not depend on this.</p>
<p>In either case, the parent process waits for the child process to complete, and checks that</p>
<ol style="list-style-type: decimal">
<li>the child&#8217;s exit status satisfies the predicate, and</li>
<li>the child&#8217;s stderr matches the regular expression.</li>
</ol>
<p>If the death test statement runs to completion without dying, the child process will nonetheless terminate, and the assertion fails.</p>
<h4 id="death-tests-and-threads">Death Tests And Threads</h4>
<p>The reason for the two death test styles has to do with thread safety. Due to well-known problems with forking in the presence of threads, death tests should be run in a single-threaded context. Sometimes, however, it isn&#8217;t feasible to arrange that kind of environment. For example, statically-initialized modules may start threads before main is ever reached. Once threads have been created, it may be difficult or impossible to clean them up.</p>
<p>Google Test has three features intended to raise awareness of threading issues.</p>
<ol style="list-style-type: decimal">
<li>A warning is emitted if multiple threads are running when a death test is encountered.</li>
<li>Test cases with a name ending in &#8220;DeathTest&#8221; are run before all other tests.</li>
<li>It uses <code>clone()</code> instead of <code>fork()</code> to spawn the child process on Linux (<code>clone()</code> is not available on Cygwin and Mac), as <code>fork()</code> is more likely to cause the child to hang when the parent process has multiple threads.</li>
</ol>
<p>It&#8217;s perfectly fine to create threads inside a death test statement; they are executed in a separate process and cannot affect the parent.</p>
<h4 id="death-test-styles">Death Test Styles</h4>
<p>The &#8220;threadsafe&#8221; death test style was introduced in order to help mitigate the risks of testing in a possibly multithreaded environment. It trades increased test execution time (potentially dramatically so) for improved thread safety. We suggest using the faster, default &#8220;fast&#8221; style unless your test has specific problems with it.</p>
<p>You can choose a particular style of death tests by setting the flag programmatically:</p>
<pre><code>::testing::FLAGS_gtest_death_test_style = &quot;threadsafe&quot;;</code></pre>
<p>You can do this in <code>main()</code> to set the style for all death tests in the binary, or in individual tests. Recall that flags are saved before running each test and restored afterwards, so you need not do that yourself. For example:</p>
<pre><code>TEST(MyDeathTest, TestOne) {
  ::testing::FLAGS_gtest_death_test_style = &quot;threadsafe&quot;;
  // This test is run in the &quot;threadsafe&quot; style:
  ASSERT_DEATH(ThisShouldDie(), &quot;&quot;);
}

TEST(MyDeathTest, TestTwo) {
  // This test is run in the &quot;fast&quot; style:
  ASSERT_DEATH(ThisShouldDie(), &quot;&quot;);
}

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&amp;argc, argv);
  ::testing::FLAGS_gtest_death_test_style = &quot;fast&quot;;
  return RUN_ALL_TESTS();
}</code></pre>
<h4 id="caveats">Caveats</h4>
<p>The <em>statement</em> argument of <code>ASSERT_EXIT()</code> can be any valid C++ statement. If it leaves the current function via a <code>return</code> statement or by throwing an exception, the death test is considered to have failed. Some Google Test macros may return from the current function (e.g. <code>ASSERT_TRUE()</code>), so be sure to avoid them in <em>statement</em>.</p>
<p>Since <em>statement</em> runs in the child process, any in-memory side effect (e.g.&#160;modifying a variable, releasing memory, etc) it causes will <em>not</em> be observable in the parent process. In particular, if you release memory in a death test, your program will fail the heap check as the parent process will never see the memory reclaimed. To solve this problem, you can</p>
<ol style="list-style-type: decimal">
<li>try not to free memory in a death test;</li>
<li>free the memory again in the parent process; or</li>
<li>do not use the heap checker in your program.</li>
</ol>
<p>Due to an implementation detail, you cannot place multiple death test assertions on the same line; otherwise, compilation will fail with an unobvious error message.</p>
<p>Despite the improved thread safety afforded by the &#8220;threadsafe&#8221; style of death test, thread problems such as deadlock are still possible in the presence of handlers registered with <code>pthread_atfork(3)</code>.</p>
<h3 id="using-assertions-in-sub-routines">Using Assertions in Sub-routines</h3>
<h4 id="adding-traces-to-assertions">Adding Traces to Assertions</h4>
<p>If a test sub-routine is called from several places, when an assertion inside it fails, it can be hard to tell which invocation of the sub-routine the failure is from. You can alleviate this problem using extra logging or custom failure messages, but that usually clutters up your tests. A better solution is to use the <code>SCOPED_TRACE</code> macro:</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>SCOPED_TRACE(</code><em>message</em><code>);</code></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>where <em>message</em> can be anything streamable to <code>std::ostream</code>. This macro will cause the current file name, line number, and the given message to be added in every failure message. The effect will be undone when the control leaves the current lexical scope.</p>
<p>For example,</p>
<pre><code>10: void Sub1(int n) {
11:   EXPECT_EQ(1, Bar(n));
12:   EXPECT_EQ(2, Bar(n + 1));
13: }
14:
15: TEST(FooTest, Bar) {
16:   {
17:     SCOPED_TRACE(&quot;A&quot;);  // This trace point will be included in
18:                         // every failure in this scope.
19:     Sub1(1);
20:   }
21:   // Now it won&#39;t.
22:   Sub1(9);
23: }</code></pre>
<p>could result in messages like these:</p>
<pre><code>path/to/foo_test.cc:11: Failure
Value of: Bar(n)
Expected: 1
  Actual: 2
   Trace:
path/to/foo_test.cc:17: A

path/to/foo_test.cc:12: Failure
Value of: Bar(n + 1)
Expected: 2
  Actual: 3</code></pre>
<p>Without the trace, it would&#8217;ve been difficult to know which invocation of <code>Sub1()</code> the two failures come from respectively. (You could add an extra message to each assertion in <code>Sub1()</code> to indicate the value of <code>n</code>, but that&#8217;s tedious.)</p>
<p>Some tips on using <code>SCOPED_TRACE</code>:</p>
<ol style="list-style-type: decimal">
<li>With a suitable message, it&#8217;s often enough to use <code>SCOPED_TRACE</code> at the beginning of a sub-routine, instead of at each call site.</li>
<li>When calling sub-routines inside a loop, make the loop iterator part of the message in <code>SCOPED_TRACE</code> such that you can know which iteration the failure is from.</li>
<li>Sometimes the line number of the trace point is enough for identifying the particular invocation of a sub-routine. In this case, you don&#8217;t have to choose a unique message for <code>SCOPED_TRACE</code>. You can simply use <code>&quot;&quot;</code>.</li>
<li>You can use <code>SCOPED_TRACE</code> in an inner scope when there is one in the outer scope. In this case, all active trace points will be included in the failure messages, in reverse order they are encountered.</li>
<li>The trace dump is clickable in Emacs&#8217; compilation buffer - hit return on a line number and you&#8217;ll be taken to that line in the source file!</li>
</ol>
<p><em>Availability:</em> Linux, Windows, Mac.</p>
<h4 id="propagating-fatal-failures">Propagating Fatal Failures</h4>
<p>A common pitfall when using <code>ASSERT_*</code> and <code>FAIL*</code> is not understanding that when they fail they only abort the <em>current function</em>, not the entire test. For example, the following test will segfault:</p>
<pre><code>void Subroutine() {
  // Generates a fatal failure and aborts the current function.
  ASSERT_EQ(1, 2);
  // The following won&#39;t be executed.
  ...
}

TEST(FooTest, Bar) {
  Subroutine();
  // The intended behavior is for the fatal failure
  // in Subroutine() to abort the entire test.
  // The actual behavior: the function goes on after Subroutine() returns.
  int* p = NULL;
  *p = 3; // Segfault!
}</code></pre>
<p>Since we don&#8217;t use exceptions, it is technically impossible to implement the intended behavior here. To alleviate this, Google Test provides two solutions. You could use either the <code>(ASSERT|EXPECT)_NO_FATAL_FAILURE</code> assertions or the <code>HasFatalFailure()</code> function. They are described in the following two subsections.</p>
<h5 id="asserting-on-subroutines">Asserting on Subroutines</h5>
<p>As shown above, if your test calls a subroutine that has an <code>ASSERT_*</code> failure in it, the test will continue after the subroutine returns. This may not be what you want.</p>
<p>Often people want fatal failures to propagate like exceptions. For that Google Test offers the following macros:</p>
<table style="width:86%;">
<colgroup>
<col width="30%" />
<col width="34%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><strong>Fatal assertion</strong></th>
<th align="left"><strong>Nonfatal assertion</strong></th>
<th align="left"><strong>Verifies</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ASSERT_NO_FATAL_FAILURE(</code><em>statement</em><code>);</code></td>
<td align="left"><code>EXPECT_NO_FATAL_FAILURE(</code><em>statement</em><code>);</code></td>
<td align="left"><em>statement</em> doesn&#8217;t generate any new fatal failures in the current thread.</td>
</tr>
</tbody>
</table>
<p>Only failures in the thread that executes the assertion are checked to determine the result of this type of assertions. If <em>statement</em> creates new threads, failures in these threads are ignored.</p>
<p>Examples:</p>
<pre><code>ASSERT_NO_FATAL_FAILURE(Foo());

int i;
EXPECT_NO_FATAL_FAILURE({
  i = Bar();
});</code></pre>
<p><em>Availability:</em> Linux, Windows, Mac. Assertions from multiple threads are currently not supported.</p>
<h5 id="checking-for-failures-in-the-current-test">Checking for Failures in the Current Test</h5>
<p><code>HasFatalFailure()</code> in the <code>::testing::Test</code> class returns <code>true</code> if an assertion in the current test has suffered a fatal failure. This allows functions to catch fatal failures in a sub-routine and return early.</p>
<pre><code>class Test {
 public:
  ...
  static bool HasFatalFailure();
};</code></pre>
<p>The typical usage, which basically simulates the behavior of a thrown exception, is:</p>
<pre><code>TEST(FooTest, Bar) {
  Subroutine();
  // Aborts if Subroutine() had a fatal failure.
  if (HasFatalFailure())
    return;
  // The following won&#39;t be executed.
  ...
}</code></pre>
<p>If <code>HasFatalFailure()</code> is used outside of <code>TEST()</code> , <code>TEST_F()</code> , or a test fixture, you must add the <code>::testing::Test::</code> prefix, as in:</p>
<pre><code>if (::testing::Test::HasFatalFailure())
  return;</code></pre>
<p>Similarly, <code>HasNonfatalFailure()</code> returns <code>true</code> if the current test has at least one non-fatal failure, and <code>HasFailure()</code> returns <code>true</code> if the current test has at least one failure of either kind.</p>
<p><em>Availability:</em> Linux, Windows, Mac. <code>HasNonfatalFailure()</code> and <code>HasFailure()</code> are available since version 1.4.0.</p>
<h3 id="logging-additional-information">Logging Additional Information</h3>
<p>In your test code, you can call <code>RecordProperty(&quot;key&quot;, value)</code> to log additional information, where <code>value</code> can be either a C string or a 32-bit integer. The <em>last</em> value recorded for a key will be emitted to the XML output if you specify one. For example, the test</p>
<pre><code>TEST_F(WidgetUsageTest, MinAndMaxWidgets) {
  RecordProperty(&quot;MaximumWidgets&quot;, ComputeMaxUsage());
  RecordProperty(&quot;MinimumWidgets&quot;, ComputeMinUsage());
}</code></pre>
<p>will output XML like this:</p>
<pre><code>...
  &lt;testcase name=&quot;MinAndMaxWidgets&quot; status=&quot;run&quot; time=&quot;6&quot; classname=&quot;WidgetUsageTest&quot;
            MaximumWidgets=&quot;12&quot;
            MinimumWidgets=&quot;9&quot; /&gt;
...</code></pre>
<p><em>Note</em>: * <code>RecordProperty()</code> is a static member of the <code>Test</code> class. Therefore it needs to be prefixed with <code>::testing::Test::</code> if used outside of the <code>TEST</code> body and the test fixture class. * <code>key</code> must be a valid XML attribute name, and cannot conflict with the ones already used by Google Test (<code>name</code>, <code>status</code>, <code>time</code>, and <code>classname</code>).</p>
<p><em>Availability</em>: Linux, Windows, Mac.</p>
<h3 id="sharing-resources-between-tests-in-the-same-test-case">Sharing Resources Between Tests in the Same Test Case</h3>
<p>Google Test creates a new test fixture object for each test in order to make tests independent and easier to debug. However, sometimes tests use resources that are expensive to set up, making the one-copy-per-test model prohibitively expensive.</p>
<p>If the tests don&#8217;t change the resource, there&#8217;s no harm in them sharing a single resource copy. So, in addition to per-test set-up/tear-down, Google Test also supports per-test-case set-up/tear-down. To use it:</p>
<ol style="list-style-type: decimal">
<li>In your test fixture class (say <code>FooTest</code> ), define as <code>static</code> some member variables to hold the shared resources.</li>
<li>In the same test fixture class, define a <code>static void SetUpTestCase()</code> function (remember not to spell it as <strong><code>SetupTestCase</code></strong> with a small <code>u</code>!) to set up the shared resources and a <code>static void TearDownTestCase()</code> function to tear them down.</li>
</ol>
<p>That&#8217;s it! Google Test automatically calls <code>SetUpTestCase()</code> before running the <em>first test</em> in the <code>FooTest</code> test case (i.e.&#160;before creating the first <code>FooTest</code> object), and calls <code>TearDownTestCase()</code> after running the <em>last test</em> in it (i.e.&#160;after deleting the last <code>FooTest</code> object). In between, the tests can use the shared resources.</p>
<p>Remember that the test order is undefined, so your code can&#8217;t depend on a test preceding or following another. Also, the tests must either not modify the state of any shared resource, or, if they do modify the state, they must restore the state to its original value before passing control to the next test.</p>
<p>Here&#8217;s an example of per-test-case set-up and tear-down:</p>
<pre><code>class FooTest : public ::testing::Test {
 protected:
  // Per-test-case set-up.
  // Called before the first test in this test case.
  // Can be omitted if not needed.
  static void SetUpTestCase() {
    shared_resource_ = new ...;
  }

  // Per-test-case tear-down.
  // Called after the last test in this test case.
  // Can be omitted if not needed.
  static void TearDownTestCase() {
    delete shared_resource_;
    shared_resource_ = NULL;
  }

  // You can define per-test set-up and tear-down logic as usual.
  virtual void SetUp() { ... }
  virtual void TearDown() { ... }

  // Some expensive resource shared by all tests.
  static T* shared_resource_;
};

T* FooTest::shared_resource_ = NULL;

TEST_F(FooTest, Test1) {
  ... you can refer to shared_resource here ...
}
TEST_F(FooTest, Test2) {
  ... you can refer to shared_resource here ...
}</code></pre>
<p><em>Availability:</em> Linux, Windows, Mac.</p>
<h3 id="global-set-up-and-tear-down">Global Set-Up and Tear-Down</h3>
<p>Just as you can do set-up and tear-down at the test level and the test case level, you can also do it at the test program level. Here&#8217;s how.</p>
<p>First, you subclass the <code>::testing::Environment</code> class to define a test environment, which knows how to set-up and tear-down:</p>
<pre><code>class Environment {
 public:
  virtual ~Environment() {}
  // Override this to define how to set up the environment.
  virtual void SetUp() {}
  // Override this to define how to tear down the environment.
  virtual void TearDown() {}
};</code></pre>
<p>Then, you register an instance of your environment class with Google Test by calling the <code>::testing::AddGlobalTestEnvironment()</code> function:</p>
<pre><code>Environment* AddGlobalTestEnvironment(Environment* env);</code></pre>
<p>Now, when <code>RUN_ALL_TESTS()</code> is called, it first calls the <code>SetUp()</code> method of the environment object, then runs the tests if there was no fatal failures, and finally calls <code>TearDown()</code> of the environment object.</p>
<p>It&#8217;s OK to register multiple environment objects. In this case, their <code>SetUp()</code> will be called in the order they are registered, and their <code>TearDown()</code> will be called in the reverse order.</p>
<p>Note that Google Test takes ownership of the registered environment objects. Therefore <strong>do not delete them</strong> by yourself.</p>
<p>You should call <code>AddGlobalTestEnvironment()</code> before <code>RUN_ALL_TESTS()</code> is called, probably in <code>main()</code>. If you use <code>gtest_main</code>, you need to call this before <code>main()</code> starts for it to take effect. One way to do this is to define a global variable like this:</p>
<pre><code>::testing::Environment* const foo_env = ::testing::AddGlobalTestEnvironment(new FooEnvironment);</code></pre>
<p>However, we strongly recommend you to write your own <code>main()</code> and call <code>AddGlobalTestEnvironment()</code> there, as relying on initialization of global variables makes the code harder to read and may cause problems when you register multiple environments from different translation units and the environments have dependencies among them (remember that the compiler doesn&#8217;t guarantee the order in which global variables from different translation units are initialized).</p>
<p><em>Availability:</em> Linux, Windows, Mac.</p>
<h3 id="value-parameterized-tests">Value Parameterized Tests</h3>
<p><em>Value-parameterized tests</em> allow you to test your code with different parameters without writing multiple copies of the same test.</p>
<p>Suppose you write a test for your code and then realize that your code is affected by a presence of a Boolean command line flag.</p>
<pre><code>TEST(MyCodeTest, TestFoo) {
  // A code to test foo().
}</code></pre>
<p>Usually people factor their test code into a function with a Boolean parameter in such situations. The function sets the flag, then executes the testing code.</p>
<pre><code>void TestFooHelper(bool flag_value) {
  flag = flag_value;
  // A code to test foo().
}

TEST(MyCodeTest, TestFooo) {
  TestFooHelper(false);
  TestFooHelper(true);
}</code></pre>
<p>But this setup has serious drawbacks. First, when a test assertion fails in your tests, it becomes unclear what value of the parameter caused it to fail. You can stream a clarifying message into your <code>EXPECT</code>/<code>ASSERT</code> statements, but it you&#8217;ll have to do it with all of them. Second, you have to add one such helper function per test. What if you have ten tests? Twenty? A hundred?</p>
<p>Value-parameterized tests will let you write your test only once and then easily instantiate and run it with an arbitrary number of parameter values.</p>
<p>Here are some other situations when value-parameterized tests come handy:</p>
<ul>
<li>You want to test different implementations of an OO interface.</li>
<li>You want to test your code over various inputs (a.k.a. data-driven testing). This feature is easy to abuse, so please exercise your good sense when doing it!</li>
</ul>
<h4 id="how-to-write-value-parameterized-tests">How to Write Value-Parameterized Tests</h4>
<p>To write value-parameterized tests, first you should define a fixture class. It must be derived from both <code>::testing::Test</code> and <code>::testing::WithParamInterface&lt;T&gt;</code> (the latter is a pure interface), where <code>T</code> is the type of your parameter values. For convenience, you can just derive the fixture class from <code>::testing::TestWithParam&lt;T&gt;</code>, which itself is derived from both <code>::testing::Test</code> and <code>::testing::WithParamInterface&lt;T&gt;</code>. <code>T</code> can be any copyable type. If it&#8217;s a raw pointer, you are responsible for managing the lifespan of the pointed values.</p>
<pre><code>class FooTest : public ::testing::TestWithParam&lt;const char*&gt; {
  // You can implement all the usual fixture class members here.
  // To access the test parameter, call GetParam() from class
  // TestWithParam&lt;T&gt;.
};

// Or, when you want to add parameters to a pre-existing fixture class:
class BaseTest : public ::testing::Test {
  ...
};
class BarTest : public BaseTest,
                public ::testing::WithParamInterface&lt;const char*&gt; {
  ...
};</code></pre>
<p>Then, use the <code>TEST_P</code> macro to define as many test patterns using this fixture as you want. The <code>_P</code> suffix is for &#8220;parameterized&#8221; or &#8220;pattern&#8221;, whichever you prefer to think.</p>
<pre><code>TEST_P(FooTest, DoesBlah) {
  // Inside a test, access the test parameter with the GetParam() method
  // of the TestWithParam&lt;T&gt; class:
  EXPECT_TRUE(foo.Blah(GetParam()));
  ...
}

TEST_P(FooTest, HasBlahBlah) {
  ...
}</code></pre>
<p>Finally, you can use <code>INSTANTIATE_TEST_CASE_P</code> to instantiate the test case with any set of parameters you want. Google Test defines a number of functions for generating test parameters. They return what we call (surprise!) <em>parameter generators</em>. Here is a summary of them, which are all in the <code>testing</code> namespace:</p>
<table>
<colgroup>
<col width="20%" />
<col width="79%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>Range(begin, end[, step])</code></th>
<th align="left">Yields values <code>{begin, begin+step, begin+step+step, ...}</code>. The values do not include <code>end</code>. <code>step</code> defaults to 1.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>Values(v1, v2, ..., vN)</code></td>
<td align="left">Yields values <code>{v1, v2, ..., vN}</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>ValuesIn(container)</code> and <code>ValuesIn(begin, end)</code></td>
<td align="left">Yields values from a C-style array, an STL-style container, or an iterator range <code>[begin, end)</code>. <code>container</code>, <code>begin</code>, and <code>end</code> can be expressions whose values are determined at run time.</td>
</tr>
<tr class="odd">
<td align="left"><code>Bool()</code></td>
<td align="left">Yields sequence <code>{false, true}</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>Combine(g1, g2, ..., gN)</code></td>
<td align="left">Yields all combinations (the Cartesian product for the math savvy) of the values generated by the <code>N</code> generators. This is only available if your system provides the <code>&lt;tr1/tuple&gt;</code> header. If you are sure your system does, and Google Test disagrees, you can override it by defining <code>GTEST_HAS_TR1_TUPLE=1</code>. See comments in <a href="../include/gtest/internal/gtest-port.h">include/gtest/internal/gtest-port.h</a> for more information.</td>
</tr>
</tbody>
</table>
<p>For more details, see the comments at the definitions of these functions in the <a href="../include/gtest/gtest-param-test.h">source code</a>.</p>
<p>The following statement will instantiate tests from the <code>FooTest</code> test case each with parameter values <code>&quot;meeny&quot;</code>, <code>&quot;miny&quot;</code>, and <code>&quot;moe&quot;</code>.</p>
<pre><code>INSTANTIATE_TEST_CASE_P(InstantiationName,
                        FooTest,
                        ::testing::Values(&quot;meeny&quot;, &quot;miny&quot;, &quot;moe&quot;));</code></pre>
<p>To distinguish different instances of the pattern (yes, you can instantiate it more than once), the first argument to <code>INSTANTIATE_TEST_CASE_P</code> is a prefix that will be added to the actual test case name. Remember to pick unique prefixes for different instantiations. The tests from the instantiation above will have these names:</p>
<ul>
<li><code>InstantiationName/FooTest.DoesBlah/0</code> for <code>&quot;meeny&quot;</code></li>
<li><code>InstantiationName/FooTest.DoesBlah/1</code> for <code>&quot;miny&quot;</code></li>
<li><code>InstantiationName/FooTest.DoesBlah/2</code> for <code>&quot;moe&quot;</code></li>
<li><code>InstantiationName/FooTest.HasBlahBlah/0</code> for <code>&quot;meeny&quot;</code></li>
<li><code>InstantiationName/FooTest.HasBlahBlah/1</code> for <code>&quot;miny&quot;</code></li>
<li><code>InstantiationName/FooTest.HasBlahBlah/2</code> for <code>&quot;moe&quot;</code></li>
</ul>
<p>You can use these names in <a href="#running-a-subset-of-the-tests">&#8211;gtest-filter</a>.</p>
<p>This statement will instantiate all tests from <code>FooTest</code> again, each with parameter values <code>&quot;cat&quot;</code> and <code>&quot;dog&quot;</code>:</p>
<pre><code>const char* pets[] = {&quot;cat&quot;, &quot;dog&quot;};
INSTANTIATE_TEST_CASE_P(AnotherInstantiationName, FooTest,
                        ::testing::ValuesIn(pets));</code></pre>
<p>The tests from the instantiation above will have these names:</p>
<ul>
<li><code>AnotherInstantiationName/FooTest.DoesBlah/0</code> for <code>&quot;cat&quot;</code></li>
<li><code>AnotherInstantiationName/FooTest.DoesBlah/1</code> for <code>&quot;dog&quot;</code></li>
<li><code>AnotherInstantiationName/FooTest.HasBlahBlah/0</code> for <code>&quot;cat&quot;</code></li>
<li><code>AnotherInstantiationName/FooTest.HasBlahBlah/1</code> for <code>&quot;dog&quot;</code></li>
</ul>
<p>Please note that <code>INSTANTIATE_TEST_CASE_P</code> will instantiate <em>all</em> tests in the given test case, whether their definitions come before or <em>after</em> the <code>INSTANTIATE_TEST_CASE_P</code> statement.</p>
<p>You can see <a href="../samples/sample7_unittest.cc">these</a> <a href="../samples/sample8_unittest.cc">files</a> for more examples.</p>
<p><em>Availability</em>: Linux, Windows (requires MSVC 8.0 or above), Mac; since version 1.2.0.</p>
<h4 id="creating-value-parameterized-abstract-tests">Creating Value-Parameterized Abstract Tests</h4>
<p>In the above, we define and instantiate <code>FooTest</code> in the same source file. Sometimes you may want to define value-parameterized tests in a library and let other people instantiate them later. This pattern is known as <i>abstract tests</i>. As an example of its application, when you are designing an interface you can write a standard suite of abstract tests (perhaps using a factory function as the test parameter) that all implementations of the interface are expected to pass. When someone implements the interface, he can instantiate your suite to get all the interface-conformance tests for free.</p>
<p>To define abstract tests, you should organize your code like this:</p>
<ol style="list-style-type: decimal">
<li>Put the definition of the parameterized test fixture class (e.g. <code>FooTest</code>) in a header file, say <code>foo_param_test.h</code>. Think of this as <em>declaring</em> your abstract tests.</li>
<li>Put the <code>TEST_P</code> definitions in <code>foo_param_test.cc</code>, which includes <code>foo_param_test.h</code>. Think of this as <em>implementing</em> your abstract tests.</li>
</ol>
<p>Once they are defined, you can instantiate them by including <code>foo_param_test.h</code>, invoking <code>INSTANTIATE_TEST_CASE_P()</code>, and linking with <code>foo_param_test.cc</code>. You can instantiate the same abstract test case multiple times, possibly in different source files.</p>
<h3 id="typed-tests">Typed Tests</h3>
<p>Suppose you have multiple implementations of the same interface and want to make sure that all of them satisfy some common requirements. Or, you may have defined several types that are supposed to conform to the same &#8220;concept&#8221; and you want to verify it. In both cases, you want the same test logic repeated for different types.</p>
<p>While you can write one <code>TEST</code> or <code>TEST_F</code> for each type you want to test (and you may even factor the test logic into a function template that you invoke from the <code>TEST</code>), it&#8217;s tedious and doesn&#8217;t scale: if you want <em>m</em> tests over <em>n</em> types, you&#8217;ll end up writing <em>m*n</em> <code>TEST</code>s.</p>
<p><em>Typed tests</em> allow you to repeat the same test logic over a list of types. You only need to write the test logic once, although you must know the type list when writing typed tests. Here&#8217;s how you do it:</p>
<p>First, define a fixture class template. It should be parameterized by a type. Remember to derive it from <code>::testing::Test</code>:</p>
<pre><code>template &lt;typename T&gt;
class FooTest : public ::testing::Test {
 public:
  ...
  typedef std::list&lt;T&gt; List;
  static T shared_;
  T value_;
};</code></pre>
<p>Next, associate a list of types with the test case, which will be repeated for each type in the list:</p>
<pre><code>typedef ::testing::Types&lt;char, int, unsigned int&gt; MyTypes;
TYPED_TEST_CASE(FooTest, MyTypes);</code></pre>
<p>The <code>typedef</code> is necessary for the <code>TYPED_TEST_CASE</code> macro to parse correctly. Otherwise the compiler will think that each comma in the type list introduces a new macro argument.</p>
<p>Then, use <code>TYPED_TEST()</code> instead of <code>TEST_F()</code> to define a typed test for this test case. You can repeat this as many times as you want:</p>
<pre><code>TYPED_TEST(FooTest, DoesBlah) {
  // Inside a test, refer to the special name TypeParam to get the type
  // parameter.  Since we are inside a derived class template, C++ requires
  // us to visit the members of FooTest via &#39;this&#39;.
  TypeParam n = this-&gt;value_;

  // To visit static members of the fixture, add the &#39;TestFixture::&#39;
  // prefix.
  n += TestFixture::shared_;

  // To refer to typedefs in the fixture, add the &#39;typename TestFixture::&#39;
  // prefix.  The &#39;typename&#39; is required to satisfy the compiler.
  typename TestFixture::List values;
  values.push_back(n);
  ...
}

TYPED_TEST(FooTest, HasPropertyA) { ... }</code></pre>
<p>You can see <code>samples/sample6_unittest.cc</code> for a complete example.</p>
<p><em>Availability:</em> Linux, Windows (requires MSVC 8.0 or above), Mac; since version 1.1.0.</p>
<h3 id="type-parameterized-tests">Type-Parameterized Tests</h3>
<p><em>Type-parameterized tests</em> are like typed tests, except that they don&#8217;t require you to know the list of types ahead of time. Instead, you can define the test logic first and instantiate it with different type lists later. You can even instantiate it more than once in the same program.</p>
<p>If you are designing an interface or concept, you can define a suite of type-parameterized tests to verify properties that any valid implementation of the interface/concept should have. Then, the author of each implementation can just instantiate the test suite with his type to verify that it conforms to the requirements, without having to write similar tests repeatedly. Here&#8217;s an example:</p>
<p>First, define a fixture class template, as we did with typed tests:</p>
<pre><code>template &lt;typename T&gt;
class FooTest : public ::testing::Test {
  ...
};</code></pre>
<p>Next, declare that you will define a type-parameterized test case:</p>
<pre><code>TYPED_TEST_CASE_P(FooTest);</code></pre>
<p>The <code>_P</code> suffix is for &#8220;parameterized&#8221; or &#8220;pattern&#8221;, whichever you prefer to think.</p>
<p>Then, use <code>TYPED_TEST_P()</code> to define a type-parameterized test. You can repeat this as many times as you want:</p>
<pre><code>TYPED_TEST_P(FooTest, DoesBlah) {
  // Inside a test, refer to TypeParam to get the type parameter.
  TypeParam n = 0;
  ...
}

TYPED_TEST_P(FooTest, HasPropertyA) { ... }</code></pre>
<p>Now the tricky part: you need to register all test patterns using the <code>REGISTER_TYPED_TEST_CASE_P</code> macro before you can instantiate them. The first argument of the macro is the test case name; the rest are the names of the tests in this test case:</p>
<pre><code>REGISTER_TYPED_TEST_CASE_P(FooTest,
                           DoesBlah, HasPropertyA);</code></pre>
<p>Finally, you are free to instantiate the pattern with the types you want. If you put the above code in a header file, you can <code>#include</code> it in multiple C++ source files and instantiate it multiple times.</p>
<pre><code>typedef ::testing::Types&lt;char, int, unsigned int&gt; MyTypes;
INSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, MyTypes);</code></pre>
<p>To distinguish different instances of the pattern, the first argument to the <code>INSTANTIATE_TYPED_TEST_CASE_P</code> macro is a prefix that will be added to the actual test case name. Remember to pick unique prefixes for different instances.</p>
<p>In the special case where the type list contains only one type, you can write that type directly without <code>::testing::Types&lt;...&gt;</code>, like this:</p>
<pre><code>INSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, int);</code></pre>
<p>You can see <code>samples/sample6_unittest.cc</code> for a complete example.</p>
<p><em>Availability:</em> Linux, Windows (requires MSVC 8.0 or above), Mac; since version 1.1.0.</p>
<h3 id="testing-private-code">Testing Private Code</h3>
<p>If you change your software&#8217;s internal implementation, your tests should not break as long as the change is not observable by users. Therefore, per the <em>black-box testing principle</em>, most of the time you should test your code through its public interfaces.</p>
<p>If you still find yourself needing to test internal implementation code, consider if there&#8217;s a better design that wouldn&#8217;t require you to do so. If you absolutely have to test non-public interface code though, you can. There are two cases to consider:</p>
<ul>
<li>Static functions (<em>not</em> the same as static member functions!) or unnamed namespaces, and</li>
<li>Private or protected class members</li>
</ul>
<h4 id="static-functions">Static Functions</h4>
<p>Both static functions and definitions/declarations in an unnamed namespace are only visible within the same translation unit. To test them, you can <code>#include</code> the entire <code>.cc</code> file being tested in your <code>*_test.cc</code> file. (<code>#include</code>ing <code>.cc</code> files is not a good way to reuse code - you should not do this in production code!)</p>
<p>However, a better approach is to move the private code into the <code>foo::internal</code> namespace, where <code>foo</code> is the namespace your project normally uses, and put the private declarations in a <code>*-internal.h</code> file. Your production <code>.cc</code> files and your tests are allowed to include this internal header, but your clients are not. This way, you can fully test your internal implementation without leaking it to your clients.</p>
<h4 id="private-class-members">Private Class Members</h4>
<p>Private class members are only accessible from within the class or by friends. To access a class&#8217; private members, you can declare your test fixture as a friend to the class and define accessors in your fixture. Tests using the fixture can then access the private members of your production class via the accessors in the fixture. Note that even though your fixture is a friend to your production class, your tests are not automatically friends to it, as they are technically defined in sub-classes of the fixture.</p>
<p>Another way to test private members is to refactor them into an implementation class, which is then declared in a <code>*-internal.h</code> file. Your clients aren&#8217;t allowed to include this header but your tests can. Such is called the Pimpl (Private Implementation) idiom.</p>
<p>Or, you can declare an individual test as a friend of your class by adding this line in the class body:</p>
<pre><code>FRIEND_TEST(TestCaseName, TestName);</code></pre>
<p>For example,</p>
<pre><code>// foo.h
#include &quot;gtest/gtest_prod.h&quot;

// Defines FRIEND_TEST.
class Foo {
  ...
 private:
  FRIEND_TEST(FooTest, BarReturnsZeroOnNull);
  int Bar(void* x);
};

// foo_test.cc
...
TEST(FooTest, BarReturnsZeroOnNull) {
  Foo foo;
  EXPECT_EQ(0, foo.Bar(NULL));
  // Uses Foo&#39;s private member Bar().
}</code></pre>
<p>Pay special attention when your class is defined in a namespace, as you should define your test fixtures and tests in the same namespace if you want them to be friends of your class. For example, if the code to be tested looks like:</p>
<pre><code>namespace my_namespace {

class Foo {
  friend class FooTest;
  FRIEND_TEST(FooTest, Bar);
  FRIEND_TEST(FooTest, Baz);
  ...
  definition of the class Foo
  ...
};

}  // namespace my_namespace</code></pre>
<p>Your test code should be something like:</p>
<pre><code>namespace my_namespace {
class FooTest : public ::testing::Test {
 protected:
  ...
};

TEST_F(FooTest, Bar) { ... }
TEST_F(FooTest, Baz) { ... }

}  // namespace my_namespace</code></pre>
<h3 id="catching-failures">Catching Failures</h3>
<p>If you are building a testing utility on top of Google Test, you&#8217;ll want to test your utility. What framework would you use to test it? Google Test, of course.</p>
<p>The challenge is to verify that your testing utility reports failures correctly. In frameworks that report a failure by throwing an exception, you could catch the exception and assert on it. But Google Test doesn&#8217;t use exceptions, so how do we test that a piece of code generates an expected failure?</p>
<p><code>&quot;gtest/gtest-spi.h&quot;</code> contains some constructs to do this. After <code>#include</code>ing this header, you can use</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>EXPECT_FATAL_FAILURE(</code><em>statement, substring</em><code>);</code></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>to assert that <em>statement</em> generates a fatal (e.g. <code>ASSERT_*</code>) failure whose message contains the given <em>substring</em>, or use</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>EXPECT_NONFATAL_FAILURE(</code><em>statement, substring</em><code>);</code></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>if you are expecting a non-fatal (e.g. <code>EXPECT_*</code>) failure.</p>
<p>For technical reasons, there are some caveats:</p>
<ol style="list-style-type: decimal">
<li>You cannot stream a failure message to either macro.</li>
<li><em>statement</em> in <code>EXPECT_FATAL_FAILURE()</code> cannot reference local non-static variables or non-static members of <code>this</code> object.</li>
<li><em>statement</em> in <code>EXPECT_FATAL_FAILURE()</code> cannot return a value.</li>
</ol>
<p><em>Note:</em> Google Test is designed with threads in mind. Once the synchronization primitives in <code>&quot;gtest/internal/gtest-port.h&quot;</code> have been implemented, Google Test will become thread-safe, meaning that you can then use assertions in multiple threads concurrently. Before</p>
<p>that, however, Google Test only supports single-threaded usage. Once thread-safe, <code>EXPECT_FATAL_FAILURE()</code> and <code>EXPECT_NONFATAL_FAILURE()</code> will capture failures in the current thread only. If <em>statement</em> creates new threads, failures in these threads will be ignored. If you want to capture failures from all threads instead, you should use the following macros:</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>EXPECT_FATAL_FAILURE_ON_ALL_THREADS(</code><em>statement, substring</em><code>);</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>EXPECT_NONFATAL_FAILURE_ON_ALL_THREADS(</code><em>statement, substring</em><code>);</code></td>
</tr>
</tbody>
</table>
<h3 id="getting-the-current-tests-name">Getting the Current Test&#8217;s Name</h3>
<p>Sometimes a function may need to know the name of the currently running test. For example, you may be using the <code>SetUp()</code> method of your test fixture to set the golden file name based on which test is running. The <code>::testing::TestInfo</code> class has this information:</p>
<pre><code>namespace testing {

class TestInfo {
 public:
  // Returns the test case name and the test name, respectively.
  //
  // Do NOT delete or free the return value - it&#39;s managed by the
  // TestInfo class.
  const char* test_case_name() const;
  const char* name() const;
};

}  // namespace testing</code></pre>
<blockquote>
<p>To obtain a <code>TestInfo</code> object for the currently running test, call <code>current_test_info()</code> on the <code>UnitTest</code> singleton object:</p>
</blockquote>
<pre><code>// Gets information about the currently running test.
// Do NOT delete the returned object - it&#39;s managed by the UnitTest class.
const ::testing::TestInfo* const test_info =
  ::testing::UnitTest::GetInstance()-&gt;current_test_info();
printf(&quot;We are in test %s of test case %s.\n&quot;,
       test_info-&gt;name(), test_info-&gt;test_case_name());</code></pre>
<p><code>current_test_info()</code> returns a null pointer if no test is running. In particular, you cannot find the test case name in <code>TestCaseSetUp()</code>, <code>TestCaseTearDown()</code> (where you know the test case name implicitly), or functions called from them.</p>
<p><em>Availability:</em> Linux, Windows, Mac.</p>
<h3 id="extending-google-test-by-handling-test-events">Extending Google Test by Handling Test Events</h3>
<p>Google Test provides an <b>event listener API</b> to let you receive notifications about the progress of a test program and test failures. The events you can listen to include the start and end of the test program, a test case, or a test method, among others. You may use this API to augment or replace the standard console output, replace the XML output, or provide a completely different form of output, such as a GUI or a database. You can also use test events as checkpoints to implement a resource leak checker, for example.</p>
<p><em>Availability:</em> Linux, Windows, Mac; since v1.4.0.</p>
<h4 id="defining-event-listeners">Defining Event Listeners</h4>
<p>To define a event listener, you subclass either <a href="../include/gtest/gtest.h#L855">testing::TestEventListener</a> or <a href="../include/gtest/gtest.h#L905">testing::EmptyTestEventListener</a>. The former is an (abstract) interface, where <i>each pure virtual method<br> can be overridden to handle a test event</i> (For example, when a test starts, the <code>OnTestStart()</code> method will be called.). The latter provides an empty implementation of all methods in the interface, such that a subclass only needs to override the methods it cares about.</p>
<p>When an event is fired, its context is passed to the handler function as an argument. The following argument types are used: * <a href="../include/gtest/gtest.h#L1007">UnitTest</a> reflects the state of the entire test program, * <a href="../include/gtest/gtest.h#L689">TestCase</a> has information about a test case, which can contain one or more tests, * <a href="../include/gtest/gtest.h#L599">TestInfo</a> contains the state of a test, and * <a href="../include/gtest/gtest-test-part.h#L42">TestPartResult</a> represents the result of a test assertion.</p>
<p>An event handler function can examine the argument it receives to find out interesting information about the event and the test program&#8217;s state. Here&#8217;s an example:</p>
<pre><code>  class MinimalistPrinter : public ::testing::EmptyTestEventListener {
    // Called before a test starts.
    virtual void OnTestStart(const ::testing::TestInfo&amp; test_info) {
      printf(&quot;*** Test %s.%s starting.\n&quot;,
             test_info.test_case_name(), test_info.name());
    }

    // Called after a failed assertion or a SUCCEED() invocation.
    virtual void OnTestPartResult(
        const ::testing::TestPartResult&amp; test_part_result) {
      printf(&quot;%s in %s:%d\n%s\n&quot;,
             test_part_result.failed() ? &quot;*** Failure&quot; : &quot;Success&quot;,
             test_part_result.file_name(),
             test_part_result.line_number(),
             test_part_result.summary());
    }

    // Called after a test ends.
    virtual void OnTestEnd(const ::testing::TestInfo&amp; test_info) {
      printf(&quot;*** Test %s.%s ending.\n&quot;,
             test_info.test_case_name(), test_info.name());
    }
  };</code></pre>
<h4 id="using-event-listeners">Using Event Listeners</h4>
<p>To use the event listener you have defined, add an instance of it to the Google Test event listener list (represented by class <a href="../include/gtest/gtest.h#L929">TestEventListeners</a> - note the &#8220;s&#8221; at the end of the name) in your <code>main()</code> function, before calling <code>RUN_ALL_TESTS()</code>:</p>
<pre><code>int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&amp;argc, argv);
  // Gets hold of the event listener list.
  ::testing::TestEventListeners&amp; listeners =
      ::testing::UnitTest::GetInstance()-&gt;listeners();
  // Adds a listener to the end.  Google Test takes the ownership.
  listeners.Append(new MinimalistPrinter);
  return RUN_ALL_TESTS();
}</code></pre>
<p>There&#8217;s only one problem: the default test result printer is still in effect, so its output will mingle with the output from your minimalist printer. To suppress the default printer, just release it from the event listener list and delete it. You can do so by adding one line:</p>
<pre><code>  ...
  delete listeners.Release(listeners.default_result_printer());
  listeners.Append(new MinimalistPrinter);
  return RUN_ALL_TESTS();</code></pre>
<p>Now, sit back and enjoy a completely different output from your tests. For more details, you can read this <a href="../samples/sample9_unittest.cc">sample</a>.</p>
<p>You may append more than one listener to the list. When an <code>On*Start()</code> or <code>OnTestPartResult()</code> event is fired, the listeners will receive it in the order they appear in the list (since new listeners are added to the end of the list, the default text printer and the default XML generator will receive the event first). An <code>On*End()</code> event will be received by the listeners in the <em>reverse</em> order. This allows output by listeners added later to be framed by output from listeners added earlier.</p>
<h4 id="generating-failures-in-listeners">Generating Failures in Listeners</h4>
<p>You may use failure-raising macros (<code>EXPECT_*()</code>, <code>ASSERT_*()</code>, <code>FAIL()</code>, etc) when processing an event. There are some restrictions:</p>
<ol style="list-style-type: decimal">
<li>You cannot generate any failure in <code>OnTestPartResult()</code> (otherwise it will cause <code>OnTestPartResult()</code> to be called recursively).</li>
<li>A listener that handles <code>OnTestPartResult()</code> is not allowed to generate any failure.</li>
</ol>
<p>When you add listeners to the listener list, you should put listeners that handle <code>OnTestPartResult()</code> <em>before</em> listeners that can generate failures. This ensures that failures generated by the latter are attributed to the right test by the former.</p>
<p>We have a sample of failure-raising listener <a href="../samples/sample10_unittest.cc">here</a>.</p>
<h3 id="running-test-programs-advanced-options">Running Test Programs: Advanced Options</h3>
<p>Google Test test programs are ordinary executables. Once built, you can run them directly and affect their behavior via the following environment variables and/or command line flags. For the flags to work, your programs must call <code>::testing::InitGoogleTest()</code> before calling <code>RUN_ALL_TESTS()</code>.</p>
<p>To see a list of supported flags and their usage, please run your test program with the <code>--help</code> flag. You can also use <code>-h</code>, <code>-?</code>, or <code>/?</code> for short. This feature is added in version 1.3.0.</p>
<p>If an option is specified both by an environment variable and by a flag, the latter takes precedence. Most of the options can also be set/read in code: to access the value of command line flag <code>--gtest_foo</code>, write <code>::testing::GTEST_FLAG(foo)</code>. A common pattern is to set the value of a flag before calling <code>::testing::InitGoogleTest()</code> to change the default value of the flag:</p>
<pre><code>int main(int argc, char** argv) {
  // Disables elapsed time by default.
  ::testing::GTEST_FLAG(print_time) = false;

  // This allows the user to override the flag on the command line.
  ::testing::InitGoogleTest(&amp;argc, argv);

  return RUN_ALL_TESTS();
}</code></pre>
<h4 id="selecting-tests">Selecting Tests</h4>
<p>This section shows various options for choosing which tests to run.</p>
<h5 id="listing-test-names">Listing Test Names</h5>
<p>Sometimes it is necessary to list the available tests in a program before running them so that a filter may be applied if needed. Including the flag <code>--gtest_list_tests</code> overrides all other flags and lists tests in the following format:</p>
<pre><code>TestCase1.
  TestName1
  TestName2
TestCase2.
  TestName</code></pre>
<p>None of the tests listed are actually run if the flag is provided. There is no corresponding environment variable for this flag.</p>
<p><em>Availability:</em> Linux, Windows, Mac.</p>
<h5 id="running-a-subset-of-the-tests">Running a Subset of the Tests</h5>
<p>By default, a Google Test program runs all tests the user has defined. Sometimes, you want to run only a subset of the tests (e.g.&#160;for debugging or quickly verifying a change). If you set the <code>GTEST_FILTER</code> environment variable or the <code>--gtest_filter</code> flag to a filter string, Google Test will only run the tests whose full names (in the form of <code>TestCaseName.TestName</code>) match the filter.</p>
<p>The format of a filter is a &#8216;<code>:</code>&#8217;-separated list of wildcard patterns (called the positive patterns) optionally followed by a &#8216;<code>-</code>&#8217; and another &#8216;<code>:</code>&#8217;-separated pattern list (called the negative patterns). A test matches the filter if and only if it matches any of the positive patterns but does not match any of the negative patterns.</p>
<p>A pattern may contain <code>'*'</code> (matches any string) or <code>'?'</code> (matches any single character). For convenience, the filter <code>'*-NegativePatterns'</code> can be also written as <code>'-NegativePatterns'</code>.</p>
<p>For example:</p>
<ul>
<li><code>./foo_test</code> Has no flag, and thus runs all its tests.</li>
<li><code>./foo_test --gtest_filter=*</code> Also runs everything, due to the single match-everything <code>*</code> value.</li>
<li><code>./foo_test --gtest_filter=FooTest.*</code> Runs everything in test case <code>FooTest</code>.</li>
<li><code>./foo_test --gtest_filter=*Null*:*Constructor*</code> Runs any test whose full name contains either <code>&quot;Null&quot;</code> or <code>&quot;Constructor&quot;</code>.</li>
<li><code>./foo_test --gtest_filter=-*DeathTest.*</code> Runs all non-death tests.</li>
<li><code>./foo_test --gtest_filter=FooTest.*-FooTest.Bar</code> Runs everything in test case <code>FooTest</code> except <code>FooTest.Bar</code>.</li>
</ul>
<p><em>Availability:</em> Linux, Windows, Mac.</p>
<h5 id="temporarily-disabling-tests">Temporarily Disabling Tests</h5>
<p>If you have a broken test that you cannot fix right away, you can add the <code>DISABLED_</code> prefix to its name. This will exclude it from execution. This is better than commenting out the code or using <code>#if 0</code>, as disabled tests are still compiled (and thus won&#8217;t rot).</p>
<p>If you need to disable all tests in a test case, you can either add <code>DISABLED_</code> to the front of the name of each test, or alternatively add it to the front of the test case name.</p>
<p>For example, the following tests won&#8217;t be run by Google Test, even though they will still be compiled:</p>
<pre><code>// Tests that Foo does Abc.
TEST(FooTest, DISABLED_DoesAbc) { ... }

class DISABLED_BarTest : public ::testing::Test { ... };

// Tests that Bar does Xyz.
TEST_F(DISABLED_BarTest, DoesXyz) { ... }</code></pre>
<p><em>Note:</em> This feature should only be used for temporary pain-relief. You still have to fix the disabled tests at a later date. As a reminder, Google Test will print a banner warning you if a test program contains any disabled tests.</p>
<p><em>Tip:</em> You can easily count the number of disabled tests you have using <code>grep</code>. This number can be used as a metric for improving your test quality.</p>
<p><em>Availability:</em> Linux, Windows, Mac.</p>
<h5 id="temporarily-enabling-disabled-tests">Temporarily Enabling Disabled Tests</h5>
<p>To include <a href="#temporarily-disabling-tests">disabled tests</a> in test execution, just invoke the test program with the <code>--gtest_also_run_disabled_tests</code> flag or set the <code>GTEST_ALSO_RUN_DISABLED_TESTS</code> environment variable to a value other than <code>0</code>. You can combine this with the <a href="#running-a-subset-of-the_tests">&#8211;gtest-filter</a> flag to further select which disabled tests to run.</p>
<p><em>Availability:</em> Linux, Windows, Mac; since version 1.3.0.</p>
<h4 id="repeating-the-tests">Repeating the Tests</h4>
<p>Once in a while you&#8217;ll run into a test whose result is hit-or-miss. Perhaps it will fail only 1% of the time, making it rather hard to reproduce the bug under a debugger. This can be a major source of frustration.</p>
<p>The <code>--gtest_repeat</code> flag allows you to repeat all (or selected) test methods in a program many times. Hopefully, a flaky test will eventually fail and give you a chance to debug. Here&#8217;s how to use it:</p>
<table>
<colgroup>
<col width="37%" />
<col width="62%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>$ foo_test --gtest_repeat=1000</code></th>
<th align="left">Repeat foo_test 1000 times and don&#8217;t stop at failures.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>$ foo_test --gtest_repeat=-1</code></td>
<td align="left">A negative count means repeating forever.</td>
</tr>
<tr class="even">
<td align="left"><code>$ foo_test --gtest_repeat=1000 --gtest_break_on_failure</code></td>
<td align="left">Repeat foo_test 1000 times, stopping at the first failure. This is especially useful when running under a debugger: when the testfails, it will drop into the debugger and you can then inspect variables and stacks.</td>
</tr>
<tr class="odd">
<td align="left"><code>$ foo_test --gtest_repeat=1000 --gtest_filter=FooBar</code></td>
<td align="left">Repeat the tests whose name matches the filter 1000 times.</td>
</tr>
</tbody>
</table>
<p>If your test program contains global set-up/tear-down code registered using <code>AddGlobalTestEnvironment()</code>, it will be repeated in each iteration as well, as the flakiness may be in it. You can also specify the repeat count by setting the <code>GTEST_REPEAT</code> environment variable.</p>
<p><em>Availability:</em> Linux, Windows, Mac.</p>
<h4 id="shuffling-the-tests">Shuffling the Tests</h4>
<p>You can specify the <code>--gtest_shuffle</code> flag (or set the <code>GTEST_SHUFFLE</code> environment variable to <code>1</code>) to run the tests in a program in a random order. This helps to reveal bad dependencies between tests.</p>
<p>By default, Google Test uses a random seed calculated from the current time. Therefore you&#8217;ll get a different order every time. The console output includes the random seed value, such that you can reproduce an order-related test failure later. To specify the random seed explicitly, use the <code>--gtest_random_seed=SEED</code> flag (or set the <code>GTEST_RANDOM_SEED</code> environment variable), where <code>SEED</code> is an integer between 0 and 99999. The seed value 0 is special: it tells Google Test to do the default behavior of calculating the seed from the current time.</p>
<p>If you combine this with <code>--gtest_repeat=N</code>, Google Test will pick a different random seed and re-shuffle the tests in each iteration.</p>
<p><em>Availability:</em> Linux, Windows, Mac; since v1.4.0.</p>
<h4 id="controlling-test-output">Controlling Test Output</h4>
<p>This section teaches how to tweak the way test results are reported.</p>
<h5 id="colored-terminal-output">Colored Terminal Output</h5>
<p>Google Test can use colors in its terminal output to make it easier to spot the separation between tests, and whether tests passed.</p>
<p>You can set the GTEST_COLOR environment variable or set the <code>--gtest_color</code> command line flag to <code>yes</code>, <code>no</code>, or <code>auto</code> (the default) to enable colors, disable colors, or let Google Test decide. When the value is <code>auto</code>, Google Test will use colors if and only if the output goes to a terminal and (on non-Windows platforms) the <code>TERM</code> environment variable is set to <code>xterm</code> or <code>xterm-color</code>.</p>
<p><em>Availability:</em> Linux, Windows, Mac.</p>
<h5 id="suppressing-the-elapsed-time">Suppressing the Elapsed Time</h5>
<p>By default, Google Test prints the time it takes to run each test. To suppress that, run the test program with the <code>--gtest_print_time=0</code> command line flag. Setting the <code>GTEST_PRINT_TIME</code> environment variable to <code>0</code> has the same effect.</p>
<p><em>Availability:</em> Linux, Windows, Mac. (In Google Test 1.3.0 and lower, the default behavior is that the elapsed time is <strong>not</strong> printed.)</p>
<h5 id="generating-an-xml-report">Generating an XML Report</h5>
<p>Google Test can emit a detailed XML report to a file in addition to its normal textual output. The report contains the duration of each test, and thus can help you identify slow tests.</p>
<p>To generate the XML report, set the <code>GTEST_OUTPUT</code> environment variable or the <code>--gtest_output</code> flag to the string <code>&quot;xml:_path_to_output_file_&quot;</code>, which will create the file at the given location. You can also just use the string <code>&quot;xml&quot;</code>, in which case the output can be found in the <code>test_detail.xml</code> file in the current directory.</p>
<p>If you specify a directory (for example, <code>&quot;xml:output/directory/&quot;</code> on Linux or <code>&quot;xml:output\directory\&quot;</code> on Windows), Google Test will create the XML file in that directory, named after the test executable (e.g. <code>foo_test.xml</code> for test program <code>foo_test</code> or <code>foo_test.exe</code>). If the file already exists (perhaps left over from a previous run), Google Test will pick a different name (e.g. <code>foo_test_1.xml</code>) to avoid overwriting it.</p>
<p>The report uses the format described here. It is based on the <code>junitreport</code> Ant task and can be parsed by popular continuous build systems like <a href="https://hudson.dev.java.net/">Hudson</a>. Since that format was originally intended for Java, a little interpretation is required to make it apply to Google Test tests, as shown here:</p>
<pre><code>&lt;testsuites name=&quot;AllTests&quot; ...&gt;
  &lt;testsuite name=&quot;test_case_name&quot; ...&gt;
    &lt;testcase name=&quot;test_name&quot; ...&gt;
      &lt;failure message=&quot;...&quot;/&gt;
      &lt;failure message=&quot;...&quot;/&gt;
      &lt;failure message=&quot;...&quot;/&gt;
    &lt;/testcase&gt;
  &lt;/testsuite&gt;
&lt;/testsuites&gt;</code></pre>
<ul>
<li>The root <code>&lt;testsuites&gt;</code> element corresponds to the entire test program.</li>
<li><code>&lt;testsuite&gt;</code> elements correspond to Google Test test cases.</li>
<li><code>&lt;testcase&gt;</code> elements correspond to Google Test test functions.</li>
</ul>
<p>For instance, the following program</p>
<pre><code>TEST(MathTest, Addition) { ... }
TEST(MathTest, Subtraction) { ... }
TEST(LogicTest, NonContradiction) { ... }</code></pre>
<p>could generate this report:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;testsuites tests=&quot;3&quot; failures=&quot;1&quot; errors=&quot;0&quot; time=&quot;35&quot; name=&quot;AllTests&quot;&gt;
  &lt;testsuite name=&quot;MathTest&quot; tests=&quot;2&quot; failures=&quot;1&quot; errors=&quot;0&quot; time=&quot;15&quot;&gt;
    &lt;testcase name=&quot;Addition&quot; status=&quot;run&quot; time=&quot;7&quot; classname=&quot;&quot;&gt;
      &lt;failure message=&quot;Value of: add(1, 1)&amp;#x0A; Actual: 3&amp;#x0A;Expected: 2&quot; type=&quot;&quot;/&gt;
      &lt;failure message=&quot;Value of: add(1, -1)&amp;#x0A; Actual: 1&amp;#x0A;Expected: 0&quot; type=&quot;&quot;/&gt;
    &lt;/testcase&gt;
    &lt;testcase name=&quot;Subtraction&quot; status=&quot;run&quot; time=&quot;5&quot; classname=&quot;&quot;&gt;
    &lt;/testcase&gt;
  &lt;/testsuite&gt;
  &lt;testsuite name=&quot;LogicTest&quot; tests=&quot;1&quot; failures=&quot;0&quot; errors=&quot;0&quot; time=&quot;5&quot;&gt;
    &lt;testcase name=&quot;NonContradiction&quot; status=&quot;run&quot; time=&quot;5&quot; classname=&quot;&quot;&gt;
    &lt;/testcase&gt;
  &lt;/testsuite&gt;
&lt;/testsuites&gt;</code></pre>
<p>Things to note:</p>
<ul>
<li>The <code>tests</code> attribute of a <code>&lt;testsuites&gt;</code> or <code>&lt;testsuite&gt;</code> element tells how many test functions the Google Test program or test case contains, while the <code>failures</code> attribute tells how many of them failed.</li>
<li>The <code>time</code> attribute expresses the duration of the test, test case, or entire test program in milliseconds.</li>
<li>Each <code>&lt;failure&gt;</code> element corresponds to a single failed Google Test assertion.</li>
<li>Some JUnit concepts don&#8217;t apply to Google Test, yet we have to conform to the DTD. Therefore you&#8217;ll see some dummy elements and attributes in the report. You can safely ignore these parts.</li>
</ul>
<p><em>Availability:</em> Linux, Windows, Mac.</p>
<h4 id="controlling-how-failures-are-reported">Controlling How Failures Are Reported</h4>
<h5 id="turning-assertion-failures-into-break-points">Turning Assertion Failures into Break-Points</h5>
<p>When running test programs under a debugger, it&#8217;s very convenient if the debugger can catch an assertion failure and automatically drop into interactive mode. Google Test&#8217;s <em>break-on-failure</em> mode supports this behavior.</p>
<p>To enable it, set the <code>GTEST_BREAK_ON_FAILURE</code> environment variable to a value other than <code>0</code> . Alternatively, you can use the <code>--gtest_break_on_failure</code> command line flag.</p>
<p><em>Availability:</em> Linux, Windows, Mac.</p>
<h5 id="disabling-catching-test-thrown-exceptions">Disabling Catching Test-Thrown Exceptions</h5>
<p>Google Test can be used either with or without exceptions enabled. If a test throws a C++ exception or (on Windows) a structured exception (SEH), by default Google Test catches it, reports it as a test failure, and continues with the next test method. This maximizes the coverage of a test run. Also, on Windows an uncaught exception will cause a pop-up window, so catching the exceptions allows you to run the tests automatically.</p>
<p>When debugging the test failures, however, you may instead want the exceptions to be handled by the debugger, such that you can examine the call stack when an exception is thrown. To achieve that, set the <code>GTEST_CATCH_EXCEPTIONS</code> environment variable to <code>0</code>, or use the <code>--gtest_catch_exceptions=0</code> flag when running the tests.</p>
<p><strong>Availability</strong>: Linux, Windows, Mac.</p>
<h5 id="letting-another-testing-framework-drive">Letting Another Testing Framework Drive</h5>
<p>If you work on a project that has already been using another testing framework and is not ready to completely switch to Google Test yet, you can get much of Google Test&#8217;s benefit by using its assertions in your existing tests. Just change your <code>main()</code> function to look like:</p>
<pre><code>#include &quot;gtest/gtest.h&quot;

int main(int argc, char** argv) {
  ::testing::GTEST_FLAG(throw_on_failure) = true;
  // Important: Google Test must be initialized.
  ::testing::InitGoogleTest(&amp;argc, argv);

  ... whatever your existing testing framework requires ...
}</code></pre>
<p>With that, you can use Google Test assertions in addition to the native assertions your testing framework provides, for example:</p>
<pre><code>void TestFooDoesBar() {
  Foo foo;
  EXPECT_LE(foo.Bar(1), 100);     // A Google Test assertion.
  CPPUNIT_ASSERT(foo.IsEmpty());  // A native assertion.
}</code></pre>
<p>If a Google Test assertion fails, it will print an error message and throw an exception, which will be treated as a failure by your host testing framework. If you compile your code with exceptions disabled, a failed Google Test assertion will instead exit your program with a non-zero code, which will also signal a test failure to your test runner.</p>
<p>If you don&#8217;t write <code>::testing::GTEST_FLAG(throw_on_failure) = true;</code> in your <code>main()</code>, you can alternatively enable this feature by specifying the <code>--gtest_throw_on_failure</code> flag on the command-line or setting the <code>GTEST_THROW_ON_FAILURE</code> environment variable to a non-zero value.</p>
<p><em>Availability:</em> Linux, Windows, Mac; since v1.3.0.</p>
<h4 id="distributing-test-functions-to-multiple-machines">Distributing Test Functions to Multiple Machines</h4>
<p>If you have more than one machine you can use to run a test program, you might want to run the test functions in parallel and get the result faster. We call this technique <em>sharding</em>, where each machine is called a <em>shard</em>.</p>
<p>Google Test is compatible with test sharding. To take advantage of this feature, your test runner (not part of Google Test) needs to do the following:</p>
<ol style="list-style-type: decimal">
<li>Allocate a number of machines (shards) to run the tests.</li>
<li>On each shard, set the <code>GTEST_TOTAL_SHARDS</code> environment variable to the total number of shards. It must be the same for all shards.</li>
<li>On each shard, set the <code>GTEST_SHARD_INDEX</code> environment variable to the index of the shard. Different shards must be assigned different indices, which must be in the range <code>[0, GTEST_TOTAL_SHARDS - 1]</code>.</li>
<li>Run the same test program on all shards. When Google Test sees the above two environment variables, it will select a subset of the test functions to run. Across all shards, each test function in the program will be run exactly once.</li>
<li>Wait for all shards to finish, then collect and report the results.</li>
</ol>
<p>Your project may have tests that were written without Google Test and thus don&#8217;t understand this protocol. In order for your test runner to figure out which test supports sharding, it can set the environment variable <code>GTEST_SHARD_STATUS_FILE</code> to a non-existent file path. If a test program supports sharding, it will create this file to acknowledge the fact (the actual contents of the file are not important at this time; although we may stick some useful information in it in the future.); otherwise it will not create it.</p>
<p>Here&#8217;s an example to make it clear. Suppose you have a test program <code>foo_test</code> that contains the following 5 test functions:</p>
<pre><code>TEST(A, V)
TEST(A, W)
TEST(B, X)
TEST(B, Y)
TEST(B, Z)</code></pre>
<p>and you have 3 machines at your disposal. To run the test functions in parallel, you would set <code>GTEST_TOTAL_SHARDS</code> to 3 on all machines, and set <code>GTEST_SHARD_INDEX</code> to 0, 1, and 2 on the machines respectively. Then you would run the same <code>foo_test</code> on each machine.</p>
<p>Google Test reserves the right to change how the work is distributed across the shards, but here&#8217;s one possible scenario:</p>
<ul>
<li>Machine #0 runs <code>A.V</code> and <code>B.X</code>.</li>
<li>Machine #1 runs <code>A.W</code> and <code>B.Y</code>.</li>
<li>Machine #2 runs <code>B.Z</code>.</li>
</ul>
<p><em>Availability:</em> Linux, Windows, Mac; since version 1.3.0.</p>
<h3 id="fusing-google-test-source-files">Fusing Google Test Source Files</h3>
<p>Google Test&#8217;s implementation consists of ~30 files (excluding its own tests). Sometimes you may want them to be packaged up in two files (a <code>.h</code> and a <code>.cc</code>) instead, such that you can easily copy them to a new machine and start hacking there. For this we provide an experimental Python script <code>fuse_gtest_files.py</code> in the <code>scripts/</code> directory (since release 1.3.0). Assuming you have Python 2.4 or above installed on your machine, just go to that directory and run</p>
<pre><code>python fuse_gtest_files.py OUTPUT_DIR</code></pre>
<p>and you should see an <code>OUTPUT_DIR</code> directory being created with files <code>gtest/gtest.h</code> and <code>gtest/gtest-all.cc</code> in it. These files contain everything you need to use Google Test. Just copy them to anywhere you want and you are ready to write tests. You can use the <a href="../scripts/test/Makefile">scripts/test/Makefile</a> file as an example on how to compile your tests against them.</p>
<h3 id="where-to-go-from-here-1">Where to Go from Here</h3>
<p>Congratulations! You&#8217;ve now learned more advanced Google Test tools and are ready to tackle more complex testing tasks. If you want to dive even deeper, you can read the <a href="V1_6_FAQ.md">Frequently-Asked Questions</a>.</p>
<hr />
<h2 id="cheat-sheet">Cheat Sheet</h2>
<h3 id="defining-a-mock-class">Defining a Mock Class</h3>
<h4 id="mocking-a-normal-class">Mocking a Normal Class</h4>
<p>Given</p>
<pre><code>class Foo {
  ...
  virtual ~Foo();
  virtual int GetSize() const = 0;
  virtual string Describe(const char* name) = 0;
  virtual string Describe(int type) = 0;
  virtual bool Process(Bar elem, int count) = 0;
};</code></pre>
<p>(note that <code>~Foo()</code> <strong>must</strong> be virtual) we can define its mock as</p>
<pre><code>#include &quot;gmock/gmock.h&quot;

class MockFoo : public Foo {
  MOCK_CONST_METHOD0(GetSize, int());
  MOCK_METHOD1(Describe, string(const char* name));
  MOCK_METHOD1(Describe, string(int type));
  MOCK_METHOD2(Process, bool(Bar elem, int count));
};</code></pre>
<p>To create a &#8220;nice&#8221; mock object which ignores all uninteresting calls, or a &#8220;strict&#8221; mock object, which treats them as failures:</p>
<pre><code>NiceMock&lt;MockFoo&gt; nice_foo;     // The type is a subclass of MockFoo.
StrictMock&lt;MockFoo&gt; strict_foo; // The type is a subclass of MockFoo.</code></pre>
<h4 id="mocking-a-class-template">Mocking a Class Template</h4>
<p>To mock</p>
<pre><code>template &lt;typename Elem&gt;
class StackInterface {
 public:
  ...
  virtual ~StackInterface();
  virtual int GetSize() const = 0;
  virtual void Push(const Elem&amp; x) = 0;
};</code></pre>
<p>(note that <code>~StackInterface()</code> <strong>must</strong> be virtual) just append <code>_T</code> to the <code>MOCK_*</code> macros:</p>
<pre><code>template &lt;typename Elem&gt;
class MockStack : public StackInterface&lt;Elem&gt; {
 public:
  ...
  MOCK_CONST_METHOD0_T(GetSize, int());
  MOCK_METHOD1_T(Push, void(const Elem&amp; x));
};</code></pre>
<h4 id="specifying-calling-conventions-for-mock-functions">Specifying Calling Conventions for Mock Functions</h4>
<p>If your mock function doesn&#8217;t use the default calling convention, you can specify it by appending <code>_WITH_CALLTYPE</code> to any of the macros described in the previous two sections and supplying the calling convention as the first argument to the macro. For example,</p>
<pre><code>  MOCK_METHOD_1_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int n));
  MOCK_CONST_METHOD2_WITH_CALLTYPE(STDMETHODCALLTYPE, Bar, int(double x, double y));</code></pre>
<p>where <code>STDMETHODCALLTYPE</code> is defined by <code>&lt;objbase.h&gt;</code> on Windows.</p>
<h3 id="using-mocks-in-tests">Using Mocks in Tests</h3>
<p>The typical flow is: 1. Import the Google Mock names you need to use. All Google Mock names are in the <code>testing</code> namespace unless they are macros or otherwise noted. 1. Create the mock objects. 1. Optionally, set the default actions of the mock objects. 1. Set your expectations on the mock objects (How will they be called? What wil they do?). 1. Exercise code that uses the mock objects; if necessary, check the result using <a href="../../googletest/">Google Test</a> assertions. 1. When a mock objects is destructed, Google Mock automatically verifies that all expectations on it have been satisfied.</p>
<p>Here is an example:</p>
<pre><code>using ::testing::Return;                            // #1

TEST(BarTest, DoesThis) {
  MockFoo foo;                                    // #2

  ON_CALL(foo, GetSize())                         // #3
      .WillByDefault(Return(1));
  // ... other default actions ...

  EXPECT_CALL(foo, Describe(5))                   // #4
      .Times(3)
      .WillRepeatedly(Return(&quot;Category 5&quot;));
  // ... other expectations ...

  EXPECT_EQ(&quot;good&quot;, MyProductionFunction(&amp;foo));  // #5
}                                                 // #6</code></pre>
<h3 id="setting-default-actions">Setting Default Actions</h3>
<p>Google Mock has a <strong>built-in default action</strong> for any function that returns <code>void</code>, <code>bool</code>, a numeric value, or a pointer.</p>
<p>To customize the default action for functions with return type <code>T</code> globally:</p>
<pre><code>using ::testing::DefaultValue;

// Sets the default value to be returned. T must be CopyConstructible.
DefaultValue&lt;T&gt;::Set(value);
// Sets a factory. Will be invoked on demand. T must be MoveConstructible.
//   T MakeT();
DefaultValue&lt;T&gt;::SetFactory(&amp;MakeT);
// ... use the mocks ...
// Resets the default value.
DefaultValue&lt;T&gt;::Clear();</code></pre>
<p>To customize the default action for a particular method, use <code>ON_CALL()</code>:</p>
<pre><code>ON_CALL(mock_object, method(matchers))
    .With(multi_argument_matcher)  ?
    .WillByDefault(action);</code></pre>
<h3 id="setting-expectations">Setting Expectations</h3>
<p><code>EXPECT_CALL()</code> sets <strong>expectations</strong> on a mock method (How will it be called? What will it do?):</p>
<pre><code>EXPECT_CALL(mock_object, method(matchers))
    .With(multi_argument_matcher)  ?
    .Times(cardinality)            ?
    .InSequence(sequences)         *
    .After(expectations)           *
    .WillOnce(action)              *
    .WillRepeatedly(action)        ?
    .RetiresOnSaturation();        ?</code></pre>
<p>If <code>Times()</code> is omitted, the cardinality is assumed to be:</p>
<ul>
<li><code>Times(1)</code> when there is neither <code>WillOnce()</code> nor <code>WillRepeatedly()</code>;</li>
<li><code>Times(n)</code> when there are <code>n WillOnce()</code>s but no <code>WillRepeatedly()</code>, where <code>n</code> &gt;= 1; or</li>
<li><code>Times(AtLeast(n))</code> when there are <code>n WillOnce()</code>s and a <code>WillRepeatedly()</code>, where <code>n</code> &gt;= 0.</li>
</ul>
<p>A method with no <code>EXPECT_CALL()</code> is free to be invoked <em>any number of times</em>, and the default action will be taken each time.</p>
<h3 id="matchers">Matchers</h3>
<p>A <strong>matcher</strong> matches a <em>single</em> argument. You can use it inside <code>ON_CALL()</code> or <code>EXPECT_CALL()</code>, or use it to validate a value directly:</p>
<table>
<colgroup>
<col width="43%" />
<col width="56%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>EXPECT_THAT(value, matcher)</code></th>
<th align="left">Asserts that <code>value</code> matches <code>matcher</code>.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ASSERT_THAT(value, matcher)</code></td>
<td align="left">The same as <code>EXPECT_THAT(value, matcher)</code>, except that it generates a <strong>fatal</strong> failure.</td>
</tr>
</tbody>
</table>
<p>Built-in matchers (where <code>argument</code> is the function argument) are divided into several categories:</p>
<h4 id="wildcard">Wildcard</h4>
<table>
<thead>
<tr class="header">
<th align="left"><code>_</code></th>
<th align="left"><code>argument</code> can be any value of the correct type.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>A&lt;type&gt;()</code> or <code>An&lt;type&gt;()</code></td>
<td align="left"><code>argument</code> can be any value of type <code>type</code>.</td>
</tr>
</tbody>
</table>
<h4 id="generic-comparison">Generic Comparison</h4>
<table style="width:60%;">
<colgroup>
<col width="31%" />
<col width="27%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>Eq(value)</code> or <code>value</code></th>
<th align="left"><code>argument == value</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>Ge(value)</code></td>
<td align="left"><code>argument &gt;= value</code></td>
</tr>
<tr class="even">
<td align="left"><code>Gt(value)</code></td>
<td align="left"><code>argument &gt; value</code></td>
</tr>
<tr class="odd">
<td align="left"><code>Le(value)</code></td>
<td align="left"><code>argument &lt;= value</code></td>
</tr>
<tr class="even">
<td align="left"><code>Lt(value)</code></td>
<td align="left"><code>argument &lt; value</code></td>
</tr>
<tr class="odd">
<td align="left"><code>Ne(value)</code></td>
<td align="left"><code>argument != value</code></td>
</tr>
<tr class="even">
<td align="left"><code>IsNull()</code></td>
<td align="left"><code>argument</code> is a <code>NULL</code> pointer (raw or smart).</td>
</tr>
<tr class="odd">
<td align="left"><code>NotNull()</code></td>
<td align="left"><code>argument</code> is a non-null pointer (raw or smart).</td>
</tr>
<tr class="even">
<td align="left"><code>Ref(variable)</code></td>
<td align="left"><code>argument</code> is a reference to <code>variable</code>.</td>
</tr>
<tr class="odd">
<td align="left"><code>TypedEq&lt;type&gt;(value)</code></td>
<td align="left"><code>argument</code> has type <code>type</code> and is equal to <code>value</code>. You may need to use this instead of <code>Eq(value)</code> when the mock function is overloaded.</td>
</tr>
</tbody>
</table>
<p>Except <code>Ref()</code>, these matchers make a <em>copy</em> of <code>value</code> in case it&#8217;s modified or destructed later. If the compiler complains that <code>value</code> doesn&#8217;t have a public copy constructor, try wrap it in <code>ByRef()</code>, e.g. <code>Eq(ByRef(non_copyable_value))</code>. If you do that, make sure <code>non_copyable_value</code> is not changed afterwards, or the meaning of your matcher will be changed.</p>
<h4 id="floating-point-matchers">Floating-Point Matchers</h4>
<table>
<colgroup>
<col width="17%" />
<col width="82%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>DoubleEq(a_double)</code></th>
<th align="left"><code>argument</code> is a <code>double</code> value approximately equal to <code>a_double</code>, treating two NaNs as unequal.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>FloatEq(a_float)</code></td>
<td align="left"><code>argument</code> is a <code>float</code> value approximately equal to <code>a_float</code>, treating two NaNs as unequal.</td>
</tr>
<tr class="even">
<td align="left"><code>NanSensitiveDoubleEq(a_double)</code></td>
<td align="left"><code>argument</code> is a <code>double</code> value approximately equal to <code>a_double</code>, treating two NaNs as equal.</td>
</tr>
<tr class="odd">
<td align="left"><code>NanSensitiveFloatEq(a_float)</code></td>
<td align="left"><code>argument</code> is a <code>float</code> value approximately equal to <code>a_float</code>, treating two NaNs as equal.</td>
</tr>
</tbody>
</table>
<p>The above matchers use ULP-based comparison (the same as used in <a href="../../googletest/">Google Test</a>). They automatically pick a reasonable error bound based on the absolute value of the expected value. <code>DoubleEq()</code> and <code>FloatEq()</code> conform to the IEEE standard, which requires comparing two NaNs for equality to return false. The <code>NanSensitive*</code> version instead treats two NaNs as equal, which is often what a user wants.</p>
<table>
<colgroup>
<col width="24%" />
<col width="75%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>DoubleNear(a_double, max_abs_error)</code></th>
<th align="left"><code>argument</code> is a <code>double</code> value close to <code>a_double</code> (absolute error &lt;= <code>max_abs_error</code>), treating two NaNs as unequal.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>FloatNear(a_float, max_abs_error)</code></td>
<td align="left"><code>argument</code> is a <code>float</code> value close to <code>a_float</code> (absolute error &lt;= <code>max_abs_error</code>), treating two NaNs as unequal.</td>
</tr>
<tr class="even">
<td align="left"><code>NanSensitiveDoubleNear(a_double, max_abs_error)</code></td>
<td align="left"><code>argument</code> is a <code>double</code> value close to <code>a_double</code> (absolute error &lt;= <code>max_abs_error</code>), treating two NaNs as equal.</td>
</tr>
<tr class="odd">
<td align="left"><code>NanSensitiveFloatNear(a_float, max_abs_error)</code></td>
<td align="left"><code>argument</code> is a <code>float</code> value close to <code>a_float</code> (absolute error &lt;= <code>max_abs_error</code>), treating two NaNs as equal.</td>
</tr>
</tbody>
</table>
<h4 id="string-matchers">String Matchers</h4>
<p>The <code>argument</code> can be either a C string or a C++ string object:</p>
<table>
<colgroup>
<col width="32%" />
<col width="67%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>ContainsRegex(string)</code></th>
<th align="left"><code>argument</code> matches the given regular expression.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>EndsWith(suffix)</code></td>
<td align="left"><code>argument</code> ends with string <code>suffix</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>HasSubstr(string)</code></td>
<td align="left"><code>argument</code> contains <code>string</code> as a sub-string.</td>
</tr>
<tr class="odd">
<td align="left"><code>MatchesRegex(string)</code></td>
<td align="left"><code>argument</code> matches the given regular expression with the match starting at the first character and ending at the last character.</td>
</tr>
<tr class="even">
<td align="left"><code>StartsWith(prefix)</code></td>
<td align="left"><code>argument</code> starts with string <code>prefix</code>.</td>
</tr>
<tr class="odd">
<td align="left"><code>StrCaseEq(string)</code></td>
<td align="left"><code>argument</code> is equal to <code>string</code>, ignoring case.</td>
</tr>
<tr class="even">
<td align="left"><code>StrCaseNe(string)</code></td>
<td align="left"><code>argument</code> is not equal to <code>string</code>, ignoring case.</td>
</tr>
<tr class="odd">
<td align="left"><code>StrEq(string)</code></td>
<td align="left"><code>argument</code> is equal to <code>string</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>StrNe(string)</code></td>
<td align="left"><code>argument</code> is not equal to <code>string</code>.</td>
</tr>
</tbody>
</table>
<p><code>ContainsRegex()</code> and <code>MatchesRegex()</code> use the regular expression syntax defined <a href="../../googletest/docs/AdvancedGuide.md#regular-expression-syntax">here</a>. <code>StrCaseEq()</code>, <code>StrCaseNe()</code>, <code>StrEq()</code>, and <code>StrNe()</code> work for wide strings as well.</p>
<h4 id="container-matchers">Container Matchers</h4>
<p>Most STL-style containers support <code>==</code>, so you can use <code>Eq(expected_container)</code> or simply <code>expected_container</code> to match a container exactly. If you want to write the elements in-line, match them more flexibly, or get more informative messages, you can use:</p>
<table style="width:100%;">
<colgroup>
<col width="17%" />
<col width="82%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>ContainerEq(container)</code></th>
<th align="left">The same as <code>Eq(container)</code> except that the failure message also includes which elements are in one container but not the other.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>Contains(e)</code></td>
<td align="left"><code>argument</code> contains an element that matches <code>e</code>, which can be either a value or a matcher.</td>
</tr>
<tr class="even">
<td align="left"><code>Each(e)</code></td>
<td align="left"><code>argument</code> is a container where <em>every</em> element matches <code>e</code>, which can be either a value or a matcher.</td>
</tr>
<tr class="odd">
<td align="left"><code>ElementsAre(e0, e1, ..., en)</code></td>
<td align="left"><code>argument</code> has <code>n + 1</code> elements, where the i-th element matches <code>ei</code>, which can be a value or a matcher. 0 to 10 arguments are allowed.</td>
</tr>
<tr class="even">
<td align="left"><code>ElementsAreArray({ e0, e1, ..., en })</code>, <code>ElementsAreArray(array)</code>, or <code>ElementsAreArray(array, count)</code></td>
<td align="left">The same as <code>ElementsAre()</code> except that the expected element values/matchers come from an initializer list, STL-style container, or C-style array.</td>
</tr>
<tr class="odd">
<td align="left"><code>IsEmpty()</code></td>
<td align="left"><code>argument</code> is an empty container (<code>container.empty()</code>).</td>
</tr>
<tr class="even">
<td align="left"><code>Pointwise(m, container)</code></td>
<td align="left"><code>argument</code> contains the same number of elements as in <code>container</code>, and for all i, (the i-th element in <code>argument</code>, the i-th element in <code>container</code>) match <code>m</code>, which is a matcher on 2-tuples. E.g. <code>Pointwise(Le(), upper_bounds)</code> verifies that each element in <code>argument</code> doesn&#8217;t exceed the corresponding element in <code>upper_bounds</code>. See more detail below.</td>
</tr>
<tr class="odd">
<td align="left"><code>SizeIs(m)</code></td>
<td align="left"><code>argument</code> is a container whose size matches <code>m</code>. E.g. <code>SizeIs(2)</code> or <code>SizeIs(Lt(2))</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>UnorderedElementsAre(e0, e1, ..., en)</code></td>
<td align="left"><code>argument</code> has <code>n + 1</code> elements, and under some permutation each element matches an <code>ei</code> (for a different <code>i</code>), which can be a value or a matcher. 0 to 10 arguments are allowed.</td>
</tr>
<tr class="odd">
<td align="left"><code>UnorderedElementsAreArray({ e0, e1, ..., en })</code>, <code>UnorderedElementsAreArray(array)</code>, or <code>UnorderedElementsAreArray(array, count)</code></td>
<td align="left">The same as <code>UnorderedElementsAre()</code> except that the expected element values/matchers come from an initializer list, STL-style container, or C-style array.</td>
</tr>
<tr class="even">
<td align="left"><code>WhenSorted(m)</code></td>
<td align="left">When <code>argument</code> is sorted using the <code>&lt;</code> operator, it matches container matcher <code>m</code>. E.g. <code>WhenSorted(UnorderedElementsAre(1, 2, 3))</code> verifies that <code>argument</code> contains elements <code>1</code>, <code>2</code>, and <code>3</code>, ignoring order.</td>
</tr>
<tr class="odd">
<td align="left"><code>WhenSortedBy(comparator, m)</code></td>
<td align="left">The same as <code>WhenSorted(m)</code>, except that the given comparator instead of <code>&lt;</code> is used to sort <code>argument</code>. E.g. <code>WhenSortedBy(std::greater&lt;int&gt;(), ElementsAre(3, 2, 1))</code>.</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ul>
<li>These matchers can also match:
<ol style="list-style-type: decimal">
<li>a native array passed by reference (e.g.&#160;in <code>Foo(const int (&amp;a)[5])</code>), and</li>
<li>an array passed as a pointer and a count (e.g.&#160;in <code>Bar(const T* buffer, int len)</code> &#8211; see <a href="#Multiargument_Matchers.md">Multi-argument Matchers</a>).</li>
</ol></li>
<li>The array being matched may be multi-dimensional (i.e.&#160;its elements can be arrays).</li>
<li><code>m</code> in <code>Pointwise(m, ...)</code> should be a matcher for <code>::testing::tuple&lt;T, U&gt;</code> where <code>T</code> and <code>U</code> are the element type of the actual container and the expected container, respectively. For example, to compare two <code>Foo</code> containers where <code>Foo</code> doesn&#8217;t support <code>operator==</code> but has an <code>Equals()</code> method, one might write:</li>
</ul>
<pre><code>using ::testing::get;
MATCHER(FooEq, &quot;&quot;) {
  return get&lt;0&gt;(arg).Equals(get&lt;1&gt;(arg));
}
...
EXPECT_THAT(actual_foos, Pointwise(FooEq(), expected_foos));</code></pre>
<h4 id="member-matchers">Member Matchers</h4>
<table>
<colgroup>
<col width="15%" />
<col width="84%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>Field(&amp;class::field, m)</code></th>
<th align="left"><code>argument.field</code> (or <code>argument-&gt;field</code> when <code>argument</code> is a plain pointer) matches matcher <code>m</code>, where <code>argument</code> is an object of type <em>class</em>.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>Key(e)</code></td>
<td align="left"><code>argument.first</code> matches <code>e</code>, which can be either a value or a matcher. E.g. <code>Contains(Key(Le(5)))</code> can verify that a <code>map</code> contains a key <code>&lt;= 5</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>Pair(m1, m2)</code></td>
<td align="left"><code>argument</code> is an <code>std::pair</code> whose <code>first</code> field matches <code>m1</code> and <code>second</code> field matches <code>m2</code>.</td>
</tr>
<tr class="odd">
<td align="left"><code>Property(&amp;class::property, m)</code></td>
<td align="left"><code>argument.property()</code> (or <code>argument-&gt;property()</code> when <code>argument</code> is a plain pointer) matches matcher <code>m</code>, where <code>argument</code> is an object of type <em>class</em>.</td>
</tr>
</tbody>
</table>
<h4 id="matching-the-result-of-a-function-or-functor">Matching the Result of a Function or Functor</h4>
<table style="width:100%;">
<colgroup>
<col width="19%" />
<col width="80%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>ResultOf(f, m)</code></th>
<th align="left"><code>f(argument)</code> matches matcher <code>m</code>, where <code>f</code> is a function or functor.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h4 id="pointer-matchers">Pointer Matchers</h4>
<table>
<colgroup>
<col width="11%" />
<col width="88%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>Pointee(m)</code></th>
<th align="left"><code>argument</code> (either a smart pointer or a raw pointer) points to a value that matches matcher <code>m</code>.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>WhenDynamicCastTo&lt;T&gt;(m)</code></td>
<td align="left">when <code>argument</code> is passed through <code>dynamic_cast&lt;T&gt;()</code>, it matches matcher <code>m</code>.</td>
</tr>
</tbody>
</table>
<h4 id="multiargument-matchers">Multiargument Matchers</h4>
<p>Technically, all matchers match a <em>single</em> value. A &#8220;multi-argument&#8221; matcher is just one that matches a <em>tuple</em>. The following matchers can be used to match a tuple <code>(x, y)</code>:</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>Eq()</code></th>
<th align="left"><code>x == y</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>Ge()</code></td>
<td align="left"><code>x &gt;= y</code></td>
</tr>
<tr class="even">
<td align="left"><code>Gt()</code></td>
<td align="left"><code>x &gt; y</code></td>
</tr>
<tr class="odd">
<td align="left"><code>Le()</code></td>
<td align="left"><code>x &lt;= y</code></td>
</tr>
<tr class="even">
<td align="left"><code>Lt()</code></td>
<td align="left"><code>x &lt; y</code></td>
</tr>
<tr class="odd">
<td align="left"><code>Ne()</code></td>
<td align="left"><code>x != y</code></td>
</tr>
</tbody>
</table>
<p>You can use the following selectors to pick a subset of the arguments (or reorder them) to participate in the matching:</p>
<table>
<colgroup>
<col width="15%" />
<col width="84%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>AllArgs(m)</code></th>
<th align="left">Equivalent to <code>m</code>. Useful as syntactic sugar in <code>.With(AllArgs(m))</code>.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>Args&lt;N1, N2, ..., Nk&gt;(m)</code></td>
<td align="left">The tuple of the <code>k</code> selected (using 0-based indices) arguments matches <code>m</code>, e.g. <code>Args&lt;1, 2&gt;(Eq())</code>.</td>
</tr>
</tbody>
</table>
<h4 id="composite-matchers">Composite Matchers</h4>
<p>You can make a matcher from one or more other matchers:</p>
<table style="width:100%;">
<colgroup>
<col width="32%" />
<col width="67%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>AllOf(m1, m2, ..., mn)</code></th>
<th align="left"><code>argument</code> matches all of the matchers <code>m1</code> to <code>mn</code>.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>AnyOf(m1, m2, ..., mn)</code></td>
<td align="left"><code>argument</code> matches at least one of the matchers <code>m1</code> to <code>mn</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>Not(m)</code></td>
<td align="left"><code>argument</code> doesn&#8217;t match matcher <code>m</code>.</td>
</tr>
</tbody>
</table>
<h4 id="adapters-for-matchers">Adapters for Matchers</h4>
<table style="width:83%;">
<colgroup>
<col width="27%" />
<col width="55%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>MatcherCast&lt;T&gt;(m)</code></th>
<th align="left">casts matcher <code>m</code> to type <code>Matcher&lt;T&gt;</code>.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>SafeMatcherCast&lt;T&gt;(m)</code></td>
<td align="left"><a href="CookBook.md#casting-matchers">safely casts</a> matcher <code>m</code> to type <code>Matcher&lt;T&gt;</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>Truly(predicate)</code></td>
<td align="left"><code>predicate(argument)</code> returns something considered by C++ to be true, where <code>predicate</code> is a function or functor.</td>
</tr>
</tbody>
</table>
<h4 id="matchers-as-predicates">Matchers as Predicates</h4>
<table style="width:100%;">
<colgroup>
<col width="17%" />
<col width="82%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>Matches(m)(value)</code></th>
<th align="left">evaluates to <code>true</code> if <code>value</code> matches <code>m</code>. You can use <code>Matches(m)</code> alone as a unary functor.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ExplainMatchResult(m, value, result_listener)</code></td>
<td align="left">evaluates to <code>true</code> if <code>value</code> matches <code>m</code>, explaining the result to <code>result_listener</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>Value(value, m)</code></td>
<td align="left">evaluates to <code>true</code> if <code>value</code> matches <code>m</code>.</td>
</tr>
</tbody>
</table>
<h4 id="defining-matchers">Defining Matchers</h4>
<table>
<colgroup>
<col width="47%" />
<col width="52%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>MATCHER(IsEven, &quot;&quot;) { return (arg % 2) == 0; }</code></th>
<th align="left">Defines a matcher <code>IsEven()</code> to match an even number.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>MATCHER_P(IsDivisibleBy, n, &quot;&quot;) { *result_listener &lt;&lt; &quot;where the remainder is &quot; &lt;&lt; (arg % n); return (arg % n) == 0; }</code></td>
<td align="left">Defines a macher <code>IsDivisibleBy(n)</code> to match a number divisible by <code>n</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>MATCHER_P2(IsBetween, a, b, std::string(negation ? &quot;isn't&quot; : &quot;is&quot;) + &quot; between &quot; + PrintToString(a) + &quot; and &quot; + PrintToString(b)) { return a &lt;= arg &amp;&amp; arg &lt;= b; }</code></td>
<td align="left">Defines a matcher <code>IsBetween(a, b)</code> to match a value in the range [<code>a</code>, <code>b</code>].</td>
</tr>
</tbody>
</table>
<p><strong>Notes:</strong></p>
<ol style="list-style-type: decimal">
<li>The <code>MATCHER*</code> macros cannot be used inside a function or class.</li>
<li>The matcher body must be <em>purely functional</em> (i.e.&#160;it cannot have any side effect, and the result must not depend on anything other than the value being matched and the matcher parameters).</li>
<li>You can use <code>PrintToString(x)</code> to convert a value <code>x</code> of any type to a string.</li>
</ol>
<h4 id="matchers-as-test-assertions">Matchers as Test Assertions</h4>
<table>
<colgroup>
<col width="16%" />
<col width="83%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>ASSERT_THAT(expression, m)</code></th>
<th align="left">Generates a <a href="../../googletest/docs/Primer.md#assertions">fatal failure</a> if the value of <code>expression</code> doesn&#8217;t match matcher <code>m</code>.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>EXPECT_THAT(expression, m)</code></td>
<td align="left">Generates a non-fatal failure if the value of <code>expression</code> doesn&#8217;t match matcher <code>m</code>.</td>
</tr>
</tbody>
</table>
<h3 id="actions">Actions</h3>
<p><strong>Actions</strong> specify what a mock function should do when invoked.</p>
<h4 id="returning-a-value">Returning a Value</h4>
<table style="width:65%;">
<colgroup>
<col width="15%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>Return()</code></th>
<th align="left">Return from a <code>void</code> mock function.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>Return(value)</code></td>
<td align="left">Return <code>value</code>. If the type of <code>value</code> is different to the mock function&#8217;s return type, <code>value</code> is converted to the latter type <i>at the time the expectation is set</i>, not when the action is executed.</td>
</tr>
<tr class="even">
<td align="left"><code>ReturnArg&lt;N&gt;()</code></td>
<td align="left">Return the <code>N</code>-th (0-based) argument.</td>
</tr>
<tr class="odd">
<td align="left"><code>ReturnNew&lt;T&gt;(a1, ..., ak)</code></td>
<td align="left">Return <code>new T(a1, ..., ak)</code>; a different object is created each time.</td>
</tr>
<tr class="even">
<td align="left"><code>ReturnNull()</code></td>
<td align="left">Return a null pointer.</td>
</tr>
<tr class="odd">
<td align="left"><code>ReturnPointee(ptr)</code></td>
<td align="left">Return the value pointed to by <code>ptr</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>ReturnRef(variable)</code></td>
<td align="left">Return a reference to <code>variable</code>.</td>
</tr>
<tr class="odd">
<td align="left"><code>ReturnRefOfCopy(value)</code></td>
<td align="left">Return a reference to a copy of <code>value</code>; the copy lives as long as the action.</td>
</tr>
</tbody>
</table>
<h4 id="side-effects">Side Effects</h4>
<table style="width:76%;">
<colgroup>
<col width="37%" />
<col width="38%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>Assign(&amp;variable, value)</code></th>
<th align="left">Assign <code>value</code> to variable.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>DeleteArg&lt;N&gt;()</code></td>
<td align="left">Delete the <code>N</code>-th (0-based) argument, which must be a pointer.</td>
</tr>
<tr class="even">
<td align="left"><code>SaveArg&lt;N&gt;(pointer)</code></td>
<td align="left">Save the <code>N</code>-th (0-based) argument to <code>*pointer</code>.</td>
</tr>
<tr class="odd">
<td align="left"><code>SaveArgPointee&lt;N&gt;(pointer)</code></td>
<td align="left">Save the value pointed to by the <code>N</code>-th (0-based) argument to <code>*pointer</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>SetArgReferee&lt;N&gt;(value)</code></td>
<td align="left">Assign value to the variable referenced by the <code>N</code>-th (0-based) argument.</td>
</tr>
<tr class="odd">
<td align="left"><code>SetArgPointee&lt;N&gt;(value)</code></td>
<td align="left">Assign <code>value</code> to the variable pointed by the <code>N</code>-th (0-based) argument.</td>
</tr>
<tr class="even">
<td align="left"><code>SetArgumentPointee&lt;N&gt;(value)</code></td>
<td align="left">Same as <code>SetArgPointee&lt;N&gt;(value)</code>. Deprecated. Will be removed in v1.7.0.</td>
</tr>
<tr class="odd">
<td align="left"><code>SetArrayArgument&lt;N&gt;(first, last)</code></td>
<td align="left">Copies the elements in source range [<code>first</code>, <code>last</code>) to the array pointed to by the <code>N</code>-th (0-based) argument, which can be either a pointer or an iterator. The action does not take ownership of the elements in the source range.</td>
</tr>
<tr class="even">
<td align="left"><code>SetErrnoAndReturn(error, value)</code></td>
<td align="left">Set <code>errno</code> to <code>error</code> and return <code>value</code>.</td>
</tr>
<tr class="odd">
<td align="left"><code>Throw(exception)</code></td>
<td align="left">Throws the given exception, which can be any copyable value. Available since v1.1.0.</td>
</tr>
</tbody>
</table>
<h4 id="using-a-function-or-a-functor-as-an-action">Using a Function or a Functor as an Action</h4>
<table style="width:100%;">
<colgroup>
<col width="9%" />
<col width="90%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>Invoke(f)</code></th>
<th align="left">Invoke <code>f</code> with the arguments passed to the mock function, where <code>f</code> can be a global/static function or a functor.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>Invoke(object_pointer, &amp;class::method)</code></td>
<td align="left">Invoke the {method on the object with the arguments passed to the mock function.</td>
</tr>
<tr class="even">
<td align="left"><code>InvokeWithoutArgs(f)</code></td>
<td align="left">Invoke <code>f</code>, which can be a global/static function or a functor. <code>f</code> must take no arguments.</td>
</tr>
<tr class="odd">
<td align="left"><code>InvokeWithoutArgs(object_pointer, &amp;class::method)</code></td>
<td align="left">Invoke the method on the object, which takes no arguments.</td>
</tr>
<tr class="even">
<td align="left"><code>InvokeArgument&lt;N&gt;(arg1, arg2, ..., argk)</code></td>
<td align="left">Invoke the mock function&#8217;s <code>N</code>-th (0-based) argument, which must be a function or a functor, with the <code>k</code> arguments.</td>
</tr>
</tbody>
</table>
<p>The return value of the invoked function is used as the return value of the action.</p>
<p>When defining a function or functor to be used with <code>Invoke*()</code>, you can declare any unused parameters as <code>Unused</code>:</p>
<pre><code>  double Distance(Unused, double x, double y) { return sqrt(x*x + y*y); }
  ...
  EXPECT_CALL(mock, Foo(&quot;Hi&quot;, _, _)).WillOnce(Invoke(Distance));</code></pre>
<p>In <code>InvokeArgument&lt;N&gt;(...)</code>, if an argument needs to be passed by reference, wrap it inside <code>ByRef()</code>. For example,</p>
<pre><code>  InvokeArgument&lt;2&gt;(5, string(&quot;Hi&quot;), ByRef(foo))</code></pre>
<p>calls the mock function&#8217;s #2 argument, passing to it <code>5</code> and <code>string(&quot;Hi&quot;)</code> by value, and <code>foo</code> by reference.</p>
<h4 id="default-action">Default Action</h4>
<table style="width:100%;">
<colgroup>
<col width="16%" />
<col width="83%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>DoDefault()</code></th>
<th align="left">Do the default action (specified by <code>ON_CALL()</code> or the built-in one).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p><strong>Note:</strong> due to technical reasons, <code>DoDefault()</code> cannot be used inside a composite action - trying to do so will result in a run-time error.</p>
<h4 id="composite-actions">Composite Actions</h4>
<table>
<colgroup>
<col width="16%" />
<col width="83%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>DoAll(a1, a2, ..., an)</code></th>
<th align="left">Do all actions <code>a1</code> to <code>an</code> and return the result of <code>an</code> in each invocation. The first <code>n - 1</code> sub-actions must return void.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>IgnoreResult(a)</code></td>
<td align="left">Perform action <code>a</code> and ignore its result. <code>a</code> must not return void.</td>
</tr>
<tr class="even">
<td align="left"><code>WithArg&lt;N&gt;(a)</code></td>
<td align="left">Pass the <code>N</code>-th (0-based) argument of the mock function to action <code>a</code> and perform it.</td>
</tr>
<tr class="odd">
<td align="left"><code>WithArgs&lt;N1, N2, ..., Nk&gt;(a)</code></td>
<td align="left">Pass the selected (0-based) arguments of the mock function to action <code>a</code> and perform it.</td>
</tr>
<tr class="even">
<td align="left"><code>WithoutArgs(a)</code></td>
<td align="left">Perform action <code>a</code> without any arguments.</td>
</tr>
</tbody>
</table>
<h4 id="defining-actions">Defining Actions</h4>
<table>
<colgroup>
<col width="31%" />
<col width="68%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>ACTION(Sum) { return arg0 + arg1; }</code></th>
<th align="left">Defines an action <code>Sum()</code> to return the sum of the mock function&#8217;s argument #0 and #1.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ACTION_P(Plus, n) { return arg0 + n; }</code></td>
<td align="left">Defines an action <code>Plus(n)</code> to return the sum of the mock function&#8217;s argument #0 and <code>n</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>ACTION_Pk(Foo, p1, ..., pk) { statements; }</code></td>
<td align="left">Defines a parameterized action <code>Foo(p1, ..., pk)</code> to execute the given <code>statements</code>.</td>
</tr>
</tbody>
</table>
<p>The <code>ACTION*</code> macros cannot be used inside a function or class.</p>
<h3 id="cardinalities">Cardinalities</h3>
<p>These are used in <code>Times()</code> to specify how many times a mock function will be called:</p>
<table style="width:86%;">
<colgroup>
<col width="19%" />
<col width="66%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>AnyNumber()</code></th>
<th align="left">The function can be called any number of times.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>AtLeast(n)</code></td>
<td align="left">The call is expected at least <code>n</code> times.</td>
</tr>
<tr class="even">
<td align="left"><code>AtMost(n)</code></td>
<td align="left">The call is expected at most <code>n</code> times.</td>
</tr>
<tr class="odd">
<td align="left"><code>Between(m, n)</code></td>
<td align="left">The call is expected between <code>m</code> and <code>n</code> (inclusive) times.</td>
</tr>
<tr class="even">
<td align="left"><code>Exactly(n) or n</code></td>
<td align="left">The call is expected exactly <code>n</code> times. In particular, the call should never happen when <code>n</code> is 0.</td>
</tr>
</tbody>
</table>
<h3 id="expectation-order">Expectation Order</h3>
<p>By default, the expectations can be matched in <em>any</em> order. If some or all expectations must be matched in a given order, there are two ways to specify it. They can be used either independently or together.</p>
<h4 id="the-after-clause">The After Clause</h4>
<pre><code>using ::testing::Expectation;
...
Expectation init_x = EXPECT_CALL(foo, InitX());
Expectation init_y = EXPECT_CALL(foo, InitY());
EXPECT_CALL(foo, Bar())
    .After(init_x, init_y);</code></pre>
<p>says that <code>Bar()</code> can be called only after both <code>InitX()</code> and <code>InitY()</code> have been called.</p>
<p>If you don&#8217;t know how many pre-requisites an expectation has when you write it, you can use an <code>ExpectationSet</code> to collect them:</p>
<pre><code>using ::testing::ExpectationSet;
...
ExpectationSet all_inits;
for (int i = 0; i &lt; element_count; i++) {
  all_inits += EXPECT_CALL(foo, InitElement(i));
}
EXPECT_CALL(foo, Bar())
    .After(all_inits);</code></pre>
<p>says that <code>Bar()</code> can be called only after all elements have been initialized (but we don&#8217;t care about which elements get initialized before the others).</p>
<p>Modifying an <code>ExpectationSet</code> after using it in an <code>.After()</code> doesn&#8217;t affect the meaning of the <code>.After()</code>.</p>
<h4 id="sequences">Sequences</h4>
<p>When you have a long chain of sequential expectations, it&#8217;s easier to specify the order using <strong>sequences</strong>, which don&#8217;t require you to given each expectation in the chain a different name. <i>All expected<br> calls</i> in the same sequence must occur in the order they are specified.</p>
<pre><code>using ::testing::Sequence;
Sequence s1, s2;
...
EXPECT_CALL(foo, Reset())
    .InSequence(s1, s2)
    .WillOnce(Return(true));
EXPECT_CALL(foo, GetSize())
    .InSequence(s1)
    .WillOnce(Return(1));
EXPECT_CALL(foo, Describe(A&lt;const char*&gt;()))
    .InSequence(s2)
    .WillOnce(Return(&quot;dummy&quot;));</code></pre>
<p>says that <code>Reset()</code> must be called before <em>both</em> <code>GetSize()</code> <em>and</em> <code>Describe()</code>, and the latter two can occur in any order.</p>
<p>To put many expectations in a sequence conveniently:</p>
<pre><code>using ::testing::InSequence;
{
  InSequence dummy;

  EXPECT_CALL(...)...;
  EXPECT_CALL(...)...;
  ...
  EXPECT_CALL(...)...;
}</code></pre>
<p>says that all expected calls in the scope of <code>dummy</code> must occur in strict order. The name <code>dummy</code> is irrelevant.)</p>
<h3 id="verifying-and-resetting-a-mock">Verifying and Resetting a Mock</h3>
<p>Google Mock will verify the expectations on a mock object when it is destructed, or you can do it earlier:</p>
<pre><code>using ::testing::Mock;
...
// Verifies and removes the expectations on mock_obj;
// returns true iff successful.
Mock::VerifyAndClearExpectations(&amp;mock_obj);
...
// Verifies and removes the expectations on mock_obj;
// also removes the default actions set by ON_CALL();
// returns true iff successful.
Mock::VerifyAndClear(&amp;mock_obj);</code></pre>
<p>You can also tell Google Mock that a mock object can be leaked and doesn&#8217;t need to be verified:</p>
<pre><code>Mock::AllowLeak(&amp;mock_obj);</code></pre>
<h3 id="mock-classes">Mock Classes</h3>
<p>Google Mock defines a convenient mock class template</p>
<pre><code>class MockFunction&lt;R(A1, ..., An)&gt; {
 public:
  MOCK_METHODn(Call, R(A1, ..., An));
};</code></pre>
<p>See this <a href="CookBook.md#using-check-points">recipe</a> for one application of it.</p>
<h3 id="flags">Flags</h3>
<table>
<colgroup>
<col width="40%" />
<col width="59%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>--gmock_catch_leaked_mocks=0</code></th>
<th align="left">Don&#8217;t report leaked mock objects as failures.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>--gmock_verbose=LEVEL</code></td>
<td align="left">Sets the default verbosity level (<code>info</code>, <code>warning</code>, or <code>error</code>) of Google Mock messages.</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="examples">Examples</h2>
<div class="sourceCode" id="sample1h"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#ifndef GTEST_SAMPLES_SAMPLE1_H_</span>
<span class="ot">#define GTEST_SAMPLES_SAMPLE1_H_</span>

<span class="co">// Returns n! (the factorial of n).  For negative n, n! is defined to be 1.</span>
<span class="dt">int</span> Factorial(<span class="dt">int</span> n);

<span class="co">// Returns true iff n is a prime number.</span>
<span class="dt">bool</span> IsPrime(<span class="dt">int</span> n);

<span class="ot">#endif  </span><span class="co">// GTEST_SAMPLES_SAMPLE1_H_</span></code></pre></div>
<div class="sourceCode" id="sample1cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// A sample program demonstrating using Google C++ testing framework.</span>
<span class="co">//</span>
<span class="co">// Author: wan@google.com (Zhanyong Wan)</span>


<span class="co">// This sample shows how to write a simple unit test for a function,</span>
<span class="co">// using Google C++ testing framework.</span>
<span class="co">//</span>
<span class="co">// Writing a unit test using Google C++ testing framework is easy as 1-2-3:</span>


<span class="co">// Step 1. Include necessary header files such that the stuff your</span>
<span class="co">// test logic needs is declared.</span>
<span class="co">//</span>
<span class="co">// Don&#39;t forget gtest.h, which declares the testing framework.</span>

<span class="ot">#include &lt;limits.h&gt;</span>
<span class="ot">#include &quot;sample1.h&quot;</span>
<span class="ot">#include &quot;gtest/gtest.h&quot;</span>


<span class="co">// Step 2. Use the TEST macro to define your tests.</span>
<span class="co">//</span>
<span class="co">// TEST has two parameters: the test case name and the test name.</span>
<span class="co">// After using the macro, you should define your test logic between a</span>
<span class="co">// pair of braces.  You can use a bunch of macros to indicate the</span>
<span class="co">// success or failure of a test.  EXPECT_TRUE and EXPECT_EQ are</span>
<span class="co">// examples of such macros.  For a complete list, see gtest.h.</span>
<span class="co">//</span>
<span class="co">// &lt;TechnicalDetails&gt;</span>
<span class="co">//</span>
<span class="co">// In Google Test, tests are grouped into test cases.  This is how we</span>
<span class="co">// keep test code organized.  You should put logically related tests</span>
<span class="co">// into the same test case.</span>
<span class="co">//</span>
<span class="co">// The test case name and the test name should both be valid C++</span>
<span class="co">// identifiers.  And you should not use underscore (_) in the names.</span>
<span class="co">//</span>
<span class="co">// Google Test guarantees that each test you define is run exactly</span>
<span class="co">// once, but it makes no guarantee on the order the tests are</span>
<span class="co">// executed.  Therefore, you should write your tests in such a way</span>
<span class="co">// that their results don&#39;t depend on their order.</span>
<span class="co">//</span>
<span class="co">// &lt;/TechnicalDetails&gt;</span>


<span class="co">// Tests Factorial().</span>

<span class="co">// Tests factorial of negative numbers.</span>
TEST(FactorialTest, Negative) {
  <span class="co">// This test is named &quot;Negative&quot;, and belongs to the &quot;FactorialTest&quot;</span>
  <span class="co">// test case.</span>
  EXPECT_EQ(<span class="dv">1</span>, Factorial(<span class="dv">-5</span>));
  EXPECT_EQ(<span class="dv">1</span>, Factorial(<span class="dv">-1</span>));
  EXPECT_GT(Factorial(<span class="dv">-10</span>), <span class="dv">0</span>);

  <span class="co">// &lt;TechnicalDetails&gt;</span>
  <span class="co">//</span>
  <span class="co">// EXPECT_EQ(expected, actual) is the same as</span>
  <span class="co">//</span>
  <span class="co">//   EXPECT_TRUE((expected) == (actual))</span>
  <span class="co">//</span>
  <span class="co">// except that it will print both the expected value and the actual</span>
  <span class="co">// value when the assertion fails.  This is very helpful for</span>
  <span class="co">// debugging.  Therefore in this case EXPECT_EQ is preferred.</span>
  <span class="co">//</span>
  <span class="co">// On the other hand, EXPECT_TRUE accepts any Boolean expression,</span>
  <span class="co">// and is thus more general.</span>
  <span class="co">//</span>
  <span class="co">// &lt;/TechnicalDetails&gt;</span>
}

<span class="co">// Tests factorial of 0.</span>
TEST(FactorialTest, Zero) {
  EXPECT_EQ(<span class="dv">1</span>, Factorial(<span class="dv">0</span>));
}

<span class="co">// Tests factorial of positive numbers.</span>
TEST(FactorialTest, Positive) {
  EXPECT_EQ(<span class="dv">1</span>, Factorial(<span class="dv">1</span>));
  EXPECT_EQ(<span class="dv">2</span>, Factorial(<span class="dv">2</span>));
  EXPECT_EQ(<span class="dv">6</span>, Factorial(<span class="dv">3</span>));
  EXPECT_EQ(<span class="dv">40320</span>, Factorial(<span class="dv">8</span>));
}


<span class="co">// Tests IsPrime()</span>

<span class="co">// Tests negative input.</span>
TEST(IsPrimeTest, Negative) {
  <span class="co">// This test belongs to the IsPrimeTest test case.</span>

  EXPECT_FALSE(IsPrime(<span class="dv">-1</span>));
  EXPECT_FALSE(IsPrime(<span class="dv">-2</span>));
  EXPECT_FALSE(IsPrime(INT_MIN));
}

<span class="co">// Tests some trivial cases.</span>
TEST(IsPrimeTest, Trivial) {
  EXPECT_FALSE(IsPrime(<span class="dv">0</span>));
  EXPECT_FALSE(IsPrime(<span class="dv">1</span>));
  EXPECT_TRUE(IsPrime(<span class="dv">2</span>));
  EXPECT_TRUE(IsPrime(<span class="dv">3</span>));
}

<span class="co">// Tests positive input.</span>
TEST(IsPrimeTest, Positive) {
  EXPECT_FALSE(IsPrime(<span class="dv">4</span>));
  EXPECT_TRUE(IsPrime(<span class="dv">5</span>));
  EXPECT_FALSE(IsPrime(<span class="dv">6</span>));
  EXPECT_TRUE(IsPrime(<span class="dv">23</span>));
}

<span class="co">// Step 3. Call RUN_ALL_TESTS() in main().</span>
<span class="co">//</span>
<span class="co">// We do this by linking in src/gtest_main.cc file, which consists of</span>
<span class="co">// a main() function which calls RUN_ALL_TESTS() for us.</span>
<span class="co">//</span>
<span class="co">// This runs all the tests you&#39;ve defined, prints the result, and</span>
<span class="co">// returns 0 if successful, or 1 otherwise.</span>
<span class="co">//</span>
<span class="co">// Did you notice that we didn&#39;t register the tests?  The</span>
<span class="co">// RUN_ALL_TESTS() macro magically knows about all the tests we</span>
<span class="co">// defined.  Isn&#39;t this convenient?</span></code></pre></div>
<div class="sourceCode" id="sample2h"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#ifndef GTEST_SAMPLES_SAMPLE2_H_</span>
<span class="ot">#define GTEST_SAMPLES_SAMPLE2_H_</span>

<span class="ot">#include &lt;string.h&gt;</span>


<span class="co">// A simple string class.</span>
<span class="kw">class</span> MyString {
 <span class="kw">private</span>:
  <span class="dt">const</span> <span class="dt">char</span>* c_string_;
  <span class="dt">const</span> MyString&amp; <span class="kw">operator</span>=(<span class="dt">const</span> MyString&amp; rhs);

 <span class="kw">public</span>:
  <span class="co">// Clones a 0-terminated C string, allocating memory using new.</span>
  <span class="dt">static</span> <span class="dt">const</span> <span class="dt">char</span>* CloneCString(<span class="dt">const</span> <span class="dt">char</span>* a_c_string);

  <span class="co">////////////////////////////////////////////////////////////</span>
  <span class="co">//</span>
  <span class="co">// C&#39;tors</span>

  <span class="co">// The default c&#39;tor constructs a NULL string.</span>
  MyString() : c_string_(NULL) {}

  <span class="co">// Constructs a MyString by cloning a 0-terminated C string.</span>
  <span class="kw">explicit</span> MyString(<span class="dt">const</span> <span class="dt">char</span>* a_c_string) : c_string_(NULL) {
    Set(a_c_string);
  }

  <span class="co">// Copy c&#39;tor</span>
  MyString(<span class="dt">const</span> MyString&amp; string) : c_string_(NULL) {
    Set(string.c_string_);
  }

  <span class="co">////////////////////////////////////////////////////////////</span>
  <span class="co">//</span>
  <span class="co">// D&#39;tor.  MyString is intended to be a final class, so the d&#39;tor</span>
  <span class="co">// doesn&#39;t need to be virtual.</span>
  ~MyString() { <span class="kw">delete</span>[] c_string_; }

  <span class="co">// Gets the 0-terminated C string this MyString object represents.</span>
  <span class="dt">const</span> <span class="dt">char</span>* c_string() <span class="dt">const</span> { <span class="kw">return</span> c_string_; }

  size_t Length() <span class="dt">const</span> {
    <span class="kw">return</span> c_string_ == NULL ? <span class="dv">0</span> : strlen(c_string_);
  }

  <span class="co">// Sets the 0-terminated C string this MyString object represents.</span>
  <span class="dt">void</span> Set(<span class="dt">const</span> <span class="dt">char</span>* c_string);
};


<span class="ot">#endif  </span><span class="co">// GTEST_SAMPLES_SAMPLE2_H_</span></code></pre></div>
<div class="sourceCode" id="sample2cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;sample2.h&quot;</span>

<span class="ot">#include &lt;string.h&gt;</span>

<span class="co">// Clones a 0-terminated C string, allocating memory using new.</span>
<span class="dt">const</span> <span class="dt">char</span>* MyString::CloneCString(<span class="dt">const</span> <span class="dt">char</span>* a_c_string) {
  <span class="kw">if</span> (a_c_string == NULL) <span class="kw">return</span> NULL;

  <span class="dt">const</span> size_t len = strlen(a_c_string);
  <span class="dt">char</span>* <span class="dt">const</span> clone = <span class="kw">new</span> <span class="dt">char</span>[ len + <span class="dv">1</span> ];
  memcpy(clone, a_c_string, len + <span class="dv">1</span>);

  <span class="kw">return</span> clone;
}

<span class="co">// Sets the 0-terminated C string this MyString object</span>
<span class="co">// represents.</span>
<span class="dt">void</span> MyString::Set(<span class="dt">const</span> <span class="dt">char</span>* a_c_string) {
  <span class="co">// Makes sure this works when c_string == c_string_</span>
  <span class="dt">const</span> <span class="dt">char</span>* <span class="dt">const</span> temp = MyString::CloneCString(a_c_string);
  <span class="kw">delete</span>[] c_string_;
  c_string_ = temp;
}</code></pre></div>
<div class="sourceCode" id="sample2test"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;sample2.h&quot;</span>
<span class="ot">#include &quot;gtest/gtest.h&quot;</span>

<span class="co">// In this example, we test the MyString class (a simple string).</span>

<span class="co">// Tests the default c&#39;tor.</span>
TEST(MyString, DefaultConstructor) {
  <span class="dt">const</span> MyString s;

  <span class="co">// Asserts that s.c_string() returns NULL.</span>
  <span class="co">//</span>
  <span class="co">// &lt;TechnicalDetails&gt;</span>
  <span class="co">//</span>
  <span class="co">// If we write NULL instead of</span>
  <span class="co">//</span>
  <span class="co">//   static_cast&lt;const char *&gt;(NULL)</span>
  <span class="co">//</span>
  <span class="co">// in this assertion, it will generate a warning on gcc 3.4.  The</span>
  <span class="co">// reason is that EXPECT_EQ needs to know the types of its</span>
  <span class="co">// arguments in order to print them when it fails.  Since NULL is</span>
  <span class="co">// #defined as 0, the compiler will use the formatter function for</span>
  <span class="co">// int to print it.  However, gcc thinks that NULL should be used as</span>
  <span class="co">// a pointer, not an int, and therefore complains.</span>
  <span class="co">//</span>
  <span class="co">// The root of the problem is C++&#39;s lack of distinction between the</span>
  <span class="co">// integer number 0 and the null pointer constant.  Unfortunately,</span>
  <span class="co">// we have to live with this fact.</span>
  <span class="co">//</span>
  <span class="co">// &lt;/TechnicalDetails&gt;</span>
  EXPECT_STREQ(NULL, s.c_string());

  EXPECT_EQ(<span class="dv">0u</span>, s.Length());
}

<span class="dt">const</span> <span class="dt">char</span> kHelloString[] = <span class="st">&quot;Hello, world!&quot;</span>;

<span class="co">// Tests the c&#39;tor that accepts a C string.</span>
TEST(MyString, ConstructorFromCString) {
  <span class="dt">const</span> MyString s(kHelloString);
  EXPECT_EQ(<span class="dv">0</span>, strcmp(s.c_string(), kHelloString));
  EXPECT_EQ(<span class="kw">sizeof</span>(kHelloString)/<span class="kw">sizeof</span>(kHelloString[<span class="dv">0</span>]) - <span class="dv">1</span>,
            s.Length());
}

<span class="co">// Tests the copy c&#39;tor.</span>
TEST(MyString, CopyConstructor) {
  <span class="dt">const</span> MyString s1(kHelloString);
  <span class="dt">const</span> MyString s2 = s1;
  EXPECT_EQ(<span class="dv">0</span>, strcmp(s2.c_string(), kHelloString));
}

<span class="co">// Tests the Set method.</span>
TEST(MyString, Set) {
  MyString s;

  s.Set(kHelloString);
  EXPECT_EQ(<span class="dv">0</span>, strcmp(s.c_string(), kHelloString));

  <span class="co">// Set should work when the input pointer is the same as the one</span>
  <span class="co">// already in the MyString object.</span>
  s.Set(s.c_string());
  EXPECT_EQ(<span class="dv">0</span>, strcmp(s.c_string(), kHelloString));

  <span class="co">// Can we set the MyString to NULL?</span>
  s.Set(NULL);
  EXPECT_STREQ(NULL, s.c_string());
}</code></pre></div>
<div class="sourceCode" id="sample3h"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#ifndef GTEST_SAMPLES_SAMPLE3_INL_H_</span>
<span class="ot">#define GTEST_SAMPLES_SAMPLE3_INL_H_</span>

<span class="ot">#include &lt;stddef.h&gt;</span>


<span class="co">// Queue is a simple queue implemented as a singled-linked list.</span>
<span class="co">//</span>
<span class="co">// The element type must support copy constructor.</span>
<span class="kw">template</span> &lt;<span class="kw">typename</span> E&gt;  <span class="co">// E is the element type</span>
<span class="kw">class</span> Queue;

<span class="co">// QueueNode is a node in a Queue, which consists of an element of</span>
<span class="co">// type E and a pointer to the next node.</span>
<span class="kw">template</span> &lt;<span class="kw">typename</span> E&gt;  <span class="co">// E is the element type</span>
<span class="kw">class</span> QueueNode {
  <span class="kw">friend</span> <span class="kw">class</span> Queue&lt;E&gt;;

 <span class="kw">public</span>:
  <span class="co">// Gets the element in this node.</span>
  <span class="dt">const</span> E&amp; element() <span class="dt">const</span> { <span class="kw">return</span> element_; }

  <span class="co">// Gets the next node in the queue.</span>
  QueueNode* next() { <span class="kw">return</span> next_; }
  <span class="dt">const</span> QueueNode* next() <span class="dt">const</span> { <span class="kw">return</span> next_; }

 <span class="kw">private</span>:
  <span class="co">// Creates a node with a given element value.  The next pointer is</span>
  <span class="co">// set to NULL.</span>
  <span class="kw">explicit</span> QueueNode(<span class="dt">const</span> E&amp; an_element) : element_(an_element), next_(NULL) {}

  <span class="co">// We disable the default assignment operator and copy c&#39;tor.</span>
  <span class="dt">const</span> QueueNode&amp; <span class="kw">operator</span> = (<span class="dt">const</span> QueueNode&amp;);
  QueueNode(<span class="dt">const</span> QueueNode&amp;);

  E element_;
  QueueNode* next_;
};

<span class="kw">template</span> &lt;<span class="kw">typename</span> E&gt;  <span class="co">// E is the element type.</span>
<span class="kw">class</span> Queue {
 <span class="kw">public</span>:
  <span class="co">// Creates an empty queue.</span>
  Queue() : head_(NULL), last_(NULL), size_(<span class="dv">0</span>) {}

  <span class="co">// D&#39;tor.  Clears the queue.</span>
  ~Queue() { Clear(); }

  <span class="co">// Clears the queue.</span>
  <span class="dt">void</span> Clear() {
    <span class="kw">if</span> (size_ &gt; <span class="dv">0</span>) {
      <span class="co">// 1. Deletes every node.</span>
      QueueNode&lt;E&gt;* node = head_;
      QueueNode&lt;E&gt;* next = node-&gt;next();
      <span class="kw">for</span> (; ;) {
        <span class="kw">delete</span> node;
        node = next;
        <span class="kw">if</span> (node == NULL) <span class="kw">break</span>;
        next = node-&gt;next();
      }

      <span class="co">// 2. Resets the member variables.</span>
      head_ = last_ = NULL;
      size_ = <span class="dv">0</span>;
    }
  }

  <span class="co">// Gets the number of elements.</span>
  size_t Size() <span class="dt">const</span> { <span class="kw">return</span> size_; }

  <span class="co">// Gets the first element of the queue, or NULL if the queue is empty.</span>
  QueueNode&lt;E&gt;* Head() { <span class="kw">return</span> head_; }
  <span class="dt">const</span> QueueNode&lt;E&gt;* Head() <span class="dt">const</span> { <span class="kw">return</span> head_; }

  <span class="co">// Gets the last element of the queue, or NULL if the queue is empty.</span>
  QueueNode&lt;E&gt;* Last() { <span class="kw">return</span> last_; }
  <span class="dt">const</span> QueueNode&lt;E&gt;* Last() <span class="dt">const</span> { <span class="kw">return</span> last_; }

  <span class="co">// Adds an element to the end of the queue.  A copy of the element is</span>
  <span class="co">// created using the copy constructor, and then stored in the queue.</span>
  <span class="co">// Changes made to the element in the queue doesn&#39;t affect the source</span>
  <span class="co">// object, and vice versa.</span>
  <span class="dt">void</span> Enqueue(<span class="dt">const</span> E&amp; element) {
    QueueNode&lt;E&gt;* new_node = <span class="kw">new</span> QueueNode&lt;E&gt;(element);

    <span class="kw">if</span> (size_ == <span class="dv">0</span>) {
      head_ = last_ = new_node;
      size_ = <span class="dv">1</span>;
    } <span class="kw">else</span> {
      last_-&gt;next_ = new_node;
      last_ = new_node;
      size_++;
    }
  }

  <span class="co">// Removes the head of the queue and returns it.  Returns NULL if</span>
  <span class="co">// the queue is empty.</span>
  E* Dequeue() {
    <span class="kw">if</span> (size_ == <span class="dv">0</span>) {
      <span class="kw">return</span> NULL;
    }

    <span class="dt">const</span> QueueNode&lt;E&gt;* <span class="dt">const</span> old_head = head_;
    head_ = head_-&gt;next_;
    size_--;
    <span class="kw">if</span> (size_ == <span class="dv">0</span>) {
      last_ = NULL;
    }

    E* element = <span class="kw">new</span> E(old_head-&gt;element());
    <span class="kw">delete</span> old_head;

    <span class="kw">return</span> element;
  }

  <span class="co">// Applies a function/functor on each element of the queue, and</span>
  <span class="co">// returns the result in a new queue.  The original queue is not</span>
  <span class="co">// affected.</span>
  <span class="kw">template</span> &lt;<span class="kw">typename</span> F&gt;
  Queue* Map(F function) <span class="dt">const</span> {
    Queue* new_queue = <span class="kw">new</span> Queue();
    <span class="kw">for</span> (<span class="dt">const</span> QueueNode&lt;E&gt;* node = head_; node != NULL; node = node-&gt;next_) {
      new_queue-&gt;Enqueue(function(node-&gt;element()));
    }

    <span class="kw">return</span> new_queue;
  }

 <span class="kw">private</span>:
  QueueNode&lt;E&gt;* head_;  <span class="co">// The first node of the queue.</span>
  QueueNode&lt;E&gt;* last_;  <span class="co">// The last node of the queue.</span>
  size_t size_;  <span class="co">// The number of elements in the queue.</span>

  <span class="co">// We disallow copying a queue.</span>
  Queue(<span class="dt">const</span> Queue&amp;);
  <span class="dt">const</span> Queue&amp; <span class="kw">operator</span> = (<span class="dt">const</span> Queue&amp;);
};

<span class="ot">#endif  </span><span class="co">// GTEST_SAMPLES_SAMPLE3_INL_H_</span></code></pre></div>
<div class="sourceCode" id="sample4h"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#ifndef GTEST_SAMPLES_SAMPLE4_H_</span>
<span class="ot">#define GTEST_SAMPLES_SAMPLE4_H_</span>

<span class="co">// A simple monotonic counter.</span>
<span class="kw">class</span> Counter {
 <span class="kw">private</span>:
  <span class="dt">int</span> counter_;

 <span class="kw">public</span>:
  <span class="co">// Creates a counter that starts at 0.</span>
  Counter() : counter_(<span class="dv">0</span>) {}

  <span class="co">// Returns the current counter value, and increments it.</span>
  <span class="dt">int</span> Increment();

  <span class="co">// Prints the current counter value to STDOUT.</span>
  <span class="dt">void</span> Print() <span class="dt">const</span>;
};

<span class="ot">#endif  </span><span class="co">// GTEST_SAMPLES_SAMPLE4_H_</span></code></pre></div>
<div class="sourceCode" id="sample4cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="ot">#include &quot;sample4.h&quot;</span>

<span class="co">// Returns the current counter value, and increments it.</span>
<span class="dt">int</span> Counter::Increment() {
  <span class="kw">return</span> counter_++;
}

<span class="co">// Prints the current counter value to STDOUT.</span>
<span class="dt">void</span> Counter::Print() <span class="dt">const</span> {
  printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, counter_);
}</code></pre></div>
<div class="sourceCode" id="sample4test"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;gtest/gtest.h&quot;</span>
<span class="ot">#include &quot;sample4.h&quot;</span>

<span class="co">// Tests the Increment() method.</span>
TEST(Counter, Increment) {
  Counter c;

  <span class="co">// EXPECT_EQ() evaluates its arguments exactly once, so they</span>
  <span class="co">// can have side effects.</span>

  EXPECT_EQ(<span class="dv">0</span>, c.Increment());
  EXPECT_EQ(<span class="dv">1</span>, c.Increment());
  EXPECT_EQ(<span class="dv">2</span>, c.Increment());
}</code></pre></div>
<div class="sourceCode" id="sample5test"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;limits.h&gt;</span>
<span class="ot">#include &lt;time.h&gt;</span>
<span class="ot">#include &quot;sample3-inl.h&quot;</span>
<span class="ot">#include &quot;gtest/gtest.h&quot;</span>
<span class="ot">#include &quot;sample1.h&quot;</span>

<span class="co">// In this sample, we want to ensure that every test finishes within</span>
<span class="co">// ~5 seconds.  If a test takes longer to run, we consider it a</span>
<span class="co">// failure.</span>
<span class="co">//</span>
<span class="co">// We put the code for timing a test in a test fixture called</span>
<span class="co">// &quot;QuickTest&quot;.  QuickTest is intended to be the super fixture that</span>
<span class="co">// other fixtures derive from, therefore there is no test case with</span>
<span class="co">// the name &quot;QuickTest&quot;.  This is OK.</span>
<span class="co">//</span>
<span class="co">// Later, we will derive multiple test fixtures from QuickTest.</span>
<span class="kw">class</span> QuickTest : <span class="kw">public</span> testing::Test {
 <span class="kw">protected</span>:
  <span class="co">// Remember that SetUp() is run immediately before a test starts.</span>
  <span class="co">// This is a good place to record the start time.</span>
  <span class="kw">virtual</span> <span class="dt">void</span> SetUp() {
    start_time_ = time(NULL);
  }

  <span class="co">// TearDown() is invoked immediately after a test finishes.  Here we</span>
  <span class="co">// check if the test was too slow.</span>
  <span class="kw">virtual</span> <span class="dt">void</span> TearDown() {
    <span class="co">// Gets the time when the test finishes</span>
    <span class="dt">const</span> time_t end_time = time(NULL);

    <span class="co">// Asserts that the test took no more than ~5 seconds.  Did you</span>
    <span class="co">// know that you can use assertions in SetUp() and TearDown() as</span>
    <span class="co">// well?</span>
    EXPECT_TRUE(end_time - start_time_ &lt;= <span class="dv">5</span>) &lt;&lt; <span class="st">&quot;The test took too long.&quot;</span>;
  }

  <span class="co">// The UTC time (in seconds) when the test starts</span>
  time_t start_time_;
};


<span class="co">// We derive a fixture named IntegerFunctionTest from the QuickTest</span>
<span class="co">// fixture.  All tests using this fixture will be automatically</span>
<span class="co">// required to be quick.</span>
<span class="kw">class</span> IntegerFunctionTest : <span class="kw">public</span> QuickTest {
  <span class="co">// We don&#39;t need any more logic than already in the QuickTest fixture.</span>
  <span class="co">// Therefore the body is empty.</span>
};


<span class="co">// Now we can write tests in the IntegerFunctionTest test case.</span>

<span class="co">// Tests Factorial()</span>
TEST_F(IntegerFunctionTest, Factorial) {
  <span class="co">// Tests factorial of negative numbers.</span>
  EXPECT_EQ(<span class="dv">1</span>, Factorial(<span class="dv">-5</span>));
  EXPECT_EQ(<span class="dv">1</span>, Factorial(<span class="dv">-1</span>));
  EXPECT_GT(Factorial(<span class="dv">-10</span>), <span class="dv">0</span>);

  <span class="co">// Tests factorial of 0.</span>
  EXPECT_EQ(<span class="dv">1</span>, Factorial(<span class="dv">0</span>));

  <span class="co">// Tests factorial of positive numbers.</span>
  EXPECT_EQ(<span class="dv">1</span>, Factorial(<span class="dv">1</span>));
  EXPECT_EQ(<span class="dv">2</span>, Factorial(<span class="dv">2</span>));
  EXPECT_EQ(<span class="dv">6</span>, Factorial(<span class="dv">3</span>));
  EXPECT_EQ(<span class="dv">40320</span>, Factorial(<span class="dv">8</span>));
}


<span class="co">// Tests IsPrime()</span>
TEST_F(IntegerFunctionTest, IsPrime) {
  <span class="co">// Tests negative input.</span>
  EXPECT_FALSE(IsPrime(<span class="dv">-1</span>));
  EXPECT_FALSE(IsPrime(<span class="dv">-2</span>));
  EXPECT_FALSE(IsPrime(INT_MIN));

  <span class="co">// Tests some trivial cases.</span>
  EXPECT_FALSE(IsPrime(<span class="dv">0</span>));
  EXPECT_FALSE(IsPrime(<span class="dv">1</span>));
  EXPECT_TRUE(IsPrime(<span class="dv">2</span>));
  EXPECT_TRUE(IsPrime(<span class="dv">3</span>));

  <span class="co">// Tests positive input.</span>
  EXPECT_FALSE(IsPrime(<span class="dv">4</span>));
  EXPECT_TRUE(IsPrime(<span class="dv">5</span>));
  EXPECT_FALSE(IsPrime(<span class="dv">6</span>));
  EXPECT_TRUE(IsPrime(<span class="dv">23</span>));
}


<span class="co">// The next test case (named &quot;QueueTest&quot;) also needs to be quick, so</span>
<span class="co">// we derive another fixture from QuickTest.</span>
<span class="co">//</span>
<span class="co">// The QueueTest test fixture has some logic and shared objects in</span>
<span class="co">// addition to what&#39;s in QuickTest already.  We define the additional</span>
<span class="co">// stuff inside the body of the test fixture, as usual.</span>
<span class="kw">class</span> QueueTest : <span class="kw">public</span> QuickTest {
 <span class="kw">protected</span>:
  <span class="kw">virtual</span> <span class="dt">void</span> SetUp() {
    <span class="co">// First, we need to set up the super fixture (QuickTest).</span>
    QuickTest::SetUp();

    <span class="co">// Second, some additional setup for this fixture.</span>
    q1_.Enqueue(<span class="dv">1</span>);
    q2_.Enqueue(<span class="dv">2</span>);
    q2_.Enqueue(<span class="dv">3</span>);
  }

  <span class="co">// By default, TearDown() inherits the behavior of</span>
  <span class="co">// QuickTest::TearDown().  As we have no additional cleaning work</span>
  <span class="co">// for QueueTest, we omit it here.</span>
  <span class="co">//</span>
  <span class="co">// virtual void TearDown() {</span>
  <span class="co">//   QuickTest::TearDown();</span>
  <span class="co">// }</span>

  Queue&lt;<span class="dt">int</span>&gt; q0_;
  Queue&lt;<span class="dt">int</span>&gt; q1_;
  Queue&lt;<span class="dt">int</span>&gt; q2_;
};


<span class="co">// Now, let&#39;s write tests using the QueueTest fixture.</span>

<span class="co">// Tests the default constructor.</span>
TEST_F(QueueTest, DefaultConstructor) {
  EXPECT_EQ(<span class="dv">0u</span>, q0_.Size());
}

<span class="co">// Tests Dequeue().</span>
TEST_F(QueueTest, Dequeue) {
  <span class="dt">int</span>* n = q0_.Dequeue();
  EXPECT_TRUE(n == NULL);

  n = q1_.Dequeue();
  EXPECT_TRUE(n != NULL);
  EXPECT_EQ(<span class="dv">1</span>, *n);
  EXPECT_EQ(<span class="dv">0u</span>, q1_.Size());
  <span class="kw">delete</span> n;

  n = q2_.Dequeue();
  EXPECT_TRUE(n != NULL);
  EXPECT_EQ(<span class="dv">2</span>, *n);
  EXPECT_EQ(<span class="dv">1u</span>, q2_.Size());
  <span class="kw">delete</span> n;
}

<span class="co">// If necessary, you can derive further test fixtures from a derived</span>
<span class="co">// fixture itself.  For example, you can derive another fixture from</span>
<span class="co">// QueueTest.  Google Test imposes no limit on how deep the hierarchy</span>
<span class="co">// can be.  In practice, however, you probably don&#39;t want it to be too</span>
<span class="co">// deep as to be confusing.</span></code></pre></div>
<div class="sourceCode" id="sample6test"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// This sample shows how to test common properties of multiple</span>
<span class="co">// implementations of the same interface (aka interface tests).</span>

<span class="co">// The interface and its implementations are in this header.</span>
<span class="ot">#include &quot;prime_tables.h&quot;</span>

<span class="ot">#include &quot;gtest/gtest.h&quot;</span>

<span class="co">// First, we define some factory functions for creating instances of</span>
<span class="co">// the implementations.  You may be able to skip this step if all your</span>
<span class="co">// implementations can be constructed the same way.</span>

<span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
PrimeTable* CreatePrimeTable();

<span class="kw">template</span> &lt;&gt;
PrimeTable* CreatePrimeTable&lt;OnTheFlyPrimeTable&gt;() {
  <span class="kw">return</span> <span class="kw">new</span> OnTheFlyPrimeTable;
}

<span class="kw">template</span> &lt;&gt;
PrimeTable* CreatePrimeTable&lt;PreCalculatedPrimeTable&gt;() {
  <span class="kw">return</span> <span class="kw">new</span> PreCalculatedPrimeTable(<span class="dv">10000</span>);
}

<span class="co">// Then we define a test fixture class template.</span>
<span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
<span class="kw">class</span> PrimeTableTest : <span class="kw">public</span> testing::Test {
 <span class="kw">protected</span>:
  <span class="co">// The ctor calls the factory function to create a prime table</span>
  <span class="co">// implemented by T.</span>
  PrimeTableTest() : table_(CreatePrimeTable&lt;T&gt;()) {}

  <span class="kw">virtual</span> ~PrimeTableTest() { <span class="kw">delete</span> table_; }

  <span class="co">// Note that we test an implementation via the base interface</span>
  <span class="co">// instead of the actual implementation class.  This is important</span>
  <span class="co">// for keeping the tests close to the real world scenario, where the</span>
  <span class="co">// implementation is invoked via the base interface.  It avoids</span>
  <span class="co">// got-yas where the implementation class has a method that shadows</span>
  <span class="co">// a method with the same name (but slightly different argument</span>
  <span class="co">// types) in the base interface, for example.</span>
  PrimeTable* <span class="dt">const</span> table_;
};

<span class="ot">#if GTEST_HAS_TYPED_TEST</span>

<span class="kw">using</span> testing::Types;

<span class="co">// Google Test offers two ways for reusing tests for different types.</span>
<span class="co">// The first is called &quot;typed tests&quot;.  You should use it if you</span>
<span class="co">// already know *all* the types you are gonna exercise when you write</span>
<span class="co">// the tests.</span>

<span class="co">// To write a typed test case, first use</span>
<span class="co">//</span>
<span class="co">//   TYPED_TEST_CASE(TestCaseName, TypeList);</span>
<span class="co">//</span>
<span class="co">// to declare it and specify the type parameters.  As with TEST_F,</span>
<span class="co">// TestCaseName must match the test fixture name.</span>

<span class="co">// The list of types we want to test.</span>
<span class="kw">typedef</span> Types&lt;OnTheFlyPrimeTable, PreCalculatedPrimeTable&gt; Implementations;

TYPED_TEST_CASE(PrimeTableTest, Implementations);

<span class="co">// Then use TYPED_TEST(TestCaseName, TestName) to define a typed test,</span>
<span class="co">// similar to TEST_F.</span>
TYPED_TEST(PrimeTableTest, ReturnsFalseForNonPrimes) {
  <span class="co">// Inside the test body, you can refer to the type parameter by</span>
  <span class="co">// TypeParam, and refer to the fixture class by TestFixture.  We</span>
  <span class="co">// don&#39;t need them in this example.</span>

  <span class="co">// Since we are in the template world, C++ requires explicitly</span>
  <span class="co">// writing &#39;this-&gt;&#39; when referring to members of the fixture class.</span>
  <span class="co">// This is something you have to learn to live with.</span>
  EXPECT_FALSE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">-5</span>));
  EXPECT_FALSE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">0</span>));
  EXPECT_FALSE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">1</span>));
  EXPECT_FALSE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">4</span>));
  EXPECT_FALSE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">6</span>));
  EXPECT_FALSE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">100</span>));
}

TYPED_TEST(PrimeTableTest, ReturnsTrueForPrimes) {
  EXPECT_TRUE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">2</span>));
  EXPECT_TRUE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">3</span>));
  EXPECT_TRUE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">5</span>));
  EXPECT_TRUE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">7</span>));
  EXPECT_TRUE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">11</span>));
  EXPECT_TRUE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">131</span>));
}

TYPED_TEST(PrimeTableTest, CanGetNextPrime) {
  EXPECT_EQ(<span class="dv">2</span>, <span class="kw">this</span>-&gt;table_-&gt;GetNextPrime(<span class="dv">0</span>));
  EXPECT_EQ(<span class="dv">3</span>, <span class="kw">this</span>-&gt;table_-&gt;GetNextPrime(<span class="dv">2</span>));
  EXPECT_EQ(<span class="dv">5</span>, <span class="kw">this</span>-&gt;table_-&gt;GetNextPrime(<span class="dv">3</span>));
  EXPECT_EQ(<span class="dv">7</span>, <span class="kw">this</span>-&gt;table_-&gt;GetNextPrime(<span class="dv">5</span>));
  EXPECT_EQ(<span class="dv">11</span>, <span class="kw">this</span>-&gt;table_-&gt;GetNextPrime(<span class="dv">7</span>));
  EXPECT_EQ(<span class="dv">131</span>, <span class="kw">this</span>-&gt;table_-&gt;GetNextPrime(<span class="dv">128</span>));
}

<span class="co">// That&#39;s it!  Google Test will repeat each TYPED_TEST for each type</span>
<span class="co">// in the type list specified in TYPED_TEST_CASE.  Sit back and be</span>
<span class="co">// happy that you don&#39;t have to define them multiple times.</span>

<span class="ot">#endif  </span><span class="co">// GTEST_HAS_TYPED_TEST</span>

<span class="ot">#if GTEST_HAS_TYPED_TEST_P</span>

<span class="kw">using</span> testing::Types;

<span class="co">// Sometimes, however, you don&#39;t yet know all the types that you want</span>
<span class="co">// to test when you write the tests.  For example, if you are the</span>
<span class="co">// author of an interface and expect other people to implement it, you</span>
<span class="co">// might want to write a set of tests to make sure each implementation</span>
<span class="co">// conforms to some basic requirements, but you don&#39;t know what</span>
<span class="co">// implementations will be written in the future.</span>
<span class="co">//</span>
<span class="co">// How can you write the tests without committing to the type</span>
<span class="co">// parameters?  That&#39;s what &quot;type-parameterized tests&quot; can do for you.</span>
<span class="co">// It is a bit more involved than typed tests, but in return you get a</span>
<span class="co">// test pattern that can be reused in many contexts, which is a big</span>
<span class="co">// win.  Here&#39;s how you do it:</span>

<span class="co">// First, define a test fixture class template.  Here we just reuse</span>
<span class="co">// the PrimeTableTest fixture defined earlier:</span>

<span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
<span class="kw">class</span> PrimeTableTest2 : <span class="kw">public</span> PrimeTableTest&lt;T&gt; {
};

<span class="co">// Then, declare the test case.  The argument is the name of the test</span>
<span class="co">// fixture, and also the name of the test case (as usual).  The _P</span>
<span class="co">// suffix is for &quot;parameterized&quot; or &quot;pattern&quot;.</span>
TYPED_TEST_CASE_P(PrimeTableTest2);

<span class="co">// Next, use TYPED_TEST_P(TestCaseName, TestName) to define a test,</span>
<span class="co">// similar to what you do with TEST_F.</span>
TYPED_TEST_P(PrimeTableTest2, ReturnsFalseForNonPrimes) {
  EXPECT_FALSE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">-5</span>));
  EXPECT_FALSE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">0</span>));
  EXPECT_FALSE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">1</span>));
  EXPECT_FALSE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">4</span>));
  EXPECT_FALSE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">6</span>));
  EXPECT_FALSE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">100</span>));
}

TYPED_TEST_P(PrimeTableTest2, ReturnsTrueForPrimes) {
  EXPECT_TRUE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">2</span>));
  EXPECT_TRUE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">3</span>));
  EXPECT_TRUE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">5</span>));
  EXPECT_TRUE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">7</span>));
  EXPECT_TRUE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">11</span>));
  EXPECT_TRUE(<span class="kw">this</span>-&gt;table_-&gt;IsPrime(<span class="dv">131</span>));
}

TYPED_TEST_P(PrimeTableTest2, CanGetNextPrime) {
  EXPECT_EQ(<span class="dv">2</span>, <span class="kw">this</span>-&gt;table_-&gt;GetNextPrime(<span class="dv">0</span>));
  EXPECT_EQ(<span class="dv">3</span>, <span class="kw">this</span>-&gt;table_-&gt;GetNextPrime(<span class="dv">2</span>));
  EXPECT_EQ(<span class="dv">5</span>, <span class="kw">this</span>-&gt;table_-&gt;GetNextPrime(<span class="dv">3</span>));
  EXPECT_EQ(<span class="dv">7</span>, <span class="kw">this</span>-&gt;table_-&gt;GetNextPrime(<span class="dv">5</span>));
  EXPECT_EQ(<span class="dv">11</span>, <span class="kw">this</span>-&gt;table_-&gt;GetNextPrime(<span class="dv">7</span>));
  EXPECT_EQ(<span class="dv">131</span>, <span class="kw">this</span>-&gt;table_-&gt;GetNextPrime(<span class="dv">128</span>));
}

<span class="co">// Type-parameterized tests involve one extra step: you have to</span>
<span class="co">// enumerate the tests you defined:</span>
REGISTER_TYPED_TEST_CASE_P(
    PrimeTableTest2,  <span class="co">// The first argument is the test case name.</span>
    <span class="co">// The rest of the arguments are the test names.</span>
    ReturnsFalseForNonPrimes, ReturnsTrueForPrimes, CanGetNextPrime);

<span class="co">// At this point the test pattern is done.  However, you don&#39;t have</span>
<span class="co">// any real test yet as you haven&#39;t said which types you want to run</span>
<span class="co">// the tests with.</span>

<span class="co">// To turn the abstract test pattern into real tests, you instantiate</span>
<span class="co">// it with a list of types.  Usually the test pattern will be defined</span>
<span class="co">// in a .h file, and anyone can #include and instantiate it.  You can</span>
<span class="co">// even instantiate it more than once in the same program.  To tell</span>
<span class="co">// different instances apart, you give each of them a name, which will</span>
<span class="co">// become part of the test case name and can be used in test filters.</span>

<span class="co">// The list of types we want to test.  Note that it doesn&#39;t have to be</span>
<span class="co">// defined at the time we write the TYPED_TEST_P()s.</span>
<span class="kw">typedef</span> Types&lt;OnTheFlyPrimeTable, PreCalculatedPrimeTable&gt;
    PrimeTableImplementations;
INSTANTIATE_TYPED_TEST_CASE_P(OnTheFlyAndPreCalculated,    <span class="co">// Instance name</span>
                              PrimeTableTest2,             <span class="co">// Test case name</span>
                              PrimeTableImplementations);  <span class="co">// Type list</span>

<span class="ot">#endif  </span><span class="co">// GTEST_HAS_TYPED_TEST_P</span></code></pre></div>
<div class="sourceCode" id="sample7test"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// This sample shows how to test common properties of multiple</span>
<span class="co">// implementations of an interface (aka interface tests) using</span>
<span class="co">// value-parameterized tests. Each test in the test case has</span>
<span class="co">// a parameter that is an interface pointer to an implementation</span>
<span class="co">// tested.</span>

<span class="co">// The interface and its implementations are in this header.</span>
<span class="ot">#include &quot;prime_tables.h&quot;</span>

<span class="ot">#include &quot;gtest/gtest.h&quot;</span>

<span class="ot">#if GTEST_HAS_PARAM_TEST</span>

<span class="kw">using</span> ::testing::TestWithParam;
<span class="kw">using</span> ::testing::Values;

<span class="co">// As a general rule, to prevent a test from affecting the tests that come</span>
<span class="co">// after it, you should create and destroy the tested objects for each test</span>
<span class="co">// instead of reusing them.  In this sample we will define a simple factory</span>
<span class="co">// function for PrimeTable objects.  We will instantiate objects in test&#39;s</span>
<span class="co">// SetUp() method and delete them in TearDown() method.</span>
<span class="kw">typedef</span> PrimeTable* CreatePrimeTableFunc();

PrimeTable* CreateOnTheFlyPrimeTable() {
  <span class="kw">return</span> <span class="kw">new</span> OnTheFlyPrimeTable();
}

<span class="kw">template</span> &lt;size_t max_precalculated&gt;
PrimeTable* CreatePreCalculatedPrimeTable() {
  <span class="kw">return</span> <span class="kw">new</span> PreCalculatedPrimeTable(max_precalculated);
}

<span class="co">// Inside the test body, fixture constructor, SetUp(), and TearDown() you</span>
<span class="co">// can refer to the test parameter by GetParam().  In this case, the test</span>
<span class="co">// parameter is a factory function which we call in fixture&#39;s SetUp() to</span>
<span class="co">// create and store an instance of PrimeTable.</span>
<span class="kw">class</span> PrimeTableTest : <span class="kw">public</span> TestWithParam&lt;CreatePrimeTableFunc*&gt; {
 <span class="kw">public</span>:
  <span class="kw">virtual</span> ~PrimeTableTest() { <span class="kw">delete</span> table_; }
  <span class="kw">virtual</span> <span class="dt">void</span> SetUp() { table_ = (*GetParam())(); }
  <span class="kw">virtual</span> <span class="dt">void</span> TearDown() {
    <span class="kw">delete</span> table_;
    table_ = NULL;
  }

 <span class="kw">protected</span>:
  PrimeTable* table_;
};

TEST_P(PrimeTableTest, ReturnsFalseForNonPrimes) {
  EXPECT_FALSE(table_-&gt;IsPrime(<span class="dv">-5</span>));
  EXPECT_FALSE(table_-&gt;IsPrime(<span class="dv">0</span>));
  EXPECT_FALSE(table_-&gt;IsPrime(<span class="dv">1</span>));
  EXPECT_FALSE(table_-&gt;IsPrime(<span class="dv">4</span>));
  EXPECT_FALSE(table_-&gt;IsPrime(<span class="dv">6</span>));
  EXPECT_FALSE(table_-&gt;IsPrime(<span class="dv">100</span>));
}

TEST_P(PrimeTableTest, ReturnsTrueForPrimes) {
  EXPECT_TRUE(table_-&gt;IsPrime(<span class="dv">2</span>));
  EXPECT_TRUE(table_-&gt;IsPrime(<span class="dv">3</span>));
  EXPECT_TRUE(table_-&gt;IsPrime(<span class="dv">5</span>));
  EXPECT_TRUE(table_-&gt;IsPrime(<span class="dv">7</span>));
  EXPECT_TRUE(table_-&gt;IsPrime(<span class="dv">11</span>));
  EXPECT_TRUE(table_-&gt;IsPrime(<span class="dv">131</span>));
}

TEST_P(PrimeTableTest, CanGetNextPrime) {
  EXPECT_EQ(<span class="dv">2</span>, table_-&gt;GetNextPrime(<span class="dv">0</span>));
  EXPECT_EQ(<span class="dv">3</span>, table_-&gt;GetNextPrime(<span class="dv">2</span>));
  EXPECT_EQ(<span class="dv">5</span>, table_-&gt;GetNextPrime(<span class="dv">3</span>));
  EXPECT_EQ(<span class="dv">7</span>, table_-&gt;GetNextPrime(<span class="dv">5</span>));
  EXPECT_EQ(<span class="dv">11</span>, table_-&gt;GetNextPrime(<span class="dv">7</span>));
  EXPECT_EQ(<span class="dv">131</span>, table_-&gt;GetNextPrime(<span class="dv">128</span>));
}

<span class="co">// In order to run value-parameterized tests, you need to instantiate them,</span>
<span class="co">// or bind them to a list of values which will be used as test parameters.</span>
<span class="co">// You can instantiate them in a different translation module, or even</span>
<span class="co">// instantiate them several times.</span>
<span class="co">//</span>
<span class="co">// Here, we instantiate our tests with a list of two PrimeTable object</span>
<span class="co">// factory functions:</span>
INSTANTIATE_TEST_CASE_P(
    OnTheFlyAndPreCalculated,
    PrimeTableTest,
    Values(&amp;CreateOnTheFlyPrimeTable, &amp;CreatePreCalculatedPrimeTable&lt;<span class="dv">1000</span>&gt;));

<span class="ot">#else</span>

<span class="co">// Google Test may not support value-parameterized tests with some</span>
<span class="co">// compilers. If we use conditional compilation to compile out all</span>
<span class="co">// code referring to the gtest_main library, MSVC linker will not link</span>
<span class="co">// that library at all and consequently complain about missing entry</span>
<span class="co">// point defined in that library (fatal error LNK1561: entry point</span>
<span class="co">// must be defined). This dummy test keeps gtest_main linked in.</span>
TEST(DummyTest, ValueParameterizedTestsAreNotSupportedOnThisPlatform) {}

<span class="ot">#endif  </span><span class="co">// GTEST_HAS_PARAM_TEST</span></code></pre></div>
<div class="sourceCode" id="sample8test"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// This sample shows how to test code relying on some global flag variables.</span>
<span class="co">// Combine() helps with generating all possible combinations of such flags,</span>
<span class="co">// and each test is given one combination as a parameter.</span>

<span class="co">// Use class definitions to test from this header.</span>
<span class="ot">#include &quot;prime_tables.h&quot;</span>

<span class="ot">#include &quot;gtest/gtest.h&quot;</span>

<span class="ot">#if GTEST_HAS_COMBINE</span>

<span class="co">// Suppose we want to introduce a new, improved implementation of PrimeTable</span>
<span class="co">// which combines speed of PrecalcPrimeTable and versatility of</span>
<span class="co">// OnTheFlyPrimeTable (see prime_tables.h). Inside it instantiates both</span>
<span class="co">// PrecalcPrimeTable and OnTheFlyPrimeTable and uses the one that is more</span>
<span class="co">// appropriate under the circumstances. But in low memory conditions, it can be</span>
<span class="co">// told to instantiate without PrecalcPrimeTable instance at all and use only</span>
<span class="co">// OnTheFlyPrimeTable.</span>
<span class="kw">class</span> HybridPrimeTable : <span class="kw">public</span> PrimeTable {
 <span class="kw">public</span>:
  HybridPrimeTable(<span class="dt">bool</span> force_on_the_fly, <span class="dt">int</span> max_precalculated)
      : on_the_fly_impl_(<span class="kw">new</span> OnTheFlyPrimeTable),
        precalc_impl_(force_on_the_fly ? NULL :
                          <span class="kw">new</span> PreCalculatedPrimeTable(max_precalculated)),
        max_precalculated_(max_precalculated) {}
  <span class="kw">virtual</span> ~HybridPrimeTable() {
    <span class="kw">delete</span> on_the_fly_impl_;
    <span class="kw">delete</span> precalc_impl_;
  }

  <span class="kw">virtual</span> <span class="dt">bool</span> IsPrime(<span class="dt">int</span> n) <span class="dt">const</span> {
    <span class="kw">if</span> (precalc_impl_ != NULL &amp;&amp; n &lt; max_precalculated_)
      <span class="kw">return</span> precalc_impl_-&gt;IsPrime(n);
    <span class="kw">else</span>
      <span class="kw">return</span> on_the_fly_impl_-&gt;IsPrime(n);
  }

  <span class="kw">virtual</span> <span class="dt">int</span> GetNextPrime(<span class="dt">int</span> p) <span class="dt">const</span> {
    <span class="dt">int</span> next_prime = <span class="dv">-1</span>;
    <span class="kw">if</span> (precalc_impl_ != NULL &amp;&amp; p &lt; max_precalculated_)
      next_prime = precalc_impl_-&gt;GetNextPrime(p);

    <span class="kw">return</span> next_prime != <span class="dv">-1</span> ? next_prime : on_the_fly_impl_-&gt;GetNextPrime(p);
  }

 <span class="kw">private</span>:
  OnTheFlyPrimeTable* on_the_fly_impl_;
  PreCalculatedPrimeTable* precalc_impl_;
  <span class="dt">int</span> max_precalculated_;
};

<span class="kw">using</span> ::testing::TestWithParam;
<span class="kw">using</span> ::testing::Bool;
<span class="kw">using</span> ::testing::Values;
<span class="kw">using</span> ::testing::Combine;

<span class="co">// To test all code paths for HybridPrimeTable we must test it with numbers</span>
<span class="co">// both within and outside PreCalculatedPrimeTable&#39;s capacity and also with</span>
<span class="co">// PreCalculatedPrimeTable disabled. We do this by defining fixture which will</span>
<span class="co">// accept different combinations of parameters for instantiating a</span>
<span class="co">// HybridPrimeTable instance.</span>
<span class="kw">class</span> PrimeTableTest : <span class="kw">public</span> TestWithParam&lt; ::testing::tuple&lt;<span class="dt">bool</span>, <span class="dt">int</span>&gt; &gt; {
 <span class="kw">protected</span>:
  <span class="kw">virtual</span> <span class="dt">void</span> SetUp() {
    <span class="co">// This can be written as</span>
    <span class="co">//</span>
    <span class="co">// bool force_on_the_fly;</span>
    <span class="co">// int max_precalculated;</span>
    <span class="co">// tie(force_on_the_fly, max_precalculated) = GetParam();</span>
    <span class="co">//</span>
    <span class="co">// once the Google C++ Style Guide allows use of ::std::tr1::tie.</span>
    <span class="co">//</span>
    <span class="dt">bool</span> force_on_the_fly = ::testing::get&lt;<span class="dv">0</span>&gt;(GetParam());
    <span class="dt">int</span> max_precalculated = ::testing::get&lt;<span class="dv">1</span>&gt;(GetParam());
    table_ = <span class="kw">new</span> HybridPrimeTable(force_on_the_fly, max_precalculated);
  }
  <span class="kw">virtual</span> <span class="dt">void</span> TearDown() {
    <span class="kw">delete</span> table_;
    table_ = NULL;
  }
  HybridPrimeTable* table_;
};

TEST_P(PrimeTableTest, ReturnsFalseForNonPrimes) {
  <span class="co">// Inside the test body, you can refer to the test parameter by GetParam().</span>
  <span class="co">// In this case, the test parameter is a PrimeTable interface pointer which</span>
  <span class="co">// we can use directly.</span>
  <span class="co">// Please note that you can also save it in the fixture&#39;s SetUp() method</span>
  <span class="co">// or constructor and use saved copy in the tests.</span>

  EXPECT_FALSE(table_-&gt;IsPrime(<span class="dv">-5</span>));
  EXPECT_FALSE(table_-&gt;IsPrime(<span class="dv">0</span>));
  EXPECT_FALSE(table_-&gt;IsPrime(<span class="dv">1</span>));
  EXPECT_FALSE(table_-&gt;IsPrime(<span class="dv">4</span>));
  EXPECT_FALSE(table_-&gt;IsPrime(<span class="dv">6</span>));
  EXPECT_FALSE(table_-&gt;IsPrime(<span class="dv">100</span>));
}

TEST_P(PrimeTableTest, ReturnsTrueForPrimes) {
  EXPECT_TRUE(table_-&gt;IsPrime(<span class="dv">2</span>));
  EXPECT_TRUE(table_-&gt;IsPrime(<span class="dv">3</span>));
  EXPECT_TRUE(table_-&gt;IsPrime(<span class="dv">5</span>));
  EXPECT_TRUE(table_-&gt;IsPrime(<span class="dv">7</span>));
  EXPECT_TRUE(table_-&gt;IsPrime(<span class="dv">11</span>));
  EXPECT_TRUE(table_-&gt;IsPrime(<span class="dv">131</span>));
}

TEST_P(PrimeTableTest, CanGetNextPrime) {
  EXPECT_EQ(<span class="dv">2</span>, table_-&gt;GetNextPrime(<span class="dv">0</span>));
  EXPECT_EQ(<span class="dv">3</span>, table_-&gt;GetNextPrime(<span class="dv">2</span>));
  EXPECT_EQ(<span class="dv">5</span>, table_-&gt;GetNextPrime(<span class="dv">3</span>));
  EXPECT_EQ(<span class="dv">7</span>, table_-&gt;GetNextPrime(<span class="dv">5</span>));
  EXPECT_EQ(<span class="dv">11</span>, table_-&gt;GetNextPrime(<span class="dv">7</span>));
  EXPECT_EQ(<span class="dv">131</span>, table_-&gt;GetNextPrime(<span class="dv">128</span>));
}

<span class="co">// In order to run value-parameterized tests, you need to instantiate them,</span>
<span class="co">// or bind them to a list of values which will be used as test parameters.</span>
<span class="co">// You can instantiate them in a different translation module, or even</span>
<span class="co">// instantiate them several times.</span>
<span class="co">//</span>
<span class="co">// Here, we instantiate our tests with a list of parameters. We must combine</span>
<span class="co">// all variations of the boolean flag suppressing PrecalcPrimeTable and some</span>
<span class="co">// meaningful values for tests. We choose a small value (1), and a value that</span>
<span class="co">// will put some of the tested numbers beyond the capability of the</span>
<span class="co">// PrecalcPrimeTable instance and some inside it (10). Combine will produce all</span>
<span class="co">// possible combinations.</span>
INSTANTIATE_TEST_CASE_P(MeaningfulTestParameters,
                        PrimeTableTest,
                        Combine(Bool(), Values(<span class="dv">1</span>, <span class="dv">10</span>)));

<span class="ot">#else</span>

<span class="co">// Google Test may not support Combine() with some compilers. If we</span>
<span class="co">// use conditional compilation to compile out all code referring to</span>
<span class="co">// the gtest_main library, MSVC linker will not link that library at</span>
<span class="co">// all and consequently complain about missing entry point defined in</span>
<span class="co">// that library (fatal error LNK1561: entry point must be</span>
<span class="co">// defined). This dummy test keeps gtest_main linked in.</span>
TEST(DummyTest, CombineIsNotSupportedOnThisPlatform) {}

<span class="ot">#endif  </span><span class="co">// GTEST_HAS_COMBINE</span></code></pre></div>
<div class="sourceCode" id="sample9test"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// This sample shows how to use Google Test listener API to implement</span>
<span class="co">// an alternative console output and how to use the UnitTest reflection API</span>
<span class="co">// to enumerate test cases and tests and to inspect their results.</span>

<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="ot">#include &quot;gtest/gtest.h&quot;</span>

<span class="kw">using</span> ::testing::EmptyTestEventListener;
<span class="kw">using</span> ::testing::InitGoogleTest;
<span class="kw">using</span> ::testing::Test;
<span class="kw">using</span> ::testing::TestCase;
<span class="kw">using</span> ::testing::TestEventListeners;
<span class="kw">using</span> ::testing::TestInfo;
<span class="kw">using</span> ::testing::TestPartResult;
<span class="kw">using</span> ::testing::UnitTest;

<span class="kw">namespace</span> {

<span class="co">// Provides alternative output mode which produces minimal amount of</span>
<span class="co">// information about tests.</span>
<span class="kw">class</span> TersePrinter : <span class="kw">public</span> EmptyTestEventListener {
 <span class="kw">private</span>:
  <span class="co">// Called before any test activity starts.</span>
  <span class="kw">virtual</span> <span class="dt">void</span> OnTestProgramStart(<span class="dt">const</span> UnitTest&amp; <span class="co">/* unit_test */</span>) {}

  <span class="co">// Called after all test activities have ended.</span>
  <span class="kw">virtual</span> <span class="dt">void</span> OnTestProgramEnd(<span class="dt">const</span> UnitTest&amp; unit_test) {
    fprintf(stdout, <span class="st">&quot;TEST </span><span class="ch">%s\n</span><span class="st">&quot;</span>, unit_test.Passed() ? <span class="st">&quot;PASSED&quot;</span> : <span class="st">&quot;FAILED&quot;</span>);
    fflush(stdout);
  }

  <span class="co">// Called before a test starts.</span>
  <span class="kw">virtual</span> <span class="dt">void</span> OnTestStart(<span class="dt">const</span> TestInfo&amp; test_info) {
    fprintf(stdout,
            <span class="st">&quot;*** Test </span><span class="ch">%s</span><span class="st">.</span><span class="ch">%s</span><span class="st"> starting.</span><span class="ch">\n</span><span class="st">&quot;</span>,
            test_info.test_case_name(),
            test_info.name());
    fflush(stdout);
  }

  <span class="co">// Called after a failed assertion or a SUCCEED() invocation.</span>
  <span class="kw">virtual</span> <span class="dt">void</span> OnTestPartResult(<span class="dt">const</span> TestPartResult&amp; test_part_result) {
    fprintf(stdout,
            <span class="st">&quot;</span><span class="ch">%s</span><span class="st"> in </span><span class="ch">%s</span><span class="st">:</span><span class="ch">%d\n%s\n</span><span class="st">&quot;</span>,
            test_part_result.failed() ? <span class="st">&quot;*** Failure&quot;</span> : <span class="st">&quot;Success&quot;</span>,
            test_part_result.file_name(),
            test_part_result.line_number(),
            test_part_result.summary());
    fflush(stdout);
  }

  <span class="co">// Called after a test ends.</span>
  <span class="kw">virtual</span> <span class="dt">void</span> OnTestEnd(<span class="dt">const</span> TestInfo&amp; test_info) {
    fprintf(stdout,
            <span class="st">&quot;*** Test </span><span class="ch">%s</span><span class="st">.</span><span class="ch">%s</span><span class="st"> ending.</span><span class="ch">\n</span><span class="st">&quot;</span>,
            test_info.test_case_name(),
            test_info.name());
    fflush(stdout);
  }
};  <span class="co">// class TersePrinter</span>

TEST(CustomOutputTest, PrintsMessage) {
  printf(<span class="st">&quot;Printing something from the test body...</span><span class="ch">\n</span><span class="st">&quot;</span>);
}

TEST(CustomOutputTest, Succeeds) {
  SUCCEED() &lt;&lt; <span class="st">&quot;SUCCEED() has been invoked from here&quot;</span>;
}

TEST(CustomOutputTest, Fails) {
  EXPECT_EQ(<span class="dv">1</span>, <span class="dv">2</span>)
      &lt;&lt; <span class="st">&quot;This test fails in order to demonstrate alternative failure messages&quot;</span>;
}

}  <span class="co">// namespace</span>

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {
  InitGoogleTest(&amp;argc, argv);

  <span class="dt">bool</span> terse_output = <span class="kw">false</span>;
  <span class="kw">if</span> (argc &gt; <span class="dv">1</span> &amp;&amp; strcmp(argv[<span class="dv">1</span>], <span class="st">&quot;--terse_output&quot;</span>) == <span class="dv">0</span> )
    terse_output = <span class="kw">true</span>;
  <span class="kw">else</span>
    printf(<span class="st">&quot;</span><span class="ch">%s\n</span><span class="st">&quot;</span>, <span class="st">&quot;Run this program with --terse_output to change the way &quot;</span>
           <span class="st">&quot;it prints its output.&quot;</span>);

  UnitTest&amp; unit_test = *UnitTest::GetInstance();

  <span class="co">// If we are given the --terse_output command line flag, suppresses the</span>
  <span class="co">// standard output and attaches own result printer.</span>
  <span class="kw">if</span> (terse_output) {
    TestEventListeners&amp; listeners = unit_test.listeners();

    <span class="co">// Removes the default console output listener from the list so it will</span>
    <span class="co">// not receive events from Google Test and won&#39;t print any output. Since</span>
    <span class="co">// this operation transfers ownership of the listener to the caller we</span>
    <span class="co">// have to delete it as well.</span>
    <span class="kw">delete</span> listeners.Release(listeners.default_result_printer());

    <span class="co">// Adds the custom output listener to the list. It will now receive</span>
    <span class="co">// events from Google Test and print the alternative output. We don&#39;t</span>
    <span class="co">// have to worry about deleting it since Google Test assumes ownership</span>
    <span class="co">// over it after adding it to the list.</span>
    listeners.Append(<span class="kw">new</span> TersePrinter);
  }
  <span class="dt">int</span> ret_val = RUN_ALL_TESTS();

  <span class="co">// This is an example of using the UnitTest reflection API to inspect test</span>
  <span class="co">// results. Here we discount failures from the tests we expected to fail.</span>
  <span class="dt">int</span> unexpectedly_failed_tests = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; unit_test.total_test_case_count(); ++i) {
    <span class="dt">const</span> TestCase&amp; test_case = *unit_test.GetTestCase(i);
    <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; test_case.total_test_count(); ++j) {
      <span class="dt">const</span> TestInfo&amp; test_info = *test_case.GetTestInfo(j);
      <span class="co">// Counts failed tests that were not meant to fail (those without</span>
      <span class="co">// &#39;Fails&#39; in the name).</span>
      <span class="kw">if</span> (test_info.result()-&gt;Failed() &amp;&amp;
          strcmp(test_info.name(), <span class="st">&quot;Fails&quot;</span>) != <span class="dv">0</span>) {
        unexpectedly_failed_tests++;
      }
    }
  }

  <span class="co">// Test that were meant to fail should not affect the test program outcome.</span>
  <span class="kw">if</span> (unexpectedly_failed_tests == <span class="dv">0</span>)
    ret_val = <span class="dv">0</span>;

  <span class="kw">return</span> ret_val;
}</code></pre></div>
<div class="sourceCode" id="sample10test"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// This sample shows how to use Google Test listener API to implement</span>
<span class="co">// a primitive leak checker.</span>

<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;stdlib.h&gt;</span>

<span class="ot">#include &quot;gtest/gtest.h&quot;</span>

<span class="kw">using</span> ::testing::EmptyTestEventListener;
<span class="kw">using</span> ::testing::InitGoogleTest;
<span class="kw">using</span> ::testing::Test;
<span class="kw">using</span> ::testing::TestCase;
<span class="kw">using</span> ::testing::TestEventListeners;
<span class="kw">using</span> ::testing::TestInfo;
<span class="kw">using</span> ::testing::TestPartResult;
<span class="kw">using</span> ::testing::UnitTest;

<span class="kw">namespace</span> {

<span class="co">// We will track memory used by this class.</span>
<span class="kw">class</span> Water {
 <span class="kw">public</span>:
  <span class="co">// Normal Water declarations go here.</span>

  <span class="co">// operator new and operator delete help us control water allocation.</span>
  <span class="dt">void</span>* <span class="kw">operator</span> <span class="kw">new</span>(size_t allocation_size) {
    allocated_++;
    <span class="kw">return</span> malloc(allocation_size);
  }

  <span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span>(<span class="dt">void</span>* block, size_t <span class="co">/* allocation_size */</span>) {
    allocated_--;
    free(block);
  }

  <span class="dt">static</span> <span class="dt">int</span> allocated() { <span class="kw">return</span> allocated_; }

 <span class="kw">private</span>:
  <span class="dt">static</span> <span class="dt">int</span> allocated_;
};

<span class="dt">int</span> Water::allocated_ = <span class="dv">0</span>;

<span class="co">// This event listener monitors how many Water objects are created and</span>
<span class="co">// destroyed by each test, and reports a failure if a test leaks some Water</span>
<span class="co">// objects. It does this by comparing the number of live Water objects at</span>
<span class="co">// the beginning of a test and at the end of a test.</span>
<span class="kw">class</span> LeakChecker : <span class="kw">public</span> EmptyTestEventListener {
 <span class="kw">private</span>:
  <span class="co">// Called before a test starts.</span>
  <span class="kw">virtual</span> <span class="dt">void</span> OnTestStart(<span class="dt">const</span> TestInfo&amp; <span class="co">/* test_info */</span>) {
    initially_allocated_ = Water::allocated();
  }

  <span class="co">// Called after a test ends.</span>
  <span class="kw">virtual</span> <span class="dt">void</span> OnTestEnd(<span class="dt">const</span> TestInfo&amp; <span class="co">/* test_info */</span>) {
    <span class="dt">int</span> difference = Water::allocated() - initially_allocated_;

    <span class="co">// You can generate a failure in any event handler except</span>
    <span class="co">// OnTestPartResult. Just use an appropriate Google Test assertion to do</span>
    <span class="co">// it.</span>
    EXPECT_LE(difference, <span class="dv">0</span>) &lt;&lt; <span class="st">&quot;Leaked &quot;</span> &lt;&lt; difference &lt;&lt; <span class="st">&quot; unit(s) of Water!&quot;</span>;
  }

  <span class="dt">int</span> initially_allocated_;
};

TEST(ListenersTest, DoesNotLeak) {
  Water* water = <span class="kw">new</span> Water;
  <span class="kw">delete</span> water;
}

<span class="co">// This should fail when the --check_for_leaks command line flag is</span>
<span class="co">// specified.</span>
TEST(ListenersTest, LeaksWater) {
  Water* water = <span class="kw">new</span> Water;
  EXPECT_TRUE(water != NULL);
}

}  <span class="co">// namespace</span>

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {
  InitGoogleTest(&amp;argc, argv);

  <span class="dt">bool</span> check_for_leaks = <span class="kw">false</span>;
  <span class="kw">if</span> (argc &gt; <span class="dv">1</span> &amp;&amp; strcmp(argv[<span class="dv">1</span>], <span class="st">&quot;--check_for_leaks&quot;</span>) == <span class="dv">0</span> )
    check_for_leaks = <span class="kw">true</span>;
  <span class="kw">else</span>
    printf(<span class="st">&quot;</span><span class="ch">%s\n</span><span class="st">&quot;</span>, <span class="st">&quot;Run this program with --check_for_leaks to enable &quot;</span>
           <span class="st">&quot;custom leak checking in the tests.&quot;</span>);

  <span class="co">// If we are given the --check_for_leaks command line flag, installs the</span>
  <span class="co">// leak checker.</span>
  <span class="kw">if</span> (check_for_leaks) {
    TestEventListeners&amp; listeners = UnitTest::GetInstance()-&gt;listeners();

    <span class="co">// Adds the leak checker to the end of the test event listener list,</span>
    <span class="co">// after the default text output printer and the default XML report</span>
    <span class="co">// generator.</span>
    <span class="co">//</span>
    <span class="co">// The order is important - it ensures that failures generated in the</span>
    <span class="co">// leak checker&#39;s OnTestEnd() method are processed by the text and XML</span>
    <span class="co">// printers *before* their OnTestEnd() methods are called, such that</span>
    <span class="co">// they are attributed to the right test. Remember that a listener</span>
    <span class="co">// receives an OnXyzStart event *after* listeners preceding it in the</span>
    <span class="co">// list received that event, and receives an OnXyzEnd event *before*</span>
    <span class="co">// listeners preceding it.</span>
    <span class="co">//</span>
    <span class="co">// We don&#39;t need to worry about deleting the new listener later, as</span>
    <span class="co">// Google Test will do it.</span>
    listeners.Append(<span class="kw">new</span> LeakChecker);
  }
  <span class="kw">return</span> RUN_ALL_TESTS();
}</code></pre></div>
</div>
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="blur-svg">
    <defs>
        <filter id="blur-filter">
            <feGaussianBlur stdDeviation="3"></feGaussianBlur>
        </filter>
    </defs>
</svg>
<script src="../lazyload.min.js"></script>
<script src="../jquery-3.0.0.min.js"></script>
<script src="../jquery.idTabs.min.js"></script>
<script src="../egg.min.js"></script>
<script src="../clipboard.min.js"></script>
<script src="../notes.js"></script>
</body>
</html>
